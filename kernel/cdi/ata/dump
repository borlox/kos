
ata.mod:     file format elf32-i386

Disassembly of section .text:

40000000 <ata_drv_identify>:
 * ATA-Geraet identifizieren
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
 */
int ata_drv_identify(struct ata_device* dev)
{
40000000:	55                   	push   %ebp
40000001:	89 e5                	mov    %esp,%ebp
40000003:	57                   	push   %edi
40000004:	81 ec 34 02 00 00    	sub    $0x234,%esp
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

        .error = 0
    };
4000000a:	8d bd cc fd ff ff    	lea    -0x234(%ebp),%edi
40000010:	fc                   	cld    
40000011:	ba 00 00 00 00       	mov    $0x0,%edx
40000016:	b8 0c 00 00 00       	mov    $0xc,%eax
4000001b:	89 c1                	mov    %eax,%ecx
4000001d:	89 d0                	mov    %edx,%eax
4000001f:	f3 ab                	rep stos %eax,%es:(%edi)
40000021:	8b 45 08             	mov    0x8(%ebp),%eax
40000024:	89 85 cc fd ff ff    	mov    %eax,-0x234(%ebp)
4000002a:	c7 85 d0 fd ff ff 01 	movl   $0x1,-0x230(%ebp)
40000031:	00 00 00 
40000034:	c6 85 d8 fd ff ff 01 	movb   $0x1,-0x228(%ebp)
4000003b:	c7 85 dc fd ff ff ec 	movl   $0xec,-0x224(%ebp)
40000042:	00 00 00 
40000045:	66 c7 85 ec fd ff ff 	movw   $0x1,-0x214(%ebp)
4000004c:	01 00 
4000004e:	66 c7 85 ee fd ff ff 	movw   $0x200,-0x212(%ebp)
40000055:	00 02 
40000057:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
4000005d:	89 85 f4 fd ff ff    	mov    %eax,-0x20c(%ebp)
    
    // Request starten
    if (!ata_request(&request)) {
40000063:	83 ec 0c             	sub    $0xc,%esp
40000066:	8d 85 cc fd ff ff    	lea    -0x234(%ebp),%eax
4000006c:	50                   	push   %eax
4000006d:	e8 67 0f 00 00       	call   40000fd9 <ata_request>
40000072:	83 c4 10             	add    $0x10,%esp
40000075:	85 c0                	test   %eax,%eax
40000077:	75 16                	jne    4000008f <ata_drv_identify+0x8f>
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
40000079:	83 ec 0c             	sub    $0xc,%esp
4000007c:	ff 75 08             	pushl  0x8(%ebp)
4000007f:	e8 1c 01 00 00       	call   400001a0 <atapi_drv_identify>
40000084:	83 c4 10             	add    $0x10,%esp
40000087:	89 85 c8 fd ff ff    	mov    %eax,-0x238(%ebp)
4000008d:	eb 11                	jmp    400000a0 <ata_drv_identify+0xa0>
    }
        
    // Ein ATA-Geraet
    dev->atapi = 0;
4000008f:	8b 45 08             	mov    0x8(%ebp),%eax
40000092:	c6 40 19 00          	movb   $0x0,0x19(%eax)

    // TODO: Informationen verarbeiten

    return 1;
40000096:	c7 85 c8 fd ff ff 01 	movl   $0x1,-0x238(%ebp)
4000009d:	00 00 00 
400000a0:	8b 85 c8 fd ff ff    	mov    -0x238(%ebp),%eax
}
400000a6:	8b 7d fc             	mov    -0x4(%ebp),%edi
400000a9:	c9                   	leave  
400000aa:	c3                   	ret    

400000ab <ata_drv_read_sectors>:
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
{
400000ab:	55                   	push   %ebp
400000ac:	89 e5                	mov    %esp,%ebp
400000ae:	83 ec 58             	sub    $0x58,%esp
400000b1:	8b 45 0c             	mov    0xc(%ebp),%eax
400000b4:	89 45 a8             	mov    %eax,-0x58(%ebp)
400000b7:	8b 45 10             	mov    0x10(%ebp),%eax
400000ba:	89 45 ac             	mov    %eax,-0x54(%ebp)
    int result = 1;
400000bd:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    struct ata_request request;
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
    // muss unter Umstaenden mehrmals gelesen werden.
    uint16_t current_count;
    void* current_buffer = buffer;
400000c4:	8b 45 18             	mov    0x18(%ebp),%eax
400000c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint64_t lba = start;
400000ca:	8b 45 a8             	mov    -0x58(%ebp),%eax
400000cd:	8b 55 ac             	mov    -0x54(%ebp),%edx
400000d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
400000d3:	89 55 f4             	mov    %edx,-0xc(%ebp)

    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;
400000d6:	8b 45 14             	mov    0x14(%ebp),%eax
400000d9:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
400000dc:	e9 af 00 00 00       	jmp    40000190 <ata_drv_read_sectors+0xe5>
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
        if (count_left > 256) {
400000e1:	81 7d fc 00 01 00 00 	cmpl   $0x100,-0x4(%ebp)
400000e8:	76 08                	jbe    400000f2 <ata_drv_read_sectors+0x47>
            current_count = 256;
400000ea:	66 c7 45 ea 00 01    	movw   $0x100,-0x16(%ebp)
400000f0:	eb 07                	jmp    400000f9 <ata_drv_read_sectors+0x4e>
        } else {
            current_count = count_left;
400000f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
400000f5:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
        }
        
        // Request vorbereiten
        request.dev = dev;
400000f9:	8b 45 08             	mov    0x8(%ebp),%eax
400000fc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        // TODO: DMA, UltraDMA...
        request.protocol = PIO;
400000ff:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
        request.flags.direction = READ;
40000106:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
        // FIXME
        request.flags.poll = 1;
4000010d:	c6 45 c0 01          	movb   $0x1,-0x40(%ebp)
        request.flags.ata = 0;
40000111:	c6 45 c1 00          	movb   $0x0,-0x3f(%ebp)
        request.flags.lba = 1;
40000115:	c6 45 c2 01          	movb   $0x1,-0x3e(%ebp)

        request.registers.ata.command = READ_SECTORS;
40000119:	c7 45 c4 20 00 00 00 	movl   $0x20,-0x3c(%ebp)
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
        // 0 steht.
        request.registers.ata.count = (uint8_t) current_count;
40000120:	66 8b 45 ea          	mov    -0x16(%ebp),%ax
40000124:	88 45 c8             	mov    %al,-0x38(%ebp)
        request.registers.ata.lba = lba;
40000127:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000012a:	8b 55 f4             	mov    -0xc(%ebp),%edx
4000012d:	89 45 cc             	mov    %eax,-0x34(%ebp)
40000130:	89 55 d0             	mov    %edx,-0x30(%ebp)

        request.block_count = current_count;
40000133:	66 8b 45 ea          	mov    -0x16(%ebp),%ax
40000137:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
        request.block_size = ATA_SECTOR_SIZE;
4000013b:	66 c7 45 d6 00 02    	movw   $0x200,-0x2a(%ebp)
        request.blocks_done = 0;
40000141:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%ebp)
        request.buffer = current_buffer;
40000147:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000014a:	89 45 dc             	mov    %eax,-0x24(%ebp)

        request.error = NO_ERROR;
4000014d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
        
        // TODO: LBA48
        // TODO: CHS
        
        // Request ausfuehren
        if (!ata_request(&request)) {
40000154:	83 ec 0c             	sub    $0xc,%esp
40000157:	8d 45 b4             	lea    -0x4c(%ebp),%eax
4000015a:	50                   	push   %eax
4000015b:	e8 79 0e 00 00       	call   40000fd9 <ata_request>
40000160:	83 c4 10             	add    $0x10,%esp
40000163:	85 c0                	test   %eax,%eax
40000165:	75 09                	jne    40000170 <ata_drv_read_sectors+0xc5>
            result = 0;
40000167:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            break;
4000016e:	eb 2a                	jmp    4000019a <ata_drv_read_sectors+0xef>
        }

        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
        current_buffer += current_count * ATA_SECTOR_SIZE;
40000170:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
40000174:	c1 e0 09             	shl    $0x9,%eax
40000177:	01 45 ec             	add    %eax,-0x14(%ebp)
        count_left -= current_count;
4000017a:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
4000017e:	29 45 fc             	sub    %eax,-0x4(%ebp)
        lba += current_count;
40000181:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
40000185:	ba 00 00 00 00       	mov    $0x0,%edx
4000018a:	01 45 f0             	add    %eax,-0x10(%ebp)
4000018d:	11 55 f4             	adc    %edx,-0xc(%ebp)

    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;

    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
40000190:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40000194:	0f 85 47 ff ff ff    	jne    400000e1 <ata_drv_read_sectors+0x36>
        current_buffer += current_count * ATA_SECTOR_SIZE;
        count_left -= current_count;
        lba += current_count;
    }

    return result;
4000019a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
4000019d:	c9                   	leave  
4000019e:	c3                   	ret    
4000019f:	90                   	nop    

400001a0 <atapi_drv_identify>:
 * ATA-Geraet identifizieren
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
 */
int ata_drv_identify(struct ata_device* dev)
{
400001a0:	55                   	push   %ebp
400001a1:	89 e5                	mov    %esp,%ebp
400001a3:	57                   	push   %edi
400001a4:	81 ec 34 02 00 00    	sub    $0x234,%esp
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

        .error = 0
    };
400001aa:	8d bd cc fd ff ff    	lea    -0x234(%ebp),%edi
400001b0:	fc                   	cld    
400001b1:	ba 00 00 00 00       	mov    $0x0,%edx
400001b6:	b8 0c 00 00 00       	mov    $0xc,%eax
400001bb:	89 c1                	mov    %eax,%ecx
400001bd:	89 d0                	mov    %edx,%eax
400001bf:	f3 ab                	rep stos %eax,%es:(%edi)
400001c1:	8b 45 08             	mov    0x8(%ebp),%eax
400001c4:	89 85 cc fd ff ff    	mov    %eax,-0x234(%ebp)
400001ca:	c7 85 d0 fd ff ff 01 	movl   $0x1,-0x230(%ebp)
400001d1:	00 00 00 
400001d4:	c6 85 d8 fd ff ff 01 	movb   $0x1,-0x228(%ebp)
400001db:	c7 85 dc fd ff ff a1 	movl   $0xa1,-0x224(%ebp)
400001e2:	00 00 00 
400001e5:	66 c7 85 ec fd ff ff 	movw   $0x1,-0x214(%ebp)
400001ec:	01 00 
400001ee:	66 c7 85 ee fd ff ff 	movw   $0x200,-0x212(%ebp)
400001f5:	00 02 
400001f7:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
400001fd:	89 85 f4 fd ff ff    	mov    %eax,-0x20c(%ebp)
    
    // Request starten
    if (!ata_request(&request)) {
40000203:	83 ec 0c             	sub    $0xc,%esp
40000206:	8d 85 cc fd ff ff    	lea    -0x234(%ebp),%eax
4000020c:	50                   	push   %eax
4000020d:	e8 c7 0d 00 00       	call   40000fd9 <ata_request>
40000212:	83 c4 10             	add    $0x10,%esp
40000215:	85 c0                	test   %eax,%eax
40000217:	75 0c                	jne    40000225 <atapi_drv_identify+0x85>
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
        // IDENTIFY PACKET DEVICE probieren.
40000219:	c7 85 c8 fd ff ff 00 	movl   $0x0,-0x238(%ebp)
40000220:	00 00 00 
40000223:	eb 11                	jmp    40000236 <atapi_drv_identify+0x96>
        return atapi_drv_identify(dev);
    }
        
    // Ein ATA-Geraet
40000225:	8b 45 08             	mov    0x8(%ebp),%eax
40000228:	c6 40 19 01          	movb   $0x1,0x19(%eax)
    dev->atapi = 0;

    // TODO: Informationen verarbeiten

4000022c:	c7 85 c8 fd ff ff 01 	movl   $0x1,-0x238(%ebp)
40000233:	00 00 00 
40000236:	8b 85 c8 fd ff ff    	mov    -0x238(%ebp),%eax
    return 1;
4000023c:	8b 7d fc             	mov    -0x4(%ebp),%edi
4000023f:	c9                   	leave  
40000240:	c3                   	ret    
40000241:	90                   	nop    
40000242:	90                   	nop    
40000243:	90                   	nop    

40000244 <ata_bus_floating>:
    // Request vorbereiten
    struct ata_request request = {
        .dev = dev,

        .flags.direction = READ,
        .flags.poll = 1,
40000244:	55                   	push   %ebp
40000245:	89 e5                	mov    %esp,%ebp
40000247:	83 ec 18             	sub    $0x18,%esp
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
4000024a:	83 ec 04             	sub    $0x4,%esp
4000024d:	6a 00                	push   $0x0
4000024f:	6a 06                	push   $0x6
40000251:	ff 75 08             	pushl  0x8(%ebp)
40000254:	e8 22 00 00 00       	call   4000027b <ata_reg_outb>
40000259:	83 c4 10             	add    $0x10,%esp
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
4000025c:	83 ec 08             	sub    $0x8,%esp
4000025f:	6a 07                	push   $0x7
40000261:	ff 75 08             	pushl  0x8(%ebp)
40000264:	e8 af 00 00 00       	call   40000318 <ata_reg_inb>
40000269:	83 c4 10             	add    $0x10,%esp
4000026c:	88 45 ff             	mov    %al,-0x1(%ebp)
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

4000026f:	80 7d ff ff          	cmpb   $0xff,-0x1(%ebp)
40000273:	0f 94 c0             	sete   %al
40000276:	0f b6 c0             	movzbl %al,%eax
        .error = 0
40000279:	c9                   	leave  
4000027a:	c3                   	ret    

4000027b <ata_reg_outb>:
4000027b:	55                   	push   %ebp
4000027c:	89 e5                	mov    %esp,%ebp
4000027e:	83 ec 18             	sub    $0x18,%esp
40000281:	8b 45 0c             	mov    0xc(%ebp),%eax
40000284:	8b 55 10             	mov    0x10(%ebp),%edx
40000287:	88 45 ec             	mov    %al,-0x14(%ebp)
4000028a:	88 55 e8             	mov    %dl,-0x18(%ebp)
4000028d:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
40000291:	83 ec 08             	sub    $0x8,%esp
40000294:	50                   	push   %eax
40000295:	ff 75 08             	pushl  0x8(%ebp)
40000298:	e8 28 00 00 00       	call   400002c5 <ata_reg_base>
4000029d:	83 c4 10             	add    $0x10,%esp
400002a0:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
400002a4:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
400002a8:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
400002ac:	83 e0 0f             	and    $0xf,%eax
400002af:	66 03 45 fe          	add    -0x2(%ebp),%ax
400002b3:	0f b7 c0             	movzwl %ax,%eax
400002b6:	83 ec 08             	sub    $0x8,%esp
400002b9:	52                   	push   %edx
400002ba:	50                   	push   %eax
400002bb:	e8 3c 00 00 00       	call   400002fc <cdi_outb>
400002c0:	83 c4 10             	add    $0x10,%esp
400002c3:	c9                   	leave  
400002c4:	c3                   	ret    

400002c5 <ata_reg_base>:
400002c5:	55                   	push   %ebp
400002c6:	89 e5                	mov    %esp,%ebp
400002c8:	83 ec 08             	sub    $0x8,%esp
400002cb:	8b 45 0c             	mov    0xc(%ebp),%eax
400002ce:	88 45 fc             	mov    %al,-0x4(%ebp)
400002d1:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
400002d5:	83 e0 10             	and    $0x10,%eax
400002d8:	85 c0                	test   %eax,%eax
400002da:	75 0f                	jne    400002eb <ata_reg_base+0x26>
400002dc:	8b 45 08             	mov    0x8(%ebp),%eax
400002df:	66 8b 40 06          	mov    0x6(%eax),%ax
400002e3:	0f b7 c0             	movzwl %ax,%eax
400002e6:	89 45 f8             	mov    %eax,-0x8(%ebp)
400002e9:	eb 0c                	jmp    400002f7 <ata_reg_base+0x32>
400002eb:	8b 45 08             	mov    0x8(%ebp),%eax
400002ee:	8b 40 08             	mov    0x8(%eax),%eax
400002f1:	0f b7 c0             	movzwl %ax,%eax
400002f4:	89 45 f8             	mov    %eax,-0x8(%ebp)
400002f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
400002fa:	c9                   	leave  
400002fb:	c3                   	ret    

400002fc <cdi_outb>:
{
	__asm__ ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void cdi_outb(uint16_t _port, uint8_t _data)
{
400002fc:	55                   	push   %ebp
400002fd:	89 e5                	mov    %esp,%ebp
400002ff:	83 ec 08             	sub    $0x8,%esp
40000302:	8b 45 08             	mov    0x8(%ebp),%eax
40000305:	8b 55 0c             	mov    0xc(%ebp),%edx
40000308:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
4000030c:	88 55 f8             	mov    %dl,-0x8(%ebp)
	__asm__ ("outb %0, %1" : : "a" (_data), "Nd" (_port));
4000030f:	8a 45 f8             	mov    -0x8(%ebp),%al
40000312:	8b 55 fc             	mov    -0x4(%ebp),%edx
40000315:	ee                   	out    %al,(%dx)
}
40000316:	c9                   	leave  
40000317:	c3                   	ret    

40000318 <ata_reg_inb>:
40000318:	55                   	push   %ebp
40000319:	89 e5                	mov    %esp,%ebp
4000031b:	83 ec 18             	sub    $0x18,%esp
4000031e:	8b 45 0c             	mov    0xc(%ebp),%eax
40000321:	88 45 ec             	mov    %al,-0x14(%ebp)
40000324:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
40000328:	50                   	push   %eax
40000329:	ff 75 08             	pushl  0x8(%ebp)
4000032c:	e8 94 ff ff ff       	call   400002c5 <ata_reg_base>
40000331:	83 c4 08             	add    $0x8,%esp
40000334:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
40000338:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
4000033c:	83 e0 0f             	and    $0xf,%eax
4000033f:	66 03 45 fe          	add    -0x2(%ebp),%ax
40000343:	0f b7 c0             	movzwl %ax,%eax
40000346:	83 ec 0c             	sub    $0xc,%esp
40000349:	50                   	push   %eax
4000034a:	e8 08 00 00 00       	call   40000357 <cdi_inb>
4000034f:	83 c4 10             	add    $0x10,%esp
40000352:	0f b6 c0             	movzbl %al,%eax
40000355:	c9                   	leave  
40000356:	c3                   	ret    

40000357 <cdi_inb>:
	__asm__ ("inw %1, %0" : "=a" (result) : "Nd" (_port));
	return result;
}

static inline uint8_t cdi_inb(uint16_t _port)
{
40000357:	55                   	push   %ebp
40000358:	89 e5                	mov    %esp,%ebp
4000035a:	83 ec 14             	sub    $0x14,%esp
4000035d:	8b 45 08             	mov    0x8(%ebp),%eax
40000360:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	uint8_t result;
	__asm__ ("inb %1, %0" : "=a" (result) : "Nd" (_port));
40000364:	8b 55 ec             	mov    -0x14(%ebp),%edx
40000367:	ec                   	in     (%dx),%al
40000368:	88 45 ff             	mov    %al,-0x1(%ebp)
	return result;
4000036b:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
4000036f:	c9                   	leave  
40000370:	c3                   	ret    

40000371 <ata_bus_responsive_drv>:
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
    }
        
    // Ein ATA-Geraet
    dev->atapi = 0;
40000371:	55                   	push   %ebp
40000372:	89 e5                	mov    %esp,%ebp
40000374:	83 ec 08             	sub    $0x8,%esp

    // TODO: Informationen verarbeiten

    return 1;
}
40000377:	83 ec 04             	sub    $0x4,%esp
4000037a:	6a 10                	push   $0x10
4000037c:	6a 06                	push   $0x6
4000037e:	ff 75 08             	pushl  0x8(%ebp)
40000381:	e8 f5 fe ff ff       	call   4000027b <ata_reg_outb>
40000386:	83 c4 10             	add    $0x10,%esp

/**
 * Sektoren von einem ATA-Geraet lesen
 *
 * @param start LBA des Startsektors
40000389:	83 ec 04             	sub    $0x4,%esp
4000038c:	68 af 00 00 00       	push   $0xaf
40000391:	6a 03                	push   $0x3
40000393:	ff 75 08             	pushl  0x8(%ebp)
40000396:	e8 e0 fe ff ff       	call   4000027b <ata_reg_outb>
4000039b:	83 c4 10             	add    $0x10,%esp
 * @param count Anzahl der Sektoren
4000039e:	83 ec 04             	sub    $0x4,%esp
400003a1:	68 bf 00 00 00       	push   $0xbf
400003a6:	6a 04                	push   $0x4
400003a8:	ff 75 08             	pushl  0x8(%ebp)
400003ab:	e8 cb fe ff ff       	call   4000027b <ata_reg_outb>
400003b0:	83 c4 10             	add    $0x10,%esp
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
400003b3:	83 ec 04             	sub    $0x4,%esp
400003b6:	68 cf 00 00 00       	push   $0xcf
400003bb:	6a 05                	push   $0x5
400003bd:	ff 75 08             	pushl  0x8(%ebp)
400003c0:	e8 b6 fe ff ff       	call   4000027b <ata_reg_outb>
400003c5:	83 c4 10             	add    $0x10,%esp
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
 */
400003c8:	83 ec 08             	sub    $0x8,%esp
400003cb:	6a 03                	push   $0x3
400003cd:	ff 75 08             	pushl  0x8(%ebp)
400003d0:	e8 43 ff ff ff       	call   40000318 <ata_reg_inb>
400003d5:	83 c4 10             	add    $0x10,%esp
400003d8:	3c af                	cmp    $0xaf,%al
400003da:	75 34                	jne    40000410 <ata_bus_responsive_drv+0x9f>
400003dc:	83 ec 08             	sub    $0x8,%esp
400003df:	6a 04                	push   $0x4
400003e1:	ff 75 08             	pushl  0x8(%ebp)
400003e4:	e8 2f ff ff ff       	call   40000318 <ata_reg_inb>
400003e9:	83 c4 10             	add    $0x10,%esp
400003ec:	3c bf                	cmp    $0xbf,%al
400003ee:	75 20                	jne    40000410 <ata_bus_responsive_drv+0x9f>
400003f0:	83 ec 08             	sub    $0x8,%esp
400003f3:	6a 05                	push   $0x5
400003f5:	ff 75 08             	pushl  0x8(%ebp)
400003f8:	e8 1b ff ff ff       	call   40000318 <ata_reg_inb>
400003fd:	83 c4 10             	add    $0x10,%esp
40000400:	3c cf                	cmp    $0xcf,%al
40000402:	75 0c                	jne    40000410 <ata_bus_responsive_drv+0x9f>
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
{
    int result = 1;
40000404:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
4000040b:	e9 9d 00 00 00       	jmp    400004ad <ata_bus_responsive_drv+0x13c>
    struct ata_request request;
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
    // muss unter Umstaenden mehrmals gelesen werden.
    uint16_t current_count;
    void* current_buffer = buffer;
    uint64_t lba = start;
40000410:	83 ec 04             	sub    $0x4,%esp
40000413:	6a 00                	push   $0x0
40000415:	6a 06                	push   $0x6
40000417:	ff 75 08             	pushl  0x8(%ebp)
4000041a:	e8 5c fe ff ff       	call   4000027b <ata_reg_outb>
4000041f:	83 c4 10             	add    $0x10,%esp

    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;

    // Solange wie noch Sektoren uebrig sind, wird gelesen
40000422:	83 ec 04             	sub    $0x4,%esp
40000425:	68 af 00 00 00       	push   $0xaf
4000042a:	6a 03                	push   $0x3
4000042c:	ff 75 08             	pushl  0x8(%ebp)
4000042f:	e8 47 fe ff ff       	call   4000027b <ata_reg_outb>
40000434:	83 c4 10             	add    $0x10,%esp
    while (count_left > 0) {
40000437:	83 ec 04             	sub    $0x4,%esp
4000043a:	68 bf 00 00 00       	push   $0xbf
4000043f:	6a 04                	push   $0x4
40000441:	ff 75 08             	pushl  0x8(%ebp)
40000444:	e8 32 fe ff ff       	call   4000027b <ata_reg_outb>
40000449:	83 c4 10             	add    $0x10,%esp
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
4000044c:	83 ec 04             	sub    $0x4,%esp
4000044f:	68 cf 00 00 00       	push   $0xcf
40000454:	6a 05                	push   $0x5
40000456:	ff 75 08             	pushl  0x8(%ebp)
40000459:	e8 1d fe ff ff       	call   4000027b <ata_reg_outb>
4000045e:	83 c4 10             	add    $0x10,%esp
        if (count_left > 256) {
            current_count = 256;
        } else {
40000461:	83 ec 08             	sub    $0x8,%esp
40000464:	6a 03                	push   $0x3
40000466:	ff 75 08             	pushl  0x8(%ebp)
40000469:	e8 aa fe ff ff       	call   40000318 <ata_reg_inb>
4000046e:	83 c4 10             	add    $0x10,%esp
40000471:	3c af                	cmp    $0xaf,%al
40000473:	75 31                	jne    400004a6 <ata_bus_responsive_drv+0x135>
40000475:	83 ec 08             	sub    $0x8,%esp
40000478:	6a 04                	push   $0x4
4000047a:	ff 75 08             	pushl  0x8(%ebp)
4000047d:	e8 96 fe ff ff       	call   40000318 <ata_reg_inb>
40000482:	83 c4 10             	add    $0x10,%esp
40000485:	3c bf                	cmp    $0xbf,%al
40000487:	75 1d                	jne    400004a6 <ata_bus_responsive_drv+0x135>
40000489:	83 ec 08             	sub    $0x8,%esp
4000048c:	6a 05                	push   $0x5
4000048e:	ff 75 08             	pushl  0x8(%ebp)
40000491:	e8 82 fe ff ff       	call   40000318 <ata_reg_inb>
40000496:	83 c4 10             	add    $0x10,%esp
40000499:	3c cf                	cmp    $0xcf,%al
4000049b:	75 09                	jne    400004a6 <ata_bus_responsive_drv+0x135>
            current_count = count_left;
        }
        
        // Request vorbereiten
4000049d:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
400004a4:	eb 07                	jmp    400004ad <ata_bus_responsive_drv+0x13c>
        request.dev = dev;
        // TODO: DMA, UltraDMA...
        request.protocol = PIO;
400004a6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
400004ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
        request.flags.direction = READ;
400004b0:	c9                   	leave  
400004b1:	c3                   	ret    

400004b2 <ata_wait_irq>:
        request.error = NO_ERROR;
        
        // TODO: LBA48
        // TODO: CHS
        
        // Request ausfuehren
400004b2:	55                   	push   %ebp
400004b3:	89 e5                	mov    %esp,%ebp
400004b5:	83 ec 18             	sub    $0x18,%esp
        if (!ata_request(&request)) {
400004b8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
            result = 0;
            break;
        }
400004bf:	eb 22                	jmp    400004e3 <ata_wait_irq+0x31>

400004c1:	83 ec 0c             	sub    $0xc,%esp
400004c4:	6a 14                	push   $0x14
400004c6:	e8 02 11 00 00       	call   400015cd <cdi_sleep_ms>
400004cb:	83 c4 10             	add    $0x10,%esp
        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
400004ce:	83 45 fc 14          	addl   $0x14,-0x4(%ebp)
        current_buffer += current_count * ATA_SECTOR_SIZE;
        count_left -= current_count;
400004d2:	8b 45 0c             	mov    0xc(%ebp),%eax
400004d5:	3b 45 fc             	cmp    -0x4(%ebp),%eax
400004d8:	77 09                	ja     400004e3 <ata_wait_irq+0x31>
        lba += current_count;
400004da:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400004e1:	eb 12                	jmp    400004f5 <ata_wait_irq+0x43>
        
        // Request ausfuehren
        if (!ata_request(&request)) {
            result = 0;
            break;
        }
400004e3:	8b 45 08             	mov    0x8(%ebp),%eax
400004e6:	8b 40 0c             	mov    0xc(%eax),%eax
400004e9:	66 85 c0             	test   %ax,%ax
400004ec:	74 d3                	je     400004c1 <ata_wait_irq+0xf>
        count_left -= current_count;
        lba += current_count;
    }

    return result;
}
400004ee:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
400004f5:	8b 45 ec             	mov    -0x14(%ebp),%eax

400004f8:	c9                   	leave  
400004f9:	c3                   	ret    

400004fa <ata_init_controller>:
400004fa:	55                   	push   %ebp
400004fb:	89 e5                	mov    %esp,%ebp
400004fd:	83 ec 18             	sub    $0x18,%esp
40000500:	8b 45 08             	mov    0x8(%ebp),%eax
40000503:	66 8b 40 06          	mov    0x6(%eax),%ax
40000507:	0f b7 c0             	movzwl %ax,%eax
4000050a:	83 ec 08             	sub    $0x8,%esp
4000050d:	6a 08                	push   $0x8
4000050f:	50                   	push   %eax
40000510:	e8 34 10 00 00       	call   40001549 <cdi_ioports_alloc>
40000515:	83 c4 10             	add    $0x10,%esp
40000518:	85 c0                	test   %eax,%eax
4000051a:	74 15                	je     40000531 <ata_init_controller+0x37>
4000051c:	83 ec 0c             	sub    $0xc,%esp
4000051f:	68 e4 96 00 40       	push   $0x400096e4
40000524:	e8 10 5e 00 00       	call   40006339 <printf>
40000529:	83 c4 10             	add    $0x10,%esp
4000052c:	e9 0b 02 00 00       	jmp    4000073c <ata_init_controller+0x242>
40000531:	8b 45 08             	mov    0x8(%ebp),%eax
40000534:	8b 40 08             	mov    0x8(%eax),%eax
40000537:	0f b7 c0             	movzwl %ax,%eax
4000053a:	83 ec 08             	sub    $0x8,%esp
4000053d:	6a 01                	push   $0x1
4000053f:	50                   	push   %eax
40000540:	e8 04 10 00 00       	call   40001549 <cdi_ioports_alloc>
40000545:	83 c4 10             	add    $0x10,%esp
40000548:	85 c0                	test   %eax,%eax
4000054a:	74 2d                	je     40000579 <ata_init_controller+0x7f>
4000054c:	83 ec 0c             	sub    $0xc,%esp
4000054f:	68 e4 96 00 40       	push   $0x400096e4
40000554:	e8 e0 5d 00 00       	call   40006339 <printf>
40000559:	83 c4 10             	add    $0x10,%esp
4000055c:	8b 45 08             	mov    0x8(%ebp),%eax
4000055f:	66 8b 40 06          	mov    0x6(%eax),%ax
40000563:	0f b7 c0             	movzwl %ax,%eax
40000566:	83 ec 08             	sub    $0x8,%esp
40000569:	6a 08                	push   $0x8
4000056b:	50                   	push   %eax
4000056c:	e8 1a 10 00 00       	call   4000158b <cdi_ioports_free>
40000571:	83 c4 10             	add    $0x10,%esp
40000574:	e9 c3 01 00 00       	jmp    4000073c <ata_init_controller+0x242>
40000579:	8b 55 08             	mov    0x8(%ebp),%edx
4000057c:	8b 45 08             	mov    0x8(%ebp),%eax
4000057f:	89 42 28             	mov    %eax,0x28(%edx)
40000582:	8b 45 08             	mov    0x8(%ebp),%eax
40000585:	83 c0 14             	add    $0x14,%eax
40000588:	89 c2                	mov    %eax,%edx
4000058a:	8b 45 08             	mov    0x8(%ebp),%eax
4000058d:	66 8b 40 0a          	mov    0xa(%eax),%ax
40000591:	0f b6 c0             	movzbl %al,%eax
40000594:	83 ec 04             	sub    $0x4,%esp
40000597:	52                   	push   %edx
40000598:	68 3e 07 00 40       	push   $0x4000073e
4000059d:	50                   	push   %eax
4000059e:	e8 25 0f 00 00       	call   400014c8 <cdi_register_irq>
400005a3:	83 c4 10             	add    $0x10,%esp
400005a6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
400005ad:	eb 2f                	jmp    400005de <ata_init_controller+0xe4>
400005af:	8b 45 f8             	mov    -0x8(%ebp),%eax
400005b2:	c1 e0 04             	shl    $0x4,%eax
400005b5:	0f b6 c0             	movzbl %al,%eax
400005b8:	83 ec 04             	sub    $0x4,%esp
400005bb:	50                   	push   %eax
400005bc:	6a 06                	push   $0x6
400005be:	ff 75 08             	pushl  0x8(%ebp)
400005c1:	e8 b5 fc ff ff       	call   4000027b <ata_reg_outb>
400005c6:	83 c4 10             	add    $0x10,%esp
400005c9:	83 ec 04             	sub    $0x4,%esp
400005cc:	6a 02                	push   $0x2
400005ce:	6a 10                	push   $0x10
400005d0:	ff 75 08             	pushl  0x8(%ebp)
400005d3:	e8 a3 fc ff ff       	call   4000027b <ata_reg_outb>
400005d8:	83 c4 10             	add    $0x10,%esp
400005db:	ff 45 f8             	incl   -0x8(%ebp)
400005de:	83 7d f8 01          	cmpl   $0x1,-0x8(%ebp)
400005e2:	7e cb                	jle    400005af <ata_init_controller+0xb5>
400005e4:	83 ec 0c             	sub    $0xc,%esp
400005e7:	ff 75 08             	pushl  0x8(%ebp)
400005ea:	e8 55 fc ff ff       	call   40000244 <ata_bus_floating>
400005ef:	83 c4 10             	add    $0x10,%esp
400005f2:	85 c0                	test   %eax,%eax
400005f4:	74 1f                	je     40000615 <ata_init_controller+0x11b>
400005f6:	8b 45 08             	mov    0x8(%ebp),%eax
400005f9:	8a 40 04             	mov    0x4(%eax),%al
400005fc:	0f b6 c0             	movzbl %al,%eax
400005ff:	83 ec 08             	sub    $0x8,%esp
40000602:	50                   	push   %eax
40000603:	68 0f 97 00 40       	push   $0x4000970f
40000608:	e8 2c 5d 00 00       	call   40006339 <printf>
4000060d:	83 c4 10             	add    $0x10,%esp
40000610:	e9 27 01 00 00       	jmp    4000073c <ata_init_controller+0x242>
40000615:	83 ec 0c             	sub    $0xc,%esp
40000618:	ff 75 08             	pushl  0x8(%ebp)
4000061b:	e8 51 fd ff ff       	call   40000371 <ata_bus_responsive_drv>
40000620:	83 c4 10             	add    $0x10,%esp
40000623:	85 c0                	test   %eax,%eax
40000625:	75 1f                	jne    40000646 <ata_init_controller+0x14c>
40000627:	8b 45 08             	mov    0x8(%ebp),%eax
4000062a:	8a 40 04             	mov    0x4(%eax),%al
4000062d:	0f b6 c0             	movzbl %al,%eax
40000630:	83 ec 08             	sub    $0x8,%esp
40000633:	50                   	push   %eax
40000634:	68 28 97 00 40       	push   $0x40009728
40000639:	e8 fb 5c 00 00       	call   40006339 <printf>
4000063e:	83 c4 10             	add    $0x10,%esp
40000641:	e9 f6 00 00 00       	jmp    4000073c <ata_init_controller+0x242>
40000646:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
4000064d:	e9 e0 00 00 00       	jmp    40000732 <ata_init_controller+0x238>
40000652:	83 ec 0c             	sub    $0xc,%esp
40000655:	6a 24                	push   $0x24
40000657:	e8 7c 7c 00 00       	call   400082d8 <malloc>
4000065c:	83 c4 10             	add    $0x10,%esp
4000065f:	89 45 fc             	mov    %eax,-0x4(%ebp)
40000662:	8b 55 fc             	mov    -0x4(%ebp),%edx
40000665:	8b 45 08             	mov    0x8(%ebp),%eax
40000668:	89 42 14             	mov    %eax,0x14(%edx)
4000066b:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000066e:	88 c2                	mov    %al,%dl
40000670:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000673:	88 50 18             	mov    %dl,0x18(%eax)
40000676:	83 ec 0c             	sub    $0xc,%esp
40000679:	ff 75 fc             	pushl  -0x4(%ebp)
4000067c:	e8 7f f9 ff ff       	call   40000000 <ata_drv_identify>
40000681:	83 c4 10             	add    $0x10,%esp
40000684:	85 c0                	test   %eax,%eax
40000686:	0f 84 95 00 00 00    	je     40000721 <ata_init_controller+0x227>
4000068c:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000068f:	8a 40 19             	mov    0x19(%eax),%al
40000692:	0f b6 d0             	movzbl %al,%edx
40000695:	8b 45 08             	mov    0x8(%ebp),%eax
40000698:	8a 40 04             	mov    0x4(%eax),%al
4000069b:	0f b6 c0             	movzbl %al,%eax
4000069e:	52                   	push   %edx
4000069f:	ff 75 f8             	pushl  -0x8(%ebp)
400006a2:	50                   	push   %eax
400006a3:	68 4c 97 00 40       	push   $0x4000974c
400006a8:	e8 8c 5c 00 00       	call   40006339 <printf>
400006ad:	83 c4 10             	add    $0x10,%esp
400006b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
400006b3:	8a 40 19             	mov    0x19(%eax),%al
400006b6:	84 c0                	test   %al,%al
400006b8:	75 2d                	jne    400006e7 <ata_init_controller+0x1ed>
400006ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
400006bd:	c7 40 1c ab 00 00 40 	movl   $0x400000ab,0x1c(%eax)
400006c4:	8b 45 08             	mov    0x8(%ebp),%eax
400006c7:	8a 40 04             	mov    0x4(%eax),%al
400006ca:	0f b6 d0             	movzbl %al,%edx
400006cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
400006d0:	83 c0 04             	add    $0x4,%eax
400006d3:	ff 75 f8             	pushl  -0x8(%ebp)
400006d6:	52                   	push   %edx
400006d7:	68 69 97 00 40       	push   $0x40009769
400006dc:	50                   	push   %eax
400006dd:	e8 84 3d 00 00       	call   40004466 <asprintf>
400006e2:	83 c4 10             	add    $0x10,%esp
400006e5:	eb 21                	jmp    40000708 <ata_init_controller+0x20e>
400006e7:	8b 45 08             	mov    0x8(%ebp),%eax
400006ea:	8a 40 04             	mov    0x4(%eax),%al
400006ed:	0f b6 d0             	movzbl %al,%edx
400006f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
400006f3:	83 c0 04             	add    $0x4,%eax
400006f6:	ff 75 f8             	pushl  -0x8(%ebp)
400006f9:	52                   	push   %edx
400006fa:	68 75 97 00 40       	push   $0x40009775
400006ff:	50                   	push   %eax
40000700:	e8 61 3d 00 00       	call   40004466 <asprintf>
40000705:	83 c4 10             	add    $0x10,%esp
40000708:	8b 45 08             	mov    0x8(%ebp),%eax
4000070b:	8b 00                	mov    (%eax),%eax
4000070d:	8b 40 08             	mov    0x8(%eax),%eax
40000710:	83 ec 08             	sub    $0x8,%esp
40000713:	ff 75 fc             	pushl  -0x4(%ebp)
40000716:	50                   	push   %eax
40000717:	e8 b9 0c 00 00       	call   400013d5 <cdi_list_push>
4000071c:	83 c4 10             	add    $0x10,%esp
4000071f:	eb 0e                	jmp    4000072f <ata_init_controller+0x235>
40000721:	83 ec 0c             	sub    $0xc,%esp
40000724:	ff 75 fc             	pushl  -0x4(%ebp)
40000727:	e8 83 82 00 00       	call   400089af <free>
4000072c:	83 c4 10             	add    $0x10,%esp
4000072f:	ff 4d f8             	decl   -0x8(%ebp)
40000732:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40000736:	0f 89 16 ff ff ff    	jns    40000652 <ata_init_controller+0x158>
4000073c:	c9                   	leave  
4000073d:	c3                   	ret    

4000073e <ata_controller_irq>:
        request.flags.lba = 1;

        request.registers.ata.command = READ_SECTORS;
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
4000073e:	55                   	push   %ebp
4000073f:	89 e5                	mov    %esp,%ebp
40000741:	83 ec 10             	sub    $0x10,%esp
        // 0 steht.
40000744:	8b 45 08             	mov    0x8(%ebp),%eax
40000747:	89 45 f8             	mov    %eax,-0x8(%ebp)
        request.registers.ata.count = (uint8_t) current_count;
4000074a:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000074d:	8b 40 14             	mov    0x14(%eax),%eax
40000750:	89 45 fc             	mov    %eax,-0x4(%ebp)
        request.registers.ata.lba = lba;

40000753:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000756:	8b 40 0c             	mov    0xc(%eax),%eax
40000759:	8d 50 01             	lea    0x1(%eax),%edx
4000075c:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000075f:	66 89 50 0c          	mov    %dx,0xc(%eax)
        request.block_count = current_count;
40000763:	c9                   	leave  
40000764:	c3                   	ret    

40000765 <ata_remove_controller>:
40000765:	55                   	push   %ebp
40000766:	89 e5                	mov    %esp,%ebp
40000768:	c9                   	leave  
40000769:	c3                   	ret    

4000076a <ata_init_device>:
4000076a:	55                   	push   %ebp
4000076b:	89 e5                	mov    %esp,%ebp
4000076d:	c9                   	leave  
4000076e:	c3                   	ret    

4000076f <ata_remove_device>:
4000076f:	55                   	push   %ebp
40000770:	89 e5                	mov    %esp,%ebp
40000772:	c9                   	leave  
40000773:	c3                   	ret    

40000774 <ata_read_blocks>:
40000774:	55                   	push   %ebp
40000775:	89 e5                	mov    %esp,%ebp
40000777:	53                   	push   %ebx
40000778:	83 ec 34             	sub    $0x34,%esp
4000077b:	8b 45 0c             	mov    0xc(%ebp),%eax
4000077e:	89 45 e0             	mov    %eax,-0x20(%ebp)
40000781:	8b 45 10             	mov    0x10(%ebp),%eax
40000784:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40000787:	8b 45 14             	mov    0x14(%ebp),%eax
4000078a:	89 45 d8             	mov    %eax,-0x28(%ebp)
4000078d:	8b 45 18             	mov    0x18(%ebp),%eax
40000790:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000793:	8b 45 08             	mov    0x8(%ebp),%eax
40000796:	89 45 f4             	mov    %eax,-0xc(%ebp)
40000799:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000079c:	8b 40 1c             	mov    0x1c(%eax),%eax
4000079f:	85 c0                	test   %eax,%eax
400007a1:	75 09                	jne    400007ac <ata_read_blocks+0x38>
400007a3:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
400007aa:	eb 31                	jmp    400007dd <ata_read_blocks+0x69>
400007ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
400007af:	8b 58 1c             	mov    0x1c(%eax),%ebx
400007b2:	8b 4d d8             	mov    -0x28(%ebp),%ecx
400007b5:	8b 45 e0             	mov    -0x20(%ebp),%eax
400007b8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
400007bb:	83 c0 01             	add    $0x1,%eax
400007be:	83 d2 00             	adc    $0x0,%edx
400007c1:	83 ec 0c             	sub    $0xc,%esp
400007c4:	ff 75 1c             	pushl  0x1c(%ebp)
400007c7:	51                   	push   %ecx
400007c8:	52                   	push   %edx
400007c9:	50                   	push   %eax
400007ca:	ff 75 f4             	pushl  -0xc(%ebp)
400007cd:	ff d3                	call   *%ebx
400007cf:	83 c4 20             	add    $0x20,%esp
400007d2:	85 c0                	test   %eax,%eax
400007d4:	0f 94 c0             	sete   %al
400007d7:	0f b6 c0             	movzbl %al,%eax
400007da:	89 45 d4             	mov    %eax,-0x2c(%ebp)
400007dd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
400007e0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400007e3:	c9                   	leave  
400007e4:	c3                   	ret    

400007e5 <ata_write_blocks>:
400007e5:	55                   	push   %ebp
400007e6:	89 e5                	mov    %esp,%ebp
400007e8:	53                   	push   %ebx
400007e9:	83 ec 34             	sub    $0x34,%esp
400007ec:	8b 45 0c             	mov    0xc(%ebp),%eax
400007ef:	89 45 e0             	mov    %eax,-0x20(%ebp)
400007f2:	8b 45 10             	mov    0x10(%ebp),%eax
400007f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400007f8:	8b 45 14             	mov    0x14(%ebp),%eax
400007fb:	89 45 d8             	mov    %eax,-0x28(%ebp)
400007fe:	8b 45 18             	mov    0x18(%ebp),%eax
40000801:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000804:	8b 45 08             	mov    0x8(%ebp),%eax
40000807:	89 45 f4             	mov    %eax,-0xc(%ebp)
4000080a:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000080d:	8b 40 20             	mov    0x20(%eax),%eax
40000810:	85 c0                	test   %eax,%eax
40000812:	75 09                	jne    4000081d <ata_write_blocks+0x38>
40000814:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
4000081b:	eb 31                	jmp    4000084e <ata_write_blocks+0x69>
4000081d:	8b 45 f4             	mov    -0xc(%ebp),%eax
40000820:	8b 58 20             	mov    0x20(%eax),%ebx
40000823:	8b 4d d8             	mov    -0x28(%ebp),%ecx
40000826:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000829:	8b 55 e4             	mov    -0x1c(%ebp),%edx
4000082c:	83 c0 01             	add    $0x1,%eax
4000082f:	83 d2 00             	adc    $0x0,%edx
40000832:	83 ec 0c             	sub    $0xc,%esp
40000835:	ff 75 1c             	pushl  0x1c(%ebp)
40000838:	51                   	push   %ecx
40000839:	52                   	push   %edx
4000083a:	50                   	push   %eax
4000083b:	ff 75 f4             	pushl  -0xc(%ebp)
4000083e:	ff d3                	call   *%ebx
40000840:	83 c4 20             	add    $0x20,%esp
40000843:	85 c0                	test   %eax,%eax
40000845:	0f 94 c0             	sete   %al
40000848:	0f b6 c0             	movzbl %al,%eax
4000084b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
4000084e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
40000851:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40000854:	c9                   	leave  
40000855:	c3                   	ret    
40000856:	90                   	nop    
40000857:	90                   	nop    

40000858 <main>:
        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
40000858:	8d 4c 24 04          	lea    0x4(%esp),%ecx
4000085c:	83 e4 f0             	and    $0xfffffff0,%esp
4000085f:	ff 71 fc             	pushl  -0x4(%ecx)
40000862:	55                   	push   %ebp
40000863:	89 e5                	mov    %esp,%ebp
40000865:	51                   	push   %ecx
40000866:	83 ec 04             	sub    $0x4,%esp
        .registers.ata.command = IDENTIFY_DEVICE,
40000869:	e8 ee 09 00 00       	call   4000125c <cdi_init>
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
4000086e:	83 ec 0c             	sub    $0xc,%esp
40000871:	68 c8 00 00 00       	push   $0xc8
40000876:	e8 75 28 00 00       	call   400030f0 <msleep>
4000087b:	83 c4 10             	add    $0x10,%esp
        .buffer = buffer,
4000087e:	e8 23 00 00 00       	call   400008a6 <ata_driver_init>

40000883:	b8 80 a0 00 40       	mov    $0x4000a080,%eax
40000888:	83 ec 0c             	sub    $0xc,%esp
4000088b:	50                   	push   %eax
4000088c:	e8 81 0d 00 00       	call   40001612 <cdi_storage_driver_register>
40000891:	83 c4 10             	add    $0x10,%esp
        .error = 0
    };
    
40000894:	e8 31 0a 00 00       	call   400012ca <cdi_run_drivers>
    // Request starten
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
40000899:	b8 00 00 00 00       	mov    $0x0,%eax
        // IDENTIFY PACKET DEVICE probieren.
4000089e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
400008a1:	c9                   	leave  
400008a2:	8d 61 fc             	lea    -0x4(%ecx),%esp
400008a5:	c3                   	ret    

400008a6 <ata_driver_init>:
        return atapi_drv_identify(dev);
    }
        
    // Ein ATA-Geraet
    dev->atapi = 0;

400008a6:	55                   	push   %ebp
400008a7:	89 e5                	mov    %esp,%ebp
400008a9:	83 ec 18             	sub    $0x18,%esp
    // TODO: Informationen verarbeiten

    return 1;
}
400008ac:	b8 80 a0 00 40       	mov    $0x4000a080,%eax
400008b1:	83 ec 0c             	sub    $0xc,%esp
400008b4:	50                   	push   %eax
400008b5:	e8 2a 0d 00 00       	call   400015e4 <cdi_storage_driver_init>
400008ba:	83 c4 10             	add    $0x10,%esp

/**
 * Sektoren von einem ATA-Geraet lesen
400008bd:	a1 00 a0 00 40       	mov    0x4000a000,%eax
400008c2:	a3 84 a0 00 40       	mov    %eax,0x4000a084
 *
 * @param start LBA des Startsektors
 * @param count Anzahl der Sektoren
400008c7:	c7 05 94 a0 00 40 c1 	movl   $0x400009c1,0x4000a094
400008ce:	09 00 40 
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
400008d1:	c7 05 8c a0 00 40 6a 	movl   $0x4000076a,0x4000a08c
400008d8:	07 00 40 
 *
400008db:	c7 05 90 a0 00 40 6f 	movl   $0x4000076f,0x4000a090
400008e2:	07 00 40 
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
400008e5:	c7 05 98 a0 00 40 74 	movl   $0x40000774,0x4000a098
400008ec:	07 00 40 
 */
400008ef:	c7 05 9c a0 00 40 e5 	movl   $0x400007e5,0x4000a09c
400008f6:	07 00 40 
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
{
400008f9:	e8 ae 0a 00 00       	call   400013ac <cdi_list_create>
400008fe:	a3 60 a0 00 40       	mov    %eax,0x4000a060
    int result = 1;
    struct ata_request request;
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
    // muss unter Umstaenden mehrmals gelesen werden.
40000903:	83 ec 0c             	sub    $0xc,%esp
40000906:	6a 38                	push   $0x38
40000908:	e8 cb 79 00 00       	call   400082d8 <malloc>
4000090d:	83 c4 10             	add    $0x10,%esp
40000910:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint16_t current_count;
40000913:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000916:	66 c7 40 06 f0 01    	movw   $0x1f0,0x6(%eax)
    void* current_buffer = buffer;
4000091c:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000091f:	66 c7 40 08 f6 03    	movw   $0x3f6,0x8(%eax)
    uint64_t lba = start;
40000925:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000928:	66 c7 40 0a 0e 00    	movw   $0xe,0xa(%eax)

4000092e:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000931:	c6 40 04 00          	movb   $0x0,0x4(%eax)
    // Anzahl der Sektoren die noch uebrig sind
40000935:	ba 80 a0 00 40       	mov    $0x4000a080,%edx
4000093a:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000093d:	89 10                	mov    %edx,(%eax)
    size_t count_left = count;
4000093f:	83 ec 0c             	sub    $0xc,%esp
40000942:	ff 75 fc             	pushl  -0x4(%ebp)
40000945:	e8 b0 fb ff ff       	call   400004fa <ata_init_controller>
4000094a:	83 c4 10             	add    $0x10,%esp

4000094d:	a1 60 a0 00 40       	mov    0x4000a060,%eax
40000952:	83 ec 08             	sub    $0x8,%esp
40000955:	ff 75 fc             	pushl  -0x4(%ebp)
40000958:	50                   	push   %eax
40000959:	e8 77 0a 00 00       	call   400013d5 <cdi_list_push>
4000095e:	83 c4 10             	add    $0x10,%esp
    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
40000961:	83 ec 0c             	sub    $0xc,%esp
40000964:	6a 38                	push   $0x38
40000966:	e8 6d 79 00 00       	call   400082d8 <malloc>
4000096b:	83 c4 10             	add    $0x10,%esp
4000096e:	89 45 fc             	mov    %eax,-0x4(%ebp)
        if (count_left > 256) {
40000971:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000974:	66 c7 40 06 70 01    	movw   $0x170,0x6(%eax)
            current_count = 256;
4000097a:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000097d:	66 c7 40 08 76 03    	movw   $0x376,0x8(%eax)
        } else {
40000983:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000986:	66 c7 40 0a 0f 00    	movw   $0xf,0xa(%eax)
            current_count = count_left;
4000098c:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000098f:	c6 40 04 01          	movb   $0x1,0x4(%eax)
        }
40000993:	ba 80 a0 00 40       	mov    $0x4000a080,%edx
40000998:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000099b:	89 10                	mov    %edx,(%eax)
        
4000099d:	83 ec 0c             	sub    $0xc,%esp
400009a0:	ff 75 fc             	pushl  -0x4(%ebp)
400009a3:	e8 52 fb ff ff       	call   400004fa <ata_init_controller>
400009a8:	83 c4 10             	add    $0x10,%esp
        // Request vorbereiten
400009ab:	a1 60 a0 00 40       	mov    0x4000a060,%eax
400009b0:	83 ec 08             	sub    $0x8,%esp
400009b3:	ff 75 fc             	pushl  -0x4(%ebp)
400009b6:	50                   	push   %eax
400009b7:	e8 19 0a 00 00       	call   400013d5 <cdi_list_push>
400009bc:	83 c4 10             	add    $0x10,%esp
        request.dev = dev;
400009bf:	c9                   	leave  
400009c0:	c3                   	ret    

400009c1 <ata_driver_destroy>:
        // TODO: DMA, UltraDMA...
        request.protocol = PIO;
        request.flags.direction = READ;
        // FIXME
        request.flags.poll = 1;
        request.flags.ata = 0;
400009c1:	55                   	push   %ebp
400009c2:	89 e5                	mov    %esp,%ebp
400009c4:	83 ec 08             	sub    $0x8,%esp
        request.flags.lba = 1;
400009c7:	b8 80 a0 00 40       	mov    $0x4000a080,%eax
400009cc:	83 ec 0c             	sub    $0xc,%esp
400009cf:	50                   	push   %eax
400009d0:	e8 26 0c 00 00       	call   400015fb <cdi_storage_driver_destroy>
400009d5:	83 c4 10             	add    $0x10,%esp

        request.registers.ata.command = READ_SECTORS;
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
400009d8:	c9                   	leave  
400009d9:	c3                   	ret    
400009da:	90                   	nop    
400009db:	90                   	nop    

400009dc <ata_request_command>:

    return 1;
}

/**
 * Sektoren von einem ATA-Geraet lesen
400009dc:	55                   	push   %ebp
400009dd:	89 e5                	mov    %esp,%ebp
400009df:	83 ec 18             	sub    $0x18,%esp
 *
400009e2:	8b 45 08             	mov    0x8(%ebp),%eax
400009e5:	8b 00                	mov    (%eax),%eax
400009e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
 * @param start LBA des Startsektors
400009ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
400009ed:	8b 40 14             	mov    0x14(%eax),%eax
400009f0:	89 45 f8             	mov    %eax,-0x8(%ebp)
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
 */
400009f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
400009f6:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
400009fc:	83 ec 0c             	sub    $0xc,%esp
400009ff:	ff 75 f4             	pushl  -0xc(%ebp)
40000a02:	e8 47 01 00 00       	call   40000b4e <ata_drv_select>
40000a07:	83 c4 10             	add    $0x10,%esp
{
    int result = 1;
    struct ata_request request;
40000a0a:	83 ec 04             	sub    $0x4,%esp
40000a0d:	68 f4 01 00 00       	push   $0x1f4
40000a12:	6a 00                	push   $0x0
40000a14:	ff 75 f4             	pushl  -0xc(%ebp)
40000a17:	e8 5b 01 00 00       	call   40000b77 <ata_drv_wait_ready>
40000a1c:	83 c4 10             	add    $0x10,%esp
40000a1f:	85 c0                	test   %eax,%eax
40000a21:	75 16                	jne    40000a39 <ata_request_command+0x5d>
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
40000a23:	8b 45 08             	mov    0x8(%ebp),%eax
40000a26:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    // muss unter Umstaenden mehrmals gelesen werden.
40000a2d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000a34:	e9 10 01 00 00       	jmp    40000b49 <ata_request_command+0x16d>
    uint16_t current_count;
    void* current_buffer = buffer;
    uint64_t lba = start;

    // Anzahl der Sektoren die noch uebrig sind
40000a39:	8b 45 08             	mov    0x8(%ebp),%eax
40000a3c:	8a 40 0e             	mov    0xe(%eax),%al
40000a3f:	0f b6 c0             	movzbl %al,%eax
40000a42:	c1 e0 08             	shl    $0x8,%eax
40000a45:	88 c2                	mov    %al,%dl
40000a47:	8b 45 08             	mov    0x8(%ebp),%eax
40000a4a:	8b 00                	mov    (%eax),%eax
40000a4c:	8a 40 18             	mov    0x18(%eax),%al
40000a4f:	0f b6 c0             	movzbl %al,%eax
40000a52:	c1 e0 04             	shl    $0x4,%eax
40000a55:	09 d0                	or     %edx,%eax
40000a57:	88 c1                	mov    %al,%cl
40000a59:	8b 45 08             	mov    0x8(%ebp),%eax
40000a5c:	8b 50 1c             	mov    0x1c(%eax),%edx
40000a5f:	8b 40 18             	mov    0x18(%eax),%eax
40000a62:	0f ac d0 18          	shrd   $0x18,%edx,%eax
40000a66:	c1 ea 18             	shr    $0x18,%edx
40000a69:	83 e0 0f             	and    $0xf,%eax
40000a6c:	09 c8                	or     %ecx,%eax
40000a6e:	0f b6 c0             	movzbl %al,%eax
40000a71:	83 ec 04             	sub    $0x4,%esp
40000a74:	50                   	push   %eax
40000a75:	6a 06                	push   $0x6
40000a77:	ff 75 f8             	pushl  -0x8(%ebp)
40000a7a:	e8 17 02 00 00       	call   40000c96 <ata_reg_outb>
40000a7f:	83 c4 10             	add    $0x10,%esp
    size_t count_left = count;

    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
40000a82:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
40000a86:	8b 45 08             	mov    0x8(%ebp),%eax
40000a89:	8a 40 0c             	mov    0xc(%eax),%al
40000a8c:	84 c0                	test   %al,%al
40000a8e:	74 04                	je     40000a94 <ata_request_command+0xb8>
        if (count_left > 256) {
            current_count = 256;
40000a90:	80 4d ff 02          	orb    $0x2,-0x1(%ebp)
        } else {
            current_count = count_left;
        }
40000a94:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
40000a98:	83 ec 04             	sub    $0x4,%esp
40000a9b:	50                   	push   %eax
40000a9c:	6a 10                	push   $0x10
40000a9e:	ff 75 f8             	pushl  -0x8(%ebp)
40000aa1:	e8 f0 01 00 00       	call   40000c96 <ata_reg_outb>
40000aa6:	83 c4 10             	add    $0x10,%esp
        
        // Request vorbereiten
        request.dev = dev;
40000aa9:	8b 45 08             	mov    0x8(%ebp),%eax
40000aac:	8a 40 14             	mov    0x14(%eax),%al
40000aaf:	0f b6 c0             	movzbl %al,%eax
40000ab2:	83 ec 04             	sub    $0x4,%esp
40000ab5:	50                   	push   %eax
40000ab6:	6a 02                	push   $0x2
40000ab8:	ff 75 f8             	pushl  -0x8(%ebp)
40000abb:	e8 d6 01 00 00       	call   40000c96 <ata_reg_outb>
40000ac0:	83 c4 10             	add    $0x10,%esp
        // TODO: DMA, UltraDMA...
        request.protocol = PIO;
        request.flags.direction = READ;
40000ac3:	8b 45 08             	mov    0x8(%ebp),%eax
40000ac6:	8b 50 1c             	mov    0x1c(%eax),%edx
40000ac9:	8b 40 18             	mov    0x18(%eax),%eax
40000acc:	0f b6 c0             	movzbl %al,%eax
40000acf:	83 ec 04             	sub    $0x4,%esp
40000ad2:	50                   	push   %eax
40000ad3:	6a 03                	push   $0x3
40000ad5:	ff 75 f8             	pushl  -0x8(%ebp)
40000ad8:	e8 b9 01 00 00       	call   40000c96 <ata_reg_outb>
40000add:	83 c4 10             	add    $0x10,%esp
        // FIXME
40000ae0:	8b 45 08             	mov    0x8(%ebp),%eax
40000ae3:	8b 50 1c             	mov    0x1c(%eax),%edx
40000ae6:	8b 40 18             	mov    0x18(%eax),%eax
40000ae9:	0f ac d0 08          	shrd   $0x8,%edx,%eax
40000aed:	c1 ea 08             	shr    $0x8,%edx
40000af0:	0f b6 c0             	movzbl %al,%eax
40000af3:	83 ec 04             	sub    $0x4,%esp
40000af6:	50                   	push   %eax
40000af7:	6a 04                	push   $0x4
40000af9:	ff 75 f8             	pushl  -0x8(%ebp)
40000afc:	e8 95 01 00 00       	call   40000c96 <ata_reg_outb>
40000b01:	83 c4 10             	add    $0x10,%esp
        request.flags.poll = 1;
40000b04:	8b 45 08             	mov    0x8(%ebp),%eax
40000b07:	8b 50 1c             	mov    0x1c(%eax),%edx
40000b0a:	8b 40 18             	mov    0x18(%eax),%eax
40000b0d:	0f ac d0 10          	shrd   $0x10,%edx,%eax
40000b11:	c1 ea 10             	shr    $0x10,%edx
40000b14:	0f b6 c0             	movzbl %al,%eax
40000b17:	83 ec 04             	sub    $0x4,%esp
40000b1a:	50                   	push   %eax
40000b1b:	6a 05                	push   $0x5
40000b1d:	ff 75 f8             	pushl  -0x8(%ebp)
40000b20:	e8 71 01 00 00       	call   40000c96 <ata_reg_outb>
40000b25:	83 c4 10             	add    $0x10,%esp
        request.flags.ata = 0;
        request.flags.lba = 1;

        request.registers.ata.command = READ_SECTORS;
40000b28:	8b 45 08             	mov    0x8(%ebp),%eax
40000b2b:	8b 40 10             	mov    0x10(%eax),%eax
40000b2e:	0f b6 c0             	movzbl %al,%eax
40000b31:	83 ec 04             	sub    $0x4,%esp
40000b34:	50                   	push   %eax
40000b35:	6a 07                	push   $0x7
40000b37:	ff 75 f8             	pushl  -0x8(%ebp)
40000b3a:	e8 57 01 00 00       	call   40000c96 <ata_reg_outb>
40000b3f:	83 c4 10             	add    $0x10,%esp
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
40000b42:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
40000b49:	8b 45 ec             	mov    -0x14(%ebp),%eax
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
40000b4c:	c9                   	leave  
40000b4d:	c3                   	ret    

40000b4e <ata_drv_select>:
40000b4e:	55                   	push   %ebp
40000b4f:	89 e5                	mov    %esp,%ebp
40000b51:	83 ec 08             	sub    $0x8,%esp
40000b54:	8b 45 08             	mov    0x8(%ebp),%eax
40000b57:	8a 40 18             	mov    0x18(%eax),%al
40000b5a:	c1 e0 04             	shl    $0x4,%eax
40000b5d:	0f b6 d0             	movzbl %al,%edx
40000b60:	8b 45 08             	mov    0x8(%ebp),%eax
40000b63:	8b 40 14             	mov    0x14(%eax),%eax
40000b66:	83 ec 04             	sub    $0x4,%esp
40000b69:	52                   	push   %edx
40000b6a:	6a 06                	push   $0x6
40000b6c:	50                   	push   %eax
40000b6d:	e8 24 01 00 00       	call   40000c96 <ata_reg_outb>
40000b72:	83 c4 10             	add    $0x10,%esp
40000b75:	c9                   	leave  
40000b76:	c3                   	ret    

40000b77 <ata_drv_wait_ready>:
 */
int ata_drv_identify(struct ata_device* dev)
{
    uint8_t buffer[ATA_SECTOR_SIZE];

    // Request vorbereiten
40000b77:	55                   	push   %ebp
40000b78:	89 e5                	mov    %esp,%ebp
40000b7a:	83 ec 18             	sub    $0x18,%esp
40000b7d:	8b 45 0c             	mov    0xc(%ebp),%eax
40000b80:	88 45 ec             	mov    %al,-0x14(%ebp)
    struct ata_request request = {
40000b83:	8b 45 08             	mov    0x8(%ebp),%eax
40000b86:	8b 40 14             	mov    0x14(%eax),%eax
40000b89:	89 45 f8             	mov    %eax,-0x8(%ebp)
        .dev = dev,
40000b8c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,
40000b93:	eb 11                	jmp    40000ba6 <ata_drv_wait_ready+0x2f>

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
40000b95:	83 45 fc 0a          	addl   $0xa,-0x4(%ebp)
        .registers.ata.command = IDENTIFY_DEVICE,
40000b99:	83 ec 0c             	sub    $0xc,%esp
40000b9c:	6a 0a                	push   $0xa
40000b9e:	e8 2a 0a 00 00       	call   400015cd <cdi_sleep_ms>
40000ba3:	83 c4 10             	add    $0x10,%esp
    struct ata_request request = {
        .dev = dev,

        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,
40000ba6:	83 ec 08             	sub    $0x8,%esp
40000ba9:	6a 07                	push   $0x7
40000bab:	ff 75 f8             	pushl  -0x8(%ebp)
40000bae:	e8 50 00 00 00       	call   40000c03 <ata_reg_inb>
40000bb3:	83 c4 10             	add    $0x10,%esp
40000bb6:	84 c0                	test   %al,%al
40000bb8:	79 1b                	jns    40000bd5 <ata_drv_wait_ready+0x5e>
40000bba:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000bbd:	3b 45 10             	cmp    0x10(%ebp),%eax
40000bc0:	72 d3                	jb     40000b95 <ata_drv_wait_ready+0x1e>
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

        .error = 0
    };
    
40000bc2:	eb 11                	jmp    40000bd5 <ata_drv_wait_ready+0x5e>
    // Request starten
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
40000bc4:	83 45 fc 0a          	addl   $0xa,-0x4(%ebp)
        // IDENTIFY PACKET DEVICE probieren.
40000bc8:	83 ec 0c             	sub    $0xc,%esp
40000bcb:	6a 0a                	push   $0xa
40000bcd:	e8 fb 09 00 00       	call   400015cd <cdi_sleep_ms>
40000bd2:	83 c4 10             	add    $0x10,%esp
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

        .error = 0
    };
    
40000bd5:	83 ec 08             	sub    $0x8,%esp
40000bd8:	6a 07                	push   $0x7
40000bda:	ff 75 f8             	pushl  -0x8(%ebp)
40000bdd:	e8 21 00 00 00       	call   40000c03 <ata_reg_inb>
40000be2:	83 c4 10             	add    $0x10,%esp
40000be5:	23 45 ec             	and    -0x14(%ebp),%eax
40000be8:	3a 45 ec             	cmp    -0x14(%ebp),%al
40000beb:	74 08                	je     40000bf5 <ata_drv_wait_ready+0x7e>
40000bed:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000bf0:	3b 45 10             	cmp    0x10(%ebp),%eax
40000bf3:	72 cf                	jb     40000bc4 <ata_drv_wait_ready+0x4d>
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
    }
        
40000bf5:	8b 45 fc             	mov    -0x4(%ebp),%eax
40000bf8:	3b 45 10             	cmp    0x10(%ebp),%eax
40000bfb:	0f 92 c0             	setb   %al
40000bfe:	0f b6 c0             	movzbl %al,%eax
    // Ein ATA-Geraet
40000c01:	c9                   	leave  
40000c02:	c3                   	ret    

40000c03 <ata_reg_inb>:
40000c03:	55                   	push   %ebp
40000c04:	89 e5                	mov    %esp,%ebp
40000c06:	83 ec 18             	sub    $0x18,%esp
40000c09:	8b 45 0c             	mov    0xc(%ebp),%eax
40000c0c:	88 45 ec             	mov    %al,-0x14(%ebp)
40000c0f:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
40000c13:	83 ec 08             	sub    $0x8,%esp
40000c16:	50                   	push   %eax
40000c17:	ff 75 08             	pushl  0x8(%ebp)
40000c1a:	e8 26 00 00 00       	call   40000c45 <ata_reg_base>
40000c1f:	83 c4 10             	add    $0x10,%esp
40000c22:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
40000c26:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
40000c2a:	83 e0 0f             	and    $0xf,%eax
40000c2d:	66 03 45 fe          	add    -0x2(%ebp),%ax
40000c31:	0f b7 c0             	movzwl %ax,%eax
40000c34:	83 ec 0c             	sub    $0xc,%esp
40000c37:	50                   	push   %eax
40000c38:	e8 3f 00 00 00       	call   40000c7c <cdi_inb>
40000c3d:	83 c4 10             	add    $0x10,%esp
40000c40:	0f b6 c0             	movzbl %al,%eax
40000c43:	c9                   	leave  
40000c44:	c3                   	ret    

40000c45 <ata_reg_base>:
40000c45:	55                   	push   %ebp
40000c46:	89 e5                	mov    %esp,%ebp
40000c48:	83 ec 08             	sub    $0x8,%esp
40000c4b:	8b 45 0c             	mov    0xc(%ebp),%eax
40000c4e:	88 45 fc             	mov    %al,-0x4(%ebp)
40000c51:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
40000c55:	83 e0 10             	and    $0x10,%eax
40000c58:	85 c0                	test   %eax,%eax
40000c5a:	75 0f                	jne    40000c6b <ata_reg_base+0x26>
40000c5c:	8b 45 08             	mov    0x8(%ebp),%eax
40000c5f:	66 8b 40 06          	mov    0x6(%eax),%ax
40000c63:	0f b7 c0             	movzwl %ax,%eax
40000c66:	89 45 f8             	mov    %eax,-0x8(%ebp)
40000c69:	eb 0c                	jmp    40000c77 <ata_reg_base+0x32>
40000c6b:	8b 45 08             	mov    0x8(%ebp),%eax
40000c6e:	8b 40 08             	mov    0x8(%eax),%eax
40000c71:	0f b7 c0             	movzwl %ax,%eax
40000c74:	89 45 f8             	mov    %eax,-0x8(%ebp)
40000c77:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000c7a:	c9                   	leave  
40000c7b:	c3                   	ret    

40000c7c <cdi_inb>:
	__asm__ ("inw %1, %0" : "=a" (result) : "Nd" (_port));
	return result;
}

static inline uint8_t cdi_inb(uint16_t _port)
{
40000c7c:	55                   	push   %ebp
40000c7d:	89 e5                	mov    %esp,%ebp
40000c7f:	83 ec 14             	sub    $0x14,%esp
40000c82:	8b 45 08             	mov    0x8(%ebp),%eax
40000c85:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	uint8_t result;
	__asm__ ("inb %1, %0" : "=a" (result) : "Nd" (_port));
40000c89:	8b 55 ec             	mov    -0x14(%ebp),%edx
40000c8c:	ec                   	in     (%dx),%al
40000c8d:	88 45 ff             	mov    %al,-0x1(%ebp)
	return result;
40000c90:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
40000c94:	c9                   	leave  
40000c95:	c3                   	ret    

40000c96 <ata_reg_outb>:
40000c96:	55                   	push   %ebp
40000c97:	89 e5                	mov    %esp,%ebp
40000c99:	83 ec 18             	sub    $0x18,%esp
40000c9c:	8b 45 0c             	mov    0xc(%ebp),%eax
40000c9f:	8b 55 10             	mov    0x10(%ebp),%edx
40000ca2:	88 45 ec             	mov    %al,-0x14(%ebp)
40000ca5:	88 55 e8             	mov    %dl,-0x18(%ebp)
40000ca8:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
40000cac:	50                   	push   %eax
40000cad:	ff 75 08             	pushl  0x8(%ebp)
40000cb0:	e8 90 ff ff ff       	call   40000c45 <ata_reg_base>
40000cb5:	83 c4 08             	add    $0x8,%esp
40000cb8:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
40000cbc:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
40000cc0:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
40000cc4:	83 e0 0f             	and    $0xf,%eax
40000cc7:	66 03 45 fe          	add    -0x2(%ebp),%ax
40000ccb:	0f b7 c0             	movzwl %ax,%eax
40000cce:	83 ec 08             	sub    $0x8,%esp
40000cd1:	52                   	push   %edx
40000cd2:	50                   	push   %eax
40000cd3:	e8 05 00 00 00       	call   40000cdd <cdi_outb>
40000cd8:	83 c4 10             	add    $0x10,%esp
40000cdb:	c9                   	leave  
40000cdc:	c3                   	ret    

40000cdd <cdi_outb>:
{
	__asm__ ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void cdi_outb(uint16_t _port, uint8_t _data)
{
40000cdd:	55                   	push   %ebp
40000cde:	89 e5                	mov    %esp,%ebp
40000ce0:	83 ec 08             	sub    $0x8,%esp
40000ce3:	8b 45 08             	mov    0x8(%ebp),%eax
40000ce6:	8b 55 0c             	mov    0xc(%ebp),%edx
40000ce9:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
40000ced:	88 55 f8             	mov    %dl,-0x8(%ebp)
	__asm__ ("outb %0, %1" : : "a" (_data), "Nd" (_port));
40000cf0:	8a 45 f8             	mov    -0x8(%ebp),%al
40000cf3:	8b 55 fc             	mov    -0x4(%ebp),%edx
40000cf6:	ee                   	out    %al,(%dx)
}
40000cf7:	c9                   	leave  
40000cf8:	c3                   	ret    

40000cf9 <ata_protocol_non_data>:
        // 0 steht.
        request.registers.ata.count = (uint8_t) current_count;
        request.registers.ata.lba = lba;

        request.block_count = current_count;
        request.block_size = ATA_SECTOR_SIZE;
40000cf9:	55                   	push   %ebp
40000cfa:	89 e5                	mov    %esp,%ebp
40000cfc:	83 ec 18             	sub    $0x18,%esp
        request.blocks_done = 0;
40000cff:	8b 45 08             	mov    0x8(%ebp),%eax
40000d02:	8b 00                	mov    (%eax),%eax
40000d04:	89 45 f0             	mov    %eax,-0x10(%ebp)
        request.buffer = current_buffer;
40000d07:	8b 45 f0             	mov    -0x10(%ebp),%eax
40000d0a:	8b 40 14             	mov    0x14(%eax),%eax
40000d0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
        // TODO: LBA48
        // TODO: CHS
        
        // Request ausfuehren
        if (!ata_request(&request)) {
            result = 0;
40000d10:	8b 45 08             	mov    0x8(%ebp),%eax
40000d13:	8a 40 0c             	mov    0xc(%eax),%al
40000d16:	84 c0                	test   %al,%al
40000d18:	74 09                	je     40000d23 <ata_protocol_non_data+0x2a>
            break;
40000d1a:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
40000d21:	eb 07                	jmp    40000d2a <ata_protocol_non_data+0x31>
        }

40000d23:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
        current_buffer += current_count * ATA_SECTOR_SIZE;
        count_left -= current_count;
        lba += current_count;
40000d2a:	8b 45 f8             	mov    -0x8(%ebp),%eax
40000d2d:	89 45 e8             	mov    %eax,-0x18(%ebp)
40000d30:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
40000d34:	74 08                	je     40000d3e <ata_protocol_non_data+0x45>
40000d36:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
40000d3a:	74 45                	je     40000d81 <ata_protocol_non_data+0x88>
40000d3c:	eb ec                	jmp    40000d2a <ata_protocol_non_data+0x31>
    }

    return result;
40000d3e:	83 ec 08             	sub    $0x8,%esp
40000d41:	68 f4 01 00 00       	push   $0x1f4
40000d46:	ff 75 f4             	pushl  -0xc(%ebp)
40000d49:	e8 64 f7 ff ff       	call   400004b2 <ata_wait_irq>
40000d4e:	83 c4 10             	add    $0x10,%esp
40000d51:	85 c0                	test   %eax,%eax
40000d53:	74 23                	je     40000d78 <ata_protocol_non_data+0x7f>
}
40000d55:	8b 45 08             	mov    0x8(%ebp),%eax
40000d58:	c7 40 2c 02 00 00 00 	movl   $0x2,0x2c(%eax)

40000d5f:	83 ec 0c             	sub    $0xc,%esp
40000d62:	68 88 97 00 40       	push   $0x40009788
40000d67:	e8 cd 55 00 00       	call   40006339 <printf>
40000d6c:	83 c4 10             	add    $0x10,%esp
40000d6f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40000d76:	eb 39                	jmp    40000db1 <ata_protocol_non_data+0xb8>
40000d78:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
40000d7f:	eb a9                	jmp    40000d2a <ata_protocol_non_data+0x31>
40000d81:	83 ec 08             	sub    $0x8,%esp
40000d84:	6a 07                	push   $0x7
40000d86:	ff 75 f4             	pushl  -0xc(%ebp)
40000d89:	e8 75 fe ff ff       	call   40000c03 <ata_reg_inb>
40000d8e:	83 c4 10             	add    $0x10,%esp
40000d91:	88 45 ff             	mov    %al,-0x1(%ebp)
40000d94:	8a 45 ff             	mov    -0x1(%ebp),%al
40000d97:	84 c0                	test   %al,%al
40000d99:	79 0f                	jns    40000daa <ata_protocol_non_data+0xb1>
40000d9b:	83 ec 0c             	sub    $0xc,%esp
40000d9e:	6a 14                	push   $0x14
40000da0:	e8 28 08 00 00       	call   400015cd <cdi_sleep_ms>
40000da5:	83 c4 10             	add    $0x10,%esp
40000da8:	eb 80                	jmp    40000d2a <ata_protocol_non_data+0x31>
40000daa:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
40000db1:	8b 45 ec             	mov    -0x14(%ebp),%eax
40000db4:	c9                   	leave  
40000db5:	c3                   	ret    

40000db6 <ata_protocol_pio_in>:
40000db6:	55                   	push   %ebp
40000db7:	89 e5                	mov    %esp,%ebp
40000db9:	53                   	push   %ebx
40000dba:	83 ec 34             	sub    $0x34,%esp
40000dbd:	8b 45 08             	mov    0x8(%ebp),%eax
40000dc0:	8b 00                	mov    (%eax),%eax
40000dc2:	89 45 e8             	mov    %eax,-0x18(%ebp)
40000dc5:	8b 45 e8             	mov    -0x18(%ebp),%eax
40000dc8:	8b 40 14             	mov    0x14(%eax),%eax
40000dcb:	89 45 ec             	mov    %eax,-0x14(%ebp)
40000dce:	8b 45 08             	mov    0x8(%ebp),%eax
40000dd1:	8a 40 0c             	mov    0xc(%eax),%al
40000dd4:	84 c0                	test   %al,%al
40000dd6:	74 09                	je     40000de1 <ata_protocol_pio_in+0x2b>
40000dd8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
40000ddf:	eb 07                	jmp    40000de8 <ata_protocol_pio_in+0x32>
40000de1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000de8:	8b 45 f0             	mov    -0x10(%ebp),%eax
40000deb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40000dee:	83 7d d4 01          	cmpl   $0x1,-0x2c(%ebp)
40000df2:	74 58                	je     40000e4c <ata_protocol_pio_in+0x96>
40000df4:	83 7d d4 01          	cmpl   $0x1,-0x2c(%ebp)
40000df8:	72 0c                	jb     40000e06 <ata_protocol_pio_in+0x50>
40000dfa:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
40000dfe:	0f 84 c0 00 00 00    	je     40000ec4 <ata_protocol_pio_in+0x10e>
40000e04:	eb e2                	jmp    40000de8 <ata_protocol_pio_in+0x32>
40000e06:	83 ec 08             	sub    $0x8,%esp
40000e09:	68 f4 01 00 00       	push   $0x1f4
40000e0e:	ff 75 ec             	pushl  -0x14(%ebp)
40000e11:	e8 9c f6 ff ff       	call   400004b2 <ata_wait_irq>
40000e16:	83 c4 10             	add    $0x10,%esp
40000e19:	85 c0                	test   %eax,%eax
40000e1b:	74 26                	je     40000e43 <ata_protocol_pio_in+0x8d>
40000e1d:	8b 45 08             	mov    0x8(%ebp),%eax
40000e20:	c7 40 2c 02 00 00 00 	movl   $0x2,0x2c(%eax)
40000e27:	83 ec 0c             	sub    $0xc,%esp
40000e2a:	68 88 97 00 40       	push   $0x40009788
40000e2f:	e8 05 55 00 00       	call   40006339 <printf>
40000e34:	83 c4 10             	add    $0x10,%esp
40000e37:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
40000e3e:	e9 29 01 00 00       	jmp    40000f6c <ata_protocol_pio_in+0x1b6>
40000e43:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
40000e4a:	eb 9c                	jmp    40000de8 <ata_protocol_pio_in+0x32>
40000e4c:	83 ec 08             	sub    $0x8,%esp
40000e4f:	6a 07                	push   $0x7
40000e51:	ff 75 ec             	pushl  -0x14(%ebp)
40000e54:	e8 aa fd ff ff       	call   40000c03 <ata_reg_inb>
40000e59:	83 c4 10             	add    $0x10,%esp
40000e5c:	88 45 f5             	mov    %al,-0xb(%ebp)
40000e5f:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
40000e63:	25 88 00 00 00       	and    $0x88,%eax
40000e68:	85 c0                	test   %eax,%eax
40000e6a:	75 21                	jne    40000e8d <ata_protocol_pio_in+0xd7>
40000e6c:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
40000e70:	83 ec 08             	sub    $0x8,%esp
40000e73:	50                   	push   %eax
40000e74:	68 a4 97 00 40       	push   $0x400097a4
40000e79:	e8 bb 54 00 00       	call   40006339 <printf>
40000e7e:	83 c4 10             	add    $0x10,%esp
40000e81:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
40000e88:	e9 df 00 00 00       	jmp    40000f6c <ata_protocol_pio_in+0x1b6>
40000e8d:	8a 45 f5             	mov    -0xb(%ebp),%al
40000e90:	84 c0                	test   %al,%al
40000e92:	79 12                	jns    40000ea6 <ata_protocol_pio_in+0xf0>
40000e94:	83 ec 0c             	sub    $0xc,%esp
40000e97:	6a 14                	push   $0x14
40000e99:	e8 2f 07 00 00       	call   400015cd <cdi_sleep_ms>
40000e9e:	83 c4 10             	add    $0x10,%esp
40000ea1:	e9 42 ff ff ff       	jmp    40000de8 <ata_protocol_pio_in+0x32>
40000ea6:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
40000eaa:	25 88 00 00 00       	and    $0x88,%eax
40000eaf:	83 f8 08             	cmp    $0x8,%eax
40000eb2:	0f 85 30 ff ff ff    	jne    40000de8 <ata_protocol_pio_in+0x32>
40000eb8:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
40000ebf:	e9 24 ff ff ff       	jmp    40000de8 <ata_protocol_pio_in+0x32>
40000ec4:	8b 45 08             	mov    0x8(%ebp),%eax
40000ec7:	8b 48 28             	mov    0x28(%eax),%ecx
40000eca:	8b 45 08             	mov    0x8(%ebp),%eax
40000ecd:	8b 40 24             	mov    0x24(%eax),%eax
40000ed0:	0f b7 d0             	movzwl %ax,%edx
40000ed3:	8b 45 08             	mov    0x8(%ebp),%eax
40000ed6:	66 8b 40 22          	mov    0x22(%eax),%ax
40000eda:	0f b7 c0             	movzwl %ax,%eax
40000edd:	0f af c2             	imul   %edx,%eax
40000ee0:	8d 04 01             	lea    (%ecx,%eax,1),%eax
40000ee3:	89 45 f8             	mov    %eax,-0x8(%ebp)
40000ee6:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
40000eec:	eb 22                	jmp    40000f10 <ata_protocol_pio_in+0x15a>
40000eee:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
40000ef2:	d1 e0                	shl    %eax
40000ef4:	89 c3                	mov    %eax,%ebx
40000ef6:	03 5d f8             	add    -0x8(%ebp),%ebx
40000ef9:	83 ec 08             	sub    $0x8,%esp
40000efc:	6a 00                	push   $0x0
40000efe:	ff 75 ec             	pushl  -0x14(%ebp)
40000f01:	e8 6e 00 00 00       	call   40000f74 <ata_reg_inw>
40000f06:	83 c4 10             	add    $0x10,%esp
40000f09:	66 89 03             	mov    %ax,(%ebx)
40000f0c:	66 ff 45 f6          	incw   -0xa(%ebp)
40000f10:	8b 45 08             	mov    0x8(%ebp),%eax
40000f13:	66 8b 40 22          	mov    0x22(%eax),%ax
40000f17:	66 d1 e8             	shr    %ax
40000f1a:	66 3b 45 f6          	cmp    -0xa(%ebp),%ax
40000f1e:	77 ce                	ja     40000eee <ata_protocol_pio_in+0x138>
40000f20:	8b 45 08             	mov    0x8(%ebp),%eax
40000f23:	8b 40 24             	mov    0x24(%eax),%eax
40000f26:	8d 50 01             	lea    0x1(%eax),%edx
40000f29:	8b 45 08             	mov    0x8(%ebp),%eax
40000f2c:	66 89 50 24          	mov    %dx,0x24(%eax)
40000f30:	8b 45 08             	mov    0x8(%ebp),%eax
40000f33:	8b 50 24             	mov    0x24(%eax),%edx
40000f36:	8b 45 08             	mov    0x8(%ebp),%eax
40000f39:	8b 40 20             	mov    0x20(%eax),%eax
40000f3c:	66 39 c2             	cmp    %ax,%dx
40000f3f:	72 09                	jb     40000f4a <ata_protocol_pio_in+0x194>
40000f41:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
40000f48:	eb 22                	jmp    40000f6c <ata_protocol_pio_in+0x1b6>
40000f4a:	8b 45 08             	mov    0x8(%ebp),%eax
40000f4d:	8a 40 0c             	mov    0xc(%eax),%al
40000f50:	84 c0                	test   %al,%al
40000f52:	74 0c                	je     40000f60 <ata_protocol_pio_in+0x1aa>
40000f54:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
40000f5b:	e9 88 fe ff ff       	jmp    40000de8 <ata_protocol_pio_in+0x32>
40000f60:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40000f67:	e9 7c fe ff ff       	jmp    40000de8 <ata_protocol_pio_in+0x32>
40000f6c:	8b 45 d8             	mov    -0x28(%ebp),%eax
40000f6f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40000f72:	c9                   	leave  
40000f73:	c3                   	ret    

40000f74 <ata_reg_inw>:
40000f74:	55                   	push   %ebp
40000f75:	89 e5                	mov    %esp,%ebp
40000f77:	83 ec 18             	sub    $0x18,%esp
40000f7a:	8b 45 0c             	mov    0xc(%ebp),%eax
40000f7d:	88 45 ec             	mov    %al,-0x14(%ebp)
40000f80:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
40000f84:	50                   	push   %eax
40000f85:	ff 75 08             	pushl  0x8(%ebp)
40000f88:	e8 b8 fc ff ff       	call   40000c45 <ata_reg_base>
40000f8d:	83 c4 08             	add    $0x8,%esp
40000f90:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
40000f94:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
40000f98:	83 e0 0f             	and    $0xf,%eax
40000f9b:	66 03 45 fe          	add    -0x2(%ebp),%ax
40000f9f:	0f b7 c0             	movzwl %ax,%eax
40000fa2:	83 ec 0c             	sub    $0xc,%esp
40000fa5:	50                   	push   %eax
40000fa6:	e8 08 00 00 00       	call   40000fb3 <cdi_inw>
40000fab:	83 c4 10             	add    $0x10,%esp
40000fae:	0f b7 c0             	movzwl %ax,%eax
40000fb1:	c9                   	leave  
40000fb2:	c3                   	ret    

40000fb3 <cdi_inw>:
#define _CDI_IO_H_

#include <stdint.h>

static inline uint16_t cdi_inw(uint16_t _port)
{
40000fb3:	55                   	push   %ebp
40000fb4:	89 e5                	mov    %esp,%ebp
40000fb6:	83 ec 14             	sub    $0x14,%esp
40000fb9:	8b 45 08             	mov    0x8(%ebp),%eax
40000fbc:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	uint16_t result;
	__asm__ ("inw %1, %0" : "=a" (result) : "Nd" (_port));
40000fc0:	8b 55 ec             	mov    -0x14(%ebp),%edx
40000fc3:	66 ed                	in     (%dx),%ax
40000fc5:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	return result;
40000fc9:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
40000fcd:	c9                   	leave  
40000fce:	c3                   	ret    

40000fcf <ata_protocol_pio_out>:
40000fcf:	55                   	push   %ebp
40000fd0:	89 e5                	mov    %esp,%ebp
40000fd2:	b8 00 00 00 00       	mov    $0x0,%eax
40000fd7:	c9                   	leave  
40000fd8:	c3                   	ret    

40000fd9 <ata_request>:
40000fd9:	55                   	push   %ebp
40000fda:	89 e5                	mov    %esp,%ebp
40000fdc:	57                   	push   %edi
40000fdd:	56                   	push   %esi
40000fde:	53                   	push   %ebx
40000fdf:	83 ec 0c             	sub    $0xc,%esp
40000fe2:	8b 45 08             	mov    0x8(%ebp),%eax
40000fe5:	8b 70 04             	mov    0x4(%eax),%esi
40000fe8:	8b 45 08             	mov    0x8(%ebp),%eax
40000feb:	8b 50 18             	mov    0x18(%eax),%edx
40000fee:	8b 48 1c             	mov    0x1c(%eax),%ecx
40000ff1:	8b 45 08             	mov    0x8(%ebp),%eax
40000ff4:	8a 40 14             	mov    0x14(%eax),%al
40000ff7:	0f b6 f8             	movzbl %al,%edi
40000ffa:	8b 45 08             	mov    0x8(%ebp),%eax
40000ffd:	8b 40 10             	mov    0x10(%eax),%eax
40001000:	89 45 e8             	mov    %eax,-0x18(%ebp)
40001003:	8b 45 08             	mov    0x8(%ebp),%eax
40001006:	8b 00                	mov    (%eax),%eax
40001008:	8a 40 18             	mov    0x18(%eax),%al
4000100b:	0f b6 d8             	movzbl %al,%ebx
4000100e:	8b 45 08             	mov    0x8(%ebp),%eax
40001011:	8b 00                	mov    (%eax),%eax
40001013:	8b 40 14             	mov    0x14(%eax),%eax
40001016:	8a 40 04             	mov    0x4(%eax),%al
40001019:	0f b6 c0             	movzbl %al,%eax
4000101c:	56                   	push   %esi
4000101d:	51                   	push   %ecx
4000101e:	52                   	push   %edx
4000101f:	57                   	push   %edi
40001020:	ff 75 e8             	pushl  -0x18(%ebp)
40001023:	53                   	push   %ebx
40001024:	50                   	push   %eax
40001025:	68 cc 97 00 40       	push   $0x400097cc
4000102a:	e8 0a 53 00 00       	call   40006339 <printf>
4000102f:	83 c4 20             	add    $0x20,%esp
40001032:	83 ec 0c             	sub    $0xc,%esp
40001035:	ff 75 08             	pushl  0x8(%ebp)
40001038:	e8 9f f9 ff ff       	call   400009dc <ata_request_command>
4000103d:	83 c4 10             	add    $0x10,%esp
40001040:	85 c0                	test   %eax,%eax
40001042:	75 1c                	jne    40001060 <ata_request+0x87>
40001044:	83 ec 0c             	sub    $0xc,%esp
40001047:	68 0c 98 00 40       	push   $0x4000980c
4000104c:	e8 e8 52 00 00       	call   40006339 <printf>
40001051:	83 c4 10             	add    $0x10,%esp
40001054:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000105b:	e9 81 00 00 00       	jmp    400010e1 <ata_request+0x108>
40001060:	8b 45 08             	mov    0x8(%ebp),%eax
40001063:	8b 40 04             	mov    0x4(%eax),%eax
40001066:	89 45 f0             	mov    %eax,-0x10(%ebp)
40001069:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
4000106d:	74 08                	je     40001077 <ata_request+0x9e>
4000106f:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
40001073:	74 1d                	je     40001092 <ata_request+0xb9>
40001075:	eb 63                	jmp    400010da <ata_request+0x101>
40001077:	83 ec 0c             	sub    $0xc,%esp
4000107a:	ff 75 08             	pushl  0x8(%ebp)
4000107d:	e8 77 fc ff ff       	call   40000cf9 <ata_protocol_non_data>
40001082:	83 c4 10             	add    $0x10,%esp
40001085:	85 c0                	test   %eax,%eax
40001087:	75 51                	jne    400010da <ata_request+0x101>
40001089:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40001090:	eb 4f                	jmp    400010e1 <ata_request+0x108>
40001092:	8b 45 08             	mov    0x8(%ebp),%eax
40001095:	8b 40 08             	mov    0x8(%eax),%eax
40001098:	85 c0                	test   %eax,%eax
4000109a:	75 1b                	jne    400010b7 <ata_request+0xde>
4000109c:	83 ec 0c             	sub    $0xc,%esp
4000109f:	ff 75 08             	pushl  0x8(%ebp)
400010a2:	e8 0f fd ff ff       	call   40000db6 <ata_protocol_pio_in>
400010a7:	83 c4 10             	add    $0x10,%esp
400010aa:	85 c0                	test   %eax,%eax
400010ac:	75 09                	jne    400010b7 <ata_request+0xde>
400010ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400010b5:	eb 2a                	jmp    400010e1 <ata_request+0x108>
400010b7:	8b 45 08             	mov    0x8(%ebp),%eax
400010ba:	8b 40 08             	mov    0x8(%eax),%eax
400010bd:	83 f8 01             	cmp    $0x1,%eax
400010c0:	75 18                	jne    400010da <ata_request+0x101>
400010c2:	ff 75 08             	pushl  0x8(%ebp)
400010c5:	e8 05 ff ff ff       	call   40000fcf <ata_protocol_pio_out>
400010ca:	83 c4 04             	add    $0x4,%esp
400010cd:	85 c0                	test   %eax,%eax
400010cf:	75 09                	jne    400010da <ata_request+0x101>
400010d1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400010d8:	eb 07                	jmp    400010e1 <ata_request+0x108>
400010da:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
400010e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
400010e4:	8d 65 f4             	lea    -0xc(%ebp),%esp
400010e7:	5b                   	pop    %ebx
400010e8:	5e                   	pop    %esi
400010e9:	5f                   	pop    %edi
400010ea:	c9                   	leave  
400010eb:	c3                   	ret    

400010ec <_start>:
400010ec:	55                   	push   %ebp
400010ed:	89 e5                	mov    %esp,%ebp
400010ef:	53                   	push   %ebx
400010f0:	83 ec 24             	sub    $0x24,%esp
400010f3:	e8 01 70 00 00       	call   400080f9 <init_memory_manager>
400010f8:	e8 27 1d 00 00       	call   40002e24 <init_messaging>
400010fd:	e8 92 21 00 00       	call   40003294 <init_sync_messages>
40001102:	e8 a9 0c 00 00       	call   40001db0 <init_envvars>
40001107:	e8 54 52 00 00       	call   40006360 <stdio_init>
4000110c:	c7 45 e0 00 01 00 00 	movl   $0x100,-0x20(%ebp)
40001113:	83 ec 0c             	sub    $0xc,%esp
40001116:	ff 75 e0             	pushl  -0x20(%ebp)
40001119:	e8 ba 71 00 00       	call   400082d8 <malloc>
4000111e:	83 c4 10             	add    $0x10,%esp
40001121:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40001124:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001127:	8b 15 04 a6 00 40    	mov    0x4000a604,%edx
4000112d:	ff 75 e0             	pushl  -0x20(%ebp)
40001130:	6a 03                	push   $0x3
40001132:	50                   	push   %eax
40001133:	52                   	push   %edx
40001134:	e8 1b 40 00 00       	call   40005154 <setvbuf>
40001139:	83 c4 10             	add    $0x10,%esp
4000113c:	e8 59 0c 00 00       	call   40001d9a <get_cmdline>
40001141:	89 45 e8             	mov    %eax,-0x18(%ebp)
40001144:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000114b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40001152:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40001159:	eb 28                	jmp    40001183 <_start+0x97>
4000115b:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000115e:	03 45 e8             	add    -0x18(%ebp),%eax
40001161:	8a 00                	mov    (%eax),%al
40001163:	3c 20                	cmp    $0x20,%al
40001165:	75 12                	jne    40001179 <_start+0x8d>
40001167:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
4000116b:	75 03                	jne    40001170 <_start+0x84>
4000116d:	ff 45 ec             	incl   -0x14(%ebp)
40001170:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40001177:	eb 07                	jmp    40001180 <_start+0x94>
40001179:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
40001180:	ff 45 f0             	incl   -0x10(%ebp)
40001183:	8b 5d f0             	mov    -0x10(%ebp),%ebx
40001186:	83 ec 0c             	sub    $0xc,%esp
40001189:	ff 75 e8             	pushl  -0x18(%ebp)
4000118c:	e8 e3 80 00 00       	call   40009274 <strlen>
40001191:	83 c4 10             	add    $0x10,%esp
40001194:	39 c3                	cmp    %eax,%ebx
40001196:	72 c3                	jb     4000115b <_start+0x6f>
40001198:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
4000119c:	75 03                	jne    400011a1 <_start+0xb5>
4000119e:	ff 45 ec             	incl   -0x14(%ebp)
400011a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
400011a4:	c1 e0 02             	shl    $0x2,%eax
400011a7:	83 c0 0f             	add    $0xf,%eax
400011aa:	83 c0 0f             	add    $0xf,%eax
400011ad:	c1 e8 04             	shr    $0x4,%eax
400011b0:	c1 e0 04             	shl    $0x4,%eax
400011b3:	29 c4                	sub    %eax,%esp
400011b5:	89 65 d8             	mov    %esp,-0x28(%ebp)
400011b8:	8b 45 d8             	mov    -0x28(%ebp),%eax
400011bb:	83 c0 0f             	add    $0xf,%eax
400011be:	c1 e8 04             	shr    $0x4,%eax
400011c1:	c1 e0 04             	shl    $0x4,%eax
400011c4:	89 45 d8             	mov    %eax,-0x28(%ebp)
400011c7:	8b 45 d8             	mov    -0x28(%ebp),%eax
400011ca:	89 45 dc             	mov    %eax,-0x24(%ebp)
400011cd:	83 ec 08             	sub    $0x8,%esp
400011d0:	68 34 98 00 40       	push   $0x40009834
400011d5:	ff 75 e8             	pushl  -0x18(%ebp)
400011d8:	e8 65 82 00 00       	call   40009442 <strtok>
400011dd:	83 c4 10             	add    $0x10,%esp
400011e0:	89 c2                	mov    %eax,%edx
400011e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
400011e5:	89 10                	mov    %edx,(%eax)
400011e7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
400011ee:	eb 20                	jmp    40001210 <_start+0x124>
400011f0:	8b 5d f0             	mov    -0x10(%ebp),%ebx
400011f3:	83 ec 08             	sub    $0x8,%esp
400011f6:	68 34 98 00 40       	push   $0x40009834
400011fb:	6a 00                	push   $0x0
400011fd:	e8 40 82 00 00       	call   40009442 <strtok>
40001202:	83 c4 10             	add    $0x10,%esp
40001205:	89 c2                	mov    %eax,%edx
40001207:	8b 45 dc             	mov    -0x24(%ebp),%eax
4000120a:	89 14 98             	mov    %edx,(%eax,%ebx,4)
4000120d:	ff 45 f0             	incl   -0x10(%ebp)
40001210:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001213:	3b 45 ec             	cmp    -0x14(%ebp),%eax
40001216:	7c d8                	jl     400011f0 <_start+0x104>
40001218:	8b 45 dc             	mov    -0x24(%ebp),%eax
4000121b:	83 ec 08             	sub    $0x8,%esp
4000121e:	50                   	push   %eax
4000121f:	ff 75 ec             	pushl  -0x14(%ebp)
40001222:	e8 31 f6 ff ff       	call   40000858 <main>
40001227:	83 c4 10             	add    $0x10,%esp
4000122a:	89 45 f8             	mov    %eax,-0x8(%ebp)
4000122d:	a1 04 a6 00 40       	mov    0x4000a604,%eax
40001232:	83 ec 0c             	sub    $0xc,%esp
40001235:	50                   	push   %eax
40001236:	e8 63 3e 00 00       	call   4000509e <fflush>
4000123b:	83 c4 10             	add    $0x10,%esp
4000123e:	83 ec 0c             	sub    $0xc,%esp
40001241:	ff 75 e4             	pushl  -0x1c(%ebp)
40001244:	e8 66 77 00 00       	call   400089af <free>
40001249:	83 c4 10             	add    $0x10,%esp
4000124c:	83 ec 0c             	sub    $0xc,%esp
4000124f:	ff 75 f8             	pushl  -0x8(%ebp)
40001252:	e8 39 32 00 00       	call   40004490 <exit>
40001257:	83 c4 10             	add    $0x10,%esp
4000125a:	eb fe                	jmp    4000125a <_start+0x16e>

4000125c <cdi_init>:
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

4000125c:	55                   	push   %ebp
4000125d:	89 e5                	mov    %esp,%ebp
4000125f:	83 ec 08             	sub    $0x8,%esp
#include <stdio.h>
40001262:	e8 b9 69 00 00       	call   40007c20 <list_create>
40001267:	a3 a0 a0 00 40       	mov    %eax,0x4000a0a0
#include <stdlib.h>
4000126c:	83 ec 0c             	sub    $0xc,%esp
4000126f:	68 88 12 00 40       	push   $0x40001288
40001274:	e8 29 01 00 00       	call   400013a2 <atexit>
40001279:	83 c4 10             	add    $0x10,%esp

#include "cdi.h"
4000127c:	e8 13 26 00 00       	call   40003894 <lostio_init>
#include "cdi/storage.h"
40001281:	e8 24 55 00 00       	call   400067aa <lostio_type_directory_use>
#include "cdi/misc.h"
40001286:	c9                   	leave  
40001287:	c3                   	ret    

40001288 <cdi_destroy>:
#include "cdi/io.h"

#include "device.h"


/**
40001288:	55                   	push   %ebp
40001289:	89 e5                	mov    %esp,%ebp
4000128b:	83 ec 18             	sub    $0x18,%esp
 * ATA-Geraet identifizieren
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
 */
4000128e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40001295:	eb 14                	jmp    400012ab <cdi_destroy+0x23>
int ata_drv_identify(struct ata_device* dev)
40001297:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000129a:	8b 40 14             	mov    0x14(%eax),%eax
4000129d:	83 ec 0c             	sub    $0xc,%esp
400012a0:	ff 75 f8             	pushl  -0x8(%ebp)
400012a3:	ff d0                	call   *%eax
400012a5:	83 c4 10             	add    $0x10,%esp

/**
 * ATA-Geraet identifizieren
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
 */
400012a8:	ff 45 fc             	incl   -0x4(%ebp)
400012ab:	a1 a0 a0 00 40       	mov    0x4000a0a0,%eax
400012b0:	83 ec 08             	sub    $0x8,%esp
400012b3:	ff 75 fc             	pushl  -0x4(%ebp)
400012b6:	50                   	push   %eax
400012b7:	e8 d1 6b 00 00       	call   40007e8d <list_get_element_at>
400012bc:	83 c4 10             	add    $0x10,%esp
400012bf:	89 45 f8             	mov    %eax,-0x8(%ebp)
400012c2:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
400012c6:	75 cf                	jne    40001297 <cdi_destroy+0xf>
int ata_drv_identify(struct ata_device* dev)
{
    uint8_t buffer[ATA_SECTOR_SIZE];
400012c8:	c9                   	leave  
400012c9:	c3                   	ret    

400012ca <cdi_run_drivers>:
    struct ata_request request = {
        .dev = dev,

        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,
400012ca:	55                   	push   %ebp
400012cb:	89 e5                	mov    %esp,%ebp
400012cd:	83 ec 18             	sub    $0x18,%esp

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
400012d0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
400012d7:	eb 48                	jmp    40001321 <cdi_run_drivers+0x57>
        .block_size = ATA_SECTOR_SIZE,
400012d9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
400012e0:	eb 1d                	jmp    400012ff <cdi_run_drivers+0x35>
        .buffer = buffer,
400012e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
400012e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
400012e8:	89 42 08             	mov    %eax,0x8(%edx)

400012eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
400012ee:	8b 40 0c             	mov    0xc(%eax),%eax
400012f1:	83 ec 0c             	sub    $0xc,%esp
400012f4:	ff 75 f4             	pushl  -0xc(%ebp)
400012f7:	ff d0                	call   *%eax
400012f9:	83 c4 10             	add    $0x10,%esp

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
400012fc:	ff 45 fc             	incl   -0x4(%ebp)
400012ff:	8b 55 fc             	mov    -0x4(%ebp),%edx
40001302:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001305:	8b 40 08             	mov    0x8(%eax),%eax
40001308:	83 ec 08             	sub    $0x8,%esp
4000130b:	52                   	push   %edx
4000130c:	50                   	push   %eax
4000130d:	e8 1a 01 00 00       	call   4000142c <cdi_list_get>
40001312:	83 c4 10             	add    $0x10,%esp
40001315:	89 45 f4             	mov    %eax,-0xc(%ebp)
40001318:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
4000131c:	75 c4                	jne    400012e2 <cdi_run_drivers+0x18>
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
4000131e:	ff 45 f8             	incl   -0x8(%ebp)
40001321:	a1 a0 a0 00 40       	mov    0x4000a0a0,%eax
40001326:	83 ec 08             	sub    $0x8,%esp
40001329:	ff 75 f8             	pushl  -0x8(%ebp)
4000132c:	50                   	push   %eax
4000132d:	e8 5b 6b 00 00       	call   40007e8d <list_get_element_at>
40001332:	83 c4 10             	add    $0x10,%esp
40001335:	89 45 f0             	mov    %eax,-0x10(%ebp)
40001338:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
4000133c:	75 9b                	jne    400012d9 <cdi_run_drivers+0xf>
        .error = 0
    };
    
    // Request starten
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
4000133e:	e8 39 25 00 00       	call   4000387c <wait_for_rpc>
        // IDENTIFY PACKET DEVICE probieren.
40001343:	eb f9                	jmp    4000133e <cdi_run_drivers+0x74>

40001345 <cdi_driver_init>:
    }
        
    // Ein ATA-Geraet
    dev->atapi = 0;

    // TODO: Informationen verarbeiten
40001345:	55                   	push   %ebp
40001346:	89 e5                	mov    %esp,%ebp
40001348:	83 ec 08             	sub    $0x8,%esp

4000134b:	e8 5c 00 00 00       	call   400013ac <cdi_list_create>
40001350:	89 c2                	mov    %eax,%edx
40001352:	8b 45 08             	mov    0x8(%ebp),%eax
40001355:	89 50 08             	mov    %edx,0x8(%eax)
    return 1;
40001358:	c9                   	leave  
40001359:	c3                   	ret    

4000135a <cdi_driver_destroy>:
}

/**
 * Sektoren von einem ATA-Geraet lesen
 *
 * @param start LBA des Startsektors
4000135a:	55                   	push   %ebp
4000135b:	89 e5                	mov    %esp,%ebp
4000135d:	83 ec 08             	sub    $0x8,%esp
 * @param count Anzahl der Sektoren
40001360:	8b 45 08             	mov    0x8(%ebp),%eax
40001363:	8b 40 08             	mov    0x8(%eax),%eax
40001366:	83 ec 0c             	sub    $0xc,%esp
40001369:	50                   	push   %eax
4000136a:	e8 4a 00 00 00       	call   400013b9 <cdi_list_destroy>
4000136f:	83 c4 10             	add    $0x10,%esp
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
40001372:	c9                   	leave  
40001373:	c3                   	ret    

40001374 <cdi_driver_register>:
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
{
    int result = 1;
    struct ata_request request;
40001374:	55                   	push   %ebp
40001375:	89 e5                	mov    %esp,%ebp
40001377:	83 ec 08             	sub    $0x8,%esp
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
4000137a:	a1 a0 a0 00 40       	mov    0x4000a0a0,%eax
4000137f:	83 ec 08             	sub    $0x8,%esp
40001382:	ff 75 08             	pushl  0x8(%ebp)
40001385:	50                   	push   %eax
40001386:	e8 41 69 00 00       	call   40007ccc <list_push>
4000138b:	83 c4 10             	add    $0x10,%esp
    // muss unter Umstaenden mehrmals gelesen werden.
4000138e:	8b 45 08             	mov    0x8(%ebp),%eax
40001391:	8b 40 04             	mov    0x4(%eax),%eax
40001394:	83 ec 0c             	sub    $0xc,%esp
40001397:	50                   	push   %eax
40001398:	e8 df 0f 00 00       	call   4000237c <init_service_register>
4000139d:	83 c4 10             	add    $0x10,%esp
    uint16_t current_count;
400013a0:	c9                   	leave  
400013a1:	c3                   	ret    

400013a2 <atexit>:
    void* current_buffer = buffer;
    uint64_t lba = start;

    // Anzahl der Sektoren die noch uebrig sind
400013a2:	55                   	push   %ebp
400013a3:	89 e5                	mov    %esp,%ebp
    size_t count_left = count;
400013a5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

400013aa:	c9                   	leave  
400013ab:	c3                   	ret    

400013ac <cdi_list_create>:
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
400013ac:	55                   	push   %ebp
400013ad:	89 e5                	mov    %esp,%ebp
400013af:	83 ec 08             	sub    $0x8,%esp
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR 
400013b2:	e8 69 68 00 00       	call   40007c20 <list_create>
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
400013b7:	c9                   	leave  
400013b8:	c3                   	ret    

400013b9 <cdi_list_destroy>:
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
400013b9:	55                   	push   %ebp
400013ba:	89 e5                	mov    %esp,%ebp
400013bc:	83 ec 18             	sub    $0x18,%esp

400013bf:	8b 45 08             	mov    0x8(%ebp),%eax
400013c2:	89 45 fc             	mov    %eax,-0x4(%ebp)
#include <stdio.h>
400013c5:	83 ec 0c             	sub    $0xc,%esp
400013c8:	ff 75 fc             	pushl  -0x4(%ebp)
400013cb:	e8 7e 68 00 00       	call   40007c4e <list_destroy>
400013d0:	83 c4 10             	add    $0x10,%esp
#include <stdlib.h>
400013d3:	c9                   	leave  
400013d4:	c3                   	ret    

400013d5 <cdi_list_push>:

#include "cdi.h"
#include "cdi/storage.h"
#include "cdi/misc.h"
#include "cdi/io.h"

400013d5:	55                   	push   %ebp
400013d6:	89 e5                	mov    %esp,%ebp
400013d8:	83 ec 18             	sub    $0x18,%esp
#include "device.h"
400013db:	8b 45 08             	mov    0x8(%ebp),%eax
400013de:	89 45 fc             	mov    %eax,-0x4(%ebp)

400013e1:	83 ec 08             	sub    $0x8,%esp
400013e4:	ff 75 0c             	pushl  0xc(%ebp)
400013e7:	ff 75 fc             	pushl  -0x4(%ebp)
400013ea:	e8 dd 68 00 00       	call   40007ccc <list_push>
400013ef:	83 c4 10             	add    $0x10,%esp

400013f2:	c9                   	leave  
400013f3:	c3                   	ret    

400013f4 <cdi_list_pop>:
/**
 * ATA-Geraet identifizieren
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
 */
int ata_drv_identify(struct ata_device* dev)
400013f4:	55                   	push   %ebp
400013f5:	89 e5                	mov    %esp,%ebp
400013f7:	83 ec 18             	sub    $0x18,%esp
{
400013fa:	8b 45 08             	mov    0x8(%ebp),%eax
400013fd:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t buffer[ATA_SECTOR_SIZE];
40001400:	83 ec 0c             	sub    $0xc,%esp
40001403:	ff 75 fc             	pushl  -0x4(%ebp)
40001406:	e8 30 69 00 00       	call   40007d3b <list_pop>
4000140b:	83 c4 10             	add    $0x10,%esp

4000140e:	c9                   	leave  
4000140f:	c3                   	ret    

40001410 <cdi_list_empty>:
    struct ata_request request = {
        .dev = dev,

        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,
40001410:	55                   	push   %ebp
40001411:	89 e5                	mov    %esp,%ebp
40001413:	83 ec 18             	sub    $0x18,%esp

40001416:	8b 45 08             	mov    0x8(%ebp),%eax
40001419:	89 45 fc             	mov    %eax,-0x4(%ebp)
        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
4000141c:	83 ec 0c             	sub    $0xc,%esp
4000141f:	ff 75 fc             	pushl  -0x4(%ebp)
40001422:	e8 4f 68 00 00       	call   40007c76 <list_is_empty>
40001427:	83 c4 10             	add    $0x10,%esp
        .protocol = PIO,
4000142a:	c9                   	leave  
4000142b:	c3                   	ret    

4000142c <cdi_list_get>:
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

        .error = 0
4000142c:	55                   	push   %ebp
4000142d:	89 e5                	mov    %esp,%ebp
4000142f:	83 ec 18             	sub    $0x18,%esp
    };
40001432:	8b 45 08             	mov    0x8(%ebp),%eax
40001435:	89 45 fc             	mov    %eax,-0x4(%ebp)
    
40001438:	8b 45 0c             	mov    0xc(%ebp),%eax
4000143b:	83 ec 08             	sub    $0x8,%esp
4000143e:	50                   	push   %eax
4000143f:	ff 75 fc             	pushl  -0x4(%ebp)
40001442:	e8 46 6a 00 00       	call   40007e8d <list_get_element_at>
40001447:	83 c4 10             	add    $0x10,%esp
    // Request starten
4000144a:	c9                   	leave  
4000144b:	c3                   	ret    

4000144c <cdi_list_insert>:
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
    }
        
    // Ein ATA-Geraet
    dev->atapi = 0;
4000144c:	55                   	push   %ebp
4000144d:	89 e5                	mov    %esp,%ebp
4000144f:	83 ec 18             	sub    $0x18,%esp

40001452:	8b 45 08             	mov    0x8(%ebp),%eax
40001455:	89 45 fc             	mov    %eax,-0x4(%ebp)
    // TODO: Informationen verarbeiten
40001458:	8b 45 0c             	mov    0xc(%ebp),%eax
4000145b:	83 ec 04             	sub    $0x4,%esp
4000145e:	ff 75 10             	pushl  0x10(%ebp)
40001461:	50                   	push   %eax
40001462:	ff 75 fc             	pushl  -0x4(%ebp)
40001465:	e8 57 6a 00 00       	call   40007ec1 <list_insert>
4000146a:	83 c4 10             	add    $0x10,%esp

4000146d:	c9                   	leave  
4000146e:	c3                   	ret    

4000146f <cdi_list_remove>:
    return 1;
}

/**
 * Sektoren von einem ATA-Geraet lesen
 *
4000146f:	55                   	push   %ebp
40001470:	89 e5                	mov    %esp,%ebp
40001472:	83 ec 18             	sub    $0x18,%esp
 * @param start LBA des Startsektors
40001475:	8b 45 08             	mov    0x8(%ebp),%eax
40001478:	89 45 fc             	mov    %eax,-0x4(%ebp)
 * @param count Anzahl der Sektoren
4000147b:	8b 45 0c             	mov    0xc(%ebp),%eax
4000147e:	83 ec 08             	sub    $0x8,%esp
40001481:	50                   	push   %eax
40001482:	ff 75 fc             	pushl  -0x4(%ebp)
40001485:	e8 ef 6a 00 00       	call   40007f79 <list_remove>
4000148a:	83 c4 10             	add    $0x10,%esp
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
4000148d:	c9                   	leave  
4000148e:	c3                   	ret    

4000148f <cdi_list_size>:
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
{
4000148f:	55                   	push   %ebp
40001490:	89 e5                	mov    %esp,%ebp
40001492:	83 ec 18             	sub    $0x18,%esp
    int result = 1;
40001495:	8b 45 08             	mov    0x8(%ebp),%eax
40001498:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct ata_request request;
4000149b:	83 ec 0c             	sub    $0xc,%esp
4000149e:	ff 75 fc             	pushl  -0x4(%ebp)
400014a1:	e8 fa 67 00 00       	call   40007ca0 <list_size>
400014a6:	83 c4 10             	add    $0x10,%esp
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
400014a9:	c9                   	leave  
400014aa:	c3                   	ret    
400014ab:	90                   	nop    

400014ac <irq_handler>:
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
400014ac:	55                   	push   %ebp
400014ad:	89 e5                	mov    %esp,%ebp
400014af:	83 ec 08             	sub    $0x8,%esp
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
400014b2:	8b 15 a4 a0 00 40    	mov    0x4000a0a4,%edx
400014b8:	a1 a8 a0 00 40       	mov    0x4000a0a8,%eax
400014bd:	83 ec 0c             	sub    $0xc,%esp
400014c0:	50                   	push   %eax
400014c1:	ff d2                	call   *%edx
400014c3:	83 c4 10             	add    $0x10,%esp
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
400014c6:	c9                   	leave  
400014c7:	c3                   	ret    

400014c8 <cdi_register_irq>:

#include <stdio.h>
#include <stdlib.h>

#include "cdi.h"
#include "cdi/storage.h"
400014c8:	55                   	push   %ebp
400014c9:	89 e5                	mov    %esp,%ebp
400014cb:	83 ec 08             	sub    $0x8,%esp
400014ce:	8b 45 08             	mov    0x8(%ebp),%eax
400014d1:	88 45 fc             	mov    %al,-0x4(%ebp)
#include "cdi/misc.h"
400014d4:	8b 45 0c             	mov    0xc(%ebp),%eax
400014d7:	a3 a4 a0 00 40       	mov    %eax,0x4000a0a4
#include "cdi/io.h"
400014dc:	8b 45 10             	mov    0x10(%ebp),%eax
400014df:	a3 a8 a0 00 40       	mov    %eax,0x4000a0a8

#include "device.h"
400014e4:	8a 45 fc             	mov    -0x4(%ebp),%al
400014e7:	83 c0 20             	add    $0x20,%eax
400014ea:	0f b6 c0             	movzbl %al,%eax
400014ed:	83 ec 08             	sub    $0x8,%esp
400014f0:	68 ac 14 00 40       	push   $0x400014ac
400014f5:	50                   	push   %eax
400014f6:	e8 72 1a 00 00       	call   40002f6d <register_intr_handler>
400014fb:	83 c4 10             	add    $0x10,%esp

400014fe:	c9                   	leave  
400014ff:	c3                   	ret    

40001500 <cdi_alloc_phys_mem>:
    uint8_t buffer[ATA_SECTOR_SIZE];

    // Request vorbereiten
    struct ata_request request = {
        .dev = dev,

40001500:	55                   	push   %ebp
40001501:	89 e5                	mov    %esp,%ebp
40001503:	83 ec 18             	sub    $0x18,%esp
        .flags.direction = READ,
40001506:	8d 45 f8             	lea    -0x8(%ebp),%eax
40001509:	83 ec 04             	sub    $0x4,%esp
4000150c:	68 80 00 00 00       	push   $0x80
40001511:	ff 75 08             	pushl  0x8(%ebp)
40001514:	50                   	push   %eax
40001515:	e8 56 18 00 00       	call   40002d70 <mem_dma_allocate>
4000151a:	83 c4 0c             	add    $0xc,%esp
        .flags.poll = 1,
        .flags.lba = 0,
4000151d:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001520:	85 c0                	test   %eax,%eax
40001522:	75 09                	jne    4000152d <cdi_alloc_phys_mem+0x2d>

40001524:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
4000152b:	eb 17                	jmp    40001544 <cdi_alloc_phys_mem+0x44>
        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
4000152d:	8b 55 f8             	mov    -0x8(%ebp),%edx
40001530:	8b 45 0c             	mov    0xc(%ebp),%eax
40001533:	89 10                	mov    %edx,(%eax)
        .block_count = 1,
40001535:	8b 55 fc             	mov    -0x4(%ebp),%edx
40001538:	8b 45 10             	mov    0x10(%ebp),%eax
4000153b:	89 10                	mov    %edx,(%eax)
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,
4000153d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40001544:	8b 45 ec             	mov    -0x14(%ebp),%eax

40001547:	c9                   	leave  
40001548:	c3                   	ret    

40001549 <cdi_ioports_alloc>:
    
    // Request starten
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
40001549:	55                   	push   %ebp
4000154a:	89 e5                	mov    %esp,%ebp
4000154c:	83 ec 18             	sub    $0x18,%esp
4000154f:	8b 45 08             	mov    0x8(%ebp),%eax
40001552:	8b 55 0c             	mov    0xc(%ebp),%edx
40001555:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
40001559:	66 89 55 f8          	mov    %dx,-0x8(%ebp)
    }
4000155d:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
40001561:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
40001565:	83 ec 08             	sub    $0x8,%esp
40001568:	50                   	push   %eax
40001569:	52                   	push   %edx
4000156a:	e8 ed 1b 00 00       	call   4000315c <request_ports>
4000156f:	83 c4 10             	add    $0x10,%esp
40001572:	85 c0                	test   %eax,%eax
40001574:	74 09                	je     4000157f <cdi_ioports_alloc+0x36>
40001576:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
4000157d:	eb 07                	jmp    40001586 <cdi_ioports_alloc+0x3d>
4000157f:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
40001586:	8b 45 f4             	mov    -0xc(%ebp),%eax
        
40001589:	c9                   	leave  
4000158a:	c3                   	ret    

4000158b <cdi_ioports_free>:

    // TODO: Informationen verarbeiten

    return 1;
}

4000158b:	55                   	push   %ebp
4000158c:	89 e5                	mov    %esp,%ebp
4000158e:	83 ec 18             	sub    $0x18,%esp
40001591:	8b 45 08             	mov    0x8(%ebp),%eax
40001594:	8b 55 0c             	mov    0xc(%ebp),%edx
40001597:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
4000159b:	66 89 55 f8          	mov    %dx,-0x8(%ebp)
/**
4000159f:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
400015a3:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
400015a7:	83 ec 08             	sub    $0x8,%esp
400015aa:	50                   	push   %eax
400015ab:	52                   	push   %edx
400015ac:	e8 c9 1b 00 00       	call   4000317a <release_ports>
400015b1:	83 c4 10             	add    $0x10,%esp
400015b4:	85 c0                	test   %eax,%eax
400015b6:	74 09                	je     400015c1 <cdi_ioports_free+0x36>
400015b8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
400015bf:	eb 07                	jmp    400015c8 <cdi_ioports_free+0x3d>
400015c1:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
400015c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 * Sektoren von einem ATA-Geraet lesen
400015cb:	c9                   	leave  
400015cc:	c3                   	ret    

400015cd <cdi_sleep_ms>:
 *
 * @param start LBA des Startsektors
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
400015cd:	55                   	push   %ebp
400015ce:	89 e5                	mov    %esp,%ebp
400015d0:	83 ec 08             	sub    $0x8,%esp
 */
400015d3:	83 ec 0c             	sub    $0xc,%esp
400015d6:	ff 75 08             	pushl  0x8(%ebp)
400015d9:	e8 12 1b 00 00       	call   400030f0 <msleep>
400015de:	83 c4 10             	add    $0x10,%esp
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
400015e1:	c9                   	leave  
400015e2:	c3                   	ret    
400015e3:	90                   	nop    

400015e4 <cdi_storage_driver_init>:
#include "cdi/io.h"

#include "device.h"


/**
400015e4:	55                   	push   %ebp
400015e5:	89 e5                	mov    %esp,%ebp
400015e7:	83 ec 08             	sub    $0x8,%esp
 * ATA-Geraet identifizieren
400015ea:	8b 45 08             	mov    0x8(%ebp),%eax
400015ed:	83 ec 0c             	sub    $0xc,%esp
400015f0:	50                   	push   %eax
400015f1:	e8 4f fd ff ff       	call   40001345 <cdi_driver_init>
400015f6:	83 c4 10             	add    $0x10,%esp
 *
400015f9:	c9                   	leave  
400015fa:	c3                   	ret    

400015fb <cdi_storage_driver_destroy>:
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
 */
int ata_drv_identify(struct ata_device* dev)
{
    uint8_t buffer[ATA_SECTOR_SIZE];

400015fb:	55                   	push   %ebp
400015fc:	89 e5                	mov    %esp,%ebp
400015fe:	83 ec 08             	sub    $0x8,%esp
    // Request vorbereiten
40001601:	8b 45 08             	mov    0x8(%ebp),%eax
40001604:	83 ec 0c             	sub    $0xc,%esp
40001607:	50                   	push   %eax
40001608:	e8 4d fd ff ff       	call   4000135a <cdi_driver_destroy>
4000160d:	83 c4 10             	add    $0x10,%esp
    struct ata_request request = {
40001610:	c9                   	leave  
40001611:	c3                   	ret    

40001612 <cdi_storage_driver_register>:
        .dev = dev,

        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,

40001612:	55                   	push   %ebp
40001613:	89 e5                	mov    %esp,%ebp
40001615:	83 ec 18             	sub    $0x18,%esp
        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
40001618:	8b 45 08             	mov    0x8(%ebp),%eax
4000161b:	83 ec 0c             	sub    $0xc,%esp
4000161e:	50                   	push   %eax
4000161f:	e8 50 fd ff ff       	call   40001374 <cdi_driver_register>
40001624:	83 c4 10             	add    $0x10,%esp
        .buffer = buffer,

40001627:	a1 ac a0 00 40       	mov    0x4000a0ac,%eax
4000162c:	85 c0                	test   %eax,%eax
4000162e:	75 0f                	jne    4000163f <cdi_storage_driver_register+0x2d>
        .error = 0
40001630:	e8 5c 04 00 00       	call   40001a91 <lostio_mst_if_init>
    };
40001635:	c7 05 ac a0 00 40 01 	movl   $0x1,0x4000a0ac
4000163c:	00 00 00 
    
    // Request starten
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
4000163f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40001646:	eb 11                	jmp    40001659 <cdi_storage_driver_register+0x47>
        // IDENTIFY PACKET DEVICE probieren.
40001648:	83 ec 0c             	sub    $0xc,%esp
4000164b:	ff 75 fc             	pushl  -0x4(%ebp)
4000164e:	e8 56 04 00 00       	call   40001aa9 <lostio_mst_if_newdev>
40001653:	83 c4 10             	add    $0x10,%esp
        .error = 0
    };
    
    // Request starten
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
40001656:	ff 45 f8             	incl   -0x8(%ebp)
40001659:	8b 55 f8             	mov    -0x8(%ebp),%edx
4000165c:	8b 45 08             	mov    0x8(%ebp),%eax
4000165f:	8b 40 08             	mov    0x8(%eax),%eax
40001662:	83 ec 08             	sub    $0x8,%esp
40001665:	52                   	push   %edx
40001666:	50                   	push   %eax
40001667:	e8 c0 fd ff ff       	call   4000142c <cdi_list_get>
4000166c:	83 c4 10             	add    $0x10,%esp
4000166f:	89 45 fc             	mov    %eax,-0x4(%ebp)
40001672:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40001676:	75 d0                	jne    40001648 <cdi_storage_driver_register+0x36>
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
    }
40001678:	c9                   	leave  
40001679:	c3                   	ret    

4000167a <cdi_storage_read>:

    return 1;
}

/**
 * Sektoren von einem ATA-Geraet lesen
4000167a:	55                   	push   %ebp
4000167b:	89 e5                	mov    %esp,%ebp
4000167d:	56                   	push   %esi
4000167e:	53                   	push   %ebx
4000167f:	83 ec 50             	sub    $0x50,%esp
40001682:	8b 45 0c             	mov    0xc(%ebp),%eax
40001685:	89 45 c0             	mov    %eax,-0x40(%ebp)
40001688:	8b 45 10             	mov    0x10(%ebp),%eax
4000168b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 *
 * @param start LBA des Startsektors
4000168e:	8b 45 08             	mov    0x8(%ebp),%eax
40001691:	8b 40 08             	mov    0x8(%eax),%eax
40001694:	89 45 d8             	mov    %eax,-0x28(%ebp)
 * @param count Anzahl der Sektoren
40001697:	8b 45 08             	mov    0x8(%ebp),%eax
4000169a:	8b 40 0c             	mov    0xc(%eax),%eax
4000169d:	89 45 dc             	mov    %eax,-0x24(%ebp)
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
400016a0:	8b 45 dc             	mov    -0x24(%ebp),%eax
400016a3:	ba 00 00 00 00       	mov    $0x0,%edx
400016a8:	52                   	push   %edx
400016a9:	50                   	push   %eax
400016aa:	ff 75 c4             	pushl  -0x3c(%ebp)
400016ad:	ff 75 c0             	pushl  -0x40(%ebp)
400016b0:	e8 a7 7d 00 00       	call   4000945c <__udivdi3>
400016b5:	83 c4 10             	add    $0x10,%esp
400016b8:	89 45 e0             	mov    %eax,-0x20(%ebp)
400016bb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
400016be:	8b 45 14             	mov    0x14(%ebp),%eax
400016c1:	ba 00 00 00 00       	mov    $0x0,%edx
400016c6:	89 c1                	mov    %eax,%ecx
400016c8:	89 d3                	mov    %edx,%ebx
400016ca:	03 4d c0             	add    -0x40(%ebp),%ecx
400016cd:	13 5d c4             	adc    -0x3c(%ebp),%ebx
400016d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
400016d3:	ba 00 00 00 00       	mov    $0x0,%edx
400016d8:	52                   	push   %edx
400016d9:	50                   	push   %eax
400016da:	53                   	push   %ebx
400016db:	51                   	push   %ecx
400016dc:	e8 7b 7d 00 00       	call   4000945c <__udivdi3>
400016e1:	83 c4 10             	add    $0x10,%esp
400016e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
400016e7:	89 55 ec             	mov    %edx,-0x14(%ebp)
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
400016ea:	8b 4d e0             	mov    -0x20(%ebp),%ecx
400016ed:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
400016f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
400016f3:	8b 55 ec             	mov    -0x14(%ebp),%edx
400016f6:	29 c8                	sub    %ecx,%eax
400016f8:	19 da                	sbb    %ebx,%edx
400016fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
400016fd:	89 55 f4             	mov    %edx,-0xc(%ebp)
    void* buffer)
{
    int result = 1;
40001700:	8b 45 dc             	mov    -0x24(%ebp),%eax
40001703:	ba 00 00 00 00       	mov    $0x0,%edx
40001708:	8b 4d c0             	mov    -0x40(%ebp),%ecx
4000170b:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
4000170e:	52                   	push   %edx
4000170f:	50                   	push   %eax
40001710:	53                   	push   %ebx
40001711:	51                   	push   %ecx
40001712:	e8 6d 7e 00 00       	call   40009584 <__umoddi3>
40001717:	83 c4 10             	add    $0x10,%esp
4000171a:	09 d0                	or     %edx,%eax
4000171c:	85 c0                	test   %eax,%eax
4000171e:	75 54                	jne    40001774 <cdi_storage_read+0xfa>
40001720:	8b 45 14             	mov    0x14(%ebp),%eax
40001723:	ba 00 00 00 00       	mov    $0x0,%edx
40001728:	89 c1                	mov    %eax,%ecx
4000172a:	89 d3                	mov    %edx,%ebx
4000172c:	03 4d c0             	add    -0x40(%ebp),%ecx
4000172f:	13 5d c4             	adc    -0x3c(%ebp),%ebx
40001732:	8b 45 dc             	mov    -0x24(%ebp),%eax
40001735:	ba 00 00 00 00       	mov    $0x0,%edx
4000173a:	52                   	push   %edx
4000173b:	50                   	push   %eax
4000173c:	53                   	push   %ebx
4000173d:	51                   	push   %ecx
4000173e:	e8 41 7e 00 00       	call   40009584 <__umoddi3>
40001743:	83 c4 10             	add    $0x10,%esp
40001746:	09 d0                	or     %edx,%eax
40001748:	85 c0                	test   %eax,%eax
4000174a:	75 28                	jne    40001774 <cdi_storage_read+0xfa>
    struct ata_request request;
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
4000174c:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000174f:	8b 40 18             	mov    0x18(%eax),%eax
40001752:	83 ec 08             	sub    $0x8,%esp
40001755:	ff 75 18             	pushl  0x18(%ebp)
40001758:	ff 75 f4             	pushl  -0xc(%ebp)
4000175b:	ff 75 f0             	pushl  -0x10(%ebp)
4000175e:	ff 75 e4             	pushl  -0x1c(%ebp)
40001761:	ff 75 e0             	pushl  -0x20(%ebp)
40001764:	ff 75 08             	pushl  0x8(%ebp)
40001767:	ff d0                	call   *%eax
40001769:	83 c4 20             	add    $0x20,%esp
4000176c:	89 45 b0             	mov    %eax,-0x50(%ebp)
4000176f:	e9 d0 00 00 00       	jmp    40001844 <cdi_storage_read+0x1ca>
40001774:	89 e0                	mov    %esp,%eax
40001776:	89 45 b8             	mov    %eax,-0x48(%ebp)
    // muss unter Umstaenden mehrmals gelesen werden.
    uint16_t current_count;
    void* current_buffer = buffer;
    uint64_t lba = start;
40001779:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
4000177d:	83 55 f4 00          	adcl   $0x0,-0xc(%ebp)

40001781:	8b 45 dc             	mov    -0x24(%ebp),%eax
40001784:	ba 00 00 00 00       	mov    $0x0,%edx
40001789:	8b 4d f0             	mov    -0x10(%ebp),%ecx
4000178c:	0f af ca             	imul   %edx,%ecx
4000178f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
40001792:	0f af d8             	imul   %eax,%ebx
40001795:	01 d9                	add    %ebx,%ecx
40001797:	f7 65 f0             	mull   -0x10(%ebp)
4000179a:	01 d1                	add    %edx,%ecx
4000179c:	89 ca                	mov    %ecx,%edx
4000179e:	83 c0 0f             	add    $0xf,%eax
400017a1:	83 c0 0f             	add    $0xf,%eax
400017a4:	c1 e8 04             	shr    $0x4,%eax
400017a7:	c1 e0 04             	shl    $0x4,%eax
400017aa:	29 c4                	sub    %eax,%esp
400017ac:	89 65 b4             	mov    %esp,-0x4c(%ebp)
400017af:	8b 45 b4             	mov    -0x4c(%ebp),%eax
400017b2:	83 c0 0f             	add    $0xf,%eax
400017b5:	c1 e8 04             	shr    $0x4,%eax
400017b8:	c1 e0 04             	shl    $0x4,%eax
400017bb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
400017be:	8b 45 b4             	mov    -0x4c(%ebp),%eax
400017c1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;

400017c4:	8b 45 d8             	mov    -0x28(%ebp),%eax
400017c7:	8b 50 18             	mov    0x18(%eax),%edx
400017ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
400017cd:	83 ec 08             	sub    $0x8,%esp
400017d0:	50                   	push   %eax
400017d1:	ff 75 f4             	pushl  -0xc(%ebp)
400017d4:	ff 75 f0             	pushl  -0x10(%ebp)
400017d7:	ff 75 e4             	pushl  -0x1c(%ebp)
400017da:	ff 75 e0             	pushl  -0x20(%ebp)
400017dd:	ff 75 08             	pushl  0x8(%ebp)
400017e0:	ff d2                	call   *%edx
400017e2:	83 c4 20             	add    $0x20,%esp
400017e5:	85 c0                	test   %eax,%eax
400017e7:	74 10                	je     400017f9 <cdi_storage_read+0x17f>
    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
400017e9:	c7 45 b0 ff ff ff ff 	movl   $0xffffffff,-0x50(%ebp)
400017f0:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
400017f7:	eb 39                	jmp    40001832 <cdi_storage_read+0x1b8>
        if (count_left > 256) {
            current_count = 256;
        } else {
            current_count = count_left;
400017f9:	8b 75 d4             	mov    -0x2c(%ebp),%esi
400017fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
400017ff:	ba 00 00 00 00       	mov    $0x0,%edx
40001804:	8b 4d c0             	mov    -0x40(%ebp),%ecx
40001807:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
4000180a:	52                   	push   %edx
4000180b:	50                   	push   %eax
4000180c:	53                   	push   %ebx
4000180d:	51                   	push   %ecx
4000180e:	e8 71 7d 00 00       	call   40009584 <__umoddi3>
40001813:	83 c4 10             	add    $0x10,%esp
40001816:	8d 04 06             	lea    (%esi,%eax,1),%eax
40001819:	83 ec 04             	sub    $0x4,%esp
4000181c:	ff 75 14             	pushl  0x14(%ebp)
4000181f:	50                   	push   %eax
40001820:	ff 75 18             	pushl  0x18(%ebp)
40001823:	e8 40 77 00 00       	call   40008f68 <memcpy>
40001828:	83 c4 10             	add    $0x10,%esp
4000182b:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
40001832:	8b 65 b8             	mov    -0x48(%ebp),%esp
40001835:	83 7d bc 01          	cmpl   $0x1,-0x44(%ebp)
40001839:	74 02                	je     4000183d <cdi_storage_read+0x1c3>
4000183b:	eb 07                	jmp    40001844 <cdi_storage_read+0x1ca>
        }
        
4000183d:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
40001844:	8b 45 b0             	mov    -0x50(%ebp),%eax
        // Request vorbereiten
40001847:	8d 65 f8             	lea    -0x8(%ebp),%esp
4000184a:	5b                   	pop    %ebx
4000184b:	5e                   	pop    %esi
4000184c:	c9                   	leave  
4000184d:	c3                   	ret    

4000184e <cdi_storage_write>:
        request.flags.poll = 1;
        request.flags.ata = 0;
        request.flags.lba = 1;

        request.registers.ata.command = READ_SECTORS;
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
4000184e:	55                   	push   %ebp
4000184f:	89 e5                	mov    %esp,%ebp
40001851:	53                   	push   %ebx
40001852:	83 ec 44             	sub    $0x44,%esp
40001855:	8b 45 0c             	mov    0xc(%ebp),%eax
40001858:	89 45 d0             	mov    %eax,-0x30(%ebp)
4000185b:	8b 45 10             	mov    0x10(%ebp),%eax
4000185e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40001861:	89 e0                	mov    %esp,%eax
40001863:	89 45 cc             	mov    %eax,-0x34(%ebp)
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
40001866:	8b 45 08             	mov    0x8(%ebp),%eax
40001869:	8b 40 08             	mov    0x8(%eax),%eax
4000186c:	89 45 e0             	mov    %eax,-0x20(%ebp)
        // 0 steht.
        request.registers.ata.count = (uint8_t) current_count;
4000186f:	8b 45 08             	mov    0x8(%ebp),%eax
40001872:	8b 40 0c             	mov    0xc(%eax),%eax
40001875:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        request.registers.ata.lba = lba;
40001878:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000187b:	ba 00 00 00 00       	mov    $0x0,%edx
40001880:	52                   	push   %edx
40001881:	50                   	push   %eax
40001882:	ff 75 d4             	pushl  -0x2c(%ebp)
40001885:	ff 75 d0             	pushl  -0x30(%ebp)
40001888:	e8 cf 7b 00 00       	call   4000945c <__udivdi3>
4000188d:	83 c4 10             	add    $0x10,%esp
40001890:	89 45 e8             	mov    %eax,-0x18(%ebp)
40001893:	89 55 ec             	mov    %edx,-0x14(%ebp)

40001896:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001899:	83 c0 0f             	add    $0xf,%eax
4000189c:	83 c0 0f             	add    $0xf,%eax
4000189f:	c1 e8 04             	shr    $0x4,%eax
400018a2:	c1 e0 04             	shl    $0x4,%eax
400018a5:	29 c4                	sub    %eax,%esp
400018a7:	89 65 c4             	mov    %esp,-0x3c(%ebp)
400018aa:	8b 45 c4             	mov    -0x3c(%ebp),%eax
400018ad:	83 c0 0f             	add    $0xf,%eax
400018b0:	c1 e8 04             	shr    $0x4,%eax
400018b3:	c1 e0 04             	shl    $0x4,%eax
400018b6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
400018b9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
400018bc:	89 45 dc             	mov    %eax,-0x24(%ebp)
        request.block_size = ATA_SECTOR_SIZE;
        request.blocks_done = 0;
        request.buffer = current_buffer;

        request.error = NO_ERROR;
        
400018bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400018c2:	ba 00 00 00 00       	mov    $0x0,%edx
400018c7:	8b 4d d0             	mov    -0x30(%ebp),%ecx
400018ca:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
400018cd:	52                   	push   %edx
400018ce:	50                   	push   %eax
400018cf:	53                   	push   %ebx
400018d0:	51                   	push   %ecx
400018d1:	e8 ae 7c 00 00       	call   40009584 <__umoddi3>
400018d6:	83 c4 10             	add    $0x10,%esp
400018d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
        // TODO: LBA48
400018dc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
400018e0:	0f 84 bc 00 00 00    	je     400019a2 <cdi_storage_write+0x154>
        // TODO: CHS
400018e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
400018e9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
400018ec:	89 d1                	mov    %edx,%ecx
400018ee:	29 c1                	sub    %eax,%ecx
400018f0:	89 c8                	mov    %ecx,%eax
400018f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
        
400018f5:	8b 45 14             	mov    0x14(%ebp),%eax
400018f8:	89 45 bc             	mov    %eax,-0x44(%ebp)
400018fb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
400018fe:	89 4d c0             	mov    %ecx,-0x40(%ebp)
40001901:	8b 45 bc             	mov    -0x44(%ebp),%eax
40001904:	39 45 c0             	cmp    %eax,-0x40(%ebp)
40001907:	76 06                	jbe    4000190f <cdi_storage_write+0xc1>
40001909:	8b 4d bc             	mov    -0x44(%ebp),%ecx
4000190c:	89 4d c0             	mov    %ecx,-0x40(%ebp)
4000190f:	8b 45 c0             	mov    -0x40(%ebp),%eax
40001912:	89 45 f4             	mov    %eax,-0xc(%ebp)
        // Request ausfuehren
        if (!ata_request(&request)) {
40001915:	8b 45 e0             	mov    -0x20(%ebp),%eax
40001918:	8b 50 18             	mov    0x18(%eax),%edx
4000191b:	8b 45 dc             	mov    -0x24(%ebp),%eax
4000191e:	83 ec 08             	sub    $0x8,%esp
40001921:	50                   	push   %eax
40001922:	6a 00                	push   $0x0
40001924:	6a 01                	push   $0x1
40001926:	ff 75 ec             	pushl  -0x14(%ebp)
40001929:	ff 75 e8             	pushl  -0x18(%ebp)
4000192c:	ff 75 08             	pushl  0x8(%ebp)
4000192f:	ff d2                	call   *%edx
40001931:	83 c4 20             	add    $0x20,%esp
40001934:	85 c0                	test   %eax,%eax
40001936:	74 0c                	je     40001944 <cdi_storage_write+0xf6>
            result = 0;
40001938:	c7 45 c8 ff ff ff ff 	movl   $0xffffffff,-0x38(%ebp)
4000193f:	e9 42 01 00 00       	jmp    40001a86 <cdi_storage_write+0x238>
            break;
        }
40001944:	8b 55 dc             	mov    -0x24(%ebp),%edx
40001947:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000194a:	8d 04 02             	lea    (%edx,%eax,1),%eax
4000194d:	83 ec 04             	sub    $0x4,%esp
40001950:	ff 75 f4             	pushl  -0xc(%ebp)
40001953:	ff 75 18             	pushl  0x18(%ebp)
40001956:	50                   	push   %eax
40001957:	e8 0c 76 00 00       	call   40008f68 <memcpy>
4000195c:	83 c4 10             	add    $0x10,%esp

        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
        current_buffer += current_count * ATA_SECTOR_SIZE;
4000195f:	8b 45 e0             	mov    -0x20(%ebp),%eax
40001962:	8b 50 1c             	mov    0x1c(%eax),%edx
40001965:	8b 45 dc             	mov    -0x24(%ebp),%eax
40001968:	83 ec 08             	sub    $0x8,%esp
4000196b:	50                   	push   %eax
4000196c:	6a 00                	push   $0x0
4000196e:	6a 01                	push   $0x1
40001970:	ff 75 ec             	pushl  -0x14(%ebp)
40001973:	ff 75 e8             	pushl  -0x18(%ebp)
40001976:	ff 75 08             	pushl  0x8(%ebp)
40001979:	ff d2                	call   *%edx
4000197b:	83 c4 20             	add    $0x20,%esp
4000197e:	85 c0                	test   %eax,%eax
40001980:	74 0c                	je     4000198e <cdi_storage_write+0x140>
        count_left -= current_count;
40001982:	c7 45 c8 ff ff ff ff 	movl   $0xffffffff,-0x38(%ebp)
40001989:	e9 f8 00 00 00       	jmp    40001a86 <cdi_storage_write+0x238>
        lba += current_count;
    }

4000198e:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001991:	29 45 14             	sub    %eax,0x14(%ebp)
    return result;
40001994:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001997:	01 45 18             	add    %eax,0x18(%ebp)
}
4000199a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
4000199e:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)

400019a2:	8b 45 14             	mov    0x14(%ebp),%eax
400019a5:	ba 00 00 00 00       	mov    $0x0,%edx
400019aa:	f7 75 e4             	divl   -0x1c(%ebp)
400019ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
400019b0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
400019b4:	74 56                	je     40001a0c <cdi_storage_write+0x1be>
400019b6:	8b 45 e0             	mov    -0x20(%ebp),%eax
400019b9:	8b 48 1c             	mov    0x1c(%eax),%ecx
400019bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
400019bf:	ba 00 00 00 00       	mov    $0x0,%edx
400019c4:	83 ec 08             	sub    $0x8,%esp
400019c7:	ff 75 18             	pushl  0x18(%ebp)
400019ca:	52                   	push   %edx
400019cb:	50                   	push   %eax
400019cc:	ff 75 ec             	pushl  -0x14(%ebp)
400019cf:	ff 75 e8             	pushl  -0x18(%ebp)
400019d2:	ff 75 08             	pushl  0x8(%ebp)
400019d5:	ff d1                	call   *%ecx
400019d7:	83 c4 20             	add    $0x20,%esp
400019da:	85 c0                	test   %eax,%eax
400019dc:	74 0c                	je     400019ea <cdi_storage_write+0x19c>
400019de:	c7 45 c8 ff ff ff ff 	movl   $0xffffffff,-0x38(%ebp)
400019e5:	e9 9c 00 00 00       	jmp    40001a86 <cdi_storage_write+0x238>
400019ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
400019ed:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
400019f1:	29 45 14             	sub    %eax,0x14(%ebp)
400019f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
400019f7:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
400019fb:	01 45 18             	add    %eax,0x18(%ebp)
400019fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001a01:	ba 00 00 00 00       	mov    $0x0,%edx
40001a06:	01 45 e8             	add    %eax,-0x18(%ebp)
40001a09:	11 55 ec             	adc    %edx,-0x14(%ebp)
40001a0c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
40001a10:	74 6d                	je     40001a7f <cdi_storage_write+0x231>
40001a12:	8b 45 e0             	mov    -0x20(%ebp),%eax
40001a15:	8b 50 18             	mov    0x18(%eax),%edx
40001a18:	8b 45 dc             	mov    -0x24(%ebp),%eax
40001a1b:	83 ec 08             	sub    $0x8,%esp
40001a1e:	50                   	push   %eax
40001a1f:	6a 00                	push   $0x0
40001a21:	6a 01                	push   $0x1
40001a23:	ff 75 ec             	pushl  -0x14(%ebp)
40001a26:	ff 75 e8             	pushl  -0x18(%ebp)
40001a29:	ff 75 08             	pushl  0x8(%ebp)
40001a2c:	ff d2                	call   *%edx
40001a2e:	83 c4 20             	add    $0x20,%esp
40001a31:	85 c0                	test   %eax,%eax
40001a33:	74 09                	je     40001a3e <cdi_storage_write+0x1f0>
40001a35:	c7 45 c8 ff ff ff ff 	movl   $0xffffffff,-0x38(%ebp)
40001a3c:	eb 48                	jmp    40001a86 <cdi_storage_write+0x238>
40001a3e:	8b 45 dc             	mov    -0x24(%ebp),%eax
40001a41:	83 ec 04             	sub    $0x4,%esp
40001a44:	ff 75 14             	pushl  0x14(%ebp)
40001a47:	ff 75 18             	pushl  0x18(%ebp)
40001a4a:	50                   	push   %eax
40001a4b:	e8 18 75 00 00       	call   40008f68 <memcpy>
40001a50:	83 c4 10             	add    $0x10,%esp
40001a53:	8b 45 e0             	mov    -0x20(%ebp),%eax
40001a56:	8b 50 1c             	mov    0x1c(%eax),%edx
40001a59:	8b 45 dc             	mov    -0x24(%ebp),%eax
40001a5c:	83 ec 08             	sub    $0x8,%esp
40001a5f:	50                   	push   %eax
40001a60:	6a 00                	push   $0x0
40001a62:	6a 01                	push   $0x1
40001a64:	ff 75 ec             	pushl  -0x14(%ebp)
40001a67:	ff 75 e8             	pushl  -0x18(%ebp)
40001a6a:	ff 75 08             	pushl  0x8(%ebp)
40001a6d:	ff d2                	call   *%edx
40001a6f:	83 c4 20             	add    $0x20,%esp
40001a72:	85 c0                	test   %eax,%eax
40001a74:	74 09                	je     40001a7f <cdi_storage_write+0x231>
40001a76:	c7 45 c8 ff ff ff ff 	movl   $0xffffffff,-0x38(%ebp)
40001a7d:	eb 07                	jmp    40001a86 <cdi_storage_write+0x238>
40001a7f:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
40001a86:	8b 65 cc             	mov    -0x34(%ebp),%esp
40001a89:	8b 45 c8             	mov    -0x38(%ebp),%eax
40001a8c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40001a8f:	c9                   	leave  
40001a90:	c3                   	ret    

40001a91 <lostio_mst_if_init>:
40001a91:	55                   	push   %ebp
40001a92:	89 e5                	mov    %esp,%ebp
40001a94:	83 ec 08             	sub    $0x8,%esp
40001a97:	83 ec 0c             	sub    $0xc,%esp
40001a9a:	68 20 a0 00 40       	push   $0x4000a020
40001a9f:	e8 40 1f 00 00       	call   400039e4 <lostio_register_typehandle>
40001aa4:	83 c4 10             	add    $0x10,%esp
40001aa7:	c9                   	leave  
40001aa8:	c3                   	ret    

40001aa9 <lostio_mst_if_newdev>:
40001aa9:	55                   	push   %ebp
40001aaa:	89 e5                	mov    %esp,%ebp
40001aac:	83 ec 28             	sub    $0x28,%esp
40001aaf:	89 e0                	mov    %esp,%eax
40001ab1:	89 45 ec             	mov    %eax,-0x14(%ebp)
40001ab4:	8b 45 08             	mov    0x8(%ebp),%eax
40001ab7:	8b 40 04             	mov    0x4(%eax),%eax
40001aba:	83 ec 0c             	sub    $0xc,%esp
40001abd:	50                   	push   %eax
40001abe:	e8 b1 77 00 00       	call   40009274 <strlen>
40001ac3:	83 c4 10             	add    $0x10,%esp
40001ac6:	83 c0 02             	add    $0x2,%eax
40001ac9:	83 c0 0f             	add    $0xf,%eax
40001acc:	83 c0 0f             	add    $0xf,%eax
40001acf:	c1 e8 04             	shr    $0x4,%eax
40001ad2:	c1 e0 04             	shl    $0x4,%eax
40001ad5:	29 c4                	sub    %eax,%esp
40001ad7:	89 65 e4             	mov    %esp,-0x1c(%ebp)
40001ada:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001add:	83 c0 0f             	add    $0xf,%eax
40001ae0:	c1 e8 04             	shr    $0x4,%eax
40001ae3:	c1 e0 04             	shl    $0x4,%eax
40001ae6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40001ae9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40001aec:	89 45 fc             	mov    %eax,-0x4(%ebp)
40001aef:	8b 45 08             	mov    0x8(%ebp),%eax
40001af2:	8b 50 04             	mov    0x4(%eax),%edx
40001af5:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001af8:	40                   	inc    %eax
40001af9:	83 ec 08             	sub    $0x8,%esp
40001afc:	52                   	push   %edx
40001afd:	50                   	push   %eax
40001afe:	e8 45 77 00 00       	call   40009248 <strcpy>
40001b03:	83 c4 10             	add    $0x10,%esp
40001b06:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001b09:	c6 00 2f             	movb   $0x2f,(%eax)
40001b0c:	8b 45 08             	mov    0x8(%ebp),%eax
40001b0f:	8b 50 0c             	mov    0xc(%eax),%edx
40001b12:	8b 45 08             	mov    0x8(%ebp),%eax
40001b15:	8b 40 10             	mov    0x10(%eax),%eax
40001b18:	0f af c2             	imul   %edx,%eax
40001b1b:	8b 55 fc             	mov    -0x4(%ebp),%edx
40001b1e:	83 ec 0c             	sub    $0xc,%esp
40001b21:	6a 00                	push   $0x0
40001b23:	ff 75 08             	pushl  0x8(%ebp)
40001b26:	50                   	push   %eax
40001b27:	68 ff 00 00 00       	push   $0xff
40001b2c:	52                   	push   %edx
40001b2d:	e8 90 22 00 00       	call   40003dc2 <vfstree_create_node>
40001b32:	83 c4 20             	add    $0x20,%esp
40001b35:	85 c0                	test   %eax,%eax
40001b37:	75 09                	jne    40001b42 <lostio_mst_if_newdev+0x99>
40001b39:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
40001b40:	eb 07                	jmp    40001b49 <lostio_mst_if_newdev+0xa0>
40001b42:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40001b49:	8b 65 ec             	mov    -0x14(%ebp),%esp
40001b4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001b4f:	c9                   	leave  
40001b50:	c3                   	ret    

40001b51 <lostio_mst_read_handler>:
40001b51:	55                   	push   %ebp
40001b52:	89 e5                	mov    %esp,%ebp
40001b54:	83 ec 18             	sub    $0x18,%esp
40001b57:	8b 45 0c             	mov    0xc(%ebp),%eax
40001b5a:	8b 40 1c             	mov    0x1c(%eax),%eax
40001b5d:	8b 40 10             	mov    0x10(%eax),%eax
40001b60:	89 45 f8             	mov    %eax,-0x8(%ebp)
40001b63:	8b 45 10             	mov    0x10(%ebp),%eax
40001b66:	0f af 45 14          	imul   0x14(%ebp),%eax
40001b6a:	89 45 fc             	mov    %eax,-0x4(%ebp)
40001b6d:	a1 b0 a0 00 40       	mov    0x4000a0b0,%eax
40001b72:	83 ec 08             	sub    $0x8,%esp
40001b75:	ff 75 fc             	pushl  -0x4(%ebp)
40001b78:	50                   	push   %eax
40001b79:	e8 01 71 00 00       	call   40008c7f <realloc>
40001b7e:	83 c4 10             	add    $0x10,%esp
40001b81:	a3 b0 a0 00 40       	mov    %eax,0x4000a0b0
40001b86:	8b 0d b0 a0 00 40    	mov    0x4000a0b0,%ecx
40001b8c:	8b 45 0c             	mov    0xc(%ebp),%eax
40001b8f:	8b 50 14             	mov    0x14(%eax),%edx
40001b92:	8b 40 10             	mov    0x10(%eax),%eax
40001b95:	83 ec 0c             	sub    $0xc,%esp
40001b98:	51                   	push   %ecx
40001b99:	ff 75 fc             	pushl  -0x4(%ebp)
40001b9c:	52                   	push   %edx
40001b9d:	50                   	push   %eax
40001b9e:	ff 75 f8             	pushl  -0x8(%ebp)
40001ba1:	e8 d4 fa ff ff       	call   4000167a <cdi_storage_read>
40001ba6:	83 c4 20             	add    $0x20,%esp
40001ba9:	85 c0                	test   %eax,%eax
40001bab:	74 10                	je     40001bbd <lostio_mst_read_handler+0x6c>
40001bad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40001bb4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40001bbb:	eb 0e                	jmp    40001bcb <lostio_mst_read_handler+0x7a>
40001bbd:	a1 b0 a0 00 40       	mov    0x4000a0b0,%eax
40001bc2:	89 45 f0             	mov    %eax,-0x10(%ebp)
40001bc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001bc8:	89 45 f4             	mov    %eax,-0xc(%ebp)
40001bcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001bce:	8b 55 f4             	mov    -0xc(%ebp),%edx
40001bd1:	8b 4d 08             	mov    0x8(%ebp),%ecx
40001bd4:	89 01                	mov    %eax,(%ecx)
40001bd6:	89 51 04             	mov    %edx,0x4(%ecx)
40001bd9:	8b 45 08             	mov    0x8(%ebp),%eax
40001bdc:	c9                   	leave  
40001bdd:	c2 04 00             	ret    $0x4

40001be0 <lostio_mst_write_handler>:
40001be0:	55                   	push   %ebp
40001be1:	89 e5                	mov    %esp,%ebp
40001be3:	83 ec 18             	sub    $0x18,%esp
40001be6:	8b 45 08             	mov    0x8(%ebp),%eax
40001be9:	8b 40 1c             	mov    0x1c(%eax),%eax
40001bec:	8b 40 10             	mov    0x10(%eax),%eax
40001bef:	89 45 f4             	mov    %eax,-0xc(%ebp)
40001bf2:	8b 45 0c             	mov    0xc(%ebp),%eax
40001bf5:	0f af 45 10          	imul   0x10(%ebp),%eax
40001bf9:	89 45 f8             	mov    %eax,-0x8(%ebp)
40001bfc:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001bff:	89 45 fc             	mov    %eax,-0x4(%ebp)
40001c02:	8b 45 08             	mov    0x8(%ebp),%eax
40001c05:	8b 50 14             	mov    0x14(%eax),%edx
40001c08:	8b 40 10             	mov    0x10(%eax),%eax
40001c0b:	83 ec 0c             	sub    $0xc,%esp
40001c0e:	ff 75 14             	pushl  0x14(%ebp)
40001c11:	ff 75 f8             	pushl  -0x8(%ebp)
40001c14:	52                   	push   %edx
40001c15:	50                   	push   %eax
40001c16:	ff 75 f4             	pushl  -0xc(%ebp)
40001c19:	e8 30 fc ff ff       	call   4000184e <cdi_storage_write>
40001c1e:	83 c4 20             	add    $0x20,%esp
40001c21:	85 c0                	test   %eax,%eax
40001c23:	74 07                	je     40001c2c <lostio_mst_write_handler+0x4c>
40001c25:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40001c2c:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001c2f:	c9                   	leave  
40001c30:	c3                   	ret    

40001c31 <lostio_mst_seek_handler>:
40001c31:	55                   	push   %ebp
40001c32:	89 e5                	mov    %esp,%ebp
40001c34:	83 ec 30             	sub    $0x30,%esp
40001c37:	8b 45 08             	mov    0x8(%ebp),%eax
40001c3a:	8b 40 1c             	mov    0x1c(%eax),%eax
40001c3d:	8b 40 10             	mov    0x10(%eax),%eax
40001c40:	89 45 ec             	mov    %eax,-0x14(%ebp)
40001c43:	8b 45 08             	mov    0x8(%ebp),%eax
40001c46:	8b 50 14             	mov    0x14(%eax),%edx
40001c49:	8b 40 10             	mov    0x10(%eax),%eax
40001c4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
40001c4f:	89 55 f4             	mov    %edx,-0xc(%ebp)
40001c52:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001c55:	8b 50 0c             	mov    0xc(%eax),%edx
40001c58:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001c5b:	8b 40 10             	mov    0x10(%eax),%eax
40001c5e:	0f af c2             	imul   %edx,%eax
40001c61:	ba 00 00 00 00       	mov    $0x0,%edx
40001c66:	89 45 f8             	mov    %eax,-0x8(%ebp)
40001c69:	89 55 fc             	mov    %edx,-0x4(%ebp)
40001c6c:	8b 45 10             	mov    0x10(%ebp),%eax
40001c6f:	89 45 d8             	mov    %eax,-0x28(%ebp)
40001c72:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
40001c76:	74 1a                	je     40001c92 <lostio_mst_seek_handler+0x61>
40001c78:	83 7d d8 02          	cmpl   $0x2,-0x28(%ebp)
40001c7c:	74 20                	je     40001c9e <lostio_mst_seek_handler+0x6d>
40001c7e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
40001c82:	74 02                	je     40001c86 <lostio_mst_seek_handler+0x55>
40001c84:	eb 24                	jmp    40001caa <lostio_mst_seek_handler+0x79>
40001c86:	8b 45 0c             	mov    0xc(%ebp),%eax
40001c89:	99                   	cltd   
40001c8a:	89 45 f0             	mov    %eax,-0x10(%ebp)
40001c8d:	89 55 f4             	mov    %edx,-0xc(%ebp)
40001c90:	eb 18                	jmp    40001caa <lostio_mst_seek_handler+0x79>
40001c92:	8b 45 0c             	mov    0xc(%ebp),%eax
40001c95:	99                   	cltd   
40001c96:	01 45 f0             	add    %eax,-0x10(%ebp)
40001c99:	11 55 f4             	adc    %edx,-0xc(%ebp)
40001c9c:	eb 0c                	jmp    40001caa <lostio_mst_seek_handler+0x79>
40001c9e:	8b 45 f8             	mov    -0x8(%ebp),%eax
40001ca1:	8b 55 fc             	mov    -0x4(%ebp),%edx
40001ca4:	89 45 f0             	mov    %eax,-0x10(%ebp)
40001ca7:	89 55 f4             	mov    %edx,-0xc(%ebp)
40001caa:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001cad:	8b 55 f4             	mov    -0xc(%ebp),%edx
40001cb0:	89 45 d0             	mov    %eax,-0x30(%ebp)
40001cb3:	89 55 d4             	mov    %edx,-0x2c(%ebp)
40001cb6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
40001cb9:	3b 55 fc             	cmp    -0x4(%ebp),%edx
40001cbc:	72 19                	jb     40001cd7 <lostio_mst_seek_handler+0xa6>
40001cbe:	8b 45 d4             	mov    -0x2c(%ebp),%eax
40001cc1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
40001cc4:	77 08                	ja     40001cce <lostio_mst_seek_handler+0x9d>
40001cc6:	8b 55 d0             	mov    -0x30(%ebp),%edx
40001cc9:	3b 55 f8             	cmp    -0x8(%ebp),%edx
40001ccc:	76 09                	jbe    40001cd7 <lostio_mst_seek_handler+0xa6>
40001cce:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
40001cd5:	eb 54                	jmp    40001d2b <lostio_mst_seek_handler+0xfa>
40001cd7:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001cda:	8b 55 f4             	mov    -0xc(%ebp),%edx
40001cdd:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40001ce0:	31 d1                	xor    %edx,%ecx
40001ce2:	33 45 f8             	xor    -0x8(%ebp),%eax
40001ce5:	09 c8                	or     %ecx,%eax
40001ce7:	85 c0                	test   %eax,%eax
40001ce9:	75 16                	jne    40001d01 <lostio_mst_seek_handler+0xd0>
40001ceb:	8b 45 08             	mov    0x8(%ebp),%eax
40001cee:	8b 40 08             	mov    0x8(%eax),%eax
40001cf1:	89 c2                	mov    %eax,%edx
40001cf3:	81 ca 00 00 01 00    	or     $0x10000,%edx
40001cf9:	8b 45 08             	mov    0x8(%ebp),%eax
40001cfc:	89 50 08             	mov    %edx,0x8(%eax)
40001cff:	eb 14                	jmp    40001d15 <lostio_mst_seek_handler+0xe4>
40001d01:	8b 45 08             	mov    0x8(%ebp),%eax
40001d04:	8b 40 08             	mov    0x8(%eax),%eax
40001d07:	89 c2                	mov    %eax,%edx
40001d09:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
40001d0f:	8b 45 08             	mov    0x8(%ebp),%eax
40001d12:	89 50 08             	mov    %edx,0x8(%eax)
40001d15:	8b 4d 08             	mov    0x8(%ebp),%ecx
40001d18:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001d1b:	8b 55 f4             	mov    -0xc(%ebp),%edx
40001d1e:	89 41 10             	mov    %eax,0x10(%ecx)
40001d21:	89 51 14             	mov    %edx,0x14(%ecx)
40001d24:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
40001d2b:	8b 45 dc             	mov    -0x24(%ebp),%eax
40001d2e:	c9                   	leave  
40001d2f:	c3                   	ret    

40001d30 <get_pid>:
 * Prozessnummer des aktuellen Prozesses abfragen.
 *
 * @return Prozessnummer
 */
pid_t get_pid()
{
40001d30:	55                   	push   %ebp
40001d31:	89 e5                	mov    %esp,%ebp
40001d33:	83 ec 10             	sub    $0x10,%esp
    pid_t pid;
    asm(
40001d36:	b8 0e 00 00 00       	mov    $0xe,%eax
40001d3b:	cd 30                	int    $0x30
40001d3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "mov %1, %%eax;"
        "int $0x30;"
        : "=a" (pid) : "i" (SYSCALL_PM_GET_PID));
    
    return pid;
40001d40:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
40001d43:	c9                   	leave  
40001d44:	c3                   	ret    

40001d45 <get_parent_pid>:
 * Prozessnummer des Elternprozesses beim Kernel anfragen
 *
 * @return Prozessnummer
 */
pid_t get_parent_pid(pid_t pid)
{
40001d45:	55                   	push   %ebp
40001d46:	89 e5                	mov    %esp,%ebp
40001d48:	83 ec 10             	sub    $0x10,%esp
    pid_t result;
    asm(
40001d4b:	8b 45 08             	mov    0x8(%ebp),%eax
40001d4e:	50                   	push   %eax
40001d4f:	b8 10 00 00 00       	mov    $0x10,%eax
40001d54:	cd 30                	int    $0x30
40001d56:	83 c4 04             	add    $0x4,%esp
40001d59:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "pushl %2;"
        "mov %1, %%eax;"
        "int $0x30;"
        "addl $4, %%esp;"
        : "=a" (result) : "i" (SYSCALL_PM_GET_PARENT_PID), "r" (pid));
    return result;
40001d5c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
40001d5f:	c9                   	leave  
40001d60:	c3                   	ret    

40001d61 <create_process>:
 *          untergeordenet werden soll, oder 0 fuer den aktuellen Prozess.
 *
 * @return Prozessnummer
 */
pid_t create_process(dword initial_eip, uid_t uid, const char* args, pid_t parent)
{
40001d61:	55                   	push   %ebp
40001d62:	89 e5                	mov    %esp,%ebp
40001d64:	53                   	push   %ebx
40001d65:	83 ec 10             	sub    $0x10,%esp
    pid_t pid;

    asm(
40001d68:	8b 5d 08             	mov    0x8(%ebp),%ebx
40001d6b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40001d6e:	8b 55 10             	mov    0x10(%ebp),%edx
40001d71:	8b 45 14             	mov    0x14(%ebp),%eax
40001d74:	50                   	push   %eax
40001d75:	52                   	push   %edx
40001d76:	51                   	push   %ecx
40001d77:	53                   	push   %ebx
40001d78:	b8 03 00 00 00       	mov    $0x3,%eax
40001d7d:	cd 30                	int    $0x30
40001d7f:	83 c4 10             	add    $0x10,%esp
40001d82:	89 45 f8             	mov    %eax,-0x8(%ebp)
        "pushl %2;"
        "mov %1, %%eax;"
        "int $0x30;"
        "add $0x10, %%esp;"
        : "=a" (pid) : "i" (SYSCALL_PM_CREATE_PROCESS), "r" (initial_eip), "r" (uid), "r" (args), "r" (parent));
    return pid;
40001d85:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
40001d88:	83 c4 10             	add    $0x10,%esp
40001d8b:	5b                   	pop    %ebx
40001d8c:	c9                   	leave  
40001d8d:	c3                   	ret    

40001d8e <destroy_process>:
/**
 * Den aktuellen Prozess beenden. TODO: Sollte auch mit Kinderprozessen
 * moeglich sein.
 */
void destroy_process()
{
40001d8e:	55                   	push   %ebp
40001d8f:	89 e5                	mov    %esp,%ebp
    asm(    "mov %0, %%eax;"
40001d91:	b8 05 00 00 00       	mov    $0x5,%eax
40001d96:	cd 30                	int    $0x30
            "int $0x30;"
        : : "i" (SYSCALL_PM_EXIT_PROCESS));
}
40001d98:	c9                   	leave  
40001d99:	c3                   	ret    

40001d9a <get_cmdline>:
 * Prozesses.
 *
 * @return Pointer auf den Argument-String
 */
char* get_cmdline()
{
40001d9a:	55                   	push   %ebp
40001d9b:	89 e5                	mov    %esp,%ebp
40001d9d:	83 ec 10             	sub    $0x10,%esp
    char* result;
    asm(
40001da0:	b8 0f 00 00 00       	mov    $0xf,%eax
40001da5:	cd 30                	int    $0x30
40001da7:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "mov %1, %%eax;"
        "int $0x30;"
        : "=a" (result) : "i" (SYSCALL_PM_GET_CMDLINE));

    return result;
40001daa:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
40001dad:	c9                   	leave  
40001dae:	c3                   	ret    
40001daf:	90                   	nop    

40001db0 <init_envvars>:
int ata_drv_identify(struct ata_device* dev)
{
    uint8_t buffer[ATA_SECTOR_SIZE];

    // Request vorbereiten
    struct ata_request request = {
40001db0:	55                   	push   %ebp
40001db1:	89 e5                	mov    %esp,%ebp
40001db3:	56                   	push   %esi
40001db4:	53                   	push   %ebx
40001db5:	83 ec 20             	sub    $0x20,%esp
        .dev = dev,
40001db8:	e8 63 5e 00 00       	call   40007c20 <list_create>
40001dbd:	a3 58 a6 00 40       	mov    %eax,0x4000a658

        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,
40001dc2:	83 ec 08             	sub    $0x8,%esp
40001dc5:	68 a7 1e 00 40       	push   $0x40001ea7
40001dca:	68 36 98 00 40       	push   $0x40009836
40001dcf:	e8 ad 10 00 00       	call   40002e81 <register_message_handler>
40001dd4:	83 c4 10             	add    $0x10,%esp

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
40001dd7:	83 ec 0c             	sub    $0xc,%esp
40001dda:	6a 00                	push   $0x0
40001ddc:	e8 64 ff ff ff       	call   40001d45 <get_parent_pid>
40001de1:	83 c4 10             	add    $0x10,%esp
40001de4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
40001de7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
40001deb:	0f 84 af 00 00 00    	je     40001ea0 <init_envvars+0xf0>
        .block_size = ATA_SECTOR_SIZE,
40001df1:	6a 00                	push   $0x0
40001df3:	6a 00                	push   $0x0
40001df5:	68 36 98 00 40       	push   $0x40009836
40001dfa:	ff 75 e4             	pushl  -0x1c(%ebp)
40001dfd:	e8 2b 18 00 00       	call   4000362d <rpc_get_response>
40001e02:	83 c4 10             	add    $0x10,%esp
40001e05:	89 45 e8             	mov    %eax,-0x18(%ebp)
        .buffer = buffer,
40001e08:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
40001e0c:	0f 84 8e 00 00 00    	je     40001ea0 <init_envvars+0xf0>
40001e12:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001e15:	8b 40 0c             	mov    0xc(%eax),%eax
40001e18:	85 c0                	test   %eax,%eax
40001e1a:	0f 84 80 00 00 00    	je     40001ea0 <init_envvars+0xf0>

40001e20:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001e23:	8b 40 0c             	mov    0xc(%eax),%eax
40001e26:	89 45 ec             	mov    %eax,-0x14(%ebp)
        .error = 0
    };
    
    // Request starten
    if (!ata_request(&request)) {
40001e29:	eb 5b                	jmp    40001e86 <init_envvars+0xd6>
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
40001e2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001e2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
40001e31:	83 ec 0c             	sub    $0xc,%esp
40001e34:	ff 75 f0             	pushl  -0x10(%ebp)
40001e37:	e8 38 74 00 00       	call   40009274 <strlen>
40001e3c:	83 c4 10             	add    $0x10,%esp
40001e3f:	03 45 f0             	add    -0x10(%ebp),%eax
40001e42:	40                   	inc    %eax
40001e43:	89 45 f4             	mov    %eax,-0xc(%ebp)
        
40001e46:	83 ec 04             	sub    $0x4,%esp
40001e49:	6a 01                	push   $0x1
40001e4b:	ff 75 f4             	pushl  -0xc(%ebp)
40001e4e:	ff 75 f0             	pushl  -0x10(%ebp)
40001e51:	e8 eb 01 00 00       	call   40002041 <setenv>
40001e56:	83 c4 10             	add    $0x10,%esp
    // Ein ATA-Geraet
    dev->atapi = 0;
40001e59:	8b 75 ec             	mov    -0x14(%ebp),%esi
40001e5c:	83 c6 02             	add    $0x2,%esi
40001e5f:	83 ec 0c             	sub    $0xc,%esp
40001e62:	ff 75 f0             	pushl  -0x10(%ebp)
40001e65:	e8 0a 74 00 00       	call   40009274 <strlen>
40001e6a:	83 c4 10             	add    $0x10,%esp
40001e6d:	89 c3                	mov    %eax,%ebx
40001e6f:	83 ec 0c             	sub    $0xc,%esp
40001e72:	ff 75 f4             	pushl  -0xc(%ebp)
40001e75:	e8 fa 73 00 00       	call   40009274 <strlen>
40001e7a:	83 c4 10             	add    $0x10,%esp
40001e7d:	8d 04 03             	lea    (%ebx,%eax,1),%eax
40001e80:	8d 04 06             	lea    (%esi,%eax,1),%eax
40001e83:	89 45 ec             	mov    %eax,-0x14(%ebp)

        .error = 0
    };
    
    // Request starten
    if (!ata_request(&request)) {
40001e86:	8b 45 ec             	mov    -0x14(%ebp),%eax
40001e89:	89 c1                	mov    %eax,%ecx
40001e8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001e8e:	8b 40 0c             	mov    0xc(%eax),%eax
40001e91:	89 c2                	mov    %eax,%edx
40001e93:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001e96:	8b 40 08             	mov    0x8(%eax),%eax
40001e99:	8d 04 02             	lea    (%edx,%eax,1),%eax
40001e9c:	39 c1                	cmp    %eax,%ecx
40001e9e:	72 8b                	jb     40001e2b <init_envvars+0x7b>
    dev->atapi = 0;

    // TODO: Informationen verarbeiten

    return 1;
}
40001ea0:	8d 65 f8             	lea    -0x8(%ebp),%esp
40001ea3:	5b                   	pop    %ebx
40001ea4:	5e                   	pop    %esi
40001ea5:	c9                   	leave  
40001ea6:	c3                   	ret    

40001ea7 <rpc_get_envvars>:
 * Sektoren von einem ATA-Geraet lesen
 *
 * @param start LBA des Startsektors
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
40001ea7:	55                   	push   %ebp
40001ea8:	89 e5                	mov    %esp,%ebp
40001eaa:	83 ec 28             	sub    $0x28,%esp
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
40001ead:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 */
40001eb4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
40001ebb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
{
    int result = 1;
    struct ata_request request;
40001ec2:	e8 d1 12 00 00       	call   40003198 <p>
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
    // muss unter Umstaenden mehrmals gelesen werden.
    uint16_t current_count;
    void* current_buffer = buffer;
40001ec7:	e9 8c 00 00 00       	jmp    40001f58 <rpc_get_envvars+0xb1>
    uint64_t lba = start;

40001ecc:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001ecf:	8b 00                	mov    (%eax),%eax
40001ed1:	83 ec 0c             	sub    $0xc,%esp
40001ed4:	50                   	push   %eax
40001ed5:	e8 9a 73 00 00       	call   40009274 <strlen>
40001eda:	83 c4 10             	add    $0x10,%esp
40001edd:	40                   	inc    %eax
40001ede:	89 45 f0             	mov    %eax,-0x10(%ebp)
    // Anzahl der Sektoren die noch uebrig sind
40001ee1:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001ee4:	8b 40 04             	mov    0x4(%eax),%eax
40001ee7:	83 ec 0c             	sub    $0xc,%esp
40001eea:	50                   	push   %eax
40001eeb:	e8 84 73 00 00       	call   40009274 <strlen>
40001ef0:	83 c4 10             	add    $0x10,%esp
40001ef3:	40                   	inc    %eax
40001ef4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t count_left = count;

    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
40001ef7:	8b 45 f0             	mov    -0x10(%ebp),%eax
40001efa:	03 45 ec             	add    -0x14(%ebp),%eax
40001efd:	03 45 f4             	add    -0xc(%ebp),%eax
40001f00:	83 ec 08             	sub    $0x8,%esp
40001f03:	50                   	push   %eax
40001f04:	ff 75 e8             	pushl  -0x18(%ebp)
40001f07:	e8 73 6d 00 00       	call   40008c7f <realloc>
40001f0c:	83 c4 10             	add    $0x10,%esp
40001f0f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
        if (count_left > 256) {
            current_count = 256;
40001f12:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001f15:	8b 10                	mov    (%eax),%edx
40001f17:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001f1a:	03 45 ec             	add    -0x14(%ebp),%eax
40001f1d:	83 ec 04             	sub    $0x4,%esp
40001f20:	ff 75 f0             	pushl  -0x10(%ebp)
40001f23:	52                   	push   %edx
40001f24:	50                   	push   %eax
40001f25:	e8 3e 70 00 00       	call   40008f68 <memcpy>
40001f2a:	83 c4 10             	add    $0x10,%esp
        } else {
            current_count = count_left;
40001f2d:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001f30:	8b 50 04             	mov    0x4(%eax),%edx
40001f33:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001f36:	03 45 ec             	add    -0x14(%ebp),%eax
40001f39:	03 45 f0             	add    -0x10(%ebp),%eax
40001f3c:	83 ec 04             	sub    $0x4,%esp
40001f3f:	ff 75 f4             	pushl  -0xc(%ebp)
40001f42:	52                   	push   %edx
40001f43:	50                   	push   %eax
40001f44:	e8 1f 70 00 00       	call   40008f68 <memcpy>
40001f49:	83 c4 10             	add    $0x10,%esp
        }
        
        // Request vorbereiten
40001f4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
40001f4f:	03 45 f0             	add    -0x10(%ebp),%eax
40001f52:	01 45 ec             	add    %eax,-0x14(%ebp)
        request.dev = dev;
40001f55:	ff 45 f8             	incl   -0x8(%ebp)
    int result = 1;
    struct ata_request request;
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
    // muss unter Umstaenden mehrmals gelesen werden.
    uint16_t current_count;
    void* current_buffer = buffer;
40001f58:	a1 58 a6 00 40       	mov    0x4000a658,%eax
40001f5d:	83 ec 08             	sub    $0x8,%esp
40001f60:	ff 75 f8             	pushl  -0x8(%ebp)
40001f63:	50                   	push   %eax
40001f64:	e8 24 5f 00 00       	call   40007e8d <list_get_element_at>
40001f69:	83 c4 10             	add    $0x10,%esp
40001f6c:	89 45 fc             	mov    %eax,-0x4(%ebp)
40001f6f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40001f73:	0f 85 53 ff ff ff    	jne    40001ecc <rpc_get_envvars+0x25>
        }
        
        // Request vorbereiten
        request.dev = dev;
        // TODO: DMA, UltraDMA...
        request.protocol = PIO;
40001f79:	e8 26 12 00 00       	call   400031a4 <v>
        request.flags.direction = READ;
        // FIXME
        request.flags.poll = 1;
40001f7e:	8b 45 e8             	mov    -0x18(%ebp),%eax
40001f81:	50                   	push   %eax
40001f82:	ff 75 ec             	pushl  -0x14(%ebp)
40001f85:	ff 75 0c             	pushl  0xc(%ebp)
40001f88:	ff 75 08             	pushl  0x8(%ebp)
40001f8b:	e8 bf 16 00 00       	call   4000364f <rpc_send_response>
40001f90:	83 c4 10             	add    $0x10,%esp
        request.flags.ata = 0;
        request.flags.lba = 1;

40001f93:	83 ec 0c             	sub    $0xc,%esp
40001f96:	ff 75 e8             	pushl  -0x18(%ebp)
40001f99:	e8 11 6a 00 00       	call   400089af <free>
40001f9e:	83 c4 10             	add    $0x10,%esp
        request.registers.ata.command = READ_SECTORS;
40001fa1:	c9                   	leave  
40001fa2:	c3                   	ret    

40001fa3 <getenvvar>:

        request.block_count = current_count;
        request.block_size = ATA_SECTOR_SIZE;
        request.blocks_done = 0;
        request.buffer = current_buffer;

40001fa3:	55                   	push   %ebp
40001fa4:	89 e5                	mov    %esp,%ebp
40001fa6:	83 ec 18             	sub    $0x18,%esp
        request.error = NO_ERROR;
40001fa9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
        
        // TODO: LBA48
        // TODO: CHS
40001fb0:	e8 e3 11 00 00       	call   40003198 <p>
        
40001fb5:	eb 28                	jmp    40001fdf <getenvvar+0x3c>
        // Request ausfuehren
        if (!ata_request(&request)) {
40001fb7:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001fba:	8b 00                	mov    (%eax),%eax
40001fbc:	83 ec 08             	sub    $0x8,%esp
40001fbf:	50                   	push   %eax
40001fc0:	ff 75 08             	pushl  0x8(%ebp)
40001fc3:	e8 28 72 00 00       	call   400091f0 <strcmp>
40001fc8:	83 c4 10             	add    $0x10,%esp
40001fcb:	85 c0                	test   %eax,%eax
40001fcd:	75 0d                	jne    40001fdc <getenvvar+0x39>
            result = 0;
40001fcf:	e8 d0 11 00 00       	call   400031a4 <v>
            break;
40001fd4:	8b 45 fc             	mov    -0x4(%ebp),%eax
40001fd7:	89 45 ec             	mov    %eax,-0x14(%ebp)
40001fda:	eb 2c                	jmp    40002008 <getenvvar+0x65>
        }

40001fdc:	ff 45 f8             	incl   -0x8(%ebp)

        request.error = NO_ERROR;
        
        // TODO: LBA48
        // TODO: CHS
        
40001fdf:	a1 58 a6 00 40       	mov    0x4000a658,%eax
40001fe4:	83 ec 08             	sub    $0x8,%esp
40001fe7:	ff 75 f8             	pushl  -0x8(%ebp)
40001fea:	50                   	push   %eax
40001feb:	e8 9d 5e 00 00       	call   40007e8d <list_get_element_at>
40001ff0:	83 c4 10             	add    $0x10,%esp
40001ff3:	89 45 fc             	mov    %eax,-0x4(%ebp)
40001ff6:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40001ffa:	75 bb                	jne    40001fb7 <getenvvar+0x14>
            result = 0;
            break;
        }

        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
        current_buffer += current_count * ATA_SECTOR_SIZE;
40001ffc:	e8 a3 11 00 00       	call   400031a4 <v>
        count_left -= current_count;
        lba += current_count;
    }
40002001:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40002008:	8b 45 ec             	mov    -0x14(%ebp),%eax

4000200b:	c9                   	leave  
4000200c:	c3                   	ret    

4000200d <getenv>:
4000200d:	55                   	push   %ebp
4000200e:	89 e5                	mov    %esp,%ebp
40002010:	83 ec 18             	sub    $0x18,%esp
40002013:	83 ec 0c             	sub    $0xc,%esp
40002016:	ff 75 08             	pushl  0x8(%ebp)
40002019:	e8 85 ff ff ff       	call   40001fa3 <getenvvar>
4000201e:	83 c4 10             	add    $0x10,%esp
40002021:	89 45 fc             	mov    %eax,-0x4(%ebp)
40002024:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40002028:	75 09                	jne    40002033 <getenv+0x26>
4000202a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40002031:	eb 09                	jmp    4000203c <getenv+0x2f>
40002033:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002036:	8b 40 04             	mov    0x4(%eax),%eax
40002039:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000203c:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000203f:	c9                   	leave  
40002040:	c3                   	ret    

40002041 <setenv>:
40002041:	55                   	push   %ebp
40002042:	89 e5                	mov    %esp,%ebp
40002044:	83 ec 18             	sub    $0x18,%esp
40002047:	83 ec 0c             	sub    $0xc,%esp
4000204a:	ff 75 08             	pushl  0x8(%ebp)
4000204d:	e8 51 ff ff ff       	call   40001fa3 <getenvvar>
40002052:	83 c4 10             	add    $0x10,%esp
40002055:	89 45 f8             	mov    %eax,-0x8(%ebp)
40002058:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
4000205c:	0f 85 1f 01 00 00    	jne    40002181 <setenv+0x140>
40002062:	83 ec 0c             	sub    $0xc,%esp
40002065:	6a 08                	push   $0x8
40002067:	e8 6c 62 00 00       	call   400082d8 <malloc>
4000206c:	83 c4 10             	add    $0x10,%esp
4000206f:	89 45 f8             	mov    %eax,-0x8(%ebp)
40002072:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40002076:	75 0c                	jne    40002084 <setenv+0x43>
40002078:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
4000207f:	e9 6d 01 00 00       	jmp    400021f1 <setenv+0x1b0>
40002084:	83 ec 0c             	sub    $0xc,%esp
40002087:	ff 75 08             	pushl  0x8(%ebp)
4000208a:	e8 e5 71 00 00       	call   40009274 <strlen>
4000208f:	83 c4 10             	add    $0x10,%esp
40002092:	40                   	inc    %eax
40002093:	83 ec 0c             	sub    $0xc,%esp
40002096:	50                   	push   %eax
40002097:	e8 3c 62 00 00       	call   400082d8 <malloc>
4000209c:	83 c4 10             	add    $0x10,%esp
4000209f:	89 c2                	mov    %eax,%edx
400020a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
400020a4:	89 10                	mov    %edx,(%eax)
400020a6:	83 ec 0c             	sub    $0xc,%esp
400020a9:	ff 75 0c             	pushl  0xc(%ebp)
400020ac:	e8 c3 71 00 00       	call   40009274 <strlen>
400020b1:	83 c4 10             	add    $0x10,%esp
400020b4:	40                   	inc    %eax
400020b5:	83 ec 0c             	sub    $0xc,%esp
400020b8:	50                   	push   %eax
400020b9:	e8 1a 62 00 00       	call   400082d8 <malloc>
400020be:	83 c4 10             	add    $0x10,%esp
400020c1:	89 c2                	mov    %eax,%edx
400020c3:	8b 45 f8             	mov    -0x8(%ebp),%eax
400020c6:	89 50 04             	mov    %edx,0x4(%eax)
400020c9:	8b 45 f8             	mov    -0x8(%ebp),%eax
400020cc:	8b 00                	mov    (%eax),%eax
400020ce:	85 c0                	test   %eax,%eax
400020d0:	74 0a                	je     400020dc <setenv+0x9b>
400020d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
400020d5:	8b 40 04             	mov    0x4(%eax),%eax
400020d8:	85 c0                	test   %eax,%eax
400020da:	75 3d                	jne    40002119 <setenv+0xd8>
400020dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
400020df:	8b 00                	mov    (%eax),%eax
400020e1:	83 ec 0c             	sub    $0xc,%esp
400020e4:	50                   	push   %eax
400020e5:	e8 c5 68 00 00       	call   400089af <free>
400020ea:	83 c4 10             	add    $0x10,%esp
400020ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
400020f0:	8b 40 04             	mov    0x4(%eax),%eax
400020f3:	83 ec 0c             	sub    $0xc,%esp
400020f6:	50                   	push   %eax
400020f7:	e8 b3 68 00 00       	call   400089af <free>
400020fc:	83 c4 10             	add    $0x10,%esp
400020ff:	83 ec 0c             	sub    $0xc,%esp
40002102:	ff 75 f8             	pushl  -0x8(%ebp)
40002105:	e8 a5 68 00 00       	call   400089af <free>
4000210a:	83 c4 10             	add    $0x10,%esp
4000210d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
40002114:	e9 d8 00 00 00       	jmp    400021f1 <setenv+0x1b0>
40002119:	83 ec 0c             	sub    $0xc,%esp
4000211c:	ff 75 08             	pushl  0x8(%ebp)
4000211f:	e8 50 71 00 00       	call   40009274 <strlen>
40002124:	83 c4 10             	add    $0x10,%esp
40002127:	8d 50 01             	lea    0x1(%eax),%edx
4000212a:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000212d:	8b 00                	mov    (%eax),%eax
4000212f:	83 ec 04             	sub    $0x4,%esp
40002132:	52                   	push   %edx
40002133:	ff 75 08             	pushl  0x8(%ebp)
40002136:	50                   	push   %eax
40002137:	e8 2c 6e 00 00       	call   40008f68 <memcpy>
4000213c:	83 c4 10             	add    $0x10,%esp
4000213f:	83 ec 0c             	sub    $0xc,%esp
40002142:	ff 75 0c             	pushl  0xc(%ebp)
40002145:	e8 2a 71 00 00       	call   40009274 <strlen>
4000214a:	83 c4 10             	add    $0x10,%esp
4000214d:	8d 50 01             	lea    0x1(%eax),%edx
40002150:	8b 45 f8             	mov    -0x8(%ebp),%eax
40002153:	8b 40 04             	mov    0x4(%eax),%eax
40002156:	83 ec 04             	sub    $0x4,%esp
40002159:	52                   	push   %edx
4000215a:	ff 75 0c             	pushl  0xc(%ebp)
4000215d:	50                   	push   %eax
4000215e:	e8 05 6e 00 00       	call   40008f68 <memcpy>
40002163:	83 c4 10             	add    $0x10,%esp
40002166:	a1 58 a6 00 40       	mov    0x4000a658,%eax
4000216b:	83 ec 08             	sub    $0x8,%esp
4000216e:	ff 75 f8             	pushl  -0x8(%ebp)
40002171:	50                   	push   %eax
40002172:	e8 55 5b 00 00       	call   40007ccc <list_push>
40002177:	83 c4 10             	add    $0x10,%esp
4000217a:	a3 58 a6 00 40       	mov    %eax,0x4000a658
4000217f:	eb 69                	jmp    400021ea <setenv+0x1a9>
40002181:	83 ec 0c             	sub    $0xc,%esp
40002184:	ff 75 0c             	pushl  0xc(%ebp)
40002187:	e8 e8 70 00 00       	call   40009274 <strlen>
4000218c:	83 c4 10             	add    $0x10,%esp
4000218f:	40                   	inc    %eax
40002190:	83 ec 0c             	sub    $0xc,%esp
40002193:	50                   	push   %eax
40002194:	e8 3f 61 00 00       	call   400082d8 <malloc>
40002199:	83 c4 10             	add    $0x10,%esp
4000219c:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000219f:	83 ec 0c             	sub    $0xc,%esp
400021a2:	ff 75 0c             	pushl  0xc(%ebp)
400021a5:	e8 ca 70 00 00       	call   40009274 <strlen>
400021aa:	83 c4 10             	add    $0x10,%esp
400021ad:	40                   	inc    %eax
400021ae:	83 ec 04             	sub    $0x4,%esp
400021b1:	50                   	push   %eax
400021b2:	ff 75 0c             	pushl  0xc(%ebp)
400021b5:	ff 75 fc             	pushl  -0x4(%ebp)
400021b8:	e8 ab 6d 00 00       	call   40008f68 <memcpy>
400021bd:	83 c4 10             	add    $0x10,%esp
400021c0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
400021c4:	75 09                	jne    400021cf <setenv+0x18e>
400021c6:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
400021cd:	eb 22                	jmp    400021f1 <setenv+0x1b0>
400021cf:	8b 45 f8             	mov    -0x8(%ebp),%eax
400021d2:	8b 40 04             	mov    0x4(%eax),%eax
400021d5:	83 ec 0c             	sub    $0xc,%esp
400021d8:	50                   	push   %eax
400021d9:	e8 d1 67 00 00       	call   400089af <free>
400021de:	83 c4 10             	add    $0x10,%esp
400021e1:	8b 55 f8             	mov    -0x8(%ebp),%edx
400021e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
400021e7:	89 42 04             	mov    %eax,0x4(%edx)
400021ea:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400021f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
400021f4:	c9                   	leave  
400021f5:	c3                   	ret    

400021f6 <unsetenv>:
400021f6:	55                   	push   %ebp
400021f7:	89 e5                	mov    %esp,%ebp
400021f9:	83 ec 18             	sub    $0x18,%esp
400021fc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40002203:	e8 90 0f 00 00       	call   40003198 <p>
40002208:	eb 62                	jmp    4000226c <unsetenv+0x76>
4000220a:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000220d:	8b 00                	mov    (%eax),%eax
4000220f:	83 ec 08             	sub    $0x8,%esp
40002212:	50                   	push   %eax
40002213:	ff 75 08             	pushl  0x8(%ebp)
40002216:	e8 d5 6f 00 00       	call   400091f0 <strcmp>
4000221b:	83 c4 10             	add    $0x10,%esp
4000221e:	85 c0                	test   %eax,%eax
40002220:	75 47                	jne    40002269 <unsetenv+0x73>
40002222:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002225:	8b 00                	mov    (%eax),%eax
40002227:	83 ec 0c             	sub    $0xc,%esp
4000222a:	50                   	push   %eax
4000222b:	e8 7f 67 00 00       	call   400089af <free>
40002230:	83 c4 10             	add    $0x10,%esp
40002233:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002236:	8b 40 04             	mov    0x4(%eax),%eax
40002239:	83 ec 0c             	sub    $0xc,%esp
4000223c:	50                   	push   %eax
4000223d:	e8 6d 67 00 00       	call   400089af <free>
40002242:	83 c4 10             	add    $0x10,%esp
40002245:	83 ec 0c             	sub    $0xc,%esp
40002248:	ff 75 fc             	pushl  -0x4(%ebp)
4000224b:	e8 5f 67 00 00       	call   400089af <free>
40002250:	83 c4 10             	add    $0x10,%esp
40002253:	a1 58 a6 00 40       	mov    0x4000a658,%eax
40002258:	83 ec 08             	sub    $0x8,%esp
4000225b:	ff 75 f8             	pushl  -0x8(%ebp)
4000225e:	50                   	push   %eax
4000225f:	e8 15 5d 00 00       	call   40007f79 <list_remove>
40002264:	83 c4 10             	add    $0x10,%esp
40002267:	eb 20                	jmp    40002289 <unsetenv+0x93>
40002269:	ff 45 f8             	incl   -0x8(%ebp)
4000226c:	a1 58 a6 00 40       	mov    0x4000a658,%eax
40002271:	83 ec 08             	sub    $0x8,%esp
40002274:	ff 75 f8             	pushl  -0x8(%ebp)
40002277:	50                   	push   %eax
40002278:	e8 10 5c 00 00       	call   40007e8d <list_get_element_at>
4000227d:	83 c4 10             	add    $0x10,%esp
40002280:	89 45 fc             	mov    %eax,-0x4(%ebp)
40002283:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40002287:	75 81                	jne    4000220a <unsetenv+0x14>
40002289:	e8 16 0f 00 00       	call   400031a4 <v>
4000228e:	c9                   	leave  
4000228f:	c3                   	ret    

40002290 <getcwd>:
40002290:	55                   	push   %ebp
40002291:	89 e5                	mov    %esp,%ebp
40002293:	83 ec 18             	sub    $0x18,%esp
40002296:	83 ec 0c             	sub    $0xc,%esp
40002299:	68 3f 98 00 40       	push   $0x4000983f
4000229e:	e8 6a fd ff ff       	call   4000200d <getenv>
400022a3:	83 c4 10             	add    $0x10,%esp
400022a6:	89 45 fc             	mov    %eax,-0x4(%ebp)
400022a9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
400022ad:	75 09                	jne    400022b8 <getcwd+0x28>
400022af:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400022b6:	eb 7a                	jmp    40002332 <getcwd+0xa2>
400022b8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
400022bc:	75 30                	jne    400022ee <getcwd+0x5e>
400022be:	83 ec 0c             	sub    $0xc,%esp
400022c1:	ff 75 fc             	pushl  -0x4(%ebp)
400022c4:	e8 ab 6f 00 00       	call   40009274 <strlen>
400022c9:	83 c4 10             	add    $0x10,%esp
400022cc:	40                   	inc    %eax
400022cd:	89 45 0c             	mov    %eax,0xc(%ebp)
400022d0:	83 ec 0c             	sub    $0xc,%esp
400022d3:	ff 75 fc             	pushl  -0x4(%ebp)
400022d6:	e8 99 6f 00 00       	call   40009274 <strlen>
400022db:	83 c4 10             	add    $0x10,%esp
400022de:	40                   	inc    %eax
400022df:	83 ec 0c             	sub    $0xc,%esp
400022e2:	50                   	push   %eax
400022e3:	e8 f0 5f 00 00       	call   400082d8 <malloc>
400022e8:	83 c4 10             	add    $0x10,%esp
400022eb:	89 45 08             	mov    %eax,0x8(%ebp)
400022ee:	83 ec 0c             	sub    $0xc,%esp
400022f1:	ff 75 fc             	pushl  -0x4(%ebp)
400022f4:	e8 7b 6f 00 00       	call   40009274 <strlen>
400022f9:	83 c4 10             	add    $0x10,%esp
400022fc:	40                   	inc    %eax
400022fd:	3b 45 0c             	cmp    0xc(%ebp),%eax
40002300:	77 29                	ja     4000232b <getcwd+0x9b>
40002302:	83 ec 0c             	sub    $0xc,%esp
40002305:	ff 75 fc             	pushl  -0x4(%ebp)
40002308:	e8 67 6f 00 00       	call   40009274 <strlen>
4000230d:	83 c4 10             	add    $0x10,%esp
40002310:	40                   	inc    %eax
40002311:	83 ec 04             	sub    $0x4,%esp
40002314:	50                   	push   %eax
40002315:	ff 75 fc             	pushl  -0x4(%ebp)
40002318:	ff 75 08             	pushl  0x8(%ebp)
4000231b:	e8 48 6c 00 00       	call   40008f68 <memcpy>
40002320:	83 c4 10             	add    $0x10,%esp
40002323:	8b 45 08             	mov    0x8(%ebp),%eax
40002326:	89 45 ec             	mov    %eax,-0x14(%ebp)
40002329:	eb 07                	jmp    40002332 <getcwd+0xa2>
4000232b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40002332:	8b 45 ec             	mov    -0x14(%ebp),%eax
40002335:	c9                   	leave  
40002336:	c3                   	ret    

40002337 <chdir>:
40002337:	55                   	push   %ebp
40002338:	89 e5                	mov    %esp,%ebp
4000233a:	83 ec 18             	sub    $0x18,%esp
4000233d:	83 ec 0c             	sub    $0xc,%esp
40002340:	ff 75 08             	pushl  0x8(%ebp)
40002343:	e8 0a 05 00 00       	call   40002852 <io_get_absolute_path>
40002348:	83 c4 10             	add    $0x10,%esp
4000234b:	89 45 f8             	mov    %eax,-0x8(%ebp)
4000234e:	83 ec 04             	sub    $0x4,%esp
40002351:	6a 01                	push   $0x1
40002353:	ff 75 08             	pushl  0x8(%ebp)
40002356:	68 3f 98 00 40       	push   $0x4000983f
4000235b:	e8 e1 fc ff ff       	call   40002041 <setenv>
40002360:	83 c4 10             	add    $0x10,%esp
40002363:	89 45 fc             	mov    %eax,-0x4(%ebp)
40002366:	83 ec 0c             	sub    $0xc,%esp
40002369:	ff 75 f8             	pushl  -0x8(%ebp)
4000236c:	e8 3e 66 00 00       	call   400089af <free>
40002371:	83 c4 10             	add    $0x10,%esp
40002374:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002377:	c9                   	leave  
40002378:	c3                   	ret    
40002379:	90                   	nop    
4000237a:	90                   	nop    
4000237b:	90                   	nop    

4000237c <init_service_register>:
#include "cdi/io.h"

#include "device.h"


/**
4000237c:	55                   	push   %ebp
4000237d:	89 e5                	mov    %esp,%ebp
4000237f:	53                   	push   %ebx
40002380:	83 ec 14             	sub    $0x14,%esp
 * ATA-Geraet identifizieren
40002383:	c7 45 f4 43 98 00 40 	movl   $0x40009843,-0xc(%ebp)
 *
4000238a:	83 ec 0c             	sub    $0xc,%esp
4000238d:	ff 75 f4             	pushl  -0xc(%ebp)
40002390:	e8 df 6e 00 00       	call   40009274 <strlen>
40002395:	83 c4 10             	add    $0x10,%esp
40002398:	89 c3                	mov    %eax,%ebx
4000239a:	83 ec 0c             	sub    $0xc,%esp
4000239d:	ff 75 08             	pushl  0x8(%ebp)
400023a0:	e8 cf 6e 00 00       	call   40009274 <strlen>
400023a5:	83 c4 10             	add    $0x10,%esp
400023a8:	8d 04 03             	lea    (%ebx,%eax,1),%eax
400023ab:	40                   	inc    %eax
400023ac:	83 ec 0c             	sub    $0xc,%esp
400023af:	50                   	push   %eax
400023b0:	e8 23 5f 00 00       	call   400082d8 <malloc>
400023b5:	83 c4 10             	add    $0x10,%esp
400023b8:	89 45 f8             	mov    %eax,-0x8(%ebp)
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
 */
400023bb:	83 ec 0c             	sub    $0xc,%esp
400023be:	ff 75 f4             	pushl  -0xc(%ebp)
400023c1:	e8 ae 6e 00 00       	call   40009274 <strlen>
400023c6:	83 c4 10             	add    $0x10,%esp
400023c9:	83 ec 04             	sub    $0x4,%esp
400023cc:	50                   	push   %eax
400023cd:	ff 75 f4             	pushl  -0xc(%ebp)
400023d0:	ff 75 f8             	pushl  -0x8(%ebp)
400023d3:	e8 90 6b 00 00       	call   40008f68 <memcpy>
400023d8:	83 c4 10             	add    $0x10,%esp
int ata_drv_identify(struct ata_device* dev)
400023db:	83 ec 0c             	sub    $0xc,%esp
400023de:	ff 75 08             	pushl  0x8(%ebp)
400023e1:	e8 8e 6e 00 00       	call   40009274 <strlen>
400023e6:	83 c4 10             	add    $0x10,%esp
400023e9:	8d 58 01             	lea    0x1(%eax),%ebx
400023ec:	83 ec 0c             	sub    $0xc,%esp
400023ef:	ff 75 f4             	pushl  -0xc(%ebp)
400023f2:	e8 7d 6e 00 00       	call   40009274 <strlen>
400023f7:	83 c4 10             	add    $0x10,%esp
400023fa:	89 c2                	mov    %eax,%edx
400023fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
400023ff:	8d 04 02             	lea    (%edx,%eax,1),%eax
40002402:	83 ec 04             	sub    $0x4,%esp
40002405:	53                   	push   %ebx
40002406:	ff 75 08             	pushl  0x8(%ebp)
40002409:	50                   	push   %eax
4000240a:	e8 59 6b 00 00       	call   40008f68 <memcpy>
4000240f:	83 c4 10             	add    $0x10,%esp
{
    uint8_t buffer[ATA_SECTOR_SIZE];

40002412:	83 ec 0c             	sub    $0xc,%esp
40002415:	ff 75 f8             	pushl  -0x8(%ebp)
40002418:	e8 57 6e 00 00       	call   40009274 <strlen>
4000241d:	83 c4 10             	add    $0x10,%esp
40002420:	40                   	inc    %eax
40002421:	83 ec 0c             	sub    $0xc,%esp
40002424:	ff 75 f8             	pushl  -0x8(%ebp)
40002427:	50                   	push   %eax
40002428:	6a 00                	push   $0x0
4000242a:	68 00 02 00 00       	push   $0x200
4000242f:	6a 01                	push   $0x1
40002431:	e8 fc 0d 00 00       	call   40003232 <send_message>
40002436:	83 c4 20             	add    $0x20,%esp
    // Request vorbereiten
40002439:	8b 5d fc             	mov    -0x4(%ebp),%ebx
4000243c:	c9                   	leave  
4000243d:	c3                   	ret    

4000243e <init_service_get>:
        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
4000243e:	55                   	push   %ebp
4000243f:	89 e5                	mov    %esp,%ebp
40002441:	83 ec 08             	sub    $0x8,%esp
        .registers.ata.command = IDENTIFY_DEVICE,
40002444:	83 ec 0c             	sub    $0xc,%esp
40002447:	ff 75 08             	pushl  0x8(%ebp)
4000244a:	e8 25 6e 00 00       	call   40009274 <strlen>
4000244f:	83 c4 10             	add    $0x10,%esp
40002452:	40                   	inc    %eax
40002453:	ff 75 08             	pushl  0x8(%ebp)
40002456:	50                   	push   %eax
40002457:	68 4c 98 00 40       	push   $0x4000984c
4000245c:	6a 01                	push   $0x1
4000245e:	e8 5a 10 00 00       	call   400034bd <rpc_get_dword>
40002463:	83 c4 10             	add    $0x10,%esp
        .block_count = 1,
40002466:	c9                   	leave  
40002467:	c3                   	ret    

40002468 <init_process_exit>:

        .error = 0
    };
    
    // Request starten
    if (!ata_request(&request)) {
40002468:	55                   	push   %ebp
40002469:	89 e5                	mov    %esp,%ebp
4000246b:	53                   	push   %ebx
4000246c:	83 ec 14             	sub    $0x14,%esp
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
4000246f:	c7 45 f4 55 98 00 40 	movl   $0x40009855,-0xc(%ebp)
        // IDENTIFY PACKET DEVICE probieren.
40002476:	83 ec 0c             	sub    $0xc,%esp
40002479:	ff 75 f4             	pushl  -0xc(%ebp)
4000247c:	e8 f3 6d 00 00       	call   40009274 <strlen>
40002481:	83 c4 10             	add    $0x10,%esp
40002484:	83 c0 05             	add    $0x5,%eax
40002487:	83 ec 0c             	sub    $0xc,%esp
4000248a:	50                   	push   %eax
4000248b:	e8 48 5e 00 00       	call   400082d8 <malloc>
40002490:	83 c4 10             	add    $0x10,%esp
40002493:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return atapi_drv_identify(dev);
    }
40002496:	83 ec 0c             	sub    $0xc,%esp
40002499:	ff 75 f4             	pushl  -0xc(%ebp)
4000249c:	e8 d3 6d 00 00       	call   40009274 <strlen>
400024a1:	83 c4 10             	add    $0x10,%esp
400024a4:	83 ec 04             	sub    $0x4,%esp
400024a7:	50                   	push   %eax
400024a8:	ff 75 f4             	pushl  -0xc(%ebp)
400024ab:	ff 75 f8             	pushl  -0x8(%ebp)
400024ae:	e8 b5 6a 00 00       	call   40008f68 <memcpy>
400024b3:	83 c4 10             	add    $0x10,%esp
        
400024b6:	83 ec 0c             	sub    $0xc,%esp
400024b9:	ff 75 f4             	pushl  -0xc(%ebp)
400024bc:	e8 b3 6d 00 00       	call   40009274 <strlen>
400024c1:	83 c4 10             	add    $0x10,%esp
400024c4:	89 c2                	mov    %eax,%edx
400024c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
400024c9:	8d 04 02             	lea    (%edx,%eax,1),%eax
400024cc:	89 c2                	mov    %eax,%edx
400024ce:	83 ec 04             	sub    $0x4,%esp
400024d1:	6a 04                	push   $0x4
400024d3:	8d 45 08             	lea    0x8(%ebp),%eax
400024d6:	50                   	push   %eax
400024d7:	52                   	push   %edx
400024d8:	e8 8b 6a 00 00       	call   40008f68 <memcpy>
400024dd:	83 c4 10             	add    $0x10,%esp
    // Ein ATA-Geraet
400024e0:	8b 5d f8             	mov    -0x8(%ebp),%ebx
400024e3:	83 c3 04             	add    $0x4,%ebx
400024e6:	83 ec 0c             	sub    $0xc,%esp
400024e9:	ff 75 f4             	pushl  -0xc(%ebp)
400024ec:	e8 83 6d 00 00       	call   40009274 <strlen>
400024f1:	83 c4 10             	add    $0x10,%esp
400024f4:	8d 04 03             	lea    (%ebx,%eax,1),%eax
400024f7:	c6 00 00             	movb   $0x0,(%eax)
    dev->atapi = 0;

    // TODO: Informationen verarbeiten
400024fa:	83 ec 0c             	sub    $0xc,%esp
400024fd:	ff 75 f8             	pushl  -0x8(%ebp)
40002500:	e8 6f 6d 00 00       	call   40009274 <strlen>
40002505:	83 c4 10             	add    $0x10,%esp
40002508:	83 ec 0c             	sub    $0xc,%esp
4000250b:	ff 75 f8             	pushl  -0x8(%ebp)
4000250e:	50                   	push   %eax
4000250f:	6a 00                	push   $0x0
40002511:	68 00 02 00 00       	push   $0x200
40002516:	6a 01                	push   $0x1
40002518:	e8 15 0d 00 00       	call   40003232 <send_message>
4000251d:	83 c4 20             	add    $0x20,%esp

    return 1;
40002520:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40002523:	c9                   	leave  
40002524:	c3                   	ret    

40002525 <init_execute>:

/**
 * Sektoren von einem ATA-Geraet lesen
 *
 * @param start LBA des Startsektors
 * @param count Anzahl der Sektoren
40002525:	55                   	push   %ebp
40002526:	89 e5                	mov    %esp,%ebp
40002528:	83 ec 08             	sub    $0x8,%esp
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
4000252b:	83 ec 0c             	sub    $0xc,%esp
4000252e:	ff 75 08             	pushl  0x8(%ebp)
40002531:	e8 3e 6d 00 00       	call   40009274 <strlen>
40002536:	83 c4 10             	add    $0x10,%esp
40002539:	40                   	inc    %eax
4000253a:	ff 75 08             	pushl  0x8(%ebp)
4000253d:	50                   	push   %eax
4000253e:	68 5e 98 00 40       	push   $0x4000985e
40002543:	6a 01                	push   $0x1
40002545:	e8 73 0f 00 00       	call   400034bd <rpc_get_dword>
4000254a:	83 c4 10             	add    $0x10,%esp
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
4000254d:	c9                   	leave  
4000254e:	c3                   	ret    

4000254f <init_wait_task_exit>:
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
{
    int result = 1;
    struct ata_request request;
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
4000254f:	55                   	push   %ebp
40002550:	89 e5                	mov    %esp,%ebp
40002552:	83 ec 08             	sub    $0x8,%esp
    // muss unter Umstaenden mehrmals gelesen werden.
40002555:	8d 45 08             	lea    0x8(%ebp),%eax
40002558:	50                   	push   %eax
40002559:	6a 04                	push   $0x4
4000255b:	68 67 98 00 40       	push   $0x40009867
40002560:	6a 01                	push   $0x1
40002562:	e8 56 0f 00 00       	call   400034bd <rpc_get_dword>
40002567:	83 c4 10             	add    $0x10,%esp
    uint16_t current_count;
4000256a:	c9                   	leave  
4000256b:	c3                   	ret    

4000256c <get_path_elements>:
    void* current_buffer = buffer;
    uint64_t lba = start;

    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;

4000256c:	55                   	push   %ebp
4000256d:	89 e5                	mov    %esp,%ebp
4000256f:	83 ec 28             	sub    $0x28,%esp
    // Solange wie noch Sektoren uebrig sind, wird gelesen
40002572:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while (count_left > 0) {
40002579:	8b 45 08             	mov    0x8(%ebp),%eax
4000257c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
4000257f:	8b 45 08             	mov    0x8(%ebp),%eax
40002582:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (count_left > 256) {
40002585:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            current_count = 256;
4000258c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
        } else {
            current_count = count_left;
        }
        
        // Request vorbereiten
        request.dev = dev;
40002593:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
40002597:	75 0c                	jne    400025a5 <get_path_elements+0x39>
        // TODO: DMA, UltraDMA...
40002599:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400025a0:	e9 e9 00 00 00       	jmp    4000268e <get_path_elements+0x122>
        request.protocol = PIO;
        request.flags.direction = READ;
400025a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
400025a8:	89 c2                	mov    %eax,%edx
400025aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
400025ad:	89 d1                	mov    %edx,%ecx
400025af:	29 c1                	sub    %eax,%ecx
400025b1:	89 c8                	mov    %ecx,%eax
400025b3:	89 45 fc             	mov    %eax,-0x4(%ebp)
        // FIXME
        request.flags.poll = 1;
400025b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
400025b9:	8a 00                	mov    (%eax),%al
400025bb:	0f be c0             	movsbl %al,%eax
400025be:	89 45 dc             	mov    %eax,-0x24(%ebp)
400025c1:	83 7d dc 3a          	cmpl   $0x3a,-0x24(%ebp)
400025c5:	74 46                	je     4000260d <get_path_elements+0xa1>
400025c7:	83 7d dc 3a          	cmpl   $0x3a,-0x24(%ebp)
400025cb:	7f 15                	jg     400025e2 <get_path_elements+0x76>
400025cd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
400025d1:	0f 84 a1 00 00 00    	je     40002678 <get_path_elements+0x10c>
400025d7:	83 7d dc 2f          	cmpl   $0x2f,-0x24(%ebp)
400025db:	74 55                	je     40002632 <get_path_elements+0xc6>
400025dd:	e9 ac 00 00 00       	jmp    4000268e <get_path_elements+0x122>
400025e2:	83 7d dc 5c          	cmpl   $0x5c,-0x24(%ebp)
400025e6:	74 0b                	je     400025f3 <get_path_elements+0x87>
400025e8:	83 7d dc 7c          	cmpl   $0x7c,-0x24(%ebp)
400025ec:	74 72                	je     40002660 <get_path_elements+0xf4>
400025ee:	e9 9b 00 00 00       	jmp    4000268e <get_path_elements+0x122>
        request.flags.lba = 1;

        request.registers.ata.command = READ_SECTORS;
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
400025f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
400025f6:	40                   	inc    %eax
400025f7:	8a 00                	mov    (%eax),%al
400025f9:	84 c0                	test   %al,%al
400025fb:	0f 84 8d 00 00 00    	je     4000268e <get_path_elements+0x122>
        // 0 steht.
40002601:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        request.registers.ata.count = (uint8_t) current_count;
        request.registers.ata.lba = lba;
40002608:	e9 81 00 00 00       	jmp    4000268e <get_path_elements+0x122>

        request.block_count = current_count;
        request.block_size = ATA_SECTOR_SIZE;
        request.blocks_done = 0;
4000260d:	8b 45 ec             	mov    -0x14(%ebp),%eax
40002610:	40                   	inc    %eax
40002611:	8a 00                	mov    (%eax),%al
40002613:	3c 2f                	cmp    $0x2f,%al
40002615:	75 77                	jne    4000268e <get_path_elements+0x122>
        request.buffer = current_buffer;
40002617:	6a 01                	push   $0x1
40002619:	ff 75 f4             	pushl  -0xc(%ebp)
4000261c:	ff 75 fc             	pushl  -0x4(%ebp)
4000261f:	ff 75 f0             	pushl  -0x10(%ebp)
40002622:	e8 ab 00 00 00       	call   400026d2 <create_path_element>
40002627:	83 c4 10             	add    $0x10,%esp
4000262a:	89 45 f8             	mov    %eax,-0x8(%ebp)

        request.error = NO_ERROR;
        
        // TODO: LBA48
        // TODO: CHS
4000262d:	ff 45 ec             	incl   -0x14(%ebp)
        
        // Request ausfuehren
40002630:	eb 5c                	jmp    4000268e <get_path_elements+0x122>
        if (!ata_request(&request)) {
            result = 0;
            break;
        }

        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
40002632:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40002636:	74 18                	je     40002650 <get_path_elements+0xe4>
        current_buffer += current_count * ATA_SECTOR_SIZE;
40002638:	6a 02                	push   $0x2
4000263a:	ff 75 f4             	pushl  -0xc(%ebp)
4000263d:	ff 75 fc             	pushl  -0x4(%ebp)
40002640:	ff 75 f0             	pushl  -0x10(%ebp)
40002643:	e8 8a 00 00 00       	call   400026d2 <create_path_element>
40002648:	83 c4 10             	add    $0x10,%esp
4000264b:	89 45 f8             	mov    %eax,-0x8(%ebp)
4000264e:	eb 3e                	jmp    4000268e <get_path_elements+0x122>
        count_left -= current_count;
        lba += current_count;
    }
40002650:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)

40002657:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000265a:	40                   	inc    %eax
4000265b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return result;
}
4000265e:	eb 2e                	jmp    4000268e <get_path_elements+0x122>

40002660:	6a 03                	push   $0x3
40002662:	ff 75 f4             	pushl  -0xc(%ebp)
40002665:	ff 75 fc             	pushl  -0x4(%ebp)
40002668:	ff 75 f0             	pushl  -0x10(%ebp)
4000266b:	e8 62 00 00 00       	call   400026d2 <create_path_element>
40002670:	83 c4 10             	add    $0x10,%esp
40002673:	89 45 f8             	mov    %eax,-0x8(%ebp)
40002676:	eb 16                	jmp    4000268e <get_path_elements+0x122>
40002678:	6a 00                	push   $0x0
4000267a:	ff 75 f4             	pushl  -0xc(%ebp)
4000267d:	ff 75 fc             	pushl  -0x4(%ebp)
40002680:	ff 75 f0             	pushl  -0x10(%ebp)
40002683:	e8 4a 00 00 00       	call   400026d2 <create_path_element>
40002688:	83 c4 10             	add    $0x10,%esp
4000268b:	89 45 f8             	mov    %eax,-0x8(%ebp)
4000268e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40002692:	74 2b                	je     400026bf <get_path_elements+0x153>
40002694:	8b 45 f8             	mov    -0x8(%ebp),%eax
40002697:	8b 40 04             	mov    0x4(%eax),%eax
4000269a:	89 45 f4             	mov    %eax,-0xc(%ebp)
4000269d:	8b 45 ec             	mov    -0x14(%ebp),%eax
400026a0:	40                   	inc    %eax
400026a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
400026a4:	83 ec 04             	sub    $0x4,%esp
400026a7:	ff 75 f8             	pushl  -0x8(%ebp)
400026aa:	ff 75 10             	pushl  0x10(%ebp)
400026ad:	ff 75 0c             	pushl  0xc(%ebp)
400026b0:	e8 0c 58 00 00       	call   40007ec1 <list_insert>
400026b5:	83 c4 10             	add    $0x10,%esp
400026b8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
400026bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
400026c2:	8a 00                	mov    (%eax),%al
400026c4:	84 c0                	test   %al,%al
400026c6:	74 08                	je     400026d0 <get_path_elements+0x164>
400026c8:	ff 45 ec             	incl   -0x14(%ebp)
400026cb:	e9 c3 fe ff ff       	jmp    40002593 <get_path_elements+0x27>
400026d0:	c9                   	leave  
400026d1:	c3                   	ret    

400026d2 <create_path_element>:
        .error = 0
    };
    
    // Request starten
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
400026d2:	55                   	push   %ebp
400026d3:	89 e5                	mov    %esp,%ebp
400026d5:	83 ec 18             	sub    $0x18,%esp
        // IDENTIFY PACKET DEVICE probieren.
400026d8:	83 ec 0c             	sub    $0xc,%esp
400026db:	68 08 01 00 00       	push   $0x108
400026e0:	e8 f3 5b 00 00       	call   400082d8 <malloc>
400026e5:	83 c4 10             	add    $0x10,%esp
400026e8:	89 45 fc             	mov    %eax,-0x4(%ebp)
        return atapi_drv_identify(dev);
    }
        
    // Ein ATA-Geraet
    dev->atapi = 0;
400026eb:	81 7d 0c ff 00 00 00 	cmpl   $0xff,0xc(%ebp)
400026f2:	76 07                	jbe    400026fb <create_path_element+0x29>

400026f4:	c7 45 0c ff 00 00 00 	movl   $0xff,0xc(%ebp)
    // TODO: Informationen verarbeiten

400026fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
400026fe:	83 c0 08             	add    $0x8,%eax
40002701:	83 ec 04             	sub    $0x4,%esp
40002704:	ff 75 0c             	pushl  0xc(%ebp)
40002707:	ff 75 08             	pushl  0x8(%ebp)
4000270a:	50                   	push   %eax
4000270b:	e8 58 68 00 00       	call   40008f68 <memcpy>
40002710:	83 c4 10             	add    $0x10,%esp
    return 1;
40002713:	8b 55 0c             	mov    0xc(%ebp),%edx
40002716:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002719:	c6 44 10 08 00       	movb   $0x0,0x8(%eax,%edx,1)
}

4000271e:	8b 55 fc             	mov    -0x4(%ebp),%edx
40002721:	8b 45 10             	mov    0x10(%ebp),%eax
40002724:	89 02                	mov    %eax,(%edx)
/**
40002726:	8b 55 fc             	mov    -0x4(%ebp),%edx
40002729:	8b 45 14             	mov    0x14(%ebp),%eax
4000272c:	89 42 04             	mov    %eax,0x4(%edx)
 * Sektoren von einem ATA-Geraet lesen
 *
4000272f:	8b 45 fc             	mov    -0x4(%ebp),%eax
 * @param start LBA des Startsektors
40002732:	c9                   	leave  
40002733:	c3                   	ret    

40002734 <eliminate_dot_elements>:
40002734:	55                   	push   %ebp
40002735:	89 e5                	mov    %esp,%ebp
40002737:	53                   	push   %ebx
40002738:	83 ec 14             	sub    $0x14,%esp
4000273b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40002742:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40002749:	e9 e1 00 00 00       	jmp    4000282f <eliminate_dot_elements+0xfb>
4000274e:	8b 45 f8             	mov    -0x8(%ebp),%eax
40002751:	83 c0 08             	add    $0x8,%eax
40002754:	83 ec 08             	sub    $0x8,%esp
40002757:	68 70 98 00 40       	push   $0x40009870
4000275c:	50                   	push   %eax
4000275d:	e8 8e 6a 00 00       	call   400091f0 <strcmp>
40002762:	83 c4 10             	add    $0x10,%esp
40002765:	85 c0                	test   %eax,%eax
40002767:	75 27                	jne    40002790 <eliminate_dot_elements+0x5c>
40002769:	83 ec 08             	sub    $0x8,%esp
4000276c:	ff 75 f0             	pushl  -0x10(%ebp)
4000276f:	ff 75 08             	pushl  0x8(%ebp)
40002772:	e8 02 58 00 00       	call   40007f79 <list_remove>
40002777:	83 c4 10             	add    $0x10,%esp
4000277a:	83 ec 0c             	sub    $0xc,%esp
4000277d:	ff 75 f8             	pushl  -0x8(%ebp)
40002780:	e8 2a 62 00 00       	call   400089af <free>
40002785:	83 c4 10             	add    $0x10,%esp
40002788:	ff 45 f4             	incl   -0xc(%ebp)
4000278b:	e9 9f 00 00 00       	jmp    4000282f <eliminate_dot_elements+0xfb>
40002790:	8b 45 f8             	mov    -0x8(%ebp),%eax
40002793:	83 c0 08             	add    $0x8,%eax
40002796:	83 ec 08             	sub    $0x8,%esp
40002799:	68 73 98 00 40       	push   $0x40009873
4000279e:	50                   	push   %eax
4000279f:	e8 4c 6a 00 00       	call   400091f0 <strcmp>
400027a4:	83 c4 10             	add    $0x10,%esp
400027a7:	85 c0                	test   %eax,%eax
400027a9:	74 16                	je     400027c1 <eliminate_dot_elements+0x8d>
400027ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
400027ae:	83 c0 08             	add    $0x8,%eax
400027b1:	83 ec 0c             	sub    $0xc,%esp
400027b4:	50                   	push   %eax
400027b5:	e8 ba 6a 00 00       	call   40009274 <strlen>
400027ba:	83 c4 10             	add    $0x10,%esp
400027bd:	85 c0                	test   %eax,%eax
400027bf:	75 21                	jne    400027e2 <eliminate_dot_elements+0xae>
400027c1:	83 ec 08             	sub    $0x8,%esp
400027c4:	ff 75 f0             	pushl  -0x10(%ebp)
400027c7:	ff 75 08             	pushl  0x8(%ebp)
400027ca:	e8 aa 57 00 00       	call   40007f79 <list_remove>
400027cf:	83 c4 10             	add    $0x10,%esp
400027d2:	83 ec 0c             	sub    $0xc,%esp
400027d5:	ff 75 f8             	pushl  -0x8(%ebp)
400027d8:	e8 d2 61 00 00       	call   400089af <free>
400027dd:	83 c4 10             	add    $0x10,%esp
400027e0:	eb 4d                	jmp    4000282f <eliminate_dot_elements+0xfb>
400027e2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
400027e6:	74 44                	je     4000282c <eliminate_dot_elements+0xf8>
400027e8:	8b 5d f0             	mov    -0x10(%ebp),%ebx
400027eb:	83 ec 0c             	sub    $0xc,%esp
400027ee:	ff 75 08             	pushl  0x8(%ebp)
400027f1:	e8 aa 54 00 00       	call   40007ca0 <list_size>
400027f6:	83 c4 10             	add    $0x10,%esp
400027f9:	48                   	dec    %eax
400027fa:	39 c3                	cmp    %eax,%ebx
400027fc:	73 2e                	jae    4000282c <eliminate_dot_elements+0xf8>
400027fe:	83 ec 08             	sub    $0x8,%esp
40002801:	ff 75 f0             	pushl  -0x10(%ebp)
40002804:	ff 75 08             	pushl  0x8(%ebp)
40002807:	e8 6d 57 00 00       	call   40007f79 <list_remove>
4000280c:	83 c4 10             	add    $0x10,%esp
4000280f:	8b 45 f8             	mov    -0x8(%ebp),%eax
40002812:	8b 00                	mov    (%eax),%eax
40002814:	83 f8 03             	cmp    $0x3,%eax
40002817:	74 03                	je     4000281c <eliminate_dot_elements+0xe8>
40002819:	ff 4d f4             	decl   -0xc(%ebp)
4000281c:	83 ec 0c             	sub    $0xc,%esp
4000281f:	ff 75 f8             	pushl  -0x8(%ebp)
40002822:	e8 88 61 00 00       	call   400089af <free>
40002827:	83 c4 10             	add    $0x10,%esp
4000282a:	eb 03                	jmp    4000282f <eliminate_dot_elements+0xfb>
4000282c:	ff 45 f0             	incl   -0x10(%ebp)
4000282f:	83 ec 08             	sub    $0x8,%esp
40002832:	ff 75 f0             	pushl  -0x10(%ebp)
40002835:	ff 75 08             	pushl  0x8(%ebp)
40002838:	e8 50 56 00 00       	call   40007e8d <list_get_element_at>
4000283d:	83 c4 10             	add    $0x10,%esp
40002840:	89 45 f8             	mov    %eax,-0x8(%ebp)
40002843:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40002847:	0f 85 01 ff ff ff    	jne    4000274e <eliminate_dot_elements+0x1a>
4000284d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40002850:	c9                   	leave  
40002851:	c3                   	ret    

40002852 <io_get_absolute_path>:
40002852:	55                   	push   %ebp
40002853:	89 e5                	mov    %esp,%ebp
40002855:	83 ec 28             	sub    $0x28,%esp
40002858:	e8 c3 53 00 00       	call   40007c20 <list_create>
4000285d:	89 45 f0             	mov    %eax,-0x10(%ebp)
40002860:	83 ec 04             	sub    $0x4,%esp
40002863:	6a 00                	push   $0x0
40002865:	ff 75 f0             	pushl  -0x10(%ebp)
40002868:	ff 75 08             	pushl  0x8(%ebp)
4000286b:	e8 fc fc ff ff       	call   4000256c <get_path_elements>
40002870:	83 c4 10             	add    $0x10,%esp
40002873:	83 ec 0c             	sub    $0xc,%esp
40002876:	ff 75 f0             	pushl  -0x10(%ebp)
40002879:	e8 22 54 00 00       	call   40007ca0 <list_size>
4000287e:	83 c4 10             	add    $0x10,%esp
40002881:	48                   	dec    %eax
40002882:	89 45 f4             	mov    %eax,-0xc(%ebp)
40002885:	83 ec 08             	sub    $0x8,%esp
40002888:	ff 75 f4             	pushl  -0xc(%ebp)
4000288b:	ff 75 f0             	pushl  -0x10(%ebp)
4000288e:	e8 fa 55 00 00       	call   40007e8d <list_get_element_at>
40002893:	83 c4 10             	add    $0x10,%esp
40002896:	89 45 ec             	mov    %eax,-0x14(%ebp)
40002899:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000289c:	8b 00                	mov    (%eax),%eax
4000289e:	85 c0                	test   %eax,%eax
400028a0:	75 1b                	jne    400028bd <io_get_absolute_path+0x6b>
400028a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
400028a5:	8b 40 04             	mov    0x4(%eax),%eax
400028a8:	83 f8 01             	cmp    $0x1,%eax
400028ab:	74 10                	je     400028bd <io_get_absolute_path+0x6b>
400028ad:	83 ec 0c             	sub    $0xc,%esp
400028b0:	ff 75 f0             	pushl  -0x10(%ebp)
400028b3:	e8 9d 00 00 00       	call   40002955 <resolve_relative_path>
400028b8:	83 c4 10             	add    $0x10,%esp
400028bb:	eb 18                	jmp    400028d5 <io_get_absolute_path+0x83>
400028bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
400028c0:	8b 00                	mov    (%eax),%eax
400028c2:	83 f8 02             	cmp    $0x2,%eax
400028c5:	75 0e                	jne    400028d5 <io_get_absolute_path+0x83>
400028c7:	83 ec 0c             	sub    $0xc,%esp
400028ca:	ff 75 f0             	pushl  -0x10(%ebp)
400028cd:	e8 ee 00 00 00       	call   400029c0 <resolve_relative_serv_path>
400028d2:	83 c4 10             	add    $0x10,%esp
400028d5:	83 ec 0c             	sub    $0xc,%esp
400028d8:	ff 75 f0             	pushl  -0x10(%ebp)
400028db:	e8 54 fe ff ff       	call   40002734 <eliminate_dot_elements>
400028e0:	83 c4 10             	add    $0x10,%esp
400028e3:	83 ec 08             	sub    $0x8,%esp
400028e6:	6a 00                	push   $0x0
400028e8:	ff 75 f0             	pushl  -0x10(%ebp)
400028eb:	e8 9d 55 00 00       	call   40007e8d <list_get_element_at>
400028f0:	83 c4 10             	add    $0x10,%esp
400028f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
400028f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
400028f9:	8b 40 04             	mov    0x4(%eax),%eax
400028fc:	83 f8 02             	cmp    $0x2,%eax
400028ff:	75 0a                	jne    4000290b <io_get_absolute_path+0xb9>
40002901:	8b 45 ec             	mov    -0x14(%ebp),%eax
40002904:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
4000290b:	83 ec 0c             	sub    $0xc,%esp
4000290e:	ff 75 f0             	pushl  -0x10(%ebp)
40002911:	e8 94 01 00 00       	call   40002aaa <calc_path_length>
40002916:	83 c4 10             	add    $0x10,%esp
40002919:	89 45 f8             	mov    %eax,-0x8(%ebp)
4000291c:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000291f:	40                   	inc    %eax
40002920:	83 ec 0c             	sub    $0xc,%esp
40002923:	50                   	push   %eax
40002924:	e8 af 59 00 00       	call   400082d8 <malloc>
40002929:	83 c4 10             	add    $0x10,%esp
4000292c:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000292f:	83 ec 04             	sub    $0x4,%esp
40002932:	6a 01                	push   $0x1
40002934:	ff 75 fc             	pushl  -0x4(%ebp)
40002937:	ff 75 f0             	pushl  -0x10(%ebp)
4000293a:	e8 ee 01 00 00       	call   40002b2d <create_path_string>
4000293f:	83 c4 10             	add    $0x10,%esp
40002942:	83 ec 0c             	sub    $0xc,%esp
40002945:	ff 75 f0             	pushl  -0x10(%ebp)
40002948:	e8 01 53 00 00       	call   40007c4e <list_destroy>
4000294d:	83 c4 10             	add    $0x10,%esp
40002950:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002953:	c9                   	leave  
40002954:	c3                   	ret    

40002955 <resolve_relative_path>:
40002955:	55                   	push   %ebp
40002956:	89 e5                	mov    %esp,%ebp
40002958:	83 ec 18             	sub    $0x18,%esp
4000295b:	83 ec 08             	sub    $0x8,%esp
4000295e:	6a 00                	push   $0x0
40002960:	6a 00                	push   $0x0
40002962:	e8 29 f9 ff ff       	call   40002290 <getcwd>
40002967:	83 c4 10             	add    $0x10,%esp
4000296a:	89 45 f4             	mov    %eax,-0xc(%ebp)
4000296d:	83 ec 0c             	sub    $0xc,%esp
40002970:	ff 75 08             	pushl  0x8(%ebp)
40002973:	e8 28 53 00 00       	call   40007ca0 <list_size>
40002978:	83 c4 10             	add    $0x10,%esp
4000297b:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000297e:	83 ec 04             	sub    $0x4,%esp
40002981:	ff 75 fc             	pushl  -0x4(%ebp)
40002984:	ff 75 08             	pushl  0x8(%ebp)
40002987:	ff 75 f4             	pushl  -0xc(%ebp)
4000298a:	e8 dd fb ff ff       	call   4000256c <get_path_elements>
4000298f:	83 c4 10             	add    $0x10,%esp
40002992:	83 ec 08             	sub    $0x8,%esp
40002995:	ff 75 fc             	pushl  -0x4(%ebp)
40002998:	ff 75 08             	pushl  0x8(%ebp)
4000299b:	e8 ed 54 00 00       	call   40007e8d <list_get_element_at>
400029a0:	83 c4 10             	add    $0x10,%esp
400029a3:	89 45 f8             	mov    %eax,-0x8(%ebp)
400029a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
400029a9:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
400029b0:	83 ec 0c             	sub    $0xc,%esp
400029b3:	ff 75 f4             	pushl  -0xc(%ebp)
400029b6:	e8 f4 5f 00 00       	call   400089af <free>
400029bb:	83 c4 10             	add    $0x10,%esp
400029be:	c9                   	leave  
400029bf:	c3                   	ret    

400029c0 <resolve_relative_serv_path>:
400029c0:	55                   	push   %ebp
400029c1:	89 e5                	mov    %esp,%ebp
400029c3:	83 ec 28             	sub    $0x28,%esp
400029c6:	e8 55 52 00 00       	call   40007c20 <list_create>
400029cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
400029ce:	83 ec 08             	sub    $0x8,%esp
400029d1:	6a 00                	push   $0x0
400029d3:	6a 00                	push   $0x0
400029d5:	e8 b6 f8 ff ff       	call   40002290 <getcwd>
400029da:	83 c4 10             	add    $0x10,%esp
400029dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
400029e0:	83 ec 04             	sub    $0x4,%esp
400029e3:	6a 00                	push   $0x0
400029e5:	ff 75 ec             	pushl  -0x14(%ebp)
400029e8:	ff 75 f0             	pushl  -0x10(%ebp)
400029eb:	e8 7c fb ff ff       	call   4000256c <get_path_elements>
400029f0:	83 c4 10             	add    $0x10,%esp
400029f3:	83 ec 0c             	sub    $0xc,%esp
400029f6:	ff 75 f0             	pushl  -0x10(%ebp)
400029f9:	e8 b1 5f 00 00       	call   400089af <free>
400029fe:	83 c4 10             	add    $0x10,%esp
40002a01:	eb 1e                	jmp    40002a21 <resolve_relative_serv_path+0x61>
40002a03:	83 ec 08             	sub    $0x8,%esp
40002a06:	6a 00                	push   $0x0
40002a08:	ff 75 ec             	pushl  -0x14(%ebp)
40002a0b:	e8 69 55 00 00       	call   40007f79 <list_remove>
40002a10:	83 c4 10             	add    $0x10,%esp
40002a13:	83 ec 0c             	sub    $0xc,%esp
40002a16:	ff 75 f4             	pushl  -0xc(%ebp)
40002a19:	e8 91 5f 00 00       	call   400089af <free>
40002a1e:	83 c4 10             	add    $0x10,%esp
40002a21:	83 ec 08             	sub    $0x8,%esp
40002a24:	6a 00                	push   $0x0
40002a26:	ff 75 ec             	pushl  -0x14(%ebp)
40002a29:	e8 5f 54 00 00       	call   40007e8d <list_get_element_at>
40002a2e:	83 c4 10             	add    $0x10,%esp
40002a31:	89 45 f4             	mov    %eax,-0xc(%ebp)
40002a34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
40002a38:	74 0b                	je     40002a45 <resolve_relative_serv_path+0x85>
40002a3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
40002a3d:	8b 40 04             	mov    0x4(%eax),%eax
40002a40:	83 f8 01             	cmp    $0x1,%eax
40002a43:	75 be                	jne    40002a03 <resolve_relative_serv_path+0x43>
40002a45:	83 ec 0c             	sub    $0xc,%esp
40002a48:	ff 75 08             	pushl  0x8(%ebp)
40002a4b:	e8 50 52 00 00       	call   40007ca0 <list_size>
40002a50:	83 c4 10             	add    $0x10,%esp
40002a53:	89 45 f8             	mov    %eax,-0x8(%ebp)
40002a56:	83 ec 0c             	sub    $0xc,%esp
40002a59:	ff 75 ec             	pushl  -0x14(%ebp)
40002a5c:	e8 3f 52 00 00       	call   40007ca0 <list_size>
40002a61:	83 c4 10             	add    $0x10,%esp
40002a64:	89 45 fc             	mov    %eax,-0x4(%ebp)
40002a67:	eb 14                	jmp    40002a7d <resolve_relative_serv_path+0xbd>
40002a69:	83 ec 04             	sub    $0x4,%esp
40002a6c:	ff 75 f4             	pushl  -0xc(%ebp)
40002a6f:	ff 75 f8             	pushl  -0x8(%ebp)
40002a72:	ff 75 08             	pushl  0x8(%ebp)
40002a75:	e8 47 54 00 00       	call   40007ec1 <list_insert>
40002a7a:	83 c4 10             	add    $0x10,%esp
40002a7d:	ff 4d fc             	decl   -0x4(%ebp)
40002a80:	83 ec 08             	sub    $0x8,%esp
40002a83:	ff 75 fc             	pushl  -0x4(%ebp)
40002a86:	ff 75 ec             	pushl  -0x14(%ebp)
40002a89:	e8 ff 53 00 00       	call   40007e8d <list_get_element_at>
40002a8e:	83 c4 10             	add    $0x10,%esp
40002a91:	89 45 f4             	mov    %eax,-0xc(%ebp)
40002a94:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
40002a98:	75 cf                	jne    40002a69 <resolve_relative_serv_path+0xa9>
40002a9a:	83 ec 0c             	sub    $0xc,%esp
40002a9d:	ff 75 ec             	pushl  -0x14(%ebp)
40002aa0:	e8 a9 51 00 00       	call   40007c4e <list_destroy>
40002aa5:	83 c4 10             	add    $0x10,%esp
40002aa8:	c9                   	leave  
40002aa9:	c3                   	ret    

40002aaa <calc_path_length>:
40002aaa:	55                   	push   %ebp
40002aab:	89 e5                	mov    %esp,%ebp
40002aad:	83 ec 18             	sub    $0x18,%esp
40002ab0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40002ab7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40002abe:	eb 4a                	jmp    40002b0a <calc_path_length+0x60>
40002ac0:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002ac3:	83 c0 08             	add    $0x8,%eax
40002ac6:	83 ec 0c             	sub    $0xc,%esp
40002ac9:	50                   	push   %eax
40002aca:	e8 a5 67 00 00       	call   40009274 <strlen>
40002acf:	83 c4 10             	add    $0x10,%esp
40002ad2:	01 45 f4             	add    %eax,-0xc(%ebp)
40002ad5:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002ad8:	8b 40 04             	mov    0x4(%eax),%eax
40002adb:	89 45 ec             	mov    %eax,-0x14(%ebp)
40002ade:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
40002ae2:	74 0e                	je     40002af2 <calc_path_length+0x48>
40002ae4:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
40002ae8:	72 20                	jb     40002b0a <calc_path_length+0x60>
40002aea:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
40002aee:	77 1a                	ja     40002b0a <calc_path_length+0x60>
40002af0:	eb 15                	jmp    40002b07 <calc_path_length+0x5d>
40002af2:	83 ec 0c             	sub    $0xc,%esp
40002af5:	68 75 98 00 40       	push   $0x40009875
40002afa:	e8 75 67 00 00       	call   40009274 <strlen>
40002aff:	83 c4 10             	add    $0x10,%esp
40002b02:	01 45 f4             	add    %eax,-0xc(%ebp)
40002b05:	eb 03                	jmp    40002b0a <calc_path_length+0x60>
40002b07:	ff 45 f4             	incl   -0xc(%ebp)
40002b0a:	8b 45 f8             	mov    -0x8(%ebp),%eax
40002b0d:	ff 45 f8             	incl   -0x8(%ebp)
40002b10:	83 ec 08             	sub    $0x8,%esp
40002b13:	50                   	push   %eax
40002b14:	ff 75 08             	pushl  0x8(%ebp)
40002b17:	e8 71 53 00 00       	call   40007e8d <list_get_element_at>
40002b1c:	83 c4 10             	add    $0x10,%esp
40002b1f:	89 45 fc             	mov    %eax,-0x4(%ebp)
40002b22:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40002b26:	75 98                	jne    40002ac0 <calc_path_length+0x16>
40002b28:	8b 45 f4             	mov    -0xc(%ebp),%eax
40002b2b:	c9                   	leave  
40002b2c:	c3                   	ret    

40002b2d <create_path_string>:
40002b2d:	55                   	push   %ebp
40002b2e:	89 e5                	mov    %esp,%ebp
40002b30:	83 ec 18             	sub    $0x18,%esp
40002b33:	83 ec 0c             	sub    $0xc,%esp
40002b36:	ff 75 08             	pushl  0x8(%ebp)
40002b39:	e8 62 51 00 00       	call   40007ca0 <list_size>
40002b3e:	83 c4 10             	add    $0x10,%esp
40002b41:	89 45 f8             	mov    %eax,-0x8(%ebp)
40002b44:	e9 83 00 00 00       	jmp    40002bcc <create_path_string+0x9f>
40002b49:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002b4c:	83 c0 08             	add    $0x8,%eax
40002b4f:	83 ec 08             	sub    $0x8,%esp
40002b52:	50                   	push   %eax
40002b53:	ff 75 0c             	pushl  0xc(%ebp)
40002b56:	e8 ed 66 00 00       	call   40009248 <strcpy>
40002b5b:	83 c4 10             	add    $0x10,%esp
40002b5e:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002b61:	83 c0 08             	add    $0x8,%eax
40002b64:	83 ec 0c             	sub    $0xc,%esp
40002b67:	50                   	push   %eax
40002b68:	e8 07 67 00 00       	call   40009274 <strlen>
40002b6d:	83 c4 10             	add    $0x10,%esp
40002b70:	01 45 0c             	add    %eax,0xc(%ebp)
40002b73:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002b76:	8b 40 04             	mov    0x4(%eax),%eax
40002b79:	89 45 ec             	mov    %eax,-0x14(%ebp)
40002b7c:	83 7d ec 02          	cmpl   $0x2,-0x14(%ebp)
40002b80:	74 22                	je     40002ba4 <create_path_string+0x77>
40002b82:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
40002b86:	74 27                	je     40002baf <create_path_string+0x82>
40002b88:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
40002b8c:	74 02                	je     40002b90 <create_path_string+0x63>
40002b8e:	eb 28                	jmp    40002bb8 <create_path_string+0x8b>
40002b90:	8b 45 0c             	mov    0xc(%ebp),%eax
40002b93:	c6 00 3a             	movb   $0x3a,(%eax)
40002b96:	ff 45 0c             	incl   0xc(%ebp)
40002b99:	8b 45 0c             	mov    0xc(%ebp),%eax
40002b9c:	c6 00 2f             	movb   $0x2f,(%eax)
40002b9f:	ff 45 0c             	incl   0xc(%ebp)
40002ba2:	eb 14                	jmp    40002bb8 <create_path_string+0x8b>
40002ba4:	8b 45 0c             	mov    0xc(%ebp),%eax
40002ba7:	c6 00 2f             	movb   $0x2f,(%eax)
40002baa:	ff 45 0c             	incl   0xc(%ebp)
40002bad:	eb 09                	jmp    40002bb8 <create_path_string+0x8b>
40002baf:	8b 45 0c             	mov    0xc(%ebp),%eax
40002bb2:	c6 00 7c             	movb   $0x7c,(%eax)
40002bb5:	ff 45 0c             	incl   0xc(%ebp)
40002bb8:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
40002bbc:	75 0e                	jne    40002bcc <create_path_string+0x9f>
40002bbe:	83 ec 0c             	sub    $0xc,%esp
40002bc1:	ff 75 fc             	pushl  -0x4(%ebp)
40002bc4:	e8 e6 5d 00 00       	call   400089af <free>
40002bc9:	83 c4 10             	add    $0x10,%esp
40002bcc:	ff 4d f8             	decl   -0x8(%ebp)
40002bcf:	83 ec 08             	sub    $0x8,%esp
40002bd2:	ff 75 f8             	pushl  -0x8(%ebp)
40002bd5:	ff 75 08             	pushl  0x8(%ebp)
40002bd8:	e8 b0 52 00 00       	call   40007e8d <list_get_element_at>
40002bdd:	83 c4 10             	add    $0x10,%esp
40002be0:	89 45 fc             	mov    %eax,-0x4(%ebp)
40002be3:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40002be7:	0f 85 5c ff ff ff    	jne    40002b49 <create_path_string+0x1c>
40002bed:	8b 45 0c             	mov    0xc(%ebp),%eax
40002bf0:	c6 00 00             	movb   $0x0,(%eax)
40002bf3:	c9                   	leave  
40002bf4:	c3                   	ret    

40002bf5 <io_split_filename>:
40002bf5:	55                   	push   %ebp
40002bf6:	89 e5                	mov    %esp,%ebp
40002bf8:	83 ec 18             	sub    $0x18,%esp
40002bfb:	e8 20 50 00 00       	call   40007c20 <list_create>
40002c00:	89 45 f4             	mov    %eax,-0xc(%ebp)
40002c03:	83 ec 04             	sub    $0x4,%esp
40002c06:	6a 00                	push   $0x0
40002c08:	ff 75 f4             	pushl  -0xc(%ebp)
40002c0b:	ff 75 08             	pushl  0x8(%ebp)
40002c0e:	e8 59 f9 ff ff       	call   4000256c <get_path_elements>
40002c13:	83 c4 10             	add    $0x10,%esp
40002c16:	83 ec 08             	sub    $0x8,%esp
40002c19:	6a 00                	push   $0x0
40002c1b:	ff 75 f4             	pushl  -0xc(%ebp)
40002c1e:	e8 6a 52 00 00       	call   40007e8d <list_get_element_at>
40002c23:	83 c4 10             	add    $0x10,%esp
40002c26:	89 45 f0             	mov    %eax,-0x10(%ebp)
40002c29:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
40002c2d:	0f 84 91 00 00 00    	je     40002cc4 <io_split_filename+0xcf>
40002c33:	8b 45 f0             	mov    -0x10(%ebp),%eax
40002c36:	83 c0 08             	add    $0x8,%eax
40002c39:	83 ec 08             	sub    $0x8,%esp
40002c3c:	68 ff 00 00 00       	push   $0xff
40002c41:	50                   	push   %eax
40002c42:	e8 a5 4d 00 00       	call   400079ec <strnlen>
40002c47:	83 c4 10             	add    $0x10,%esp
40002c4a:	89 45 fc             	mov    %eax,-0x4(%ebp)
40002c4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002c50:	40                   	inc    %eax
40002c51:	83 ec 0c             	sub    $0xc,%esp
40002c54:	50                   	push   %eax
40002c55:	e8 7e 56 00 00       	call   400082d8 <malloc>
40002c5a:	83 c4 10             	add    $0x10,%esp
40002c5d:	89 45 f8             	mov    %eax,-0x8(%ebp)
40002c60:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40002c64:	74 31                	je     40002c97 <io_split_filename+0xa2>
40002c66:	8b 45 f0             	mov    -0x10(%ebp),%eax
40002c69:	83 c0 08             	add    $0x8,%eax
40002c6c:	83 ec 04             	sub    $0x4,%esp
40002c6f:	ff 75 fc             	pushl  -0x4(%ebp)
40002c72:	50                   	push   %eax
40002c73:	ff 75 f8             	pushl  -0x8(%ebp)
40002c76:	e8 8d 66 00 00       	call   40009308 <strncpy>
40002c7b:	83 c4 10             	add    $0x10,%esp
40002c7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
40002c81:	03 45 f8             	add    -0x8(%ebp),%eax
40002c84:	c6 00 00             	movb   $0x0,(%eax)
40002c87:	eb 0e                	jmp    40002c97 <io_split_filename+0xa2>
40002c89:	83 ec 0c             	sub    $0xc,%esp
40002c8c:	ff 75 f0             	pushl  -0x10(%ebp)
40002c8f:	e8 1b 5d 00 00       	call   400089af <free>
40002c94:	83 c4 10             	add    $0x10,%esp
40002c97:	83 ec 0c             	sub    $0xc,%esp
40002c9a:	ff 75 f4             	pushl  -0xc(%ebp)
40002c9d:	e8 99 50 00 00       	call   40007d3b <list_pop>
40002ca2:	83 c4 10             	add    $0x10,%esp
40002ca5:	89 45 f0             	mov    %eax,-0x10(%ebp)
40002ca8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
40002cac:	75 db                	jne    40002c89 <io_split_filename+0x94>
40002cae:	83 ec 0c             	sub    $0xc,%esp
40002cb1:	ff 75 f4             	pushl  -0xc(%ebp)
40002cb4:	e8 95 4f 00 00       	call   40007c4e <list_destroy>
40002cb9:	83 c4 10             	add    $0x10,%esp
40002cbc:	8b 45 f8             	mov    -0x8(%ebp),%eax
40002cbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
40002cc2:	eb 15                	jmp    40002cd9 <io_split_filename+0xe4>
40002cc4:	83 ec 0c             	sub    $0xc,%esp
40002cc7:	ff 75 f4             	pushl  -0xc(%ebp)
40002cca:	e8 7f 4f 00 00       	call   40007c4e <list_destroy>
40002ccf:	83 c4 10             	add    $0x10,%esp
40002cd2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40002cd9:	8b 45 ec             	mov    -0x14(%ebp),%eax
40002cdc:	c9                   	leave  
40002cdd:	c3                   	ret    

40002cde <io_split_dirname>:
40002cde:	55                   	push   %ebp
40002cdf:	89 e5                	mov    %esp,%ebp
40002ce1:	53                   	push   %ebx
40002ce2:	83 ec 14             	sub    $0x14,%esp
40002ce5:	89 e0                	mov    %esp,%eax
40002ce7:	89 c3                	mov    %eax,%ebx
40002ce9:	83 ec 0c             	sub    $0xc,%esp
40002cec:	ff 75 08             	pushl  0x8(%ebp)
40002cef:	e8 80 65 00 00       	call   40009274 <strlen>
40002cf4:	83 c4 10             	add    $0x10,%esp
40002cf7:	89 45 f8             	mov    %eax,-0x8(%ebp)
40002cfa:	8b 45 f8             	mov    -0x8(%ebp),%eax
40002cfd:	83 c0 04             	add    $0x4,%eax
40002d00:	83 c0 0f             	add    $0xf,%eax
40002d03:	83 c0 0f             	add    $0xf,%eax
40002d06:	c1 e8 04             	shr    $0x4,%eax
40002d09:	c1 e0 04             	shl    $0x4,%eax
40002d0c:	29 c4                	sub    %eax,%esp
40002d0e:	89 65 e8             	mov    %esp,-0x18(%ebp)
40002d11:	8b 45 e8             	mov    -0x18(%ebp),%eax
40002d14:	83 c0 0f             	add    $0xf,%eax
40002d17:	c1 e8 04             	shr    $0x4,%eax
40002d1a:	c1 e0 04             	shl    $0x4,%eax
40002d1d:	89 45 e8             	mov    %eax,-0x18(%ebp)
40002d20:	8b 45 e8             	mov    -0x18(%ebp),%eax
40002d23:	89 45 f4             	mov    %eax,-0xc(%ebp)
40002d26:	8b 45 f4             	mov    -0xc(%ebp),%eax
40002d29:	83 ec 04             	sub    $0x4,%esp
40002d2c:	ff 75 f8             	pushl  -0x8(%ebp)
40002d2f:	ff 75 08             	pushl  0x8(%ebp)
40002d32:	50                   	push   %eax
40002d33:	e8 30 62 00 00       	call   40008f68 <memcpy>
40002d38:	83 c4 10             	add    $0x10,%esp
40002d3b:	8b 55 f4             	mov    -0xc(%ebp),%edx
40002d3e:	8b 45 f8             	mov    -0x8(%ebp),%eax
40002d41:	8d 04 02             	lea    (%edx,%eax,1),%eax
40002d44:	83 ec 04             	sub    $0x4,%esp
40002d47:	6a 04                	push   $0x4
40002d49:	68 78 98 00 40       	push   $0x40009878
40002d4e:	50                   	push   %eax
40002d4f:	e8 14 62 00 00       	call   40008f68 <memcpy>
40002d54:	83 c4 10             	add    $0x10,%esp
40002d57:	8b 45 f4             	mov    -0xc(%ebp),%eax
40002d5a:	83 ec 0c             	sub    $0xc,%esp
40002d5d:	50                   	push   %eax
40002d5e:	e8 ef fa ff ff       	call   40002852 <io_get_absolute_path>
40002d63:	83 c4 10             	add    $0x10,%esp
40002d66:	89 dc                	mov    %ebx,%esp
40002d68:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40002d6b:	c9                   	leave  
40002d6c:	c3                   	ret    
40002d6d:	90                   	nop    
40002d6e:	90                   	nop    
40002d6f:	90                   	nop    

40002d70 <mem_dma_allocate>:
/*
 * Copyright (c) 2007 Kevin Wolf
 *
 * This program is free software. It comes without any warranty, to
 * the extent permitted by applicable law. You can redistribute it 
40002d70:	55                   	push   %ebp
40002d71:	89 e5                	mov    %esp,%ebp
40002d73:	53                   	push   %ebx
40002d74:	83 ec 10             	sub    $0x10,%esp
40002d77:	8b 5d 08             	mov    0x8(%ebp),%ebx
 * and/or modify it under the terms of the Do What The Fuck You Want 
 * To Public License, Version 2, as published by Sam Hocevar. See
 * http://sam.zoy.org/projects/COPYING.WTFPL for more details.
40002d7a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40002d7d:	8b 55 10             	mov    0x10(%ebp),%edx
40002d80:	8d 45 f4             	lea    -0xc(%ebp),%eax
40002d83:	83 c0 04             	add    $0x4,%eax
40002d86:	50                   	push   %eax
40002d87:	52                   	push   %edx
40002d88:	51                   	push   %ecx
40002d89:	b8 01 00 00 00       	mov    $0x1,%eax
40002d8e:	cd 30                	int    $0x30
40002d90:	83 c4 0c             	add    $0xc,%esp
40002d93:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define _CDI_IO_H_

#include <stdint.h>

static inline uint16_t cdi_inw(uint16_t _port)
{
40002d96:	8b 45 f4             	mov    -0xc(%ebp),%eax
40002d99:	8b 55 f8             	mov    -0x8(%ebp),%edx
40002d9c:	89 03                	mov    %eax,(%ebx)
40002d9e:	89 53 04             	mov    %edx,0x4(%ebx)
	uint16_t result;
40002da1:	89 d8                	mov    %ebx,%eax
40002da3:	83 c4 10             	add    $0x10,%esp
40002da6:	5b                   	pop    %ebx
40002da7:	c9                   	leave  
40002da8:	c2 04 00             	ret    $0x4

40002dab <mem_allocate>:
	__asm__ ("inw %1, %0" : "=a" (result) : "Nd" (_port));
	return result;
}
40002dab:	55                   	push   %ebp
40002dac:	89 e5                	mov    %esp,%ebp
40002dae:	83 ec 10             	sub    $0x10,%esp

40002db1:	8d 45 f8             	lea    -0x8(%ebp),%eax
40002db4:	ff 75 0c             	pushl  0xc(%ebp)
40002db7:	ff 75 08             	pushl  0x8(%ebp)
40002dba:	50                   	push   %eax
40002dbb:	e8 b0 ff ff ff       	call   40002d70 <mem_dma_allocate>
40002dc0:	83 c4 08             	add    $0x8,%esp
static inline uint8_t cdi_inb(uint16_t _port)
40002dc3:	8b 45 f8             	mov    -0x8(%ebp),%eax
{
40002dc6:	c9                   	leave  
40002dc7:	c3                   	ret    

40002dc8 <mem_allocate_physical>:
	uint8_t result;
	__asm__ ("inb %1, %0" : "=a" (result) : "Nd" (_port));
	return result;
40002dc8:	55                   	push   %ebp
40002dc9:	89 e5                	mov    %esp,%ebp
40002dcb:	83 ec 10             	sub    $0x10,%esp
}

static inline uint32_t cdi_inl(uint16_t _port)
40002dce:	8b 4d 08             	mov    0x8(%ebp),%ecx
40002dd1:	8b 55 0c             	mov    0xc(%ebp),%edx
40002dd4:	8b 45 10             	mov    0x10(%ebp),%eax
40002dd7:	50                   	push   %eax
40002dd8:	52                   	push   %edx
40002dd9:	51                   	push   %ecx
40002dda:	b8 3d 00 00 00       	mov    $0x3d,%eax
40002ddf:	cd 30                	int    $0x30
40002de1:	83 c4 0c             	add    $0xc,%esp
40002de4:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return result;
}



static inline void cdi_outw(uint16_t _port, uint16_t _data)
40002de7:	8b 45 f8             	mov    -0x8(%ebp),%eax
{
40002dea:	c9                   	leave  
40002deb:	c3                   	ret    

40002dec <mem_free>:
	__asm__ ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

40002dec:	55                   	push   %ebp
40002ded:	89 e5                	mov    %esp,%ebp
40002def:	83 ec 10             	sub    $0x10,%esp
static inline void cdi_outb(uint16_t _port, uint8_t _data)
{
40002df2:	8b 55 08             	mov    0x8(%ebp),%edx
40002df5:	8b 45 0c             	mov    0xc(%ebp),%eax
40002df8:	50                   	push   %eax
40002df9:	52                   	push   %edx
40002dfa:	b8 02 00 00 00       	mov    $0x2,%eax
40002dff:	cd 30                	int    $0x30
40002e01:	83 c4 08             	add    $0x8,%esp
40002e04:	89 45 fc             	mov    %eax,-0x4(%ebp)

static inline void cdi_outl(uint16_t _port, uint32_t _data)
{
	__asm__ ("outl %0, %1" : : "a"(_data), "Nd" (_port));
}

40002e07:	8b 45 fc             	mov    -0x4(%ebp),%eax
#endif
40002e0a:	c9                   	leave  
40002e0b:	c3                   	ret    

40002e0c <mem_free_physical>:

40002e0c:	55                   	push   %ebp
40002e0d:	89 e5                	mov    %esp,%ebp
40002e0f:	8b 55 08             	mov    0x8(%ebp),%edx
40002e12:	8b 45 0c             	mov    0xc(%ebp),%eax
40002e15:	50                   	push   %eax
40002e16:	52                   	push   %edx
40002e17:	b8 3e 00 00 00       	mov    $0x3e,%eax
40002e1c:	cd 30                	int    $0x30
40002e1e:	83 c4 08             	add    $0x8,%esp
40002e21:	c9                   	leave  
40002e22:	c3                   	ret    
40002e23:	90                   	nop    

40002e24 <init_messaging>:
    struct ata_request request = {
        .dev = dev,

        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,
40002e24:	55                   	push   %ebp
40002e25:	89 e5                	mov    %esp,%ebp
40002e27:	83 ec 18             	sub    $0x18,%esp

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
40002e2a:	e8 01 ef ff ff       	call   40001d30 <get_pid>
40002e2f:	a3 c4 a4 00 40       	mov    %eax,0x4000a4c4
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
40002e34:	83 ec 0c             	sub    $0xc,%esp
40002e37:	68 c0 31 00 40       	push   $0x400031c0
40002e3c:	e8 3f 04 00 00       	call   40003280 <set_rpc_handler>
40002e41:	83 c4 10             	add    $0x10,%esp
        .block_size = ATA_SECTOR_SIZE,
40002e44:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40002e4b:	eb 2c                	jmp    40002e79 <init_messaging+0x55>
        .buffer = buffer,
40002e4d:	8b 55 fc             	mov    -0x4(%ebp),%edx
40002e50:	89 d0                	mov    %edx,%eax
40002e52:	d1 e0                	shl    %eax
40002e54:	01 d0                	add    %edx,%eax
40002e56:	c1 e0 02             	shl    $0x2,%eax
40002e59:	c6 80 60 a6 00 40 00 	movb   $0x0,0x4000a660(%eax)

40002e60:	8b 55 fc             	mov    -0x4(%ebp),%edx
40002e63:	89 d0                	mov    %edx,%eax
40002e65:	d1 e0                	shl    %eax
40002e67:	01 d0                	add    %edx,%eax
40002e69:	c1 e0 02             	shl    $0x2,%eax
40002e6c:	c7 80 68 a6 00 40 00 	movl   $0x0,0x4000a668(%eax)
40002e73:	00 00 00 

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
40002e76:	ff 45 fc             	incl   -0x4(%ebp)
40002e79:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%ebp)
40002e7d:	76 ce                	jbe    40002e4d <init_messaging+0x29>
        .buffer = buffer,

        .error = 0
    };
40002e7f:	c9                   	leave  
40002e80:	c3                   	ret    

40002e81 <register_message_handler>:
    
    // Request starten
    if (!ata_request(&request)) {
40002e81:	55                   	push   %ebp
40002e82:	89 e5                	mov    %esp,%ebp
40002e84:	83 ec 18             	sub    $0x18,%esp
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
    }
        
40002e87:	83 ec 04             	sub    $0x4,%esp
40002e8a:	6a 08                	push   $0x8
40002e8c:	6a 00                	push   $0x0
40002e8e:	8d 45 f0             	lea    -0x10(%ebp),%eax
40002e91:	50                   	push   %eax
40002e92:	e8 7d 62 00 00       	call   40009114 <memset>
40002e97:	83 c4 10             	add    $0x10,%esp
    // Ein ATA-Geraet
40002e9a:	83 ec 04             	sub    $0x4,%esp
40002e9d:	6a 08                	push   $0x8
40002e9f:	ff 75 08             	pushl  0x8(%ebp)
40002ea2:	8d 45 f0             	lea    -0x10(%ebp),%eax
40002ea5:	50                   	push   %eax
40002ea6:	e8 5d 64 00 00       	call   40009308 <strncpy>
40002eab:	83 c4 10             	add    $0x10,%esp
    dev->atapi = 0;

    // TODO: Informationen verarbeiten

    return 1;
40002eae:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
}
40002eb5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40002ebc:	eb 51                	jmp    40002f0f <register_message_handler+0x8e>

40002ebe:	8b 55 f8             	mov    -0x8(%ebp),%edx
40002ec1:	89 d0                	mov    %edx,%eax
40002ec3:	d1 e0                	shl    %eax
40002ec5:	01 d0                	add    %edx,%eax
40002ec7:	c1 e0 02             	shl    $0x2,%eax
40002eca:	8a 80 60 a6 00 40    	mov    0x4000a660(%eax),%al
40002ed0:	84 c0                	test   %al,%al
40002ed2:	75 08                	jne    40002edc <register_message_handler+0x5b>
/**
40002ed4:	8b 45 f8             	mov    -0x8(%ebp),%eax
40002ed7:	89 45 fc             	mov    %eax,-0x4(%ebp)
40002eda:	eb 30                	jmp    40002f0c <register_message_handler+0x8b>
 * Sektoren von einem ATA-Geraet lesen
40002edc:	8b 55 f8             	mov    -0x8(%ebp),%edx
40002edf:	89 d0                	mov    %edx,%eax
40002ee1:	d1 e0                	shl    %eax
40002ee3:	01 d0                	add    %edx,%eax
40002ee5:	c1 e0 02             	shl    $0x2,%eax
40002ee8:	05 60 a6 00 40       	add    $0x4000a660,%eax
40002eed:	83 ec 04             	sub    $0x4,%esp
40002ef0:	6a 08                	push   $0x8
40002ef2:	50                   	push   %eax
40002ef3:	8d 45 f0             	lea    -0x10(%ebp),%eax
40002ef6:	50                   	push   %eax
40002ef7:	e8 a0 63 00 00       	call   4000929c <strncmp>
40002efc:	83 c4 10             	add    $0x10,%esp
40002eff:	85 c0                	test   %eax,%eax
40002f01:	75 09                	jne    40002f0c <register_message_handler+0x8b>
 *
40002f03:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40002f0a:	eb 5c                	jmp    40002f68 <register_message_handler+0xe7>
    dev->atapi = 0;

    // TODO: Informationen verarbeiten

    return 1;
}
40002f0c:	ff 45 f8             	incl   -0x8(%ebp)
40002f0f:	83 7d f8 1f          	cmpl   $0x1f,-0x8(%ebp)
40002f13:	76 a9                	jbe    40002ebe <register_message_handler+0x3d>
 * Sektoren von einem ATA-Geraet lesen
 *
 * @param start LBA des Startsektors
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
40002f15:	83 7d fc 20          	cmpl   $0x20,-0x4(%ebp)
40002f19:	75 09                	jne    40002f24 <register_message_handler+0xa3>
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
40002f1b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40002f22:	eb 44                	jmp    40002f68 <register_message_handler+0xe7>
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
40002f24:	8b 55 fc             	mov    -0x4(%ebp),%edx
40002f27:	89 d0                	mov    %edx,%eax
40002f29:	d1 e0                	shl    %eax
40002f2b:	01 d0                	add    %edx,%eax
40002f2d:	c1 e0 02             	shl    $0x2,%eax
40002f30:	8d 90 60 a6 00 40    	lea    0x4000a660(%eax),%edx
40002f36:	83 ec 04             	sub    $0x4,%esp
40002f39:	6a 08                	push   $0x8
40002f3b:	8d 45 f0             	lea    -0x10(%ebp),%eax
40002f3e:	50                   	push   %eax
40002f3f:	52                   	push   %edx
40002f40:	e8 c3 63 00 00       	call   40009308 <strncpy>
40002f45:	83 c4 10             	add    $0x10,%esp
{
40002f48:	8b 55 fc             	mov    -0x4(%ebp),%edx
40002f4b:	89 d0                	mov    %edx,%eax
40002f4d:	d1 e0                	shl    %eax
40002f4f:	01 d0                	add    %edx,%eax
40002f51:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
40002f58:	8b 45 0c             	mov    0xc(%ebp),%eax
40002f5b:	89 82 68 a6 00 40    	mov    %eax,0x4000a668(%edx)
    int result = 1;
    struct ata_request request;
40002f61:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
40002f68:	8b 45 ec             	mov    -0x14(%ebp),%eax
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
40002f6b:	c9                   	leave  
40002f6c:	c3                   	ret    

40002f6d <register_intr_handler>:
    // muss unter Umstaenden mehrmals gelesen werden.
    uint16_t current_count;
    void* current_buffer = buffer;
40002f6d:	55                   	push   %ebp
40002f6e:	89 e5                	mov    %esp,%ebp
40002f70:	83 ec 08             	sub    $0x8,%esp
40002f73:	8b 45 08             	mov    0x8(%ebp),%eax
40002f76:	88 45 fc             	mov    %al,-0x4(%ebp)
    uint64_t lba = start;
40002f79:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
40002f7d:	8b 45 0c             	mov    0xc(%ebp),%eax
40002f80:	89 04 95 c0 a0 00 40 	mov    %eax,0x4000a0c0(,%edx,4)

40002f87:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
40002f8b:	83 ec 0c             	sub    $0xc,%esp
40002f8e:	50                   	push   %eax
40002f8f:	e8 a4 3b 00 00       	call   40006b38 <add_intr_handler>
40002f94:	83 c4 10             	add    $0x10,%esp
    // Anzahl der Sektoren die noch uebrig sind
40002f97:	c9                   	leave  
40002f98:	c3                   	ret    

40002f99 <librpc_c_rpc_handler>:
    size_t count_left = count;

    // Solange wie noch Sektoren uebrig sind, wird gelesen
40002f99:	55                   	push   %ebp
40002f9a:	89 e5                	mov    %esp,%ebp
40002f9c:	83 ec 18             	sub    $0x18,%esp
    while (count_left > 0) {
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
        if (count_left > 256) {
            current_count = 256;
        } else {
            current_count = count_left;
40002f9f:	8b 45 10             	mov    0x10(%ebp),%eax
40002fa2:	8b 00                	mov    (%eax),%eax
40002fa4:	89 45 f8             	mov    %eax,-0x8(%ebp)
        }
40002fa7:	8b 45 10             	mov    0x10(%ebp),%eax
40002faa:	83 c0 04             	add    $0x4,%eax
40002fad:	8b 00                	mov    (%eax),%eax
40002faf:	89 45 fc             	mov    %eax,-0x4(%ebp)
        
        // Request vorbereiten
        request.dev = dev;
        // TODO: DMA, UltraDMA...
40002fb2:	81 7d f8 ff 00 00 00 	cmpl   $0xff,-0x8(%ebp)
40002fb9:	77 31                	ja     40002fec <librpc_c_rpc_handler+0x53>
        request.protocol = PIO;
        request.flags.direction = READ;
40002fbb:	8b 45 f8             	mov    -0x8(%ebp),%eax
40002fbe:	8b 04 85 c0 a0 00 40 	mov    0x4000a0c0(,%eax,4),%eax
40002fc5:	85 c0                	test   %eax,%eax
40002fc7:	0f 84 1e 01 00 00    	je     400030eb <librpc_c_rpc_handler+0x152>
40002fcd:	a1 c4 a4 00 40       	mov    0x4000a4c4,%eax
40002fd2:	39 45 08             	cmp    %eax,0x8(%ebp)
40002fd5:	0f 85 10 01 00 00    	jne    400030eb <librpc_c_rpc_handler+0x152>
        // FIXME
40002fdb:	8b 45 f8             	mov    -0x8(%ebp),%eax
40002fde:	8b 04 85 c0 a0 00 40 	mov    0x4000a0c0(,%eax,4),%eax
40002fe5:	ff d0                	call   *%eax
40002fe7:	e9 ff 00 00 00       	jmp    400030eb <librpc_c_rpc_handler+0x152>
        request.flags.poll = 1;
        request.flags.ata = 0;
40002fec:	81 7d f8 ff 00 00 00 	cmpl   $0xff,-0x8(%ebp)
40002ff3:	76 22                	jbe    40003017 <librpc_c_rpc_handler+0x7e>
40002ff5:	81 7d f8 ff 01 00 00 	cmpl   $0x1ff,-0x8(%ebp)
40002ffc:	77 19                	ja     40003017 <librpc_c_rpc_handler+0x7e>
        request.flags.lba = 1;

        request.registers.ata.command = READ_SECTORS;
40002ffe:	8b 45 f8             	mov    -0x8(%ebp),%eax
40003001:	2d 00 01 00 00       	sub    $0x100,%eax
40003006:	83 ec 0c             	sub    $0xc,%esp
40003009:	50                   	push   %eax
4000300a:	e8 3f 10 00 00       	call   4000404e <raise>
4000300f:	83 c4 10             	add    $0x10,%esp
        // TODO: DMA, UltraDMA...
        request.protocol = PIO;
        request.flags.direction = READ;
        // FIXME
        request.flags.poll = 1;
        request.flags.ata = 0;
40003012:	e9 d4 00 00 00       	jmp    400030eb <librpc_c_rpc_handler+0x152>
        request.flags.lba = 1;

        request.registers.ata.command = READ_SECTORS;
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
40003017:	81 7d f8 00 02 00 00 	cmpl   $0x200,-0x8(%ebp)
4000301e:	0f 85 87 00 00 00    	jne    400030ab <librpc_c_rpc_handler+0x112>
        request.registers.ata.count = (uint8_t) current_count;
        request.registers.ata.lba = lba;

        request.block_count = current_count;
        request.block_size = ATA_SECTOR_SIZE;
        request.blocks_done = 0;
40003024:	8b 45 10             	mov    0x10(%ebp),%eax
40003027:	83 c0 08             	add    $0x8,%eax
4000302a:	83 ec 08             	sub    $0x8,%esp
4000302d:	6a 08                	push   $0x8
4000302f:	50                   	push   %eax
40003030:	e8 b7 49 00 00       	call   400079ec <strnlen>
40003035:	83 c4 10             	add    $0x10,%esp
40003038:	85 c0                	test   %eax,%eax
4000303a:	0f 84 ab 00 00 00    	je     400030eb <librpc_c_rpc_handler+0x152>
        request.buffer = current_buffer;

        request.error = NO_ERROR;
        
40003040:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40003047:	eb 5a                	jmp    400030a3 <librpc_c_rpc_handler+0x10a>
        // TODO: LBA48
40003049:	8b 55 f4             	mov    -0xc(%ebp),%edx
4000304c:	89 d0                	mov    %edx,%eax
4000304e:	d1 e0                	shl    %eax
40003050:	01 d0                	add    %edx,%eax
40003052:	c1 e0 02             	shl    $0x2,%eax
40003055:	05 60 a6 00 40       	add    $0x4000a660,%eax
4000305a:	8b 55 10             	mov    0x10(%ebp),%edx
4000305d:	83 c2 08             	add    $0x8,%edx
40003060:	83 ec 04             	sub    $0x4,%esp
40003063:	6a 08                	push   $0x8
40003065:	50                   	push   %eax
40003066:	52                   	push   %edx
40003067:	e8 30 62 00 00       	call   4000929c <strncmp>
4000306c:	83 c4 10             	add    $0x10,%esp
4000306f:	85 c0                	test   %eax,%eax
40003071:	75 2d                	jne    400030a0 <librpc_c_rpc_handler+0x107>
        // TODO: CHS
40003073:	8b 55 f4             	mov    -0xc(%ebp),%edx
40003076:	89 d0                	mov    %edx,%eax
40003078:	d1 e0                	shl    %eax
4000307a:	01 d0                	add    %edx,%eax
4000307c:	c1 e0 02             	shl    $0x2,%eax
4000307f:	8b 88 68 a6 00 40    	mov    0x4000a668(%eax),%ecx
40003085:	8b 45 10             	mov    0x10(%ebp),%eax
40003088:	83 c0 10             	add    $0x10,%eax
4000308b:	8b 55 0c             	mov    0xc(%ebp),%edx
4000308e:	83 ea 10             	sub    $0x10,%edx
40003091:	50                   	push   %eax
40003092:	52                   	push   %edx
40003093:	ff 75 fc             	pushl  -0x4(%ebp)
40003096:	ff 75 08             	pushl  0x8(%ebp)
40003099:	ff d1                	call   *%ecx
4000309b:	83 c4 10             	add    $0x10,%esp
        
        // Request ausfuehren
        if (!ata_request(&request)) {
            result = 0;
            break;
        }
4000309e:	eb 4b                	jmp    400030eb <librpc_c_rpc_handler+0x152>
        request.block_size = ATA_SECTOR_SIZE;
        request.blocks_done = 0;
        request.buffer = current_buffer;

        request.error = NO_ERROR;
        
400030a0:	ff 45 f4             	incl   -0xc(%ebp)
400030a3:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
400030a7:	7e a0                	jle    40003049 <librpc_c_rpc_handler+0xb0>
400030a9:	eb 40                	jmp    400030eb <librpc_c_rpc_handler+0x152>
            result = 0;
            break;
        }

        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
        current_buffer += current_count * ATA_SECTOR_SIZE;
400030ab:	81 7d f8 01 02 00 00 	cmpl   $0x201,-0x8(%ebp)
400030b2:	75 20                	jne    400030d4 <librpc_c_rpc_handler+0x13b>
        count_left -= current_count;
        lba += current_count;
400030b4:	a1 c0 a4 00 40       	mov    0x4000a4c0,%eax
400030b9:	8b 55 10             	mov    0x10(%ebp),%edx
400030bc:	83 c2 08             	add    $0x8,%edx
400030bf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
400030c2:	83 e9 08             	sub    $0x8,%ecx
400030c5:	52                   	push   %edx
400030c6:	51                   	push   %ecx
400030c7:	ff 75 fc             	pushl  -0x4(%ebp)
400030ca:	ff 75 08             	pushl  0x8(%ebp)
400030cd:	ff d0                	call   *%eax
400030cf:	83 c4 10             	add    $0x10,%esp
400030d2:	eb 17                	jmp    400030eb <librpc_c_rpc_handler+0x152>
400030d4:	81 7d f8 02 02 00 00 	cmpl   $0x202,-0x8(%ebp)
400030db:	75 0e                	jne    400030eb <librpc_c_rpc_handler+0x152>
400030dd:	83 ec 0c             	sub    $0xc,%esp
400030e0:	ff 75 fc             	pushl  -0x4(%ebp)
400030e3:	e8 b6 06 00 00       	call   4000379e <timer_callback>
400030e8:	83 c4 10             	add    $0x10,%esp
400030eb:	c9                   	leave  
400030ec:	c3                   	ret    
400030ed:	90                   	nop    
400030ee:	90                   	nop    
400030ef:	90                   	nop    

400030f0 <msleep>:
#include <stdio.h>
#include <stdlib.h>

#include "cdi.h"
#include "cdi/storage.h"
#include "cdi/misc.h"
400030f0:	55                   	push   %ebp
400030f1:	89 e5                	mov    %esp,%ebp
400030f3:	53                   	push   %ebx
400030f4:	83 ec 24             	sub    $0x24,%esp
#include "cdi/io.h"
400030f7:	e8 50 3a 00 00       	call   40006b4c <get_tick_count>
400030fc:	89 c1                	mov    %eax,%ecx
400030fe:	89 d3                	mov    %edx,%ebx
40003100:	8b 55 08             	mov    0x8(%ebp),%edx
40003103:	89 d0                	mov    %edx,%eax
40003105:	c1 e0 02             	shl    $0x2,%eax
40003108:	01 d0                	add    %edx,%eax
4000310a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
40003111:	01 d0                	add    %edx,%eax
40003113:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
4000311a:	01 d0                	add    %edx,%eax
4000311c:	c1 e0 03             	shl    $0x3,%eax
4000311f:	ba 00 00 00 00       	mov    $0x0,%edx
40003124:	01 c8                	add    %ecx,%eax
40003126:	11 da                	adc    %ebx,%edx
40003128:	89 45 f0             	mov    %eax,-0x10(%ebp)
4000312b:	89 55 f4             	mov    %edx,-0xc(%ebp)

4000312e:	eb 01                	jmp    40003131 <msleep+0x41>
#include "device.h"

40003130:	90                   	nop    

#include "cdi.h"
#include "cdi/storage.h"
#include "cdi/misc.h"
#include "cdi/io.h"

40003131:	e8 16 3a 00 00       	call   40006b4c <get_tick_count>
40003136:	89 45 e0             	mov    %eax,-0x20(%ebp)
40003139:	89 55 e4             	mov    %edx,-0x1c(%ebp)
4000313c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000313f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
40003142:	72 ec                	jb     40003130 <msleep+0x40>
40003144:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40003147:	3b 45 f4             	cmp    -0xc(%ebp),%eax
4000314a:	77 08                	ja     40003154 <msleep+0x64>
4000314c:	8b 45 e0             	mov    -0x20(%ebp),%eax
4000314f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
40003152:	72 dc                	jb     40003130 <msleep+0x40>
#include "device.h"


/**
40003154:	83 c4 24             	add    $0x24,%esp
40003157:	5b                   	pop    %ebx
40003158:	c9                   	leave  
40003159:	c3                   	ret    
4000315a:	90                   	nop    
4000315b:	90                   	nop    

4000315c <request_ports>:

#include <stdio.h>
#include <stdlib.h>

#include "cdi.h"
#include "cdi/storage.h"
4000315c:	55                   	push   %ebp
4000315d:	89 e5                	mov    %esp,%ebp
4000315f:	83 ec 10             	sub    $0x10,%esp
#include "cdi/misc.h"
#include "cdi/io.h"
40003162:	ff 75 0c             	pushl  0xc(%ebp)
40003165:	ff 75 08             	pushl  0x8(%ebp)
40003168:	b8 09 00 00 00       	mov    $0x9,%eax
4000316d:	cd 30                	int    $0x30
4000316f:	83 c4 08             	add    $0x8,%esp
40003172:	89 45 fc             	mov    %eax,-0x4(%ebp)


/**
 * ATA-Geraet identifizieren
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
40003175:	8b 45 fc             	mov    -0x4(%ebp),%eax
 */
40003178:	c9                   	leave  
40003179:	c3                   	ret    

4000317a <release_ports>:
int ata_drv_identify(struct ata_device* dev)
{
    uint8_t buffer[ATA_SECTOR_SIZE];
4000317a:	55                   	push   %ebp
4000317b:	89 e5                	mov    %esp,%ebp
4000317d:	83 ec 10             	sub    $0x10,%esp

    // Request vorbereiten
40003180:	ff 75 0c             	pushl  0xc(%ebp)
40003183:	ff 75 08             	pushl  0x8(%ebp)
40003186:	b8 0a 00 00 00       	mov    $0xa,%eax
4000318b:	cd 30                	int    $0x30
4000318d:	83 c4 08             	add    $0x8,%esp
40003190:	89 45 fc             	mov    %eax,-0x4(%ebp)

        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
40003193:	8b 45 fc             	mov    -0x4(%ebp),%eax
        .protocol = PIO,
40003196:	c9                   	leave  
40003197:	c3                   	ret    

40003198 <p>:
/*  
 * Copyright (c) 2007 The tyndur Project. All rights reserved.
 *
 * This code is derived from software contributed to the tyndur Project
40003198:	55                   	push   %ebp
40003199:	89 e5                	mov    %esp,%ebp
 * by Antoine Kaufmann.
4000319b:	b8 0b 00 00 00       	mov    $0xb,%eax
400031a0:	cd 30                	int    $0x30
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
400031a2:	c9                   	leave  
400031a3:	c3                   	ret    

400031a4 <v>:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
400031a4:	55                   	push   %ebp
400031a5:	89 e5                	mov    %esp,%ebp
 *    notice, this list of conditions and the following disclaimer in the
400031a7:	b8 0c 00 00 00       	mov    $0xc,%eax
400031ac:	6a 00                	push   $0x0
400031ae:	cd 30                	int    $0x30
400031b0:	83 c4 04             	add    $0x4,%esp
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *     This product includes software developed by the tyndur Project
 *     and its contributors.
 * 4. Neither the name of the tyndur Project nor the names of its
400031b3:	c9                   	leave  
400031b4:	c3                   	ret    
400031b5:	90                   	nop    
400031b6:	90                   	nop    
400031b7:	90                   	nop    
400031b8:	90                   	nop    
400031b9:	90                   	nop    
400031ba:	90                   	nop    
400031bb:	90                   	nop    
400031bc:	90                   	nop    
400031bd:	90                   	nop    
400031be:	90                   	nop    
400031bf:	90                   	nop    

400031c0 <librpc_rpc_handler>:
400031c0:	60                   	pusha  
400031c1:	8b 44 24 20          	mov    0x20(%esp),%eax
400031c5:	8b 4c 24 24          	mov    0x24(%esp),%ecx
400031c9:	8d 54 24 28          	lea    0x28(%esp),%edx
400031cd:	52                   	push   %edx
400031ce:	50                   	push   %eax
400031cf:	51                   	push   %ecx
400031d0:	e8 c4 fd ff ff       	call   40002f99 <librpc_c_rpc_handler>
400031d5:	83 c4 0c             	add    $0xc,%esp
400031d8:	61                   	popa   
400031d9:	b8 38 00 00 00       	mov    $0x38,%eax
400031de:	cd 30                	int    $0x30
400031e0:	f4                   	hlt    
400031e1:	50                   	push   %eax
400031e2:	8b 44 24 04          	mov    0x4(%esp),%eax
400031e6:	83 e0 03             	and    $0x3,%eax
400031e9:	74 0a                	je     400031f5 <librpc_rpc_handler.1>
400031eb:	8b 44 24 04          	mov    0x4(%esp),%eax
400031ef:	83 c8 03             	or     $0x3,%eax
400031f2:	40                   	inc    %eax
400031f3:	eb 04                	jmp    400031f9 <librpc_rpc_handler.2>

400031f5 <librpc_rpc_handler.1>:
400031f5:	8b 44 24 04          	mov    0x4(%esp),%eax

400031f9 <librpc_rpc_handler.2>:
400031f9:	01 c4                	add    %eax,%esp
400031fb:	83 c4 0c             	add    $0xc,%esp
400031fe:	f7 d8                	neg    %eax
40003200:	8b 44 04 f4          	mov    -0xc(%esp,%eax,1),%eax
40003204:	c3                   	ret    
40003205:	90                   	nop    
40003206:	90                   	nop    
40003207:	90                   	nop    

40003208 <rpc>:
/*  
 * Copyright (c) 2007 The tyndur Project. All rights reserved.
 *
 * This code is derived from software contributed to the tyndur Project
 * by Antoine Kaufmann.
40003208:	55                   	push   %ebp
40003209:	89 e5                	mov    %esp,%ebp
4000320b:	83 ec 10             	sub    $0x10,%esp
 *
4000320e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
40003215:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003218:	6a 00                	push   $0x0
4000321a:	ff 75 08             	pushl  0x8(%ebp)
4000321d:	b8 33 00 00 00       	mov    $0x33,%eax
40003222:	cd 30                	int    $0x30
40003224:	83 c4 08             	add    $0x8,%esp
40003227:	89 45 fc             	mov    %eax,-0x4(%ebp)
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
4000322a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
4000322e:	75 e5                	jne    40003215 <rpc+0xd>
 *     This product includes software developed by the tyndur Project
40003230:	c9                   	leave  
40003231:	c3                   	ret    

40003232 <send_message>:
 *     and its contributors.
 * 4. Neither the name of the tyndur Project nor the names of its
 *    contributors may be used to endorse or promote products derived
40003232:	55                   	push   %ebp
40003233:	89 e5                	mov    %esp,%ebp
40003235:	83 ec 14             	sub    $0x14,%esp
 *    from this software without specific prior written permission.
40003238:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 *
4000323f:	8b 45 0c             	mov    0xc(%ebp),%eax
40003242:	89 45 f4             	mov    %eax,-0xc(%ebp)
40003245:	8b 45 10             	mov    0x10(%ebp),%eax
40003248:	89 45 f8             	mov    %eax,-0x8(%ebp)
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
4000324b:	8d 45 f4             	lea    -0xc(%ebp),%eax
4000324e:	89 45 ec             	mov    %eax,-0x14(%ebp)
40003251:	8b 55 fc             	mov    -0x4(%ebp),%edx
40003254:	89 d0                	mov    %edx,%eax
40003256:	ff 75 18             	pushl  0x18(%ebp)
40003259:	ff 75 14             	pushl  0x14(%ebp)
4000325c:	ff 75 ec             	pushl  -0x14(%ebp)
4000325f:	6a 08                	push   $0x8
40003261:	ff 75 08             	pushl  0x8(%ebp)
40003264:	b8 37 00 00 00       	mov    $0x37,%eax
40003269:	cd 30                	int    $0x30
4000326b:	83 c4 14             	add    $0x14,%esp
4000326e:	89 45 ec             	mov    %eax,-0x14(%ebp)
40003271:	8b 45 ec             	mov    -0x14(%ebp),%eax
40003274:	89 45 fc             	mov    %eax,-0x4(%ebp)
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

40003277:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
4000327b:	75 ce                	jne    4000324b <send_message+0x19>
#include <stdio.h>
4000327d:	c9                   	leave  
4000327e:	c3                   	ret    
4000327f:	90                   	nop    

40003280 <set_rpc_handler>:
#include "syscall.h"


/**
40003280:	55                   	push   %ebp
40003281:	89 e5                	mov    %esp,%ebp
 * Prozessnummer des aktuellen Prozesses abfragen.
40003283:	8b 45 08             	mov    0x8(%ebp),%eax
40003286:	50                   	push   %eax
40003287:	b8 32 00 00 00       	mov    $0x32,%eax
4000328c:	cd 30                	int    $0x30
4000328e:	83 c4 04             	add    $0x4,%esp
 *
 * @return Prozessnummer
 */
pid_t get_pid()
{
    pid_t pid;
40003291:	c9                   	leave  
40003292:	c3                   	ret    
40003293:	90                   	nop    

40003294 <init_sync_messages>:
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

40003294:	55                   	push   %ebp
40003295:	89 e5                	mov    %esp,%ebp
40003297:	83 ec 08             	sub    $0x8,%esp
        .error = 0
4000329a:	e8 81 49 00 00       	call   40007c20 <list_create>
4000329f:	a3 c8 a4 00 40       	mov    %eax,0x4000a4c8
    };
400032a4:	c7 05 c0 a4 00 40 b0 	movl   $0x400032b0,0x4000a4c0
400032ab:	32 00 40 
    
400032ae:	c9                   	leave  
400032af:	c3                   	ret    

400032b0 <sync_rpc_response_handler>:
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
    }
        
400032b0:	55                   	push   %ebp
400032b1:	89 e5                	mov    %esp,%ebp
400032b3:	83 ec 18             	sub    $0x18,%esp
    // Ein ATA-Geraet
    dev->atapi = 0;

400032b6:	e8 dd fe ff ff       	call   40003198 <p>
    // TODO: Informationen verarbeiten
400032bb:	a1 c8 a4 00 40       	mov    0x4000a4c8,%eax
400032c0:	85 c0                	test   %eax,%eax
400032c2:	75 05                	jne    400032c9 <sync_rpc_response_handler+0x19>

400032c4:	e8 cb ff ff ff       	call   40003294 <init_sync_messages>
 * Sektoren von einem ATA-Geraet lesen
 *
 * @param start LBA des Startsektors
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
400032c9:	83 ec 0c             	sub    $0xc,%esp
400032cc:	6a 10                	push   $0x10
400032ce:	e8 05 50 00 00       	call   400082d8 <malloc>
400032d3:	83 c4 10             	add    $0x10,%esp
400032d6:	89 45 f8             	mov    %eax,-0x8(%ebp)
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
400032d9:	8b 55 f8             	mov    -0x8(%ebp),%edx
400032dc:	8b 45 08             	mov    0x8(%ebp),%eax
400032df:	89 02                	mov    %eax,(%edx)
 */
400032e1:	8b 55 f8             	mov    -0x8(%ebp),%edx
400032e4:	8b 45 0c             	mov    0xc(%ebp),%eax
400032e7:	89 42 04             	mov    %eax,0x4(%edx)
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
400032ea:	8b 55 f8             	mov    -0x8(%ebp),%edx
400032ed:	8b 45 10             	mov    0x10(%ebp),%eax
400032f0:	89 42 08             	mov    %eax,0x8(%edx)
{
    int result = 1;
400032f3:	83 ec 0c             	sub    $0xc,%esp
400032f6:	ff 75 10             	pushl  0x10(%ebp)
400032f9:	e8 da 4f 00 00       	call   400082d8 <malloc>
400032fe:	83 c4 10             	add    $0x10,%esp
40003301:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct ata_request request;
40003304:	83 ec 04             	sub    $0x4,%esp
40003307:	ff 75 10             	pushl  0x10(%ebp)
4000330a:	ff 75 14             	pushl  0x14(%ebp)
4000330d:	ff 75 fc             	pushl  -0x4(%ebp)
40003310:	e8 53 5c 00 00       	call   40008f68 <memcpy>
40003315:	83 c4 10             	add    $0x10,%esp
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
40003318:	8b 55 f8             	mov    -0x8(%ebp),%edx
4000331b:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000331e:	89 42 0c             	mov    %eax,0xc(%edx)
    // muss unter Umstaenden mehrmals gelesen werden.
40003321:	a1 c8 a4 00 40       	mov    0x4000a4c8,%eax
40003326:	83 ec 08             	sub    $0x8,%esp
40003329:	ff 75 f8             	pushl  -0x8(%ebp)
4000332c:	50                   	push   %eax
4000332d:	e8 9a 49 00 00       	call   40007ccc <list_push>
40003332:	83 c4 10             	add    $0x10,%esp
    uint16_t current_count;
40003335:	e8 6a fe ff ff       	call   400031a4 <v>
    void* current_buffer = buffer;
4000333a:	c9                   	leave  
4000333b:	c3                   	ret    

4000333c <sync_rpc_has_response>:
        if (count_left > 256) {
            current_count = 256;
        } else {
            current_count = count_left;
        }
        
4000333c:	55                   	push   %ebp
4000333d:	89 e5                	mov    %esp,%ebp
4000333f:	83 ec 18             	sub    $0x18,%esp
        // Request vorbereiten
40003342:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
        request.dev = dev;
40003349:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
        // TODO: DMA, UltraDMA...
        request.protocol = PIO;
40003350:	e8 43 fe ff ff       	call   40003198 <p>
        request.flags.direction = READ;
40003355:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
        // FIXME
4000335c:	eb 2c                	jmp    4000338a <sync_rpc_has_response+0x4e>
        request.flags.poll = 1;
        request.flags.ata = 0;
4000335e:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003361:	8b 40 04             	mov    0x4(%eax),%eax
40003364:	3b 45 0c             	cmp    0xc(%ebp),%eax
40003367:	75 1e                	jne    40003387 <sync_rpc_has_response+0x4b>
        request.flags.lba = 1;
40003369:	a1 c8 a4 00 40       	mov    0x4000a4c8,%eax
4000336e:	83 ec 08             	sub    $0x8,%esp
40003371:	ff 75 f8             	pushl  -0x8(%ebp)
40003374:	50                   	push   %eax
40003375:	e8 ff 4b 00 00       	call   40007f79 <list_remove>
4000337a:	83 c4 10             	add    $0x10,%esp

4000337d:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003380:	8b 00                	mov    (%eax),%eax
40003382:	3b 45 08             	cmp    0x8(%ebp),%eax
40003385:	74 20                	je     400033a7 <sync_rpc_has_response+0x6b>
        request.registers.ata.command = READ_SECTORS;
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
40003387:	ff 45 f8             	incl   -0x8(%ebp)
        // Request vorbereiten
        request.dev = dev;
        // TODO: DMA, UltraDMA...
        request.protocol = PIO;
        request.flags.direction = READ;
        // FIXME
4000338a:	a1 c8 a4 00 40       	mov    0x4000a4c8,%eax
4000338f:	83 ec 08             	sub    $0x8,%esp
40003392:	ff 75 f8             	pushl  -0x8(%ebp)
40003395:	50                   	push   %eax
40003396:	e8 f2 4a 00 00       	call   40007e8d <list_get_element_at>
4000339b:	83 c4 10             	add    $0x10,%esp
4000339e:	89 45 fc             	mov    %eax,-0x4(%ebp)
400033a1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
400033a5:	75 b7                	jne    4000335e <sync_rpc_has_response+0x22>
        request.registers.ata.command = READ_SECTORS;
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
        // 0 steht.
        request.registers.ata.count = (uint8_t) current_count;
400033a7:	e8 f8 fd ff ff       	call   400031a4 <v>
        request.registers.ata.lba = lba;

400033ac:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
400033b0:	74 1d                	je     400033cf <sync_rpc_has_response+0x93>
400033b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
400033b5:	8b 40 04             	mov    0x4(%eax),%eax
400033b8:	3b 45 0c             	cmp    0xc(%ebp),%eax
400033bb:	75 12                	jne    400033cf <sync_rpc_has_response+0x93>
400033bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
400033c0:	8b 00                	mov    (%eax),%eax
400033c2:	3b 45 08             	cmp    0x8(%ebp),%eax
400033c5:	75 08                	jne    400033cf <sync_rpc_has_response+0x93>
        request.block_count = current_count;
400033c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
400033ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
400033cd:	eb 07                	jmp    400033d6 <sync_rpc_has_response+0x9a>
        request.block_size = ATA_SECTOR_SIZE;
        request.blocks_done = 0;
400033cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400033d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
        request.buffer = current_buffer;

400033d9:	c9                   	leave  
400033da:	c3                   	ret    

400033db <sync_rpc>:
        }

        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
        current_buffer += current_count * ATA_SECTOR_SIZE;
        count_left -= current_count;
        lba += current_count;
400033db:	55                   	push   %ebp
400033dc:	89 e5                	mov    %esp,%ebp
400033de:	83 ec 18             	sub    $0x18,%esp
400033e1:	89 e0                	mov    %esp,%eax
400033e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
400033e6:	e8 ad fd ff ff       	call   40003198 <p>

    return result;
400033eb:	a1 cc a4 00 40       	mov    0x4000a4cc,%eax
400033f0:	89 45 f8             	mov    %eax,-0x8(%ebp)
400033f3:	40                   	inc    %eax
400033f4:	a3 cc a4 00 40       	mov    %eax,0x4000a4cc
400033f9:	a1 c8 a4 00 40       	mov    0x4000a4c8,%eax
400033fe:	85 c0                	test   %eax,%eax
40003400:	75 05                	jne    40003407 <sync_rpc+0x2c>
40003402:	e8 8d fe ff ff       	call   40003294 <init_sync_messages>
40003407:	8b 45 10             	mov    0x10(%ebp),%eax
4000340a:	83 c0 08             	add    $0x8,%eax
4000340d:	83 c0 0f             	add    $0xf,%eax
40003410:	83 c0 0f             	add    $0xf,%eax
40003413:	c1 e8 04             	shr    $0x4,%eax
40003416:	c1 e0 04             	shl    $0x4,%eax
40003419:	29 c4                	sub    %eax,%esp
4000341b:	89 65 e8             	mov    %esp,-0x18(%ebp)
4000341e:	8b 45 e8             	mov    -0x18(%ebp),%eax
40003421:	83 c0 0f             	add    $0xf,%eax
40003424:	c1 e8 04             	shr    $0x4,%eax
40003427:	c1 e0 04             	shl    $0x4,%eax
4000342a:	89 45 e8             	mov    %eax,-0x18(%ebp)
4000342d:	8b 45 e8             	mov    -0x18(%ebp),%eax
40003430:	89 45 f4             	mov    %eax,-0xc(%ebp)
40003433:	8b 45 f4             	mov    -0xc(%ebp),%eax
40003436:	83 ec 04             	sub    $0x4,%esp
40003439:	6a 08                	push   $0x8
4000343b:	ff 75 0c             	pushl  0xc(%ebp)
4000343e:	50                   	push   %eax
4000343f:	e8 c4 5e 00 00       	call   40009308 <strncpy>
40003444:	83 c4 10             	add    $0x10,%esp
40003447:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000344a:	83 c0 08             	add    $0x8,%eax
4000344d:	83 ec 04             	sub    $0x4,%esp
40003450:	ff 75 10             	pushl  0x10(%ebp)
40003453:	ff 75 14             	pushl  0x14(%ebp)
40003456:	50                   	push   %eax
40003457:	e8 0c 5b 00 00       	call   40008f68 <memcpy>
4000345c:	83 c4 10             	add    $0x10,%esp
4000345f:	e8 40 fd ff ff       	call   400031a4 <v>
40003464:	8b 45 f4             	mov    -0xc(%ebp),%eax
40003467:	8b 55 10             	mov    0x10(%ebp),%edx
4000346a:	83 c2 08             	add    $0x8,%edx
4000346d:	83 ec 0c             	sub    $0xc,%esp
40003470:	50                   	push   %eax
40003471:	52                   	push   %edx
40003472:	ff 75 f8             	pushl  -0x8(%ebp)
40003475:	68 00 02 00 00       	push   $0x200
4000347a:	ff 75 08             	pushl  0x8(%ebp)
4000347d:	e8 b0 fd ff ff       	call   40003232 <send_message>
40003482:	83 c4 20             	add    $0x20,%esp
40003485:	e8 0e fd ff ff       	call   40003198 <p>
4000348a:	eb 0a                	jmp    40003496 <sync_rpc+0xbb>
4000348c:	e8 f7 03 00 00       	call   40003888 <v_and_wait_for_rpc>
40003491:	e8 02 fd ff ff       	call   40003198 <p>
40003496:	83 ec 08             	sub    $0x8,%esp
40003499:	ff 75 f8             	pushl  -0x8(%ebp)
4000349c:	ff 75 08             	pushl  0x8(%ebp)
4000349f:	e8 98 fe ff ff       	call   4000333c <sync_rpc_has_response>
400034a4:	83 c4 10             	add    $0x10,%esp
400034a7:	89 45 fc             	mov    %eax,-0x4(%ebp)
400034aa:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
400034ae:	74 dc                	je     4000348c <sync_rpc+0xb1>
400034b0:	e8 ef fc ff ff       	call   400031a4 <v>
400034b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
400034b8:	8b 65 ec             	mov    -0x14(%ebp),%esp
400034bb:	c9                   	leave  
400034bc:	c3                   	ret    

400034bd <rpc_get_dword>:
400034bd:	55                   	push   %ebp
400034be:	89 e5                	mov    %esp,%ebp
400034c0:	83 ec 18             	sub    $0x18,%esp
400034c3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
400034ca:	ff 75 14             	pushl  0x14(%ebp)
400034cd:	ff 75 10             	pushl  0x10(%ebp)
400034d0:	ff 75 0c             	pushl  0xc(%ebp)
400034d3:	ff 75 08             	pushl  0x8(%ebp)
400034d6:	e8 00 ff ff ff       	call   400033db <sync_rpc>
400034db:	83 c4 10             	add    $0x10,%esp
400034de:	89 45 fc             	mov    %eax,-0x4(%ebp)
400034e1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
400034e5:	74 16                	je     400034fd <rpc_get_dword+0x40>
400034e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
400034ea:	8b 40 08             	mov    0x8(%eax),%eax
400034ed:	83 f8 03             	cmp    $0x3,%eax
400034f0:	76 0b                	jbe    400034fd <rpc_get_dword+0x40>
400034f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
400034f5:	8b 40 0c             	mov    0xc(%eax),%eax
400034f8:	8b 00                	mov    (%eax),%eax
400034fa:	89 45 f8             	mov    %eax,-0x8(%ebp)
400034fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003500:	8b 40 0c             	mov    0xc(%eax),%eax
40003503:	83 ec 0c             	sub    $0xc,%esp
40003506:	50                   	push   %eax
40003507:	e8 a3 54 00 00       	call   400089af <free>
4000350c:	83 c4 10             	add    $0x10,%esp
4000350f:	83 ec 0c             	sub    $0xc,%esp
40003512:	ff 75 fc             	pushl  -0x4(%ebp)
40003515:	e8 95 54 00 00       	call   400089af <free>
4000351a:	83 c4 10             	add    $0x10,%esp
4000351d:	8b 45 f8             	mov    -0x8(%ebp),%eax
40003520:	c9                   	leave  
40003521:	c3                   	ret    

40003522 <rpc_get_int>:
40003522:	55                   	push   %ebp
40003523:	89 e5                	mov    %esp,%ebp
40003525:	83 ec 18             	sub    $0x18,%esp
40003528:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
4000352f:	ff 75 14             	pushl  0x14(%ebp)
40003532:	ff 75 10             	pushl  0x10(%ebp)
40003535:	ff 75 0c             	pushl  0xc(%ebp)
40003538:	ff 75 08             	pushl  0x8(%ebp)
4000353b:	e8 9b fe ff ff       	call   400033db <sync_rpc>
40003540:	83 c4 10             	add    $0x10,%esp
40003543:	89 45 fc             	mov    %eax,-0x4(%ebp)
40003546:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
4000354a:	74 16                	je     40003562 <rpc_get_int+0x40>
4000354c:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000354f:	8b 40 08             	mov    0x8(%eax),%eax
40003552:	83 f8 03             	cmp    $0x3,%eax
40003555:	76 0b                	jbe    40003562 <rpc_get_int+0x40>
40003557:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000355a:	8b 40 0c             	mov    0xc(%eax),%eax
4000355d:	8b 00                	mov    (%eax),%eax
4000355f:	89 45 f8             	mov    %eax,-0x8(%ebp)
40003562:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003565:	8b 40 0c             	mov    0xc(%eax),%eax
40003568:	83 ec 0c             	sub    $0xc,%esp
4000356b:	50                   	push   %eax
4000356c:	e8 3e 54 00 00       	call   400089af <free>
40003571:	83 c4 10             	add    $0x10,%esp
40003574:	83 ec 0c             	sub    $0xc,%esp
40003577:	ff 75 fc             	pushl  -0x4(%ebp)
4000357a:	e8 30 54 00 00       	call   400089af <free>
4000357f:	83 c4 10             	add    $0x10,%esp
40003582:	8b 45 f8             	mov    -0x8(%ebp),%eax
40003585:	c9                   	leave  
40003586:	c3                   	ret    

40003587 <rpc_get_string>:
40003587:	55                   	push   %ebp
40003588:	89 e5                	mov    %esp,%ebp
4000358a:	83 ec 18             	sub    $0x18,%esp
4000358d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40003594:	ff 75 14             	pushl  0x14(%ebp)
40003597:	ff 75 10             	pushl  0x10(%ebp)
4000359a:	ff 75 0c             	pushl  0xc(%ebp)
4000359d:	ff 75 08             	pushl  0x8(%ebp)
400035a0:	e8 36 fe ff ff       	call   400033db <sync_rpc>
400035a5:	83 c4 10             	add    $0x10,%esp
400035a8:	89 45 f8             	mov    %eax,-0x8(%ebp)
400035ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
400035ae:	8b 50 08             	mov    0x8(%eax),%edx
400035b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
400035b4:	8b 40 0c             	mov    0xc(%eax),%eax
400035b7:	83 ec 08             	sub    $0x8,%esp
400035ba:	52                   	push   %edx
400035bb:	50                   	push   %eax
400035bc:	e8 2b 44 00 00       	call   400079ec <strnlen>
400035c1:	83 c4 10             	add    $0x10,%esp
400035c4:	89 45 fc             	mov    %eax,-0x4(%ebp)
400035c7:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
400035cb:	74 3b                	je     40003608 <rpc_get_string+0x81>
400035cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
400035d0:	8b 40 08             	mov    0x8(%eax),%eax
400035d3:	3b 45 fc             	cmp    -0x4(%ebp),%eax
400035d6:	76 30                	jbe    40003608 <rpc_get_string+0x81>
400035d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
400035db:	40                   	inc    %eax
400035dc:	83 ec 0c             	sub    $0xc,%esp
400035df:	50                   	push   %eax
400035e0:	e8 f3 4c 00 00       	call   400082d8 <malloc>
400035e5:	83 c4 10             	add    $0x10,%esp
400035e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
400035eb:	83 ec 04             	sub    $0x4,%esp
400035ee:	ff 75 fc             	pushl  -0x4(%ebp)
400035f1:	ff 75 14             	pushl  0x14(%ebp)
400035f4:	ff 75 f4             	pushl  -0xc(%ebp)
400035f7:	e8 0c 5d 00 00       	call   40009308 <strncpy>
400035fc:	83 c4 10             	add    $0x10,%esp
400035ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003602:	03 45 f4             	add    -0xc(%ebp),%eax
40003605:	c6 00 00             	movb   $0x0,(%eax)
40003608:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000360b:	8b 40 0c             	mov    0xc(%eax),%eax
4000360e:	83 ec 0c             	sub    $0xc,%esp
40003611:	50                   	push   %eax
40003612:	e8 98 53 00 00       	call   400089af <free>
40003617:	83 c4 10             	add    $0x10,%esp
4000361a:	83 ec 0c             	sub    $0xc,%esp
4000361d:	ff 75 f8             	pushl  -0x8(%ebp)
40003620:	e8 8a 53 00 00       	call   400089af <free>
40003625:	83 c4 10             	add    $0x10,%esp
40003628:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000362b:	c9                   	leave  
4000362c:	c3                   	ret    

4000362d <rpc_get_response>:
4000362d:	55                   	push   %ebp
4000362e:	89 e5                	mov    %esp,%ebp
40003630:	83 ec 18             	sub    $0x18,%esp
40003633:	ff 75 14             	pushl  0x14(%ebp)
40003636:	ff 75 10             	pushl  0x10(%ebp)
40003639:	ff 75 0c             	pushl  0xc(%ebp)
4000363c:	ff 75 08             	pushl  0x8(%ebp)
4000363f:	e8 97 fd ff ff       	call   400033db <sync_rpc>
40003644:	83 c4 10             	add    $0x10,%esp
40003647:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000364a:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000364d:	c9                   	leave  
4000364e:	c3                   	ret    

4000364f <rpc_send_response>:
4000364f:	55                   	push   %ebp
40003650:	89 e5                	mov    %esp,%ebp
40003652:	83 ec 08             	sub    $0x8,%esp
40003655:	83 ec 0c             	sub    $0xc,%esp
40003658:	ff 75 14             	pushl  0x14(%ebp)
4000365b:	ff 75 10             	pushl  0x10(%ebp)
4000365e:	ff 75 0c             	pushl  0xc(%ebp)
40003661:	68 01 02 00 00       	push   $0x201
40003666:	ff 75 08             	pushl  0x8(%ebp)
40003669:	e8 c4 fb ff ff       	call   40003232 <send_message>
4000366e:	83 c4 20             	add    $0x20,%esp
40003671:	c9                   	leave  
40003672:	c3                   	ret    

40003673 <rpc_send_dword_response>:
40003673:	55                   	push   %ebp
40003674:	89 e5                	mov    %esp,%ebp
40003676:	83 ec 08             	sub    $0x8,%esp
40003679:	8d 45 10             	lea    0x10(%ebp),%eax
4000367c:	83 ec 0c             	sub    $0xc,%esp
4000367f:	50                   	push   %eax
40003680:	6a 04                	push   $0x4
40003682:	ff 75 0c             	pushl  0xc(%ebp)
40003685:	68 01 02 00 00       	push   $0x201
4000368a:	ff 75 08             	pushl  0x8(%ebp)
4000368d:	e8 a0 fb ff ff       	call   40003232 <send_message>
40003692:	83 c4 20             	add    $0x20,%esp
40003695:	c9                   	leave  
40003696:	c3                   	ret    

40003697 <rpc_send_int_response>:
40003697:	55                   	push   %ebp
40003698:	89 e5                	mov    %esp,%ebp
4000369a:	83 ec 08             	sub    $0x8,%esp
4000369d:	8d 45 10             	lea    0x10(%ebp),%eax
400036a0:	83 ec 0c             	sub    $0xc,%esp
400036a3:	50                   	push   %eax
400036a4:	6a 04                	push   $0x4
400036a6:	ff 75 0c             	pushl  0xc(%ebp)
400036a9:	68 01 02 00 00       	push   $0x201
400036ae:	ff 75 08             	pushl  0x8(%ebp)
400036b1:	e8 7c fb ff ff       	call   40003232 <send_message>
400036b6:	83 c4 20             	add    $0x20,%esp
400036b9:	c9                   	leave  
400036ba:	c3                   	ret    

400036bb <rpc_send_string_response>:
400036bb:	55                   	push   %ebp
400036bc:	89 e5                	mov    %esp,%ebp
400036be:	83 ec 08             	sub    $0x8,%esp
400036c1:	83 ec 0c             	sub    $0xc,%esp
400036c4:	ff 75 10             	pushl  0x10(%ebp)
400036c7:	e8 a8 5b 00 00       	call   40009274 <strlen>
400036cc:	83 c4 10             	add    $0x10,%esp
400036cf:	83 ec 0c             	sub    $0xc,%esp
400036d2:	ff 75 10             	pushl  0x10(%ebp)
400036d5:	50                   	push   %eax
400036d6:	ff 75 0c             	pushl  0xc(%ebp)
400036d9:	68 01 02 00 00       	push   $0x201
400036de:	ff 75 08             	pushl  0x8(%ebp)
400036e1:	e8 4c fb ff ff       	call   40003232 <send_message>
400036e6:	83 c4 20             	add    $0x20,%esp
400036e9:	c9                   	leave  
400036ea:	c3                   	ret    
400036eb:	90                   	nop    

400036ec <timer_register>:

/**
 * ATA-Geraet identifizieren
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
 */
400036ec:	55                   	push   %ebp
400036ed:	89 e5                	mov    %esp,%ebp
400036ef:	83 ec 18             	sub    $0x18,%esp
int ata_drv_identify(struct ata_device* dev)
{
400036f2:	a1 d4 a4 00 40       	mov    0x4000a4d4,%eax
400036f7:	85 c0                	test   %eax,%eax
400036f9:	75 0a                	jne    40003705 <timer_register+0x19>
    uint8_t buffer[ATA_SECTOR_SIZE];
400036fb:	e8 20 45 00 00       	call   40007c20 <list_create>
40003700:	a3 d4 a4 00 40       	mov    %eax,0x4000a4d4

    // Request vorbereiten
    struct ata_request request = {
        .dev = dev,
40003705:	83 ec 0c             	sub    $0xc,%esp
40003708:	6a 08                	push   $0x8
4000370a:	e8 c9 4b 00 00       	call   400082d8 <malloc>
4000370f:	83 c4 10             	add    $0x10,%esp
40003712:	89 45 f4             	mov    %eax,-0xc(%ebp)

        .flags.direction = READ,
40003715:	8b 55 f4             	mov    -0xc(%ebp),%edx
40003718:	8b 45 08             	mov    0x8(%ebp),%eax
4000371b:	89 02                	mov    %eax,(%edx)
        .flags.poll = 1,
4000371d:	8b 15 d0 a4 00 40    	mov    0x4000a4d0,%edx
40003723:	8b 45 f4             	mov    -0xc(%ebp),%eax
40003726:	89 50 04             	mov    %edx,0x4(%eax)
40003729:	8d 42 01             	lea    0x1(%edx),%eax
4000372c:	a3 d0 a4 00 40       	mov    %eax,0x4000a4d0
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
40003731:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40003738:	eb 13                	jmp    4000374d <timer_register+0x61>
        .block_count = 1,
4000373a:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000373d:	8b 50 04             	mov    0x4(%eax),%edx
40003740:	8b 45 f4             	mov    -0xc(%ebp),%eax
40003743:	8b 40 04             	mov    0x4(%eax),%eax
40003746:	39 c2                	cmp    %eax,%edx
40003748:	77 20                	ja     4000376a <timer_register+0x7e>
        .flags.poll = 1,
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
4000374a:	ff 45 fc             	incl   -0x4(%ebp)
4000374d:	a1 d4 a4 00 40       	mov    0x4000a4d4,%eax
40003752:	83 ec 08             	sub    $0x8,%esp
40003755:	ff 75 fc             	pushl  -0x4(%ebp)
40003758:	50                   	push   %eax
40003759:	e8 2f 47 00 00       	call   40007e8d <list_get_element_at>
4000375e:	83 c4 10             	add    $0x10,%esp
40003761:	89 45 f8             	mov    %eax,-0x8(%ebp)
40003764:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40003768:	75 d0                	jne    4000373a <timer_register+0x4e>
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

        .error = 0
4000376a:	a1 d4 a4 00 40       	mov    0x4000a4d4,%eax
4000376f:	83 ec 04             	sub    $0x4,%esp
40003772:	ff 75 f4             	pushl  -0xc(%ebp)
40003775:	ff 75 fc             	pushl  -0x4(%ebp)
40003778:	50                   	push   %eax
40003779:	e8 43 47 00 00       	call   40007ec1 <list_insert>
4000377e:	83 c4 10             	add    $0x10,%esp
    };
    
    // Request starten
40003781:	8b 45 f4             	mov    -0xc(%ebp),%eax
40003784:	8b 40 04             	mov    0x4(%eax),%eax
40003787:	83 ec 08             	sub    $0x8,%esp
4000378a:	ff 75 0c             	pushl  0xc(%ebp)
4000378d:	50                   	push   %eax
4000378e:	e8 b5 35 00 00       	call   40006d48 <syscall_timer>
40003793:	83 c4 10             	add    $0x10,%esp
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
40003796:	8b 45 f4             	mov    -0xc(%ebp),%eax
40003799:	8b 40 04             	mov    0x4(%eax),%eax
        // IDENTIFY PACKET DEVICE probieren.
4000379c:	c9                   	leave  
4000379d:	c3                   	ret    

4000379e <timer_callback>:
        return atapi_drv_identify(dev);
    }
        
4000379e:	55                   	push   %ebp
4000379f:	89 e5                	mov    %esp,%ebp
400037a1:	83 ec 18             	sub    $0x18,%esp
    // Ein ATA-Geraet
    dev->atapi = 0;

    // TODO: Informationen verarbeiten
400037a4:	e8 ef f9 ff ff       	call   40003198 <p>

400037a9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
400037b0:	eb 3e                	jmp    400037f0 <timer_callback+0x52>
    return 1;
400037b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
400037b5:	8b 40 04             	mov    0x4(%eax),%eax
400037b8:	3b 45 08             	cmp    0x8(%ebp),%eax
400037bb:	75 30                	jne    400037ed <timer_callback+0x4f>
}
400037bd:	a1 d4 a4 00 40       	mov    0x4000a4d4,%eax
400037c2:	83 ec 08             	sub    $0x8,%esp
400037c5:	ff 75 fc             	pushl  -0x4(%ebp)
400037c8:	50                   	push   %eax
400037c9:	e8 ab 47 00 00       	call   40007f79 <list_remove>
400037ce:	83 c4 10             	add    $0x10,%esp

400037d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
400037d4:	8b 00                	mov    (%eax),%eax
400037d6:	ff d0                	call   *%eax
/**
400037d8:	83 ec 0c             	sub    $0xc,%esp
400037db:	ff 75 f8             	pushl  -0x8(%ebp)
400037de:	e8 cc 51 00 00       	call   400089af <free>
400037e3:	83 c4 10             	add    $0x10,%esp
 * Sektoren von einem ATA-Geraet lesen
400037e6:	e8 b9 f9 ff ff       	call   400031a4 <v>
 *
400037eb:	eb 25                	jmp    40003812 <timer_callback+0x74>
        
    // Ein ATA-Geraet
    dev->atapi = 0;

    // TODO: Informationen verarbeiten

400037ed:	ff 45 fc             	incl   -0x4(%ebp)
400037f0:	a1 d4 a4 00 40       	mov    0x4000a4d4,%eax
400037f5:	83 ec 08             	sub    $0x8,%esp
400037f8:	ff 75 fc             	pushl  -0x4(%ebp)
400037fb:	50                   	push   %eax
400037fc:	e8 8c 46 00 00       	call   40007e8d <list_get_element_at>
40003801:	83 c4 10             	add    $0x10,%esp
40003804:	89 45 f8             	mov    %eax,-0x8(%ebp)
40003807:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
4000380b:	75 a5                	jne    400037b2 <timer_callback+0x14>
/**
 * Sektoren von einem ATA-Geraet lesen
 *
 * @param start LBA des Startsektors
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
4000380d:	e8 92 f9 ff ff       	call   400031a4 <v>
 *
40003812:	c9                   	leave  
40003813:	c3                   	ret    

40003814 <timer_cancel>:
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
40003814:	55                   	push   %ebp
40003815:	89 e5                	mov    %esp,%ebp
40003817:	83 ec 18             	sub    $0x18,%esp
    void* buffer)
{
    int result = 1;
    struct ata_request request;
4000381a:	e8 79 f9 ff ff       	call   40003198 <p>
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
4000381f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40003826:	eb 30                	jmp    40003858 <timer_cancel+0x44>
    // muss unter Umstaenden mehrmals gelesen werden.
40003828:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000382b:	8b 40 04             	mov    0x4(%eax),%eax
4000382e:	3b 45 08             	cmp    0x8(%ebp),%eax
40003831:	75 22                	jne    40003855 <timer_cancel+0x41>
    uint16_t current_count;
40003833:	a1 d4 a4 00 40       	mov    0x4000a4d4,%eax
40003838:	83 ec 08             	sub    $0x8,%esp
4000383b:	ff 75 fc             	pushl  -0x4(%ebp)
4000383e:	50                   	push   %eax
4000383f:	e8 35 47 00 00       	call   40007f79 <list_remove>
40003844:	83 c4 10             	add    $0x10,%esp
    void* current_buffer = buffer;
40003847:	83 ec 0c             	sub    $0xc,%esp
4000384a:	ff 75 f8             	pushl  -0x8(%ebp)
4000384d:	e8 5d 51 00 00       	call   400089af <free>
40003852:	83 c4 10             	add    $0x10,%esp
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
{
    int result = 1;
    struct ata_request request;
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
40003855:	ff 45 fc             	incl   -0x4(%ebp)
40003858:	a1 d4 a4 00 40       	mov    0x4000a4d4,%eax
4000385d:	83 ec 08             	sub    $0x8,%esp
40003860:	ff 75 fc             	pushl  -0x4(%ebp)
40003863:	50                   	push   %eax
40003864:	e8 24 46 00 00       	call   40007e8d <list_get_element_at>
40003869:	83 c4 10             	add    $0x10,%esp
4000386c:	89 45 f8             	mov    %eax,-0x8(%ebp)
4000386f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40003873:	75 b3                	jne    40003828 <timer_cancel+0x14>
    // muss unter Umstaenden mehrmals gelesen werden.
    uint16_t current_count;
    void* current_buffer = buffer;
    uint64_t lba = start;

    // Anzahl der Sektoren die noch uebrig sind
40003875:	e8 2a f9 ff ff       	call   400031a4 <v>
    size_t count_left = count;
4000387a:	c9                   	leave  
4000387b:	c3                   	ret    

4000387c <wait_for_rpc>:
/*
 * Copyright (c) 2007 Kevin Wolf
 *
 * This program is free software. It comes without any warranty, to
4000387c:	55                   	push   %ebp
4000387d:	89 e5                	mov    %esp,%ebp
 * the extent permitted by applicable law. You can redistribute it 
4000387f:	b8 11 00 00 00       	mov    $0x11,%eax
40003884:	cd 30                	int    $0x30
 * and/or modify it under the terms of the Do What The Fuck You Want 
 * To Public License, Version 2, as published by Sam Hocevar. See
 * http://sam.zoy.org/projects/COPYING.WTFPL for more details.
 */  
40003886:	c9                   	leave  
40003887:	c3                   	ret    

40003888 <v_and_wait_for_rpc>:

#ifndef _CDI_IO_H_
#define _CDI_IO_H_
40003888:	55                   	push   %ebp
40003889:	89 e5                	mov    %esp,%ebp

4000388b:	b8 13 00 00 00       	mov    $0x13,%eax
40003890:	cd 30                	int    $0x30
#include <stdint.h>

static inline uint16_t cdi_inw(uint16_t _port)
{
40003892:	c9                   	leave  
40003893:	c3                   	ret    

40003894 <lostio_init>:
 */
int ata_drv_identify(struct ata_device* dev)
{
    uint8_t buffer[ATA_SECTOR_SIZE];

    // Request vorbereiten
40003894:	55                   	push   %ebp
40003895:	89 e5                	mov    %esp,%ebp
40003897:	83 ec 08             	sub    $0x8,%esp
    struct ata_request request = {
        .dev = dev,
4000389a:	e8 81 43 00 00       	call   40007c20 <list_create>
4000389f:	a3 20 a8 00 40       	mov    %eax,0x4000a820

400038a4:	c7 05 04 a8 00 40 7c 	movl   $0x4000987c,0x4000a804
400038ab:	98 00 40 
        .flags.direction = READ,
400038ae:	c6 05 00 a8 00 40 01 	movb   $0x1,0x4000a800
        .flags.poll = 1,
400038b5:	c7 05 1c a8 00 40 00 	movl   $0x20000,0x4000a81c
400038bc:	00 02 00 
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
400038bf:	e8 5c 43 00 00       	call   40007c20 <list_create>
400038c4:	a3 e4 a7 00 40       	mov    %eax,0x4000a7e4
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
400038c9:	e8 52 43 00 00       	call   40007c20 <list_create>
400038ce:	a3 e0 a7 00 40       	mov    %eax,0x4000a7e0
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

400038d3:	83 ec 08             	sub    $0x8,%esp
400038d6:	68 60 6d 00 40       	push   $0x40006d60
400038db:	68 7e 98 00 40       	push   $0x4000987e
400038e0:	e8 9c f5 ff ff       	call   40002e81 <register_message_handler>
400038e5:	83 c4 10             	add    $0x10,%esp
        .error = 0
400038e8:	83 ec 08             	sub    $0x8,%esp
400038eb:	68 83 6f 00 40       	push   $0x40006f83
400038f0:	68 87 98 00 40       	push   $0x40009887
400038f5:	e8 87 f5 ff ff       	call   40002e81 <register_message_handler>
400038fa:	83 c4 10             	add    $0x10,%esp
    };
400038fd:	83 ec 08             	sub    $0x8,%esp
40003900:	68 d2 6f 00 40       	push   $0x40006fd2
40003905:	68 90 98 00 40       	push   $0x40009890
4000390a:	e8 72 f5 ff ff       	call   40002e81 <register_message_handler>
4000390f:	83 c4 10             	add    $0x10,%esp
    
40003912:	83 ec 08             	sub    $0x8,%esp
40003915:	68 31 71 00 40       	push   $0x40007131
4000391a:	68 99 98 00 40       	push   $0x40009899
4000391f:	e8 5d f5 ff ff       	call   40002e81 <register_message_handler>
40003924:	83 c4 10             	add    $0x10,%esp
    // Request starten
40003927:	83 ec 08             	sub    $0x8,%esp
4000392a:	68 70 72 00 40       	push   $0x40007270
4000392f:	68 a2 98 00 40       	push   $0x400098a2
40003934:	e8 48 f5 ff ff       	call   40002e81 <register_message_handler>
40003939:	83 c4 10             	add    $0x10,%esp
    if (!ata_request(&request)) {
4000393c:	83 ec 08             	sub    $0x8,%esp
4000393f:	68 26 73 00 40       	push   $0x40007326
40003944:	68 ab 98 00 40       	push   $0x400098ab
40003949:	e8 33 f5 ff ff       	call   40002e81 <register_message_handler>
4000394e:	83 c4 10             	add    $0x10,%esp
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
40003951:	83 ec 08             	sub    $0x8,%esp
40003954:	68 88 73 00 40       	push   $0x40007388
40003959:	68 b4 98 00 40       	push   $0x400098b4
4000395e:	e8 1e f5 ff ff       	call   40002e81 <register_message_handler>
40003963:	83 c4 10             	add    $0x10,%esp
        // IDENTIFY PACKET DEVICE probieren.
40003966:	83 ec 08             	sub    $0x8,%esp
40003969:	68 e6 73 00 40       	push   $0x400073e6
4000396e:	68 bd 98 00 40       	push   $0x400098bd
40003973:	e8 09 f5 ff ff       	call   40002e81 <register_message_handler>
40003978:	83 c4 10             	add    $0x10,%esp
        return atapi_drv_identify(dev);
4000397b:	83 ec 08             	sub    $0x8,%esp
4000397e:	68 14 75 00 40       	push   $0x40007514
40003983:	68 c6 98 00 40       	push   $0x400098c6
40003988:	e8 f4 f4 ff ff       	call   40002e81 <register_message_handler>
4000398d:	83 c4 10             	add    $0x10,%esp
    }
40003990:	c9                   	leave  
40003991:	c3                   	ret    

40003992 <lostio_dispatch>:
        
    // Ein ATA-Geraet
    dev->atapi = 0;

    // TODO: Informationen verarbeiten

40003992:	55                   	push   %ebp
40003993:	89 e5                	mov    %esp,%ebp
40003995:	83 ec 08             	sub    $0x8,%esp
    return 1;
40003998:	e8 5b 32 00 00       	call   40006bf8 <lostio_sync_dispatch>
}
4000399d:	c9                   	leave  
4000399e:	c3                   	ret    

4000399f <get_typehandle>:
 * @param start LBA des Startsektors
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
 */
4000399f:	55                   	push   %ebp
400039a0:	89 e5                	mov    %esp,%ebp
400039a2:	83 ec 18             	sub    $0x18,%esp
400039a5:	8b 45 08             	mov    0x8(%ebp),%eax
400039a8:	88 45 ec             	mov    %al,-0x14(%ebp)
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
400039ab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
{
    int result = 1;
400039b2:	eb 0a                	jmp    400039be <get_typehandle+0x1f>
    struct ata_request request;
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
400039b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
400039b7:	8a 00                	mov    (%eax),%al
400039b9:	3a 45 ec             	cmp    -0x14(%ebp),%al
400039bc:	74 21                	je     400039df <get_typehandle+0x40>
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
{
    int result = 1;
400039be:	8b 55 fc             	mov    -0x4(%ebp),%edx
400039c1:	ff 45 fc             	incl   -0x4(%ebp)
400039c4:	a1 e0 a7 00 40       	mov    0x4000a7e0,%eax
400039c9:	83 ec 08             	sub    $0x8,%esp
400039cc:	52                   	push   %edx
400039cd:	50                   	push   %eax
400039ce:	e8 ba 44 00 00       	call   40007e8d <list_get_element_at>
400039d3:	83 c4 10             	add    $0x10,%esp
400039d6:	89 45 f8             	mov    %eax,-0x8(%ebp)
400039d9:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
400039dd:	75 d5                	jne    400039b4 <get_typehandle+0x15>
    // muss unter Umstaenden mehrmals gelesen werden.
    uint16_t current_count;
    void* current_buffer = buffer;
    uint64_t lba = start;

    // Anzahl der Sektoren die noch uebrig sind
400039df:	8b 45 f8             	mov    -0x8(%ebp),%eax
    size_t count_left = count;
400039e2:	c9                   	leave  
400039e3:	c3                   	ret    

400039e4 <lostio_register_typehandle>:
        if (count_left > 256) {
            current_count = 256;
        } else {
            current_count = count_left;
        }
        
400039e4:	55                   	push   %ebp
400039e5:	89 e5                	mov    %esp,%ebp
400039e7:	57                   	push   %edi
400039e8:	56                   	push   %esi
400039e9:	83 ec 10             	sub    $0x10,%esp
        // Request vorbereiten
400039ec:	8b 45 08             	mov    0x8(%ebp),%eax
400039ef:	8a 00                	mov    (%eax),%al
400039f1:	0f b6 c0             	movzbl %al,%eax
400039f4:	83 ec 0c             	sub    $0xc,%esp
400039f7:	50                   	push   %eax
400039f8:	e8 a2 ff ff ff       	call   4000399f <get_typehandle>
400039fd:	83 c4 10             	add    $0x10,%esp
40003a00:	89 45 f4             	mov    %eax,-0xc(%ebp)
        request.dev = dev;
        // TODO: DMA, UltraDMA...
        request.protocol = PIO;
        request.flags.direction = READ;
        // FIXME
        request.flags.poll = 1;
40003a03:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
40003a07:	75 1b                	jne    40003a24 <lostio_register_typehandle+0x40>
        request.flags.ata = 0;
        request.flags.lba = 1;
40003a09:	a1 e0 a7 00 40       	mov    0x4000a7e0,%eax
40003a0e:	83 ec 08             	sub    $0x8,%esp
40003a11:	ff 75 08             	pushl  0x8(%ebp)
40003a14:	50                   	push   %eax
40003a15:	e8 b2 42 00 00       	call   40007ccc <list_push>
40003a1a:	83 c4 10             	add    $0x10,%esp
40003a1d:	a3 e0 a7 00 40       	mov    %eax,0x4000a7e0
40003a22:	eb 14                	jmp    40003a38 <lostio_register_typehandle+0x54>

        request.registers.ata.command = READ_SECTORS;
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
40003a24:	8b 45 f4             	mov    -0xc(%ebp),%eax
40003a27:	8b 55 08             	mov    0x8(%ebp),%edx
40003a2a:	89 c7                	mov    %eax,%edi
40003a2c:	89 d6                	mov    %edx,%esi
40003a2e:	fc                   	cld    
40003a2f:	b8 0a 00 00 00       	mov    $0xa,%eax
40003a34:	89 c1                	mov    %eax,%ecx
40003a36:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        // 0 steht.
        request.registers.ata.count = (uint8_t) current_count;
40003a38:	8d 65 f8             	lea    -0x8(%ebp),%esp
40003a3b:	5e                   	pop    %esi
40003a3c:	5f                   	pop    %edi
40003a3d:	c9                   	leave  
40003a3e:	c3                   	ret    

40003a3f <get_filehandle>:

        request.error = NO_ERROR;
        
        // TODO: LBA48
        // TODO: CHS
        
40003a3f:	55                   	push   %ebp
40003a40:	89 e5                	mov    %esp,%ebp
40003a42:	83 ec 18             	sub    $0x18,%esp
        // Request ausfuehren
        if (!ata_request(&request)) {
40003a45:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
            result = 0;
            break;
40003a4c:	eb 0a                	jmp    40003a58 <get_filehandle+0x19>
        }

        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
        current_buffer += current_count * ATA_SECTOR_SIZE;
40003a4e:	8b 45 f8             	mov    -0x8(%ebp),%eax
40003a51:	8b 00                	mov    (%eax),%eax
40003a53:	3b 45 0c             	cmp    0xc(%ebp),%eax
40003a56:	74 21                	je     40003a79 <get_filehandle+0x3a>
        // TODO: CHS
        
        // Request ausfuehren
        if (!ata_request(&request)) {
            result = 0;
            break;
40003a58:	8b 55 fc             	mov    -0x4(%ebp),%edx
40003a5b:	ff 45 fc             	incl   -0x4(%ebp)
40003a5e:	a1 e4 a7 00 40       	mov    0x4000a7e4,%eax
40003a63:	83 ec 08             	sub    $0x8,%esp
40003a66:	52                   	push   %edx
40003a67:	50                   	push   %eax
40003a68:	e8 20 44 00 00       	call   40007e8d <list_get_element_at>
40003a6d:	83 c4 10             	add    $0x10,%esp
40003a70:	89 45 f8             	mov    %eax,-0x8(%ebp)
40003a73:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40003a77:	75 d5                	jne    40003a4e <get_filehandle+0xf>
        count_left -= current_count;
        lba += current_count;
    }

    return result;
}
40003a79:	8b 45 f8             	mov    -0x8(%ebp),%eax

40003a7c:	c9                   	leave  
40003a7d:	c3                   	ret    
40003a7e:	90                   	nop    
40003a7f:	90                   	nop    

40003a80 <vfstree_dirname>:
        .flags.poll = 1,
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
40003a80:	55                   	push   %ebp
40003a81:	89 e5                	mov    %esp,%ebp
40003a83:	83 ec 18             	sub    $0x18,%esp
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
40003a86:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
        .buffer = buffer,

        .error = 0
40003a8d:	83 ec 0c             	sub    $0xc,%esp
40003a90:	ff 75 08             	pushl  0x8(%ebp)
40003a93:	e8 dc 57 00 00       	call   40009274 <strlen>
40003a98:	83 c4 10             	add    $0x10,%esp
40003a9b:	48                   	dec    %eax
40003a9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
40003a9f:	eb 1a                	jmp    40003abb <vfstree_dirname+0x3b>
    };
    
40003aa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
40003aa4:	03 45 08             	add    0x8(%ebp),%eax
40003aa7:	8a 00                	mov    (%eax),%al
40003aa9:	3c 2f                	cmp    $0x2f,%al
40003aab:	75 0b                	jne    40003ab8 <vfstree_dirname+0x38>
    // Request starten
    if (!ata_request(&request)) {
40003aad:	8b 45 f4             	mov    -0xc(%ebp),%eax
40003ab0:	03 45 08             	add    0x8(%ebp),%eax
40003ab3:	89 45 f8             	mov    %eax,-0x8(%ebp)
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
40003ab6:	eb 09                	jmp    40003ac1 <vfstree_dirname+0x41>
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

        .error = 0
40003ab8:	ff 4d f4             	decl   -0xc(%ebp)
40003abb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
40003abf:	79 e0                	jns    40003aa1 <vfstree_dirname+0x21>
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
    }
        
    // Ein ATA-Geraet
    dev->atapi = 0;
40003ac1:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40003ac5:	74 08                	je     40003acf <vfstree_dirname+0x4f>
40003ac7:	8b 45 f8             	mov    -0x8(%ebp),%eax
40003aca:	3b 45 08             	cmp    0x8(%ebp),%eax
40003acd:	75 1f                	jne    40003aee <vfstree_dirname+0x6e>

    // TODO: Informationen verarbeiten
40003acf:	83 ec 0c             	sub    $0xc,%esp
40003ad2:	6a 02                	push   $0x2
40003ad4:	e8 ff 47 00 00       	call   400082d8 <malloc>
40003ad9:	83 c4 10             	add    $0x10,%esp
40003adc:	89 45 fc             	mov    %eax,-0x4(%ebp)

40003adf:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003ae2:	c6 00 2f             	movb   $0x2f,(%eax)
    return 1;
40003ae5:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003ae8:	40                   	inc    %eax
40003ae9:	c6 00 00             	movb   $0x0,(%eax)
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
    }
        
    // Ein ATA-Geraet
    dev->atapi = 0;
40003aec:	eb 52                	jmp    40003b40 <vfstree_dirname+0xc0>

    return 1;
}

/**
 * Sektoren von einem ATA-Geraet lesen
40003aee:	8b 45 f8             	mov    -0x8(%ebp),%eax
40003af1:	89 c2                	mov    %eax,%edx
40003af3:	8b 45 08             	mov    0x8(%ebp),%eax
40003af6:	89 d1                	mov    %edx,%ecx
40003af8:	29 c1                	sub    %eax,%ecx
40003afa:	89 c8                	mov    %ecx,%eax
40003afc:	40                   	inc    %eax
40003afd:	83 ec 0c             	sub    $0xc,%esp
40003b00:	50                   	push   %eax
40003b01:	e8 d2 47 00 00       	call   400082d8 <malloc>
40003b06:	83 c4 10             	add    $0x10,%esp
40003b09:	89 45 fc             	mov    %eax,-0x4(%ebp)
 *
40003b0c:	8b 45 f8             	mov    -0x8(%ebp),%eax
40003b0f:	89 c2                	mov    %eax,%edx
40003b11:	8b 45 08             	mov    0x8(%ebp),%eax
40003b14:	89 d1                	mov    %edx,%ecx
40003b16:	29 c1                	sub    %eax,%ecx
40003b18:	89 c8                	mov    %ecx,%eax
40003b1a:	83 ec 04             	sub    $0x4,%esp
40003b1d:	50                   	push   %eax
40003b1e:	ff 75 08             	pushl  0x8(%ebp)
40003b21:	ff 75 fc             	pushl  -0x4(%ebp)
40003b24:	e8 3f 54 00 00       	call   40008f68 <memcpy>
40003b29:	83 c4 10             	add    $0x10,%esp
 * @param start LBA des Startsektors
40003b2c:	8b 45 f8             	mov    -0x8(%ebp),%eax
40003b2f:	89 c2                	mov    %eax,%edx
40003b31:	8b 45 08             	mov    0x8(%ebp),%eax
40003b34:	89 d1                	mov    %edx,%ecx
40003b36:	29 c1                	sub    %eax,%ecx
40003b38:	89 c8                	mov    %ecx,%eax
40003b3a:	03 45 fc             	add    -0x4(%ebp),%eax
40003b3d:	c6 00 00             	movb   $0x0,(%eax)
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
40003b40:	8b 45 fc             	mov    -0x4(%ebp),%eax
 *
40003b43:	c9                   	leave  
40003b44:	c3                   	ret    

40003b45 <vfstree_basename>:
    int result = 1;
    struct ata_request request;
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
    // muss unter Umstaenden mehrmals gelesen werden.
    uint16_t current_count;
    void* current_buffer = buffer;
40003b45:	55                   	push   %ebp
40003b46:	89 e5                	mov    %esp,%ebp
40003b48:	83 ec 18             	sub    $0x18,%esp
    uint64_t lba = start;

40003b4b:	8b 45 08             	mov    0x8(%ebp),%eax
40003b4e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;

40003b51:	83 ec 0c             	sub    $0xc,%esp
40003b54:	ff 75 08             	pushl  0x8(%ebp)
40003b57:	e8 18 57 00 00       	call   40009274 <strlen>
40003b5c:	83 c4 10             	add    $0x10,%esp
40003b5f:	48                   	dec    %eax
40003b60:	89 45 f8             	mov    %eax,-0x8(%ebp)
40003b63:	eb 1e                	jmp    40003b83 <vfstree_basename+0x3e>
    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
40003b65:	8b 45 f8             	mov    -0x8(%ebp),%eax
40003b68:	03 45 08             	add    0x8(%ebp),%eax
40003b6b:	8a 00                	mov    (%eax),%al
40003b6d:	3c 2f                	cmp    $0x2f,%al
40003b6f:	75 0f                	jne    40003b80 <vfstree_basename+0x3b>
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
        if (count_left > 256) {
40003b71:	8b 55 08             	mov    0x8(%ebp),%edx
40003b74:	42                   	inc    %edx
40003b75:	8b 45 f8             	mov    -0x8(%ebp),%eax
40003b78:	8d 04 02             	lea    (%edx,%eax,1),%eax
40003b7b:	89 45 fc             	mov    %eax,-0x4(%ebp)
            current_count = 256;
40003b7e:	eb 09                	jmp    40003b89 <vfstree_basename+0x44>
    void* current_buffer = buffer;
    uint64_t lba = start;

    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;

40003b80:	ff 4d f8             	decl   -0x8(%ebp)
40003b83:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40003b87:	79 dc                	jns    40003b65 <vfstree_basename+0x20>
        if (count_left > 256) {
            current_count = 256;
        } else {
            current_count = count_left;
        }
        
40003b89:	8b 45 fc             	mov    -0x4(%ebp),%eax
        // Request vorbereiten
40003b8c:	c9                   	leave  
40003b8d:	c3                   	ret    

40003b8e <vfstree_get_node_by_name>:
        request.flags.ata = 0;
        request.flags.lba = 1;

        request.registers.ata.command = READ_SECTORS;
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
40003b8e:	55                   	push   %ebp
40003b8f:	89 e5                	mov    %esp,%ebp
40003b91:	83 ec 18             	sub    $0x18,%esp
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
40003b94:	8b 45 0c             	mov    0xc(%ebp),%eax
40003b97:	8a 00                	mov    (%eax),%al
40003b99:	3c 2f                	cmp    $0x2f,%al
40003b9b:	75 03                	jne    40003ba0 <vfstree_get_node_by_name+0x12>
        // 0 steht.
        request.registers.ata.count = (uint8_t) current_count;
40003b9d:	ff 45 0c             	incl   0xc(%ebp)
        request.registers.ata.lba = lba;

        request.block_count = current_count;
        request.block_size = ATA_SECTOR_SIZE;
40003ba0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
        request.blocks_done = 0;
        request.buffer = current_buffer;
40003ba7:	eb 21                	jmp    40003bca <vfstree_get_node_by_name+0x3c>

        request.error = NO_ERROR;
40003ba9:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003bac:	8b 40 04             	mov    0x4(%eax),%eax
40003baf:	83 ec 08             	sub    $0x8,%esp
40003bb2:	50                   	push   %eax
40003bb3:	ff 75 0c             	pushl  0xc(%ebp)
40003bb6:	e8 35 56 00 00       	call   400091f0 <strcmp>
40003bbb:	83 c4 10             	add    $0x10,%esp
40003bbe:	85 c0                	test   %eax,%eax
40003bc0:	75 08                	jne    40003bca <vfstree_get_node_by_name+0x3c>
        
        // TODO: LBA48
40003bc2:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003bc5:	89 45 ec             	mov    %eax,-0x14(%ebp)
40003bc8:	eb 29                	jmp    40003bf3 <vfstree_get_node_by_name+0x65>
        request.registers.ata.lba = lba;

        request.block_count = current_count;
        request.block_size = ATA_SECTOR_SIZE;
        request.blocks_done = 0;
        request.buffer = current_buffer;
40003bca:	8b 55 f8             	mov    -0x8(%ebp),%edx
40003bcd:	ff 45 f8             	incl   -0x8(%ebp)
40003bd0:	8b 45 08             	mov    0x8(%ebp),%eax
40003bd3:	8b 40 20             	mov    0x20(%eax),%eax
40003bd6:	83 ec 08             	sub    $0x8,%esp
40003bd9:	52                   	push   %edx
40003bda:	50                   	push   %eax
40003bdb:	e8 ad 42 00 00       	call   40007e8d <list_get_element_at>
40003be0:	83 c4 10             	add    $0x10,%esp
40003be3:	89 45 fc             	mov    %eax,-0x4(%ebp)
40003be6:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40003bea:	75 bd                	jne    40003ba9 <vfstree_get_node_by_name+0x1b>
        request.error = NO_ERROR;
        
        // TODO: LBA48
        // TODO: CHS
        
        // Request ausfuehren
40003bec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40003bf3:	8b 45 ec             	mov    -0x14(%ebp),%eax
        if (!ata_request(&request)) {
40003bf6:	c9                   	leave  
40003bf7:	c3                   	ret    

40003bf8 <vfstree_get_node_by_path>:
        current_buffer += current_count * ATA_SECTOR_SIZE;
        count_left -= current_count;
        lba += current_count;
    }

    return result;
40003bf8:	55                   	push   %ebp
40003bf9:	89 e5                	mov    %esp,%ebp
40003bfb:	53                   	push   %ebx
40003bfc:	83 ec 24             	sub    $0x24,%esp
}

40003bff:	8b 45 08             	mov    0x8(%ebp),%eax
40003c02:	8a 00                	mov    (%eax),%al
40003c04:	3c 2f                	cmp    $0x2f,%al
40003c06:	75 03                	jne    40003c0b <vfstree_get_node_by_path+0x13>
40003c08:	ff 45 08             	incl   0x8(%ebp)
40003c0b:	8b 45 08             	mov    0x8(%ebp),%eax
40003c0e:	89 45 e8             	mov    %eax,-0x18(%ebp)
40003c11:	8b 45 08             	mov    0x8(%ebp),%eax
40003c14:	89 45 ec             	mov    %eax,-0x14(%ebp)
40003c17:	c7 45 f0 00 a8 00 40 	movl   $0x4000a800,-0x10(%ebp)
40003c1e:	83 ec 0c             	sub    $0xc,%esp
40003c21:	ff 75 e8             	pushl  -0x18(%ebp)
40003c24:	e8 4b 56 00 00       	call   40009274 <strlen>
40003c29:	83 c4 10             	add    $0x10,%esp
40003c2c:	85 c0                	test   %eax,%eax
40003c2e:	75 08                	jne    40003c38 <vfstree_get_node_by_path+0x40>
40003c30:	8b 45 f0             	mov    -0x10(%ebp),%eax
40003c33:	89 45 d8             	mov    %eax,-0x28(%ebp)
40003c36:	eb 7a                	jmp    40003cb2 <vfstree_get_node_by_path+0xba>
40003c38:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40003c3f:	eb 56                	jmp    40003c97 <vfstree_get_node_by_path+0x9f>
40003c41:	8b 45 ec             	mov    -0x14(%ebp),%eax
40003c44:	8a 00                	mov    (%eax),%al
40003c46:	88 45 fb             	mov    %al,-0x5(%ebp)
40003c49:	80 7d fb 2f          	cmpb   $0x2f,-0x5(%ebp)
40003c4d:	74 06                	je     40003c55 <vfstree_get_node_by_path+0x5d>
40003c4f:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
40003c53:	75 3c                	jne    40003c91 <vfstree_get_node_by_path+0x99>
40003c55:	8b 45 ec             	mov    -0x14(%ebp),%eax
40003c58:	c6 00 00             	movb   $0x0,(%eax)
40003c5b:	83 ec 08             	sub    $0x8,%esp
40003c5e:	ff 75 e8             	pushl  -0x18(%ebp)
40003c61:	ff 75 f0             	pushl  -0x10(%ebp)
40003c64:	e8 25 ff ff ff       	call   40003b8e <vfstree_get_node_by_name>
40003c69:	83 c4 10             	add    $0x10,%esp
40003c6c:	89 45 f0             	mov    %eax,-0x10(%ebp)
40003c6f:	8b 55 ec             	mov    -0x14(%ebp),%edx
40003c72:	8a 45 fb             	mov    -0x5(%ebp),%al
40003c75:	88 02                	mov    %al,(%edx)
40003c77:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
40003c7b:	75 09                	jne    40003c86 <vfstree_get_node_by_path+0x8e>
40003c7d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
40003c84:	eb 2c                	jmp    40003cb2 <vfstree_get_node_by_path+0xba>
40003c86:	ff 45 ec             	incl   -0x14(%ebp)
40003c89:	8b 45 ec             	mov    -0x14(%ebp),%eax
40003c8c:	89 45 e8             	mov    %eax,-0x18(%ebp)
40003c8f:	eb 03                	jmp    40003c94 <vfstree_get_node_by_path+0x9c>
40003c91:	ff 45 ec             	incl   -0x14(%ebp)
40003c94:	ff 45 f4             	incl   -0xc(%ebp)
40003c97:	8b 5d f4             	mov    -0xc(%ebp),%ebx
40003c9a:	83 ec 0c             	sub    $0xc,%esp
40003c9d:	ff 75 08             	pushl  0x8(%ebp)
40003ca0:	e8 cf 55 00 00       	call   40009274 <strlen>
40003ca5:	83 c4 10             	add    $0x10,%esp
40003ca8:	39 c3                	cmp    %eax,%ebx
40003caa:	76 95                	jbe    40003c41 <vfstree_get_node_by_path+0x49>
40003cac:	8b 45 f0             	mov    -0x10(%ebp),%eax
40003caf:	89 45 d8             	mov    %eax,-0x28(%ebp)
40003cb2:	8b 45 d8             	mov    -0x28(%ebp),%eax
40003cb5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40003cb8:	c9                   	leave  
40003cb9:	c3                   	ret    

40003cba <vfstree_create_child>:
40003cba:	55                   	push   %ebp
40003cbb:	89 e5                	mov    %esp,%ebp
40003cbd:	83 ec 18             	sub    $0x18,%esp
40003cc0:	8b 45 10             	mov    0x10(%ebp),%eax
40003cc3:	88 45 ec             	mov    %al,-0x14(%ebp)
40003cc6:	83 ec 0c             	sub    $0xc,%esp
40003cc9:	6a 28                	push   $0x28
40003ccb:	e8 08 46 00 00       	call   400082d8 <malloc>
40003cd0:	83 c4 10             	add    $0x10,%esp
40003cd3:	89 45 fc             	mov    %eax,-0x4(%ebp)
40003cd6:	8b 45 08             	mov    0x8(%ebp),%eax
40003cd9:	8b 40 20             	mov    0x20(%eax),%eax
40003cdc:	83 ec 08             	sub    $0x8,%esp
40003cdf:	ff 75 fc             	pushl  -0x4(%ebp)
40003ce2:	50                   	push   %eax
40003ce3:	e8 e4 3f 00 00       	call   40007ccc <list_push>
40003ce8:	83 c4 10             	add    $0x10,%esp
40003ceb:	89 c2                	mov    %eax,%edx
40003ced:	8b 45 08             	mov    0x8(%ebp),%eax
40003cf0:	89 50 20             	mov    %edx,0x20(%eax)
40003cf3:	8b 45 08             	mov    0x8(%ebp),%eax
40003cf6:	8b 50 0c             	mov    0xc(%eax),%edx
40003cf9:	8b 40 08             	mov    0x8(%eax),%eax
40003cfc:	83 c0 01             	add    $0x1,%eax
40003cff:	83 d2 00             	adc    $0x0,%edx
40003d02:	8b 4d 08             	mov    0x8(%ebp),%ecx
40003d05:	89 41 08             	mov    %eax,0x8(%ecx)
40003d08:	89 51 0c             	mov    %edx,0xc(%ecx)
40003d0b:	8b 55 fc             	mov    -0x4(%ebp),%edx
40003d0e:	8a 45 ec             	mov    -0x14(%ebp),%al
40003d11:	88 02                	mov    %al,(%edx)
40003d13:	83 ec 0c             	sub    $0xc,%esp
40003d16:	ff 75 0c             	pushl  0xc(%ebp)
40003d19:	e8 56 55 00 00       	call   40009274 <strlen>
40003d1e:	83 c4 10             	add    $0x10,%esp
40003d21:	40                   	inc    %eax
40003d22:	83 ec 0c             	sub    $0xc,%esp
40003d25:	50                   	push   %eax
40003d26:	e8 ad 45 00 00       	call   400082d8 <malloc>
40003d2b:	83 c4 10             	add    $0x10,%esp
40003d2e:	89 c2                	mov    %eax,%edx
40003d30:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003d33:	89 50 04             	mov    %edx,0x4(%eax)
40003d36:	83 ec 0c             	sub    $0xc,%esp
40003d39:	ff 75 0c             	pushl  0xc(%ebp)
40003d3c:	e8 33 55 00 00       	call   40009274 <strlen>
40003d41:	83 c4 10             	add    $0x10,%esp
40003d44:	8d 50 01             	lea    0x1(%eax),%edx
40003d47:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003d4a:	8b 40 04             	mov    0x4(%eax),%eax
40003d4d:	83 ec 04             	sub    $0x4,%esp
40003d50:	52                   	push   %edx
40003d51:	ff 75 0c             	pushl  0xc(%ebp)
40003d54:	50                   	push   %eax
40003d55:	e8 0e 52 00 00       	call   40008f68 <memcpy>
40003d5a:	83 c4 10             	add    $0x10,%esp
40003d5d:	8b 45 14             	mov    0x14(%ebp),%eax
40003d60:	ba 00 00 00 00       	mov    $0x0,%edx
40003d65:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40003d68:	89 41 08             	mov    %eax,0x8(%ecx)
40003d6b:	89 51 0c             	mov    %edx,0xc(%ecx)
40003d6e:	8b 55 fc             	mov    -0x4(%ebp),%edx
40003d71:	8b 45 18             	mov    0x18(%ebp),%eax
40003d74:	89 42 10             	mov    %eax,0x10(%edx)
40003d77:	8b 55 fc             	mov    -0x4(%ebp),%edx
40003d7a:	8b 45 1c             	mov    0x1c(%ebp),%eax
40003d7d:	89 42 1c             	mov    %eax,0x1c(%edx)
40003d80:	a1 48 a0 00 40       	mov    0x4000a048,%eax
40003d85:	8b 15 4c a0 00 40    	mov    0x4000a04c,%edx
40003d8b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40003d8e:	89 41 14             	mov    %eax,0x14(%ecx)
40003d91:	89 51 18             	mov    %edx,0x18(%ecx)
40003d94:	83 c0 01             	add    $0x1,%eax
40003d97:	83 d2 00             	adc    $0x0,%edx
40003d9a:	a3 48 a0 00 40       	mov    %eax,0x4000a048
40003d9f:	89 15 4c a0 00 40    	mov    %edx,0x4000a04c
40003da5:	e8 76 3e 00 00       	call   40007c20 <list_create>
40003daa:	89 c2                	mov    %eax,%edx
40003dac:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003daf:	89 50 20             	mov    %edx,0x20(%eax)
40003db2:	8b 55 fc             	mov    -0x4(%ebp),%edx
40003db5:	8b 45 08             	mov    0x8(%ebp),%eax
40003db8:	89 42 24             	mov    %eax,0x24(%edx)
40003dbb:	b8 01 00 00 00       	mov    $0x1,%eax
40003dc0:	c9                   	leave  
40003dc1:	c3                   	ret    

40003dc2 <vfstree_create_node>:
40003dc2:	55                   	push   %ebp
40003dc3:	89 e5                	mov    %esp,%ebp
40003dc5:	83 ec 18             	sub    $0x18,%esp
40003dc8:	8b 45 0c             	mov    0xc(%ebp),%eax
40003dcb:	88 45 ec             	mov    %al,-0x14(%ebp)
40003dce:	83 ec 0c             	sub    $0xc,%esp
40003dd1:	ff 75 08             	pushl  0x8(%ebp)
40003dd4:	e8 a7 fc ff ff       	call   40003a80 <vfstree_dirname>
40003dd9:	83 c4 10             	add    $0x10,%esp
40003ddc:	89 45 f4             	mov    %eax,-0xc(%ebp)
40003ddf:	83 ec 0c             	sub    $0xc,%esp
40003de2:	ff 75 08             	pushl  0x8(%ebp)
40003de5:	e8 5b fd ff ff       	call   40003b45 <vfstree_basename>
40003dea:	83 c4 10             	add    $0x10,%esp
40003ded:	89 45 f8             	mov    %eax,-0x8(%ebp)
40003df0:	83 ec 0c             	sub    $0xc,%esp
40003df3:	ff 75 f4             	pushl  -0xc(%ebp)
40003df6:	e8 fd fd ff ff       	call   40003bf8 <vfstree_get_node_by_path>
40003dfb:	83 c4 10             	add    $0x10,%esp
40003dfe:	89 45 fc             	mov    %eax,-0x4(%ebp)
40003e01:	83 ec 0c             	sub    $0xc,%esp
40003e04:	ff 75 f4             	pushl  -0xc(%ebp)
40003e07:	e8 a3 4b 00 00       	call   400089af <free>
40003e0c:	83 c4 10             	add    $0x10,%esp
40003e0f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40003e13:	75 19                	jne    40003e2e <vfstree_create_node+0x6c>
40003e15:	83 ec 0c             	sub    $0xc,%esp
40003e18:	68 d0 98 00 40       	push   $0x400098d0
40003e1d:	e8 11 27 00 00       	call   40006533 <puts>
40003e22:	83 c4 10             	add    $0x10,%esp
40003e25:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40003e2c:	eb 22                	jmp    40003e50 <vfstree_create_node+0x8e>
40003e2e:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
40003e32:	83 ec 08             	sub    $0x8,%esp
40003e35:	ff 75 18             	pushl  0x18(%ebp)
40003e38:	ff 75 14             	pushl  0x14(%ebp)
40003e3b:	ff 75 10             	pushl  0x10(%ebp)
40003e3e:	50                   	push   %eax
40003e3f:	ff 75 f8             	pushl  -0x8(%ebp)
40003e42:	ff 75 fc             	pushl  -0x4(%ebp)
40003e45:	e8 70 fe ff ff       	call   40003cba <vfstree_create_child>
40003e4a:	83 c4 20             	add    $0x20,%esp
40003e4d:	89 45 e8             	mov    %eax,-0x18(%ebp)
40003e50:	8b 45 e8             	mov    -0x18(%ebp),%eax
40003e53:	c9                   	leave  
40003e54:	c3                   	ret    

40003e55 <vfstree_delete_child>:
40003e55:	55                   	push   %ebp
40003e56:	89 e5                	mov    %esp,%ebp
40003e58:	83 ec 18             	sub    $0x18,%esp
40003e5b:	83 ec 08             	sub    $0x8,%esp
40003e5e:	ff 75 0c             	pushl  0xc(%ebp)
40003e61:	ff 75 08             	pushl  0x8(%ebp)
40003e64:	e8 25 fd ff ff       	call   40003b8e <vfstree_get_node_by_name>
40003e69:	83 c4 10             	add    $0x10,%esp
40003e6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
40003e6f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
40003e73:	74 06                	je     40003e7b <vfstree_delete_child+0x26>
40003e75:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
40003e79:	75 0c                	jne    40003e87 <vfstree_delete_child+0x32>
40003e7b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40003e82:	e9 ab 00 00 00       	jmp    40003f32 <vfstree_delete_child+0xdd>
40003e87:	e8 0c f3 ff ff       	call   40003198 <p>
40003e8c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40003e93:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40003e9a:	eb 03                	jmp    40003e9f <vfstree_delete_child+0x4a>
40003e9c:	ff 45 f8             	incl   -0x8(%ebp)
40003e9f:	8b 45 08             	mov    0x8(%ebp),%eax
40003ea2:	8b 40 20             	mov    0x20(%eax),%eax
40003ea5:	83 ec 08             	sub    $0x8,%esp
40003ea8:	ff 75 f8             	pushl  -0x8(%ebp)
40003eab:	50                   	push   %eax
40003eac:	e8 dc 3f 00 00       	call   40007e8d <list_get_element_at>
40003eb1:	83 c4 10             	add    $0x10,%esp
40003eb4:	89 45 fc             	mov    %eax,-0x4(%ebp)
40003eb7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40003ebb:	74 08                	je     40003ec5 <vfstree_delete_child+0x70>
40003ebd:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003ec0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
40003ec3:	75 d7                	jne    40003e9c <vfstree_delete_child+0x47>
40003ec5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40003ec9:	75 0e                	jne    40003ed9 <vfstree_delete_child+0x84>
40003ecb:	e8 d4 f2 ff ff       	call   400031a4 <v>
40003ed0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40003ed7:	eb 59                	jmp    40003f32 <vfstree_delete_child+0xdd>
40003ed9:	8b 45 08             	mov    0x8(%ebp),%eax
40003edc:	8b 40 20             	mov    0x20(%eax),%eax
40003edf:	83 ec 08             	sub    $0x8,%esp
40003ee2:	ff 75 f8             	pushl  -0x8(%ebp)
40003ee5:	50                   	push   %eax
40003ee6:	e8 8e 40 00 00       	call   40007f79 <list_remove>
40003eeb:	83 c4 10             	add    $0x10,%esp
40003eee:	e8 b1 f2 ff ff       	call   400031a4 <v>
40003ef3:	8b 45 08             	mov    0x8(%ebp),%eax
40003ef6:	8b 50 0c             	mov    0xc(%eax),%edx
40003ef9:	8b 40 08             	mov    0x8(%eax),%eax
40003efc:	83 c0 ff             	add    $0xffffffff,%eax
40003eff:	83 d2 ff             	adc    $0xffffffff,%edx
40003f02:	8b 4d 08             	mov    0x8(%ebp),%ecx
40003f05:	89 41 08             	mov    %eax,0x8(%ecx)
40003f08:	89 51 0c             	mov    %edx,0xc(%ecx)
40003f0b:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003f0e:	8b 40 04             	mov    0x4(%eax),%eax
40003f11:	83 ec 0c             	sub    $0xc,%esp
40003f14:	50                   	push   %eax
40003f15:	e8 95 4a 00 00       	call   400089af <free>
40003f1a:	83 c4 10             	add    $0x10,%esp
40003f1d:	83 ec 0c             	sub    $0xc,%esp
40003f20:	ff 75 fc             	pushl  -0x4(%ebp)
40003f23:	e8 87 4a 00 00       	call   400089af <free>
40003f28:	83 c4 10             	add    $0x10,%esp
40003f2b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
40003f32:	8b 45 ec             	mov    -0x14(%ebp),%eax
40003f35:	c9                   	leave  
40003f36:	c3                   	ret    

40003f37 <vfstree_delete_node>:
40003f37:	55                   	push   %ebp
40003f38:	89 e5                	mov    %esp,%ebp
40003f3a:	83 ec 18             	sub    $0x18,%esp
40003f3d:	83 ec 0c             	sub    $0xc,%esp
40003f40:	ff 75 08             	pushl  0x8(%ebp)
40003f43:	e8 38 fb ff ff       	call   40003a80 <vfstree_dirname>
40003f48:	83 c4 10             	add    $0x10,%esp
40003f4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
40003f4e:	83 ec 0c             	sub    $0xc,%esp
40003f51:	ff 75 08             	pushl  0x8(%ebp)
40003f54:	e8 ec fb ff ff       	call   40003b45 <vfstree_basename>
40003f59:	83 c4 10             	add    $0x10,%esp
40003f5c:	89 45 f8             	mov    %eax,-0x8(%ebp)
40003f5f:	83 ec 0c             	sub    $0xc,%esp
40003f62:	ff 75 f4             	pushl  -0xc(%ebp)
40003f65:	e8 8e fc ff ff       	call   40003bf8 <vfstree_get_node_by_path>
40003f6a:	83 c4 10             	add    $0x10,%esp
40003f6d:	89 45 fc             	mov    %eax,-0x4(%ebp)
40003f70:	83 ec 0c             	sub    $0xc,%esp
40003f73:	ff 75 f4             	pushl  -0xc(%ebp)
40003f76:	e8 34 4a 00 00       	call   400089af <free>
40003f7b:	83 c4 10             	add    $0x10,%esp
40003f7e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40003f82:	75 09                	jne    40003f8d <vfstree_delete_node+0x56>
40003f84:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40003f8b:	eb 14                	jmp    40003fa1 <vfstree_delete_node+0x6a>
40003f8d:	83 ec 08             	sub    $0x8,%esp
40003f90:	ff 75 f8             	pushl  -0x8(%ebp)
40003f93:	ff 75 fc             	pushl  -0x4(%ebp)
40003f96:	e8 ba fe ff ff       	call   40003e55 <vfstree_delete_child>
40003f9b:	83 c4 10             	add    $0x10,%esp
40003f9e:	89 45 ec             	mov    %eax,-0x14(%ebp)
40003fa1:	8b 45 ec             	mov    -0x14(%ebp),%eax
40003fa4:	c9                   	leave  
40003fa5:	c3                   	ret    

40003fa6 <vfstree_clear_node>:
40003fa6:	55                   	push   %ebp
40003fa7:	89 e5                	mov    %esp,%ebp
40003fa9:	83 ec 18             	sub    $0x18,%esp
40003fac:	8b 45 08             	mov    0x8(%ebp),%eax
40003faf:	8b 50 0c             	mov    0xc(%eax),%edx
40003fb2:	8b 40 08             	mov    0x8(%eax),%eax
40003fb5:	09 d0                	or     %edx,%eax
40003fb7:	85 c0                	test   %eax,%eax
40003fb9:	74 5c                	je     40004017 <vfstree_clear_node+0x71>
40003fbb:	eb 2e                	jmp    40003feb <vfstree_clear_node+0x45>
40003fbd:	83 ec 0c             	sub    $0xc,%esp
40003fc0:	ff 75 fc             	pushl  -0x4(%ebp)
40003fc3:	e8 de ff ff ff       	call   40003fa6 <vfstree_clear_node>
40003fc8:	83 c4 10             	add    $0x10,%esp
40003fcb:	8b 45 fc             	mov    -0x4(%ebp),%eax
40003fce:	8b 40 10             	mov    0x10(%eax),%eax
40003fd1:	83 ec 0c             	sub    $0xc,%esp
40003fd4:	50                   	push   %eax
40003fd5:	e8 d5 49 00 00       	call   400089af <free>
40003fda:	83 c4 10             	add    $0x10,%esp
40003fdd:	83 ec 0c             	sub    $0xc,%esp
40003fe0:	ff 75 fc             	pushl  -0x4(%ebp)
40003fe3:	e8 c7 49 00 00       	call   400089af <free>
40003fe8:	83 c4 10             	add    $0x10,%esp
40003feb:	8b 45 08             	mov    0x8(%ebp),%eax
40003fee:	8b 40 20             	mov    0x20(%eax),%eax
40003ff1:	83 ec 0c             	sub    $0xc,%esp
40003ff4:	50                   	push   %eax
40003ff5:	e8 41 3d 00 00       	call   40007d3b <list_pop>
40003ffa:	83 c4 10             	add    $0x10,%esp
40003ffd:	89 45 fc             	mov    %eax,-0x4(%ebp)
40004000:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40004004:	75 b7                	jne    40003fbd <vfstree_clear_node+0x17>
40004006:	8b 45 08             	mov    0x8(%ebp),%eax
40004009:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
40004010:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
40004017:	c9                   	leave  
40004018:	c3                   	ret    
40004019:	90                   	nop    
4000401a:	90                   	nop    
4000401b:	90                   	nop    

4000401c <init_signals>:
 * ATA-Geraet identifizieren
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
 */
int ata_drv_identify(struct ata_device* dev)
{
4000401c:	55                   	push   %ebp
4000401d:	89 e5                	mov    %esp,%ebp
4000401f:	83 ec 10             	sub    $0x10,%esp
    uint8_t buffer[ATA_SECTOR_SIZE];

40004022:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40004029:	eb 11                	jmp    4000403c <init_signals+0x20>
    // Request vorbereiten
4000402b:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000402e:	c7 04 85 00 a5 00 40 	movl   $0x400040e5,0x4000a500(,%eax,4)
40004035:	e5 40 00 40 
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
 */
int ata_drv_identify(struct ata_device* dev)
{
    uint8_t buffer[ATA_SECTOR_SIZE];

40004039:	ff 45 fc             	incl   -0x4(%ebp)
4000403c:	83 7d fc 3f          	cmpl   $0x3f,-0x4(%ebp)
40004040:	7e e9                	jle    4000402b <init_signals+0xf>
    // Request vorbereiten
    struct ata_request request = {
        .dev = dev,

40004042:	c7 05 e0 a4 00 40 01 	movl   $0x1,0x4000a4e0
40004049:	00 00 00 
        .flags.direction = READ,
4000404c:	c9                   	leave  
4000404d:	c3                   	ret    

4000404e <raise>:
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

4000404e:	55                   	push   %ebp
4000404f:	89 e5                	mov    %esp,%ebp
40004051:	83 ec 18             	sub    $0x18,%esp
        .error = 0
    };
40004054:	a1 e0 a4 00 40       	mov    0x4000a4e0,%eax
40004059:	85 c0                	test   %eax,%eax
4000405b:	75 05                	jne    40004062 <raise+0x14>
    
4000405d:	e8 ba ff ff ff       	call   4000401c <init_signals>
    // Request starten
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
40004062:	83 7d 08 3f          	cmpl   $0x3f,0x8(%ebp)
40004066:	7e 09                	jle    40004071 <raise+0x23>
    }
40004068:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
4000406f:	eb 28                	jmp    40004099 <raise+0x4b>
        
    // Ein ATA-Geraet
    dev->atapi = 0;
40004071:	8b 45 08             	mov    0x8(%ebp),%eax
40004074:	8b 04 85 00 a5 00 40 	mov    0x4000a500(,%eax,4),%eax
4000407b:	89 45 fc             	mov    %eax,-0x4(%ebp)

4000407e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40004082:	74 0e                	je     40004092 <raise+0x44>
    // TODO: Informationen verarbeiten
40004084:	83 ec 0c             	sub    $0xc,%esp
40004087:	ff 75 08             	pushl  0x8(%ebp)
4000408a:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000408d:	ff d0                	call   *%eax
4000408f:	83 c4 10             	add    $0x10,%esp

    return 1;
40004092:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40004099:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
4000409c:	c9                   	leave  
4000409d:	c3                   	ret    

4000409e <kill>:
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
4000409e:	55                   	push   %ebp
4000409f:	89 e5                	mov    %esp,%ebp
400040a1:	83 ec 08             	sub    $0x8,%esp
    void* buffer)
{
400040a4:	8b 45 0c             	mov    0xc(%ebp),%eax
400040a7:	05 00 01 00 00       	add    $0x100,%eax
400040ac:	3d ff 01 00 00       	cmp    $0x1ff,%eax
400040b1:	7e 09                	jle    400040bc <kill+0x1e>
    int result = 1;
400040b3:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
400040ba:	eb 24                	jmp    400040e0 <kill+0x42>
    struct ata_request request;
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
    // muss unter Umstaenden mehrmals gelesen werden.
400040bc:	8b 45 0c             	mov    0xc(%ebp),%eax
400040bf:	05 00 01 00 00       	add    $0x100,%eax
400040c4:	83 ec 0c             	sub    $0xc,%esp
400040c7:	6a 00                	push   $0x0
400040c9:	6a 00                	push   $0x0
400040cb:	6a 00                	push   $0x0
400040cd:	50                   	push   %eax
400040ce:	ff 75 08             	pushl  0x8(%ebp)
400040d1:	e8 5c f1 ff ff       	call   40003232 <send_message>
400040d6:	83 c4 20             	add    $0x20,%esp
    uint16_t current_count;
400040d9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
400040e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    void* current_buffer = buffer;
400040e3:	c9                   	leave  
400040e4:	c3                   	ret    

400040e5 <_signal_default_handler>:
    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;

    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
400040e5:	55                   	push   %ebp
400040e6:	89 e5                	mov    %esp,%ebp
400040e8:	83 ec 08             	sub    $0x8,%esp
        if (count_left > 256) {
400040eb:	8b 45 08             	mov    0x8(%ebp),%eax
400040ee:	48                   	dec    %eax
400040ef:	83 f8 0e             	cmp    $0xe,%eax
400040f2:	77 0d                	ja     40004101 <_signal_default_handler+0x1c>
        request.flags.poll = 1;
        request.flags.ata = 0;
        request.flags.lba = 1;

        request.registers.ata.command = READ_SECTORS;
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
400040f4:	83 ec 0c             	sub    $0xc,%esp
400040f7:	6a 01                	push   $0x1
400040f9:	e8 bd 03 00 00       	call   400044bb <_exit>
400040fe:	83 c4 10             	add    $0x10,%esp
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
        // 0 steht.
        request.registers.ata.count = (uint8_t) current_count;
40004101:	c9                   	leave  
40004102:	c3                   	ret    

40004103 <signal>:
        request.buffer = current_buffer;

        request.error = NO_ERROR;
        
        // TODO: LBA48
        // TODO: CHS
40004103:	55                   	push   %ebp
40004104:	89 e5                	mov    %esp,%ebp
40004106:	83 ec 14             	sub    $0x14,%esp
        
        // Request ausfuehren
40004109:	a1 e0 a4 00 40       	mov    0x4000a4e0,%eax
4000410e:	85 c0                	test   %eax,%eax
40004110:	75 05                	jne    40004117 <signal+0x14>
        if (!ata_request(&request)) {
40004112:	e8 05 ff ff ff       	call   4000401c <init_signals>
            result = 0;
            break;
        }

40004117:	83 7d 08 3f          	cmpl   $0x3f,0x8(%ebp)
4000411b:	7f 06                	jg     40004123 <signal+0x20>
4000411d:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
40004121:	75 09                	jne    4000412c <signal+0x29>
        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
40004123:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
4000412a:	eb 20                	jmp    4000414c <signal+0x49>
        current_buffer += current_count * ATA_SECTOR_SIZE;
        count_left -= current_count;
        lba += current_count;
    }
4000412c:	8b 45 08             	mov    0x8(%ebp),%eax
4000412f:	8b 04 85 00 a5 00 40 	mov    0x4000a500(,%eax,4),%eax
40004136:	89 45 fc             	mov    %eax,-0x4(%ebp)

    return result;
}
40004139:	8b 55 08             	mov    0x8(%ebp),%edx
4000413c:	8b 45 0c             	mov    0xc(%ebp),%eax
4000413f:	89 04 95 00 a5 00 40 	mov    %eax,0x4000a500(,%edx,4)

40004146:	8b 45 fc             	mov    -0x4(%ebp),%eax
40004149:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000414c:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000414f:	c9                   	leave  
40004150:	c3                   	ret    

40004151 <sigemptyset>:
40004151:	55                   	push   %ebp
40004152:	89 e5                	mov    %esp,%ebp
40004154:	83 ec 08             	sub    $0x8,%esp
40004157:	8b 45 08             	mov    0x8(%ebp),%eax
4000415a:	83 ec 04             	sub    $0x4,%esp
4000415d:	6a 08                	push   $0x8
4000415f:	6a 00                	push   $0x0
40004161:	50                   	push   %eax
40004162:	e8 ad 4f 00 00       	call   40009114 <memset>
40004167:	83 c4 10             	add    $0x10,%esp
4000416a:	b8 00 00 00 00       	mov    $0x0,%eax
4000416f:	c9                   	leave  
40004170:	c3                   	ret    

40004171 <sigfillset>:
40004171:	55                   	push   %ebp
40004172:	89 e5                	mov    %esp,%ebp
40004174:	83 ec 08             	sub    $0x8,%esp
40004177:	8b 45 08             	mov    0x8(%ebp),%eax
4000417a:	83 ec 04             	sub    $0x4,%esp
4000417d:	6a 08                	push   $0x8
4000417f:	68 ff 00 00 00       	push   $0xff
40004184:	50                   	push   %eax
40004185:	e8 8a 4f 00 00       	call   40009114 <memset>
4000418a:	83 c4 10             	add    $0x10,%esp
4000418d:	b8 00 00 00 00       	mov    $0x0,%eax
40004192:	c9                   	leave  
40004193:	c3                   	ret    

40004194 <sigaddset>:
40004194:	55                   	push   %ebp
40004195:	89 e5                	mov    %esp,%ebp
40004197:	83 ec 14             	sub    $0x14,%esp
4000419a:	83 7d 0c 3f          	cmpl   $0x3f,0xc(%ebp)
4000419e:	7e 13                	jle    400041b3 <sigaddset+0x1f>
400041a0:	c7 05 28 a8 00 40 02 	movl   $0x2,0x4000a828
400041a7:	00 00 00 
400041aa:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
400041b1:	eb 61                	jmp    40004214 <sigaddset+0x80>
400041b3:	8b 45 0c             	mov    0xc(%ebp),%eax
400041b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
400041b9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
400041bd:	79 04                	jns    400041c3 <sigaddset+0x2f>
400041bf:	83 45 f0 07          	addl   $0x7,-0x10(%ebp)
400041c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
400041c6:	c1 f8 03             	sar    $0x3,%eax
400041c9:	89 45 f8             	mov    %eax,-0x8(%ebp)
400041cc:	89 c2                	mov    %eax,%edx
400041ce:	8b 45 08             	mov    0x8(%ebp),%eax
400041d1:	8a 04 10             	mov    (%eax,%edx,1),%al
400041d4:	88 45 ff             	mov    %al,-0x1(%ebp)
400041d7:	8b 45 0c             	mov    0xc(%ebp),%eax
400041da:	89 c2                	mov    %eax,%edx
400041dc:	81 e2 07 00 00 80    	and    $0x80000007,%edx
400041e2:	89 55 ec             	mov    %edx,-0x14(%ebp)
400041e5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
400041e9:	79 0a                	jns    400041f5 <sigaddset+0x61>
400041eb:	ff 4d ec             	decl   -0x14(%ebp)
400041ee:	83 4d ec f8          	orl    $0xfffffff8,-0x14(%ebp)
400041f2:	ff 45 ec             	incl   -0x14(%ebp)
400041f5:	8b 4d ec             	mov    -0x14(%ebp),%ecx
400041f8:	b8 01 00 00 00       	mov    $0x1,%eax
400041fd:	d3 e0                	shl    %cl,%eax
400041ff:	0a 45 ff             	or     -0x1(%ebp),%al
40004202:	88 c2                	mov    %al,%dl
40004204:	8b 45 08             	mov    0x8(%ebp),%eax
40004207:	8b 4d f8             	mov    -0x8(%ebp),%ecx
4000420a:	88 14 08             	mov    %dl,(%eax,%ecx,1)
4000420d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40004214:	8b 45 f4             	mov    -0xc(%ebp),%eax
40004217:	c9                   	leave  
40004218:	c3                   	ret    

40004219 <sigdelset>:
40004219:	55                   	push   %ebp
4000421a:	89 e5                	mov    %esp,%ebp
4000421c:	83 ec 14             	sub    $0x14,%esp
4000421f:	83 7d 0c 3f          	cmpl   $0x3f,0xc(%ebp)
40004223:	7e 13                	jle    40004238 <sigdelset+0x1f>
40004225:	c7 05 28 a8 00 40 02 	movl   $0x2,0x4000a828
4000422c:	00 00 00 
4000422f:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
40004236:	eb 63                	jmp    4000429b <sigdelset+0x82>
40004238:	8b 45 0c             	mov    0xc(%ebp),%eax
4000423b:	89 45 f0             	mov    %eax,-0x10(%ebp)
4000423e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
40004242:	79 04                	jns    40004248 <sigdelset+0x2f>
40004244:	83 45 f0 07          	addl   $0x7,-0x10(%ebp)
40004248:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000424b:	c1 f8 03             	sar    $0x3,%eax
4000424e:	89 45 f8             	mov    %eax,-0x8(%ebp)
40004251:	89 c2                	mov    %eax,%edx
40004253:	8b 45 08             	mov    0x8(%ebp),%eax
40004256:	8a 04 10             	mov    (%eax,%edx,1),%al
40004259:	88 45 ff             	mov    %al,-0x1(%ebp)
4000425c:	8b 45 0c             	mov    0xc(%ebp),%eax
4000425f:	89 c2                	mov    %eax,%edx
40004261:	81 e2 07 00 00 80    	and    $0x80000007,%edx
40004267:	89 55 ec             	mov    %edx,-0x14(%ebp)
4000426a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
4000426e:	79 0a                	jns    4000427a <sigdelset+0x61>
40004270:	ff 4d ec             	decl   -0x14(%ebp)
40004273:	83 4d ec f8          	orl    $0xfffffff8,-0x14(%ebp)
40004277:	ff 45 ec             	incl   -0x14(%ebp)
4000427a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
4000427d:	b8 01 00 00 00       	mov    $0x1,%eax
40004282:	d3 e0                	shl    %cl,%eax
40004284:	f7 d0                	not    %eax
40004286:	22 45 ff             	and    -0x1(%ebp),%al
40004289:	88 c2                	mov    %al,%dl
4000428b:	8b 45 08             	mov    0x8(%ebp),%eax
4000428e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
40004291:	88 14 08             	mov    %dl,(%eax,%ecx,1)
40004294:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
4000429b:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000429e:	c9                   	leave  
4000429f:	c3                   	ret    

400042a0 <sigismember>:
400042a0:	55                   	push   %ebp
400042a1:	89 e5                	mov    %esp,%ebp
400042a3:	83 ec 10             	sub    $0x10,%esp
400042a6:	83 7d 0c 3f          	cmpl   $0x3f,0xc(%ebp)
400042aa:	7e 13                	jle    400042bf <sigismember+0x1f>
400042ac:	c7 05 28 a8 00 40 02 	movl   $0x2,0x4000a828
400042b3:	00 00 00 
400042b6:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
400042bd:	eb 52                	jmp    40004311 <sigismember+0x71>
400042bf:	8b 45 0c             	mov    0xc(%ebp),%eax
400042c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
400042c5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
400042c9:	79 04                	jns    400042cf <sigismember+0x2f>
400042cb:	83 45 f4 07          	addl   $0x7,-0xc(%ebp)
400042cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
400042d2:	c1 f8 03             	sar    $0x3,%eax
400042d5:	89 c2                	mov    %eax,%edx
400042d7:	8b 45 08             	mov    0x8(%ebp),%eax
400042da:	8a 04 10             	mov    (%eax,%edx,1),%al
400042dd:	0f b6 c0             	movzbl %al,%eax
400042e0:	89 45 fc             	mov    %eax,-0x4(%ebp)
400042e3:	8b 45 0c             	mov    0xc(%ebp),%eax
400042e6:	89 c2                	mov    %eax,%edx
400042e8:	81 e2 07 00 00 80    	and    $0x80000007,%edx
400042ee:	89 55 f0             	mov    %edx,-0x10(%ebp)
400042f1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
400042f5:	79 0a                	jns    40004301 <sigismember+0x61>
400042f7:	ff 4d f0             	decl   -0x10(%ebp)
400042fa:	83 4d f0 f8          	orl    $0xfffffff8,-0x10(%ebp)
400042fe:	ff 45 f0             	incl   -0x10(%ebp)
40004301:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40004304:	8b 45 fc             	mov    -0x4(%ebp),%eax
40004307:	d3 f8                	sar    %cl,%eax
40004309:	89 c2                	mov    %eax,%edx
4000430b:	83 e2 01             	and    $0x1,%edx
4000430e:	89 55 f8             	mov    %edx,-0x8(%ebp)
40004311:	8b 45 f8             	mov    -0x8(%ebp),%eax
40004314:	c9                   	leave  
40004315:	c3                   	ret    
40004316:	90                   	nop    
40004317:	90                   	nop    

40004318 <asprintf_putc>:
/**
 * ATA-Geraet identifizieren
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
 */
int ata_drv_identify(struct ata_device* dev)
40004318:	55                   	push   %ebp
40004319:	89 e5                	mov    %esp,%ebp
4000431b:	83 ec 08             	sub    $0x8,%esp
4000431e:	8b 45 0c             	mov    0xc(%ebp),%eax
40004321:	88 45 fc             	mov    %al,-0x4(%ebp)
{
40004324:	8b 45 08             	mov    0x8(%ebp),%eax
40004327:	8b 50 08             	mov    0x8(%eax),%edx
4000432a:	8b 45 08             	mov    0x8(%ebp),%eax
4000432d:	8b 40 04             	mov    0x4(%eax),%eax
40004330:	48                   	dec    %eax
40004331:	39 c2                	cmp    %eax,%edx
40004333:	75 43                	jne    40004378 <asprintf_putc+0x60>
    uint8_t buffer[ATA_SECTOR_SIZE];

40004335:	8b 45 08             	mov    0x8(%ebp),%eax
40004338:	8b 40 04             	mov    0x4(%eax),%eax
4000433b:	8d 14 00             	lea    (%eax,%eax,1),%edx
4000433e:	8b 45 08             	mov    0x8(%ebp),%eax
40004341:	89 50 04             	mov    %edx,0x4(%eax)
    // Request vorbereiten
40004344:	8b 45 08             	mov    0x8(%ebp),%eax
40004347:	8b 40 04             	mov    0x4(%eax),%eax
4000434a:	8d 14 00             	lea    (%eax,%eax,1),%edx
4000434d:	8b 45 08             	mov    0x8(%ebp),%eax
40004350:	8b 00                	mov    (%eax),%eax
40004352:	83 ec 08             	sub    $0x8,%esp
40004355:	52                   	push   %edx
40004356:	50                   	push   %eax
40004357:	e8 23 49 00 00       	call   40008c7f <realloc>
4000435c:	83 c4 10             	add    $0x10,%esp
4000435f:	89 c2                	mov    %eax,%edx
40004361:	8b 45 08             	mov    0x8(%ebp),%eax
40004364:	89 10                	mov    %edx,(%eax)
    struct ata_request request = {
40004366:	8b 45 08             	mov    0x8(%ebp),%eax
40004369:	8b 00                	mov    (%eax),%eax
4000436b:	85 c0                	test   %eax,%eax
4000436d:	75 09                	jne    40004378 <asprintf_putc+0x60>
        .dev = dev,

4000436f:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
40004376:	eb 24                	jmp    4000439c <asprintf_putc+0x84>
        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,

40004378:	8b 45 08             	mov    0x8(%ebp),%eax
4000437b:	8b 10                	mov    (%eax),%edx
4000437d:	8b 45 08             	mov    0x8(%ebp),%eax
40004380:	8b 48 08             	mov    0x8(%eax),%ecx
40004383:	89 c8                	mov    %ecx,%eax
40004385:	01 c2                	add    %eax,%edx
40004387:	8a 45 fc             	mov    -0x4(%ebp),%al
4000438a:	88 02                	mov    %al,(%edx)
4000438c:	8d 51 01             	lea    0x1(%ecx),%edx
4000438f:	8b 45 08             	mov    0x8(%ebp),%eax
40004392:	89 50 08             	mov    %edx,0x8(%eax)
        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
40004395:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
4000439c:	8b 45 f8             	mov    -0x8(%ebp),%eax
        .registers.ata.command = IDENTIFY_DEVICE,
4000439f:	c9                   	leave  
400043a0:	c3                   	ret    

400043a1 <vasprintf>:
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,
400043a1:	55                   	push   %ebp
400043a2:	89 e5                	mov    %esp,%ebp
400043a4:	83 ec 28             	sub    $0x28,%esp

        .error = 0
400043a7:	b8 18 43 00 40       	mov    $0x40004318,%eax
400043ac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400043af:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
400043b6:	8d 45 f0             	lea    -0x10(%ebp),%eax
400043b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    };
    
    // Request starten
400043bc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
400043c0:	75 0c                	jne    400043ce <vasprintf+0x2d>
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
400043c2:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
400043c9:	e9 93 00 00 00       	jmp    40004461 <vasprintf+0xc0>
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
    }
400043ce:	83 ec 0c             	sub    $0xc,%esp
400043d1:	6a 40                	push   $0x40
400043d3:	e8 00 3f 00 00       	call   400082d8 <malloc>
400043d8:	83 c4 10             	add    $0x10,%esp
400043db:	89 45 f0             	mov    %eax,-0x10(%ebp)
        
400043de:	8b 45 f0             	mov    -0x10(%ebp),%eax
400043e1:	85 c0                	test   %eax,%eax
400043e3:	75 09                	jne    400043ee <vasprintf+0x4d>
    // Ein ATA-Geraet
    dev->atapi = 0;
400043e5:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
400043ec:	eb 73                	jmp    40004461 <vasprintf+0xc0>

    // TODO: Informationen verarbeiten

400043ee:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    return 1;
400043f5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
}

400043fc:	83 ec 04             	sub    $0x4,%esp
400043ff:	ff 75 10             	pushl  0x10(%ebp)
40004402:	ff 75 0c             	pushl  0xc(%ebp)
40004405:	8d 45 e4             	lea    -0x1c(%ebp),%eax
40004408:	50                   	push   %eax
40004409:	e8 64 10 00 00       	call   40005472 <jvprintf>
4000440e:	83 c4 10             	add    $0x10,%esp
40004411:	89 45 fc             	mov    %eax,-0x4(%ebp)
/**
 * Sektoren von einem ATA-Geraet lesen
 *
40004414:	83 ec 08             	sub    $0x8,%esp
40004417:	6a 00                	push   $0x0
40004419:	8d 45 f0             	lea    -0x10(%ebp),%eax
4000441c:	50                   	push   %eax
4000441d:	e8 f6 fe ff ff       	call   40004318 <asprintf_putc>
40004422:	83 c4 10             	add    $0x10,%esp
40004425:	83 f8 ff             	cmp    $0xffffffff,%eax
40004428:	75 09                	jne    40004433 <vasprintf+0x92>
 * @param start LBA des Startsektors
 * @param count Anzahl der Sektoren
4000442a:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
40004431:	eb 2e                	jmp    40004461 <vasprintf+0xc0>
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
40004433:	8b 55 f8             	mov    -0x8(%ebp),%edx
40004436:	8b 45 f4             	mov    -0xc(%ebp),%eax
40004439:	39 c2                	cmp    %eax,%edx
4000443b:	73 16                	jae    40004453 <vasprintf+0xb2>
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
4000443d:	8b 45 f8             	mov    -0x8(%ebp),%eax
40004440:	8b 55 f0             	mov    -0x10(%ebp),%edx
40004443:	83 ec 08             	sub    $0x8,%esp
40004446:	50                   	push   %eax
40004447:	52                   	push   %edx
40004448:	e8 32 48 00 00       	call   40008c7f <realloc>
4000444d:	83 c4 10             	add    $0x10,%esp
40004450:	89 45 f0             	mov    %eax,-0x10(%ebp)
{
    int result = 1;
    struct ata_request request;
40004453:	8b 55 f0             	mov    -0x10(%ebp),%edx
40004456:	8b 45 08             	mov    0x8(%ebp),%eax
40004459:	89 10                	mov    %edx,(%eax)
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
    // muss unter Umstaenden mehrmals gelesen werden.
4000445b:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000445e:	89 45 dc             	mov    %eax,-0x24(%ebp)
40004461:	8b 45 dc             	mov    -0x24(%ebp),%eax
    uint16_t current_count;
40004464:	c9                   	leave  
40004465:	c3                   	ret    

40004466 <asprintf>:
    void* current_buffer = buffer;
    uint64_t lba = start;

40004466:	55                   	push   %ebp
40004467:	89 e5                	mov    %esp,%ebp
40004469:	83 ec 18             	sub    $0x18,%esp
    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;

    // Solange wie noch Sektoren uebrig sind, wird gelesen
4000446c:	8d 45 10             	lea    0x10(%ebp),%eax
4000446f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while (count_left > 0) {
40004472:	8b 45 f8             	mov    -0x8(%ebp),%eax
40004475:	83 ec 04             	sub    $0x4,%esp
40004478:	50                   	push   %eax
40004479:	ff 75 0c             	pushl  0xc(%ebp)
4000447c:	ff 75 08             	pushl  0x8(%ebp)
4000447f:	e8 1d ff ff ff       	call   400043a1 <vasprintf>
40004484:	83 c4 10             	add    $0x10,%esp
40004487:	89 45 fc             	mov    %eax,-0x4(%ebp)
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
        if (count_left > 256) {
            current_count = 256;
4000448a:	8b 45 fc             	mov    -0x4(%ebp),%eax
        } else {
4000448d:	c9                   	leave  
4000448e:	c3                   	ret    
4000448f:	90                   	nop    

40004490 <exit>:

#include "device.h"


/**
 * ATA-Geraet identifizieren
40004490:	55                   	push   %ebp
40004491:	89 e5                	mov    %esp,%ebp
40004493:	83 ec 08             	sub    $0x8,%esp
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
40004496:	83 ec 0c             	sub    $0xc,%esp
40004499:	ff 75 08             	pushl  0x8(%ebp)
4000449c:	e8 1a 00 00 00       	call   400044bb <_exit>
400044a1:	83 c4 10             	add    $0x10,%esp
 */
400044a4:	c9                   	leave  
400044a5:	c3                   	ret    

400044a6 <abort>:
int ata_drv_identify(struct ata_device* dev)
{
    uint8_t buffer[ATA_SECTOR_SIZE];

    // Request vorbereiten
    struct ata_request request = {
400044a6:	55                   	push   %ebp
400044a7:	89 e5                	mov    %esp,%ebp
400044a9:	83 ec 08             	sub    $0x8,%esp
        .dev = dev,
400044ac:	83 ec 0c             	sub    $0xc,%esp
400044af:	6a ff                	push   $0xffffffff
400044b1:	e8 05 00 00 00       	call   400044bb <_exit>
400044b6:	83 c4 10             	add    $0x10,%esp

400044b9:	c9                   	leave  
400044ba:	c3                   	ret    

400044bb <_exit>:
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
400044bb:	55                   	push   %ebp
400044bc:	89 e5                	mov    %esp,%ebp
400044be:	83 ec 08             	sub    $0x8,%esp
        .block_size = ATA_SECTOR_SIZE,
400044c1:	83 ec 0c             	sub    $0xc,%esp
400044c4:	ff 75 08             	pushl  0x8(%ebp)
400044c7:	e8 9c df ff ff       	call   40002468 <init_process_exit>
400044cc:	83 c4 10             	add    $0x10,%esp
        .buffer = buffer,
400044cf:	e8 ba d8 ff ff       	call   40001d8e <destroy_process>

        .error = 0
400044d4:	eb fe                	jmp    400044d4 <_exit+0x19>
400044d6:	90                   	nop    
400044d7:	90                   	nop    

400044d8 <fopen>:
    uint8_t buffer[ATA_SECTOR_SIZE];

    // Request vorbereiten
    struct ata_request request = {
        .dev = dev,

400044d8:	55                   	push   %ebp
400044d9:	89 e5                	mov    %esp,%ebp
400044db:	53                   	push   %ebx
400044dc:	83 ec 34             	sub    $0x34,%esp
400044df:	89 e0                	mov    %esp,%eax
400044e1:	89 45 d8             	mov    %eax,-0x28(%ebp)
        .flags.direction = READ,
400044e4:	83 ec 0c             	sub    $0xc,%esp
400044e7:	ff 75 08             	pushl  0x8(%ebp)
400044ea:	e8 63 e3 ff ff       	call   40002852 <io_get_absolute_path>
400044ef:	83 c4 10             	add    $0x10,%esp
400044f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
        .flags.poll = 1,
        .flags.lba = 0,

400044f5:	83 ec 0c             	sub    $0xc,%esp
400044f8:	ff 75 e8             	pushl  -0x18(%ebp)
400044fb:	e8 74 4d 00 00       	call   40009274 <strlen>
40004500:	83 c4 10             	add    $0x10,%esp
40004503:	83 c0 02             	add    $0x2,%eax
40004506:	83 c0 0f             	add    $0xf,%eax
40004509:	83 c0 0f             	add    $0xf,%eax
4000450c:	c1 e8 04             	shr    $0x4,%eax
4000450f:	c1 e0 04             	shl    $0x4,%eax
40004512:	29 c4                	sub    %eax,%esp
40004514:	89 65 d4             	mov    %esp,-0x2c(%ebp)
40004517:	8b 45 d4             	mov    -0x2c(%ebp),%eax
4000451a:	83 c0 0f             	add    $0xf,%eax
4000451d:	c1 e8 04             	shr    $0x4,%eax
40004520:	c1 e0 04             	shl    $0x4,%eax
40004523:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40004526:	8b 45 d4             	mov    -0x2c(%ebp),%eax
40004529:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
4000452c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000452f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
40004532:	8b 45 ec             	mov    -0x14(%ebp),%eax
40004535:	c6 00 00             	movb   $0x0,(%eax)
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,
40004538:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000453f:	e9 98 00 00 00       	jmp    400045dc <fopen+0x104>

40004544:	8b 45 f0             	mov    -0x10(%ebp),%eax
40004547:	03 45 0c             	add    0xc(%ebp),%eax
4000454a:	8a 00                	mov    (%eax),%al
4000454c:	0f be c0             	movsbl %al,%eax
4000454f:	83 e8 61             	sub    $0x61,%eax
40004552:	89 45 d0             	mov    %eax,-0x30(%ebp)
40004555:	83 7d d0 16          	cmpl   $0x16,-0x30(%ebp)
40004559:	77 7e                	ja     400045d9 <fopen+0x101>
4000455b:	8b 55 d0             	mov    -0x30(%ebp),%edx
4000455e:	8b 04 95 fc 98 00 40 	mov    0x400098fc(,%edx,4),%eax
40004565:	ff e0                	jmp    *%eax
        .error = 0
    };
40004567:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000456a:	8a 00                	mov    (%eax),%al
4000456c:	88 c2                	mov    %al,%dl
4000456e:	83 ca 01             	or     $0x1,%edx
40004571:	8b 45 ec             	mov    -0x14(%ebp),%eax
40004574:	88 10                	mov    %dl,(%eax)
    
40004576:	eb 61                	jmp    400045d9 <fopen+0x101>
    // Request starten
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
40004578:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000457b:	8a 00                	mov    (%eax),%al
4000457d:	88 c2                	mov    %al,%dl
4000457f:	83 ca 2a             	or     $0x2a,%edx
40004582:	8b 45 ec             	mov    -0x14(%ebp),%eax
40004585:	88 10                	mov    %dl,(%eax)
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
    }
        
40004587:	8b 55 0c             	mov    0xc(%ebp),%edx
4000458a:	42                   	inc    %edx
4000458b:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000458e:	8d 04 02             	lea    (%edx,%eax,1),%eax
40004591:	8a 00                	mov    (%eax),%al
40004593:	3c 2b                	cmp    $0x2b,%al
40004595:	75 42                	jne    400045d9 <fopen+0x101>
    // Ein ATA-Geraet
40004597:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000459a:	8a 00                	mov    (%eax),%al
4000459c:	88 c2                	mov    %al,%dl
4000459e:	83 ca 01             	or     $0x1,%edx
400045a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
400045a4:	88 10                	mov    %dl,(%eax)
    dev->atapi = 0;

400045a6:	eb 31                	jmp    400045d9 <fopen+0x101>
    // TODO: Informationen verarbeiten

    return 1;
400045a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
400045ab:	8a 00                	mov    (%eax),%al
400045ad:	88 c2                	mov    %al,%dl
400045af:	83 ca 26             	or     $0x26,%edx
400045b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
400045b5:	88 10                	mov    %dl,(%eax)
}

400045b7:	eb 20                	jmp    400045d9 <fopen+0x101>
/**
 * Sektoren von einem ATA-Geraet lesen
 *
400045b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
400045bc:	8a 00                	mov    (%eax),%al
400045be:	88 c2                	mov    %al,%dl
400045c0:	83 ca 10             	or     $0x10,%edx
400045c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
400045c6:	88 10                	mov    %dl,(%eax)
 * @param start LBA des Startsektors
400045c8:	eb 0f                	jmp    400045d9 <fopen+0x101>
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
400045ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
400045cd:	8a 00                	mov    (%eax),%al
400045cf:	88 c2                	mov    %al,%dl
400045d1:	83 ca 40             	or     $0x40,%edx
400045d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
400045d7:	88 10                	mov    %dl,(%eax)
        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,
400045d9:	ff 45 f0             	incl   -0x10(%ebp)
400045dc:	8b 5d f0             	mov    -0x10(%ebp),%ebx
400045df:	83 ec 0c             	sub    $0xc,%esp
400045e2:	ff 75 0c             	pushl  0xc(%ebp)
400045e5:	e8 8a 4c 00 00       	call   40009274 <strlen>
400045ea:	83 c4 10             	add    $0x10,%esp
400045ed:	39 c3                	cmp    %eax,%ebx
400045ef:	0f 82 4f ff ff ff    	jb     40004544 <fopen+0x6c>
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
{
    int result = 1;
    struct ata_request request;
400045f5:	83 ec 0c             	sub    $0xc,%esp
400045f8:	ff 75 e8             	pushl  -0x18(%ebp)
400045fb:	e8 74 4c 00 00       	call   40009274 <strlen>
40004600:	83 c4 10             	add    $0x10,%esp
40004603:	8d 50 01             	lea    0x1(%eax),%edx
40004606:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40004609:	40                   	inc    %eax
4000460a:	83 ec 04             	sub    $0x4,%esp
4000460d:	52                   	push   %edx
4000460e:	ff 75 e8             	pushl  -0x18(%ebp)
40004611:	50                   	push   %eax
40004612:	e8 51 49 00 00       	call   40008f68 <memcpy>
40004617:	83 c4 10             	add    $0x10,%esp
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
    // muss unter Umstaenden mehrmals gelesen werden.
    uint16_t current_count;
4000461a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
4000461d:	83 ec 0c             	sub    $0xc,%esp
40004620:	ff 75 e8             	pushl  -0x18(%ebp)
40004623:	e8 4c 4c 00 00       	call   40009274 <strlen>
40004628:	83 c4 10             	add    $0x10,%esp
4000462b:	83 c0 02             	add    $0x2,%eax
4000462e:	53                   	push   %ebx
4000462f:	50                   	push   %eax
40004630:	68 f0 98 00 40       	push   $0x400098f0
40004635:	6a 01                	push   $0x1
40004637:	e8 f1 ef ff ff       	call   4000362d <rpc_get_response>
4000463c:	83 c4 10             	add    $0x10,%esp
4000463f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* current_buffer = buffer;
    uint64_t lba = start;

    // Anzahl der Sektoren die noch uebrig sind
40004642:	83 ec 0c             	sub    $0xc,%esp
40004645:	ff 75 e8             	pushl  -0x18(%ebp)
40004648:	e8 62 43 00 00       	call   400089af <free>
4000464d:	83 c4 10             	add    $0x10,%esp
    size_t count_left = count;

40004650:	8b 45 f4             	mov    -0xc(%ebp),%eax
40004653:	8b 40 0c             	mov    0xc(%eax),%eax
40004656:	89 45 f8             	mov    %eax,-0x8(%ebp)
    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
40004659:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
4000465d:	74 14                	je     40004673 <fopen+0x19b>
4000465f:	8b 45 f8             	mov    -0x8(%ebp),%eax
40004662:	8b 40 04             	mov    0x4(%eax),%eax
40004665:	85 c0                	test   %eax,%eax
40004667:	74 0a                	je     40004673 <fopen+0x19b>
40004669:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000466c:	8b 40 08             	mov    0x8(%eax),%eax
4000466f:	85 c0                	test   %eax,%eax
40004671:	75 09                	jne    4000467c <fopen+0x1a4>
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
40004673:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;

    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
4000467a:	eb 25                	jmp    400046a1 <fopen+0x1c9>
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
        if (count_left > 256) {
            current_count = 256;
4000467c:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000467f:	c6 40 1c 00          	movb   $0x0,0x1c(%eax)
        } else {
40004683:	8b 45 f8             	mov    -0x8(%ebp),%eax
40004686:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
            current_count = count_left;
4000468d:	8b 45 f8             	mov    -0x8(%ebp),%eax
40004690:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
        }
40004697:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000469a:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
        
        // Request vorbereiten
400046a1:	83 ec 0c             	sub    $0xc,%esp
400046a4:	ff 75 f4             	pushl  -0xc(%ebp)
400046a7:	e8 03 43 00 00       	call   400089af <free>
400046ac:	83 c4 10             	add    $0x10,%esp
        request.dev = dev;
        // TODO: DMA, UltraDMA...
400046af:	8b 45 f8             	mov    -0x8(%ebp),%eax
400046b2:	8b 65 d8             	mov    -0x28(%ebp),%esp
        request.protocol = PIO;
400046b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400046b8:	c9                   	leave  
400046b9:	c3                   	ret    

400046ba <fclose>:

        request.registers.ata.command = READ_SECTORS;
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
        // 0 steht.
400046ba:	55                   	push   %ebp
400046bb:	89 e5                	mov    %esp,%ebp
400046bd:	83 ec 18             	sub    $0x18,%esp
        request.registers.ata.count = (uint8_t) current_count;
        request.registers.ata.lba = lba;

400046c0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
400046c4:	74 0a                	je     400046d0 <fclose+0x16>
400046c6:	8b 45 08             	mov    0x8(%ebp),%eax
400046c9:	8b 40 04             	mov    0x4(%eax),%eax
400046cc:	85 c0                	test   %eax,%eax
400046ce:	75 09                	jne    400046d9 <fclose+0x1f>
        request.block_count = current_count;
        request.block_size = ATA_SECTOR_SIZE;
400046d0:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
400046d7:	eb 33                	jmp    4000470c <fclose+0x52>
        request.blocks_done = 0;
        request.buffer = current_buffer;

400046d9:	8b 45 08             	mov    0x8(%ebp),%eax
400046dc:	89 c2                	mov    %eax,%edx
400046de:	8b 45 08             	mov    0x8(%ebp),%eax
400046e1:	8b 40 04             	mov    0x4(%eax),%eax
400046e4:	52                   	push   %edx
400046e5:	6a 04                	push   $0x4
400046e7:	68 58 99 00 40       	push   $0x40009958
400046ec:	50                   	push   %eax
400046ed:	e8 cb ed ff ff       	call   400034bd <rpc_get_dword>
400046f2:	83 c4 10             	add    $0x10,%esp
400046f5:	89 45 fc             	mov    %eax,-0x4(%ebp)
        request.error = NO_ERROR;
        
400046f8:	83 ec 0c             	sub    $0xc,%esp
400046fb:	ff 75 08             	pushl  0x8(%ebp)
400046fe:	e8 ac 42 00 00       	call   400089af <free>
40004703:	83 c4 10             	add    $0x10,%esp
        // TODO: LBA48
        // TODO: CHS
40004706:	8b 45 fc             	mov    -0x4(%ebp),%eax
40004709:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000470c:	8b 45 ec             	mov    -0x14(%ebp),%eax
        
4000470f:	c9                   	leave  
40004710:	c3                   	ret    

40004711 <fread>:
        count_left -= current_count;
        lba += current_count;
    }

    return result;
}
40004711:	55                   	push   %ebp
40004712:	89 e5                	mov    %esp,%ebp
40004714:	56                   	push   %esi
40004715:	53                   	push   %ebx
40004716:	83 ec 40             	sub    $0x40,%esp

40004719:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
4000471d:	74 0a                	je     40004729 <fread+0x18>
4000471f:	8b 45 14             	mov    0x14(%ebp),%eax
40004722:	8b 40 04             	mov    0x4(%eax),%eax
40004725:	85 c0                	test   %eax,%eax
40004727:	75 0c                	jne    40004735 <fread+0x24>
40004729:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
40004730:	e9 b3 02 00 00       	jmp    400049e8 <fread+0x2d7>
40004735:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
4000473c:	8b 45 14             	mov    0x14(%ebp),%eax
4000473f:	8b 40 1d             	mov    0x1d(%eax),%eax
40004742:	85 c0                	test   %eax,%eax
40004744:	0f 84 0a 01 00 00    	je     40004854 <fread+0x143>
4000474a:	8b 45 14             	mov    0x14(%ebp),%eax
4000474d:	8b 50 1d             	mov    0x1d(%eax),%edx
40004750:	8b 45 0c             	mov    0xc(%ebp),%eax
40004753:	89 c1                	mov    %eax,%ecx
40004755:	0f af 4d 10          	imul   0x10(%ebp),%ecx
40004759:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
4000475c:	89 55 bc             	mov    %edx,-0x44(%ebp)
4000475f:	8b 75 c4             	mov    -0x3c(%ebp),%esi
40004762:	39 75 bc             	cmp    %esi,-0x44(%ebp)
40004765:	76 06                	jbe    4000476d <fread+0x5c>
40004767:	8b 45 c4             	mov    -0x3c(%ebp),%eax
4000476a:	89 45 bc             	mov    %eax,-0x44(%ebp)
4000476d:	8b 55 bc             	mov    -0x44(%ebp),%edx
40004770:	89 55 d8             	mov    %edx,-0x28(%ebp)
40004773:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
4000477a:	eb 2d                	jmp    400047a9 <fread+0x98>
4000477c:	8b 45 08             	mov    0x8(%ebp),%eax
4000477f:	89 c2                	mov    %eax,%edx
40004781:	8b 45 dc             	mov    -0x24(%ebp),%eax
40004784:	8d 04 02             	lea    (%edx,%eax,1),%eax
40004787:	48                   	dec    %eax
40004788:	89 c1                	mov    %eax,%ecx
4000478a:	8b 45 14             	mov    0x14(%ebp),%eax
4000478d:	8b 58 21             	mov    0x21(%eax),%ebx
40004790:	8b 45 14             	mov    0x14(%ebp),%eax
40004793:	8b 50 1d             	mov    0x1d(%eax),%edx
40004796:	8b 45 dc             	mov    -0x24(%ebp),%eax
40004799:	89 d6                	mov    %edx,%esi
4000479b:	29 c6                	sub    %eax,%esi
4000479d:	89 f0                	mov    %esi,%eax
4000479f:	8d 04 03             	lea    (%ebx,%eax,1),%eax
400047a2:	8a 00                	mov    (%eax),%al
400047a4:	88 01                	mov    %al,(%ecx)
400047a6:	ff 45 dc             	incl   -0x24(%ebp)
400047a9:	8b 45 dc             	mov    -0x24(%ebp),%eax
400047ac:	3b 45 d8             	cmp    -0x28(%ebp),%eax
400047af:	76 cb                	jbe    4000477c <fread+0x6b>
400047b1:	8b 45 14             	mov    0x14(%ebp),%eax
400047b4:	8b 40 1d             	mov    0x1d(%eax),%eax
400047b7:	89 c2                	mov    %eax,%edx
400047b9:	2b 55 d8             	sub    -0x28(%ebp),%edx
400047bc:	8b 45 14             	mov    0x14(%ebp),%eax
400047bf:	89 50 1d             	mov    %edx,0x1d(%eax)
400047c2:	8b 45 14             	mov    0x14(%ebp),%eax
400047c5:	8b 50 1d             	mov    0x1d(%eax),%edx
400047c8:	8b 45 14             	mov    0x14(%ebp),%eax
400047cb:	8b 40 21             	mov    0x21(%eax),%eax
400047ce:	83 ec 08             	sub    $0x8,%esp
400047d1:	52                   	push   %edx
400047d2:	50                   	push   %eax
400047d3:	e8 a7 44 00 00       	call   40008c7f <realloc>
400047d8:	83 c4 10             	add    $0x10,%esp
400047db:	89 45 e0             	mov    %eax,-0x20(%ebp)
400047de:	8b 45 14             	mov    0x14(%ebp),%eax
400047e1:	8b 40 1d             	mov    0x1d(%eax),%eax
400047e4:	85 c0                	test   %eax,%eax
400047e6:	75 12                	jne    400047fa <fread+0xe9>
400047e8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
400047ec:	75 0c                	jne    400047fa <fread+0xe9>
400047ee:	8b 45 14             	mov    0x14(%ebp),%eax
400047f1:	c7 40 21 00 00 00 00 	movl   $0x0,0x21(%eax)
400047f8:	eb 43                	jmp    4000483d <fread+0x12c>
400047fa:	8b 45 14             	mov    0x14(%ebp),%eax
400047fd:	8b 40 1d             	mov    0x1d(%eax),%eax
40004800:	85 c0                	test   %eax,%eax
40004802:	75 20                	jne    40004824 <fread+0x113>
40004804:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
40004808:	74 1a                	je     40004824 <fread+0x113>
4000480a:	83 ec 0c             	sub    $0xc,%esp
4000480d:	ff 75 e0             	pushl  -0x20(%ebp)
40004810:	e8 9a 41 00 00       	call   400089af <free>
40004815:	83 c4 10             	add    $0x10,%esp
40004818:	8b 45 14             	mov    0x14(%ebp),%eax
4000481b:	c7 40 21 00 00 00 00 	movl   $0x0,0x21(%eax)
40004822:	eb 19                	jmp    4000483d <fread+0x12c>
40004824:	8b 45 14             	mov    0x14(%ebp),%eax
40004827:	8b 40 1d             	mov    0x1d(%eax),%eax
4000482a:	85 c0                	test   %eax,%eax
4000482c:	74 0f                	je     4000483d <fread+0x12c>
4000482e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
40004832:	74 09                	je     4000483d <fread+0x12c>
40004834:	8b 55 14             	mov    0x14(%ebp),%edx
40004837:	8b 45 e0             	mov    -0x20(%ebp),%eax
4000483a:	89 42 21             	mov    %eax,0x21(%edx)
4000483d:	8b 45 0c             	mov    0xc(%ebp),%eax
40004840:	0f af 45 10          	imul   0x10(%ebp),%eax
40004844:	3b 45 d8             	cmp    -0x28(%ebp),%eax
40004847:	75 0b                	jne    40004854 <fread+0x143>
40004849:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000484c:	89 45 c0             	mov    %eax,-0x40(%ebp)
4000484f:	e9 94 01 00 00       	jmp    400049e8 <fread+0x2d7>
40004854:	8b 45 14             	mov    0x14(%ebp),%eax
40004857:	8b 00                	mov    (%eax),%eax
40004859:	89 45 c8             	mov    %eax,-0x38(%ebp)
4000485c:	8b 45 0c             	mov    0xc(%ebp),%eax
4000485f:	89 45 cc             	mov    %eax,-0x34(%ebp)
40004862:	8b 45 10             	mov    0x10(%ebp),%eax
40004865:	89 45 d0             	mov    %eax,-0x30(%ebp)
40004868:	8b 45 0c             	mov    0xc(%ebp),%eax
4000486b:	0f af 45 10          	imul   0x10(%ebp),%eax
4000486f:	2b 45 d8             	sub    -0x28(%ebp),%eax
40004872:	3d 00 04 00 00       	cmp    $0x400,%eax
40004877:	0f 86 c9 00 00 00    	jbe    40004946 <fread+0x235>
4000487d:	8b 55 cc             	mov    -0x34(%ebp),%edx
40004880:	8b 45 d0             	mov    -0x30(%ebp),%eax
40004883:	0f af c2             	imul   %edx,%eax
40004886:	83 ec 0c             	sub    $0xc,%esp
40004889:	50                   	push   %eax
4000488a:	e8 1d 23 00 00       	call   40006bac <create_shared_memory>
4000488f:	83 c4 10             	add    $0x10,%esp
40004892:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40004895:	8b 45 d4             	mov    -0x2c(%ebp),%eax
40004898:	83 ec 0c             	sub    $0xc,%esp
4000489b:	50                   	push   %eax
4000489c:	e8 27 23 00 00       	call   40006bc8 <open_shared_memory>
400048a1:	83 c4 10             	add    $0x10,%esp
400048a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400048a7:	8d 55 c8             	lea    -0x38(%ebp),%edx
400048aa:	8b 45 14             	mov    0x14(%ebp),%eax
400048ad:	8b 40 04             	mov    0x4(%eax),%eax
400048b0:	52                   	push   %edx
400048b1:	6a 10                	push   $0x10
400048b3:	68 61 99 00 40       	push   $0x40009961
400048b8:	50                   	push   %eax
400048b9:	e8 6f ed ff ff       	call   4000362d <rpc_get_response>
400048be:	83 c4 10             	add    $0x10,%esp
400048c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
400048c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
400048c7:	8b 40 0c             	mov    0xc(%eax),%eax
400048ca:	8b 00                	mov    (%eax),%eax
400048cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
400048cf:	8b 45 d8             	mov    -0x28(%ebp),%eax
400048d2:	8b 55 ec             	mov    -0x14(%ebp),%edx
400048d5:	01 c2                	add    %eax,%edx
400048d7:	8b 45 0c             	mov    0xc(%ebp),%eax
400048da:	0f af 45 10          	imul   0x10(%ebp),%eax
400048de:	39 c2                	cmp    %eax,%edx
400048e0:	76 0d                	jbe    400048ef <fread+0x1de>
400048e2:	8b 45 0c             	mov    0xc(%ebp),%eax
400048e5:	0f af 45 10          	imul   0x10(%ebp),%eax
400048e9:	2b 45 d8             	sub    -0x28(%ebp),%eax
400048ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
400048ef:	8b 45 08             	mov    0x8(%ebp),%eax
400048f2:	03 45 d8             	add    -0x28(%ebp),%eax
400048f5:	83 ec 04             	sub    $0x4,%esp
400048f8:	ff 75 ec             	pushl  -0x14(%ebp)
400048fb:	ff 75 e4             	pushl  -0x1c(%ebp)
400048fe:	50                   	push   %eax
400048ff:	e8 64 46 00 00       	call   40008f68 <memcpy>
40004904:	83 c4 10             	add    $0x10,%esp
40004907:	8b 45 d4             	mov    -0x2c(%ebp),%eax
4000490a:	83 ec 0c             	sub    $0xc,%esp
4000490d:	50                   	push   %eax
4000490e:	e8 d1 22 00 00       	call   40006be4 <close_shared_memory>
40004913:	83 c4 10             	add    $0x10,%esp
40004916:	8b 45 e8             	mov    -0x18(%ebp),%eax
40004919:	8b 40 0c             	mov    0xc(%eax),%eax
4000491c:	83 ec 0c             	sub    $0xc,%esp
4000491f:	50                   	push   %eax
40004920:	e8 8a 40 00 00       	call   400089af <free>
40004925:	83 c4 10             	add    $0x10,%esp
40004928:	83 ec 0c             	sub    $0xc,%esp
4000492b:	ff 75 e8             	pushl  -0x18(%ebp)
4000492e:	e8 7c 40 00 00       	call   400089af <free>
40004933:	83 c4 10             	add    $0x10,%esp
40004936:	8b 45 d8             	mov    -0x28(%ebp),%eax
40004939:	8b 55 ec             	mov    -0x14(%ebp),%edx
4000493c:	01 c2                	add    %eax,%edx
4000493e:	89 55 c0             	mov    %edx,-0x40(%ebp)
40004941:	e9 a2 00 00 00       	jmp    400049e8 <fread+0x2d7>
40004946:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
4000494d:	83 ec 0c             	sub    $0xc,%esp
40004950:	ff 75 14             	pushl  0x14(%ebp)
40004953:	e8 46 07 00 00       	call   4000509e <fflush>
40004958:	83 c4 10             	add    $0x10,%esp
4000495b:	8d 55 c8             	lea    -0x38(%ebp),%edx
4000495e:	8b 45 14             	mov    0x14(%ebp),%eax
40004961:	8b 40 04             	mov    0x4(%eax),%eax
40004964:	52                   	push   %edx
40004965:	6a 10                	push   $0x10
40004967:	68 61 99 00 40       	push   $0x40009961
4000496c:	50                   	push   %eax
4000496d:	e8 bb ec ff ff       	call   4000362d <rpc_get_response>
40004972:	83 c4 10             	add    $0x10,%esp
40004975:	89 45 f0             	mov    %eax,-0x10(%ebp)
40004978:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000497b:	8b 40 08             	mov    0x8(%eax),%eax
4000497e:	89 45 f4             	mov    %eax,-0xc(%ebp)
40004981:	8b 45 d8             	mov    -0x28(%ebp),%eax
40004984:	8b 55 f4             	mov    -0xc(%ebp),%edx
40004987:	01 c2                	add    %eax,%edx
40004989:	8b 45 0c             	mov    0xc(%ebp),%eax
4000498c:	0f af 45 10          	imul   0x10(%ebp),%eax
40004990:	39 c2                	cmp    %eax,%edx
40004992:	76 0d                	jbe    400049a1 <fread+0x290>
40004994:	8b 45 0c             	mov    0xc(%ebp),%eax
40004997:	0f af 45 10          	imul   0x10(%ebp),%eax
4000499b:	2b 45 d8             	sub    -0x28(%ebp),%eax
4000499e:	89 45 f4             	mov    %eax,-0xc(%ebp)
400049a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
400049a4:	8b 50 0c             	mov    0xc(%eax),%edx
400049a7:	8b 45 08             	mov    0x8(%ebp),%eax
400049aa:	03 45 d8             	add    -0x28(%ebp),%eax
400049ad:	83 ec 04             	sub    $0x4,%esp
400049b0:	ff 75 f4             	pushl  -0xc(%ebp)
400049b3:	52                   	push   %edx
400049b4:	50                   	push   %eax
400049b5:	e8 ae 45 00 00       	call   40008f68 <memcpy>
400049ba:	83 c4 10             	add    $0x10,%esp
400049bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
400049c0:	8b 40 0c             	mov    0xc(%eax),%eax
400049c3:	83 ec 0c             	sub    $0xc,%esp
400049c6:	50                   	push   %eax
400049c7:	e8 e3 3f 00 00       	call   400089af <free>
400049cc:	83 c4 10             	add    $0x10,%esp
400049cf:	83 ec 0c             	sub    $0xc,%esp
400049d2:	ff 75 f0             	pushl  -0x10(%ebp)
400049d5:	e8 d5 3f 00 00       	call   400089af <free>
400049da:	83 c4 10             	add    $0x10,%esp
400049dd:	8b 45 d8             	mov    -0x28(%ebp),%eax
400049e0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
400049e3:	01 c1                	add    %eax,%ecx
400049e5:	89 4d c0             	mov    %ecx,-0x40(%ebp)
400049e8:	8b 45 c0             	mov    -0x40(%ebp),%eax
400049eb:	8d 65 f8             	lea    -0x8(%ebp),%esp
400049ee:	5b                   	pop    %ebx
400049ef:	5e                   	pop    %esi
400049f0:	c9                   	leave  
400049f1:	c3                   	ret    

400049f2 <fgetc>:
400049f2:	55                   	push   %ebp
400049f3:	89 e5                	mov    %esp,%ebp
400049f5:	83 ec 18             	sub    $0x18,%esp
400049f8:	83 ec 0c             	sub    $0xc,%esp
400049fb:	ff 75 08             	pushl  0x8(%ebp)
400049fe:	e8 fd 05 00 00       	call   40005000 <feof>
40004a03:	83 c4 10             	add    $0x10,%esp
40004a06:	85 c0                	test   %eax,%eax
40004a08:	75 23                	jne    40004a2d <fgetc+0x3b>
40004a0a:	ff 75 08             	pushl  0x8(%ebp)
40004a0d:	6a 01                	push   $0x1
40004a0f:	6a 01                	push   $0x1
40004a11:	8d 45 ff             	lea    -0x1(%ebp),%eax
40004a14:	50                   	push   %eax
40004a15:	e8 f7 fc ff ff       	call   40004711 <fread>
40004a1a:	83 c4 10             	add    $0x10,%esp
40004a1d:	83 f8 01             	cmp    $0x1,%eax
40004a20:	75 0b                	jne    40004a2d <fgetc+0x3b>
40004a22:	8a 45 ff             	mov    -0x1(%ebp),%al
40004a25:	0f be c0             	movsbl %al,%eax
40004a28:	89 45 ec             	mov    %eax,-0x14(%ebp)
40004a2b:	eb 07                	jmp    40004a34 <fgetc+0x42>
40004a2d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
40004a34:	8b 45 ec             	mov    -0x14(%ebp),%eax
40004a37:	c9                   	leave  
40004a38:	c3                   	ret    

40004a39 <fgets>:
40004a39:	55                   	push   %ebp
40004a3a:	89 e5                	mov    %esp,%ebp
40004a3c:	83 ec 18             	sub    $0x18,%esp
40004a3f:	83 ec 0c             	sub    $0xc,%esp
40004a42:	ff 75 10             	pushl  0x10(%ebp)
40004a45:	e8 b6 05 00 00       	call   40005000 <feof>
40004a4a:	83 c4 10             	add    $0x10,%esp
40004a4d:	85 c0                	test   %eax,%eax
40004a4f:	75 12                	jne    40004a63 <fgets+0x2a>
40004a51:	83 ec 0c             	sub    $0xc,%esp
40004a54:	ff 75 10             	pushl  0x10(%ebp)
40004a57:	e8 0e 06 00 00       	call   4000506a <ferror>
40004a5c:	83 c4 10             	add    $0x10,%esp
40004a5f:	85 c0                	test   %eax,%eax
40004a61:	74 09                	je     40004a6c <fgets+0x33>
40004a63:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40004a6a:	eb 7b                	jmp    40004ae7 <fgets+0xae>
40004a6c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40004a73:	eb 4e                	jmp    40004ac3 <fgets+0x8a>
40004a75:	83 ec 0c             	sub    $0xc,%esp
40004a78:	ff 75 10             	pushl  0x10(%ebp)
40004a7b:	e8 72 ff ff ff       	call   400049f2 <fgetc>
40004a80:	83 c4 10             	add    $0x10,%esp
40004a83:	89 45 fc             	mov    %eax,-0x4(%ebp)
40004a86:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%ebp)
40004a8a:	75 1b                	jne    40004aa7 <fgets+0x6e>
40004a8c:	83 ec 0c             	sub    $0xc,%esp
40004a8f:	ff 75 10             	pushl  0x10(%ebp)
40004a92:	e8 d3 05 00 00       	call   4000506a <ferror>
40004a97:	83 c4 10             	add    $0x10,%esp
40004a9a:	85 c0                	test   %eax,%eax
40004a9c:	74 09                	je     40004aa7 <fgets+0x6e>
40004a9e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40004aa5:	eb 25                	jmp    40004acc <fgets+0x93>
40004aa7:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%ebp)
40004aab:	74 13                	je     40004ac0 <fgets+0x87>
40004aad:	83 7d fc 0a          	cmpl   $0xa,-0x4(%ebp)
40004ab1:	74 19                	je     40004acc <fgets+0x93>
40004ab3:	8b 45 fc             	mov    -0x4(%ebp),%eax
40004ab6:	88 c2                	mov    %al,%dl
40004ab8:	8b 45 08             	mov    0x8(%ebp),%eax
40004abb:	88 10                	mov    %dl,(%eax)
40004abd:	ff 45 08             	incl   0x8(%ebp)
40004ac0:	ff 45 f8             	incl   -0x8(%ebp)
40004ac3:	8b 45 0c             	mov    0xc(%ebp),%eax
40004ac6:	48                   	dec    %eax
40004ac7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
40004aca:	7f a9                	jg     40004a75 <fgets+0x3c>
40004acc:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40004ad0:	75 09                	jne    40004adb <fgets+0xa2>
40004ad2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40004ad9:	eb 0c                	jmp    40004ae7 <fgets+0xae>
40004adb:	8b 45 08             	mov    0x8(%ebp),%eax
40004ade:	c6 00 00             	movb   $0x0,(%eax)
40004ae1:	8b 45 08             	mov    0x8(%ebp),%eax
40004ae4:	89 45 ec             	mov    %eax,-0x14(%ebp)
40004ae7:	8b 45 ec             	mov    -0x14(%ebp),%eax
40004aea:	c9                   	leave  
40004aeb:	c3                   	ret    

40004aec <ungetc>:
40004aec:	55                   	push   %ebp
40004aed:	89 e5                	mov    %esp,%ebp
40004aef:	83 ec 18             	sub    $0x18,%esp
40004af2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
40004af6:	75 09                	jne    40004b01 <ungetc+0x15>
40004af8:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
40004aff:	eb 62                	jmp    40004b63 <ungetc+0x77>
40004b01:	8b 45 0c             	mov    0xc(%ebp),%eax
40004b04:	8b 40 1d             	mov    0x1d(%eax),%eax
40004b07:	8d 50 01             	lea    0x1(%eax),%edx
40004b0a:	8b 45 0c             	mov    0xc(%ebp),%eax
40004b0d:	8b 40 21             	mov    0x21(%eax),%eax
40004b10:	83 ec 08             	sub    $0x8,%esp
40004b13:	52                   	push   %edx
40004b14:	50                   	push   %eax
40004b15:	e8 65 41 00 00       	call   40008c7f <realloc>
40004b1a:	83 c4 10             	add    $0x10,%esp
40004b1d:	89 45 fc             	mov    %eax,-0x4(%ebp)
40004b20:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40004b24:	75 09                	jne    40004b2f <ungetc+0x43>
40004b26:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
40004b2d:	eb 34                	jmp    40004b63 <ungetc+0x77>
40004b2f:	8b 55 0c             	mov    0xc(%ebp),%edx
40004b32:	8b 45 fc             	mov    -0x4(%ebp),%eax
40004b35:	89 42 21             	mov    %eax,0x21(%edx)
40004b38:	8b 45 0c             	mov    0xc(%ebp),%eax
40004b3b:	8b 40 1d             	mov    0x1d(%eax),%eax
40004b3e:	8d 50 01             	lea    0x1(%eax),%edx
40004b41:	8b 45 0c             	mov    0xc(%ebp),%eax
40004b44:	89 50 1d             	mov    %edx,0x1d(%eax)
40004b47:	8b 45 0c             	mov    0xc(%ebp),%eax
40004b4a:	8b 40 21             	mov    0x21(%eax),%eax
40004b4d:	8d 50 ff             	lea    -0x1(%eax),%edx
40004b50:	8b 45 0c             	mov    0xc(%ebp),%eax
40004b53:	8b 40 1d             	mov    0x1d(%eax),%eax
40004b56:	01 c2                	add    %eax,%edx
40004b58:	8b 45 08             	mov    0x8(%ebp),%eax
40004b5b:	88 02                	mov    %al,(%edx)
40004b5d:	8b 45 08             	mov    0x8(%ebp),%eax
40004b60:	89 45 ec             	mov    %eax,-0x14(%ebp)
40004b63:	8b 45 ec             	mov    -0x14(%ebp),%eax
40004b66:	c9                   	leave  
40004b67:	c3                   	ret    

40004b68 <io_write>:
40004b68:	55                   	push   %ebp
40004b69:	89 e5                	mov    %esp,%ebp
40004b6b:	83 ec 28             	sub    $0x28,%esp
40004b6e:	89 e0                	mov    %esp,%eax
40004b70:	89 45 dc             	mov    %eax,-0x24(%ebp)
40004b73:	8b 45 10             	mov    0x10(%ebp),%eax
40004b76:	0f af 45 0c          	imul   0xc(%ebp),%eax
40004b7a:	89 45 ec             	mov    %eax,-0x14(%ebp)
40004b7d:	c7 45 f0 10 00 00 00 	movl   $0x10,-0x10(%ebp)
40004b84:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
40004b8b:	77 06                	ja     40004b93 <io_write+0x2b>
40004b8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
40004b90:	01 45 f0             	add    %eax,-0x10(%ebp)
40004b93:	8b 45 f0             	mov    -0x10(%ebp),%eax
40004b96:	83 c0 0f             	add    $0xf,%eax
40004b99:	83 c0 0f             	add    $0xf,%eax
40004b9c:	c1 e8 04             	shr    $0x4,%eax
40004b9f:	c1 e0 04             	shl    $0x4,%eax
40004ba2:	29 c4                	sub    %eax,%esp
40004ba4:	89 65 d8             	mov    %esp,-0x28(%ebp)
40004ba7:	8b 45 d8             	mov    -0x28(%ebp),%eax
40004baa:	83 c0 0f             	add    $0xf,%eax
40004bad:	c1 e8 04             	shr    $0x4,%eax
40004bb0:	c1 e0 04             	shl    $0x4,%eax
40004bb3:	89 45 d8             	mov    %eax,-0x28(%ebp)
40004bb6:	8b 45 d8             	mov    -0x28(%ebp),%eax
40004bb9:	89 45 e8             	mov    %eax,-0x18(%ebp)
40004bbc:	8b 45 e8             	mov    -0x18(%ebp),%eax
40004bbf:	89 45 f4             	mov    %eax,-0xc(%ebp)
40004bc2:	8b 45 14             	mov    0x14(%ebp),%eax
40004bc5:	8b 10                	mov    (%eax),%edx
40004bc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
40004bca:	89 10                	mov    %edx,(%eax)
40004bcc:	8b 55 f4             	mov    -0xc(%ebp),%edx
40004bcf:	8b 45 0c             	mov    0xc(%ebp),%eax
40004bd2:	89 42 04             	mov    %eax,0x4(%edx)
40004bd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
40004bd8:	8b 45 10             	mov    0x10(%ebp),%eax
40004bdb:	89 42 08             	mov    %eax,0x8(%edx)
40004bde:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
40004be5:	77 24                	ja     40004c0b <io_write+0xa3>
40004be7:	8b 45 f4             	mov    -0xc(%ebp),%eax
40004bea:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
40004bf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
40004bf4:	83 c0 10             	add    $0x10,%eax
40004bf7:	83 ec 04             	sub    $0x4,%esp
40004bfa:	ff 75 ec             	pushl  -0x14(%ebp)
40004bfd:	ff 75 08             	pushl  0x8(%ebp)
40004c00:	50                   	push   %eax
40004c01:	e8 62 43 00 00       	call   40008f68 <memcpy>
40004c06:	83 c4 10             	add    $0x10,%esp
40004c09:	eb 3f                	jmp    40004c4a <io_write+0xe2>
40004c0b:	83 ec 0c             	sub    $0xc,%esp
40004c0e:	ff 75 ec             	pushl  -0x14(%ebp)
40004c11:	e8 96 1f 00 00       	call   40006bac <create_shared_memory>
40004c16:	83 c4 10             	add    $0x10,%esp
40004c19:	89 c2                	mov    %eax,%edx
40004c1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
40004c1e:	89 50 0c             	mov    %edx,0xc(%eax)
40004c21:	8b 45 f4             	mov    -0xc(%ebp),%eax
40004c24:	8b 40 0c             	mov    0xc(%eax),%eax
40004c27:	83 ec 0c             	sub    $0xc,%esp
40004c2a:	50                   	push   %eax
40004c2b:	e8 98 1f 00 00       	call   40006bc8 <open_shared_memory>
40004c30:	83 c4 10             	add    $0x10,%esp
40004c33:	89 45 fc             	mov    %eax,-0x4(%ebp)
40004c36:	83 ec 04             	sub    $0x4,%esp
40004c39:	ff 75 ec             	pushl  -0x14(%ebp)
40004c3c:	ff 75 08             	pushl  0x8(%ebp)
40004c3f:	ff 75 fc             	pushl  -0x4(%ebp)
40004c42:	e8 21 43 00 00       	call   40008f68 <memcpy>
40004c47:	83 c4 10             	add    $0x10,%esp
40004c4a:	8b 45 e8             	mov    -0x18(%ebp),%eax
40004c4d:	89 c2                	mov    %eax,%edx
40004c4f:	8b 45 14             	mov    0x14(%ebp),%eax
40004c52:	8b 40 04             	mov    0x4(%eax),%eax
40004c55:	52                   	push   %edx
40004c56:	ff 75 f0             	pushl  -0x10(%ebp)
40004c59:	68 6a 99 00 40       	push   $0x4000996a
40004c5e:	50                   	push   %eax
40004c5f:	e8 59 e8 ff ff       	call   400034bd <rpc_get_dword>
40004c64:	83 c4 10             	add    $0x10,%esp
40004c67:	89 45 f8             	mov    %eax,-0x8(%ebp)
40004c6a:	81 7d ec 00 04 00 00 	cmpl   $0x400,-0x14(%ebp)
40004c71:	76 12                	jbe    40004c85 <io_write+0x11d>
40004c73:	8b 45 f4             	mov    -0xc(%ebp),%eax
40004c76:	8b 40 0c             	mov    0xc(%eax),%eax
40004c79:	83 ec 0c             	sub    $0xc,%esp
40004c7c:	50                   	push   %eax
40004c7d:	e8 62 1f 00 00       	call   40006be4 <close_shared_memory>
40004c82:	83 c4 10             	add    $0x10,%esp
40004c85:	8b 45 f8             	mov    -0x8(%ebp),%eax
40004c88:	8b 65 dc             	mov    -0x24(%ebp),%esp
40004c8b:	c9                   	leave  
40004c8c:	c3                   	ret    

40004c8d <fwrite>:
40004c8d:	55                   	push   %ebp
40004c8e:	89 e5                	mov    %esp,%ebp
40004c90:	83 ec 18             	sub    $0x18,%esp
40004c93:	8b 45 0c             	mov    0xc(%ebp),%eax
40004c96:	0f af 45 10          	imul   0x10(%ebp),%eax
40004c9a:	89 45 fc             	mov    %eax,-0x4(%ebp)
40004c9d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
40004ca1:	74 0a                	je     40004cad <fwrite+0x20>
40004ca3:	8b 45 14             	mov    0x14(%ebp),%eax
40004ca6:	8b 40 04             	mov    0x4(%eax),%eax
40004ca9:	85 c0                	test   %eax,%eax
40004cab:	75 0c                	jne    40004cb9 <fwrite+0x2c>
40004cad:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40004cb4:	e9 a8 01 00 00       	jmp    40004e61 <fwrite+0x1d4>
40004cb9:	8b 45 14             	mov    0x14(%ebp),%eax
40004cbc:	8b 40 1d             	mov    0x1d(%eax),%eax
40004cbf:	85 c0                	test   %eax,%eax
40004cc1:	74 1c                	je     40004cdf <fwrite+0x52>
40004cc3:	8b 45 14             	mov    0x14(%ebp),%eax
40004cc6:	c7 40 1d 00 00 00 00 	movl   $0x0,0x1d(%eax)
40004ccd:	8b 45 14             	mov    0x14(%ebp),%eax
40004cd0:	8b 40 21             	mov    0x21(%eax),%eax
40004cd3:	83 ec 0c             	sub    $0xc,%esp
40004cd6:	50                   	push   %eax
40004cd7:	e8 d3 3c 00 00       	call   400089af <free>
40004cdc:	83 c4 10             	add    $0x10,%esp
40004cdf:	8b 45 14             	mov    0x14(%ebp),%eax
40004ce2:	8b 40 10             	mov    0x10(%eax),%eax
40004ce5:	85 c0                	test   %eax,%eax
40004ce7:	75 11                	jne    40004cfa <fwrite+0x6d>
40004ce9:	8b 45 14             	mov    0x14(%ebp),%eax
40004cec:	8a 40 1c             	mov    0x1c(%eax),%al
40004cef:	84 c0                	test   %al,%al
40004cf1:	74 07                	je     40004cfa <fwrite+0x6d>
40004cf3:	8b 45 14             	mov    0x14(%ebp),%eax
40004cf6:	c6 40 1c 00          	movb   $0x0,0x1c(%eax)
40004cfa:	8b 45 14             	mov    0x14(%ebp),%eax
40004cfd:	8a 40 1c             	mov    0x1c(%eax),%al
40004d00:	0f b6 c0             	movzbl %al,%eax
40004d03:	89 45 ec             	mov    %eax,-0x14(%ebp)
40004d06:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
40004d0a:	74 31                	je     40004d3d <fwrite+0xb0>
40004d0c:	83 7d ec 02          	cmpl   $0x2,-0x14(%ebp)
40004d10:	0f 84 a9 00 00 00    	je     40004dbf <fwrite+0x132>
40004d16:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
40004d1a:	74 05                	je     40004d21 <fwrite+0x94>
40004d1c:	e9 39 01 00 00       	jmp    40004e5a <fwrite+0x1cd>
40004d21:	ff 75 14             	pushl  0x14(%ebp)
40004d24:	ff 75 10             	pushl  0x10(%ebp)
40004d27:	ff 75 0c             	pushl  0xc(%ebp)
40004d2a:	ff 75 08             	pushl  0x8(%ebp)
40004d2d:	e8 36 fe ff ff       	call   40004b68 <io_write>
40004d32:	83 c4 10             	add    $0x10,%esp
40004d35:	89 45 e8             	mov    %eax,-0x18(%ebp)
40004d38:	e9 24 01 00 00       	jmp    40004e61 <fwrite+0x1d4>
40004d3d:	8b 45 14             	mov    0x14(%ebp),%eax
40004d40:	8b 50 14             	mov    0x14(%eax),%edx
40004d43:	8b 45 14             	mov    0x14(%ebp),%eax
40004d46:	8b 40 18             	mov    0x18(%eax),%eax
40004d49:	03 45 fc             	add    -0x4(%ebp),%eax
40004d4c:	39 c2                	cmp    %eax,%edx
40004d4e:	73 34                	jae    40004d84 <fwrite+0xf7>
40004d50:	8b 45 14             	mov    0x14(%ebp),%eax
40004d53:	8b 40 10             	mov    0x10(%eax),%eax
40004d56:	83 ec 04             	sub    $0x4,%esp
40004d59:	ff 75 fc             	pushl  -0x4(%ebp)
40004d5c:	ff 75 08             	pushl  0x8(%ebp)
40004d5f:	50                   	push   %eax
40004d60:	e8 03 42 00 00       	call   40008f68 <memcpy>
40004d65:	83 c4 10             	add    $0x10,%esp
40004d68:	8b 45 14             	mov    0x14(%ebp),%eax
40004d6b:	8b 40 18             	mov    0x18(%eax),%eax
40004d6e:	89 c2                	mov    %eax,%edx
40004d70:	03 55 fc             	add    -0x4(%ebp),%edx
40004d73:	8b 45 14             	mov    0x14(%ebp),%eax
40004d76:	89 50 18             	mov    %edx,0x18(%eax)
40004d79:	8b 45 fc             	mov    -0x4(%ebp),%eax
40004d7c:	89 45 e8             	mov    %eax,-0x18(%ebp)
40004d7f:	e9 dd 00 00 00       	jmp    40004e61 <fwrite+0x1d4>
40004d84:	83 ec 0c             	sub    $0xc,%esp
40004d87:	ff 75 14             	pushl  0x14(%ebp)
40004d8a:	e8 0f 03 00 00       	call   4000509e <fflush>
40004d8f:	83 c4 10             	add    $0x10,%esp
40004d92:	83 f8 ff             	cmp    $0xffffffff,%eax
40004d95:	75 0c                	jne    40004da3 <fwrite+0x116>
40004d97:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40004d9e:	e9 be 00 00 00       	jmp    40004e61 <fwrite+0x1d4>
40004da3:	ff 75 14             	pushl  0x14(%ebp)
40004da6:	ff 75 10             	pushl  0x10(%ebp)
40004da9:	ff 75 0c             	pushl  0xc(%ebp)
40004dac:	ff 75 08             	pushl  0x8(%ebp)
40004daf:	e8 b4 fd ff ff       	call   40004b68 <io_write>
40004db4:	83 c4 10             	add    $0x10,%esp
40004db7:	89 45 e8             	mov    %eax,-0x18(%ebp)
40004dba:	e9 a2 00 00 00       	jmp    40004e61 <fwrite+0x1d4>
40004dbf:	8b 45 14             	mov    0x14(%ebp),%eax
40004dc2:	8b 50 14             	mov    0x14(%eax),%edx
40004dc5:	8b 45 14             	mov    0x14(%ebp),%eax
40004dc8:	8b 40 18             	mov    0x18(%eax),%eax
40004dcb:	03 45 fc             	add    -0x4(%ebp),%eax
40004dce:	39 c2                	cmp    %eax,%edx
40004dd0:	72 17                	jb     40004de9 <fwrite+0x15c>
40004dd2:	83 ec 04             	sub    $0x4,%esp
40004dd5:	ff 75 fc             	pushl  -0x4(%ebp)
40004dd8:	6a 0a                	push   $0xa
40004dda:	ff 75 08             	pushl  0x8(%ebp)
40004ddd:	e8 3e 41 00 00       	call   40008f20 <memchr>
40004de2:	83 c4 10             	add    $0x10,%esp
40004de5:	85 c0                	test   %eax,%eax
40004de7:	74 35                	je     40004e1e <fwrite+0x191>
40004de9:	83 ec 0c             	sub    $0xc,%esp
40004dec:	ff 75 14             	pushl  0x14(%ebp)
40004def:	e8 aa 02 00 00       	call   4000509e <fflush>
40004df4:	83 c4 10             	add    $0x10,%esp
40004df7:	83 f8 ff             	cmp    $0xffffffff,%eax
40004dfa:	75 09                	jne    40004e05 <fwrite+0x178>
40004dfc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40004e03:	eb 5c                	jmp    40004e61 <fwrite+0x1d4>
40004e05:	ff 75 14             	pushl  0x14(%ebp)
40004e08:	ff 75 10             	pushl  0x10(%ebp)
40004e0b:	ff 75 0c             	pushl  0xc(%ebp)
40004e0e:	ff 75 08             	pushl  0x8(%ebp)
40004e11:	e8 52 fd ff ff       	call   40004b68 <io_write>
40004e16:	83 c4 10             	add    $0x10,%esp
40004e19:	89 45 e8             	mov    %eax,-0x18(%ebp)
40004e1c:	eb 43                	jmp    40004e61 <fwrite+0x1d4>
40004e1e:	8b 45 14             	mov    0x14(%ebp),%eax
40004e21:	8b 40 10             	mov    0x10(%eax),%eax
40004e24:	89 c2                	mov    %eax,%edx
40004e26:	8b 45 14             	mov    0x14(%ebp),%eax
40004e29:	8b 40 18             	mov    0x18(%eax),%eax
40004e2c:	8d 04 02             	lea    (%edx,%eax,1),%eax
40004e2f:	83 ec 04             	sub    $0x4,%esp
40004e32:	ff 75 fc             	pushl  -0x4(%ebp)
40004e35:	ff 75 08             	pushl  0x8(%ebp)
40004e38:	50                   	push   %eax
40004e39:	e8 2a 41 00 00       	call   40008f68 <memcpy>
40004e3e:	83 c4 10             	add    $0x10,%esp
40004e41:	8b 45 14             	mov    0x14(%ebp),%eax
40004e44:	8b 40 18             	mov    0x18(%eax),%eax
40004e47:	89 c2                	mov    %eax,%edx
40004e49:	03 55 fc             	add    -0x4(%ebp),%edx
40004e4c:	8b 45 14             	mov    0x14(%ebp),%eax
40004e4f:	89 50 18             	mov    %edx,0x18(%eax)
40004e52:	8b 45 fc             	mov    -0x4(%ebp),%eax
40004e55:	89 45 e8             	mov    %eax,-0x18(%ebp)
40004e58:	eb 07                	jmp    40004e61 <fwrite+0x1d4>
40004e5a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40004e61:	8b 45 e8             	mov    -0x18(%ebp),%eax
40004e64:	c9                   	leave  
40004e65:	c3                   	ret    

40004e66 <fputc>:
40004e66:	55                   	push   %ebp
40004e67:	89 e5                	mov    %esp,%ebp
40004e69:	83 ec 18             	sub    $0x18,%esp
40004e6c:	8b 45 08             	mov    0x8(%ebp),%eax
40004e6f:	88 45 ff             	mov    %al,-0x1(%ebp)
40004e72:	ff 75 0c             	pushl  0xc(%ebp)
40004e75:	6a 01                	push   $0x1
40004e77:	6a 01                	push   $0x1
40004e79:	8d 45 ff             	lea    -0x1(%ebp),%eax
40004e7c:	50                   	push   %eax
40004e7d:	e8 0b fe ff ff       	call   40004c8d <fwrite>
40004e82:	83 c4 10             	add    $0x10,%esp
40004e85:	83 f8 01             	cmp    $0x1,%eax
40004e88:	75 08                	jne    40004e92 <fputc+0x2c>
40004e8a:	8b 45 08             	mov    0x8(%ebp),%eax
40004e8d:	89 45 ec             	mov    %eax,-0x14(%ebp)
40004e90:	eb 07                	jmp    40004e99 <fputc+0x33>
40004e92:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
40004e99:	8b 45 ec             	mov    -0x14(%ebp),%eax
40004e9c:	c9                   	leave  
40004e9d:	c3                   	ret    

40004e9e <fputs>:
40004e9e:	55                   	push   %ebp
40004e9f:	89 e5                	mov    %esp,%ebp
40004ea1:	53                   	push   %ebx
40004ea2:	83 ec 04             	sub    $0x4,%esp
40004ea5:	83 ec 0c             	sub    $0xc,%esp
40004ea8:	ff 75 08             	pushl  0x8(%ebp)
40004eab:	e8 c4 43 00 00       	call   40009274 <strlen>
40004eb0:	83 c4 10             	add    $0x10,%esp
40004eb3:	ff 75 0c             	pushl  0xc(%ebp)
40004eb6:	50                   	push   %eax
40004eb7:	6a 01                	push   $0x1
40004eb9:	ff 75 08             	pushl  0x8(%ebp)
40004ebc:	e8 cc fd ff ff       	call   40004c8d <fwrite>
40004ec1:	83 c4 10             	add    $0x10,%esp
40004ec4:	89 c3                	mov    %eax,%ebx
40004ec6:	83 ec 0c             	sub    $0xc,%esp
40004ec9:	ff 75 08             	pushl  0x8(%ebp)
40004ecc:	e8 a3 43 00 00       	call   40009274 <strlen>
40004ed1:	83 c4 10             	add    $0x10,%esp
40004ed4:	39 c3                	cmp    %eax,%ebx
40004ed6:	75 09                	jne    40004ee1 <fputs+0x43>
40004ed8:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
40004edf:	eb 07                	jmp    40004ee8 <fputs+0x4a>
40004ee1:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
40004ee8:	8b 45 f8             	mov    -0x8(%ebp),%eax
40004eeb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40004eee:	c9                   	leave  
40004eef:	c3                   	ret    

40004ef0 <fseek>:
40004ef0:	55                   	push   %ebp
40004ef1:	89 e5                	mov    %esp,%ebp
40004ef3:	83 ec 18             	sub    $0x18,%esp
40004ef6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
40004efa:	74 0a                	je     40004f06 <fseek+0x16>
40004efc:	8b 45 08             	mov    0x8(%ebp),%eax
40004eff:	8b 40 04             	mov    0x4(%eax),%eax
40004f02:	85 c0                	test   %eax,%eax
40004f04:	75 09                	jne    40004f0f <fseek+0x1f>
40004f06:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
40004f0d:	eb 57                	jmp    40004f66 <fseek+0x76>
40004f0f:	8b 45 08             	mov    0x8(%ebp),%eax
40004f12:	8b 40 1d             	mov    0x1d(%eax),%eax
40004f15:	85 c0                	test   %eax,%eax
40004f17:	74 1c                	je     40004f35 <fseek+0x45>
40004f19:	8b 45 08             	mov    0x8(%ebp),%eax
40004f1c:	c7 40 1d 00 00 00 00 	movl   $0x0,0x1d(%eax)
40004f23:	8b 45 08             	mov    0x8(%ebp),%eax
40004f26:	8b 40 21             	mov    0x21(%eax),%eax
40004f29:	83 ec 0c             	sub    $0xc,%esp
40004f2c:	50                   	push   %eax
40004f2d:	e8 7d 3a 00 00       	call   400089af <free>
40004f32:	83 c4 10             	add    $0x10,%esp
40004f35:	8b 45 08             	mov    0x8(%ebp),%eax
40004f38:	8b 00                	mov    (%eax),%eax
40004f3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
40004f3d:	8b 45 0c             	mov    0xc(%ebp),%eax
40004f40:	89 45 f8             	mov    %eax,-0x8(%ebp)
40004f43:	8b 45 10             	mov    0x10(%ebp),%eax
40004f46:	89 45 fc             	mov    %eax,-0x4(%ebp)
40004f49:	8d 55 f4             	lea    -0xc(%ebp),%edx
40004f4c:	8b 45 08             	mov    0x8(%ebp),%eax
40004f4f:	8b 40 04             	mov    0x4(%eax),%eax
40004f52:	52                   	push   %edx
40004f53:	6a 0c                	push   $0xc
40004f55:	68 73 99 00 40       	push   $0x40009973
40004f5a:	50                   	push   %eax
40004f5b:	e8 5d e5 ff ff       	call   400034bd <rpc_get_dword>
40004f60:	83 c4 10             	add    $0x10,%esp
40004f63:	89 45 ec             	mov    %eax,-0x14(%ebp)
40004f66:	8b 45 ec             	mov    -0x14(%ebp),%eax
40004f69:	c9                   	leave  
40004f6a:	c3                   	ret    

40004f6b <ftell>:
40004f6b:	55                   	push   %ebp
40004f6c:	89 e5                	mov    %esp,%ebp
40004f6e:	83 ec 18             	sub    $0x18,%esp
40004f71:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
40004f75:	74 0a                	je     40004f81 <ftell+0x16>
40004f77:	8b 45 08             	mov    0x8(%ebp),%eax
40004f7a:	8b 40 04             	mov    0x4(%eax),%eax
40004f7d:	85 c0                	test   %eax,%eax
40004f7f:	75 09                	jne    40004f8a <ftell+0x1f>
40004f81:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
40004f88:	eb 71                	jmp    40004ffb <ftell+0x90>
40004f8a:	8b 45 08             	mov    0x8(%ebp),%eax
40004f8d:	8b 00                	mov    (%eax),%eax
40004f8f:	89 45 f8             	mov    %eax,-0x8(%ebp)
40004f92:	83 ec 0c             	sub    $0xc,%esp
40004f95:	ff 75 08             	pushl  0x8(%ebp)
40004f98:	e8 01 01 00 00       	call   4000509e <fflush>
40004f9d:	83 c4 10             	add    $0x10,%esp
40004fa0:	8d 55 f8             	lea    -0x8(%ebp),%edx
40004fa3:	8b 45 08             	mov    0x8(%ebp),%eax
40004fa6:	8b 40 04             	mov    0x4(%eax),%eax
40004fa9:	52                   	push   %edx
40004faa:	6a 04                	push   $0x4
40004fac:	68 7c 99 00 40       	push   $0x4000997c
40004fb1:	50                   	push   %eax
40004fb2:	e8 76 e6 ff ff       	call   4000362d <rpc_get_response>
40004fb7:	83 c4 10             	add    $0x10,%esp
40004fba:	89 45 fc             	mov    %eax,-0x4(%ebp)
40004fbd:	8b 45 fc             	mov    -0x4(%ebp),%eax
40004fc0:	8b 40 0c             	mov    0xc(%eax),%eax
40004fc3:	83 ec 04             	sub    $0x4,%esp
40004fc6:	6a 04                	push   $0x4
40004fc8:	50                   	push   %eax
40004fc9:	8d 45 f4             	lea    -0xc(%ebp),%eax
40004fcc:	50                   	push   %eax
40004fcd:	e8 96 3f 00 00       	call   40008f68 <memcpy>
40004fd2:	83 c4 10             	add    $0x10,%esp
40004fd5:	8b 45 fc             	mov    -0x4(%ebp),%eax
40004fd8:	8b 40 0c             	mov    0xc(%eax),%eax
40004fdb:	83 ec 0c             	sub    $0xc,%esp
40004fde:	50                   	push   %eax
40004fdf:	e8 cb 39 00 00       	call   400089af <free>
40004fe4:	83 c4 10             	add    $0x10,%esp
40004fe7:	83 ec 0c             	sub    $0xc,%esp
40004fea:	ff 75 fc             	pushl  -0x4(%ebp)
40004fed:	e8 bd 39 00 00       	call   400089af <free>
40004ff2:	83 c4 10             	add    $0x10,%esp
40004ff5:	8b 45 f4             	mov    -0xc(%ebp),%eax
40004ff8:	89 45 ec             	mov    %eax,-0x14(%ebp)
40004ffb:	8b 45 ec             	mov    -0x14(%ebp),%eax
40004ffe:	c9                   	leave  
40004fff:	c3                   	ret    

40005000 <feof>:
40005000:	55                   	push   %ebp
40005001:	89 e5                	mov    %esp,%ebp
40005003:	83 ec 18             	sub    $0x18,%esp
40005006:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
4000500a:	74 0a                	je     40005016 <feof+0x16>
4000500c:	8b 45 08             	mov    0x8(%ebp),%eax
4000500f:	8b 40 04             	mov    0x4(%eax),%eax
40005012:	85 c0                	test   %eax,%eax
40005014:	75 09                	jne    4000501f <feof+0x1f>
40005016:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
4000501d:	eb 46                	jmp    40005065 <feof+0x65>
4000501f:	8b 45 08             	mov    0x8(%ebp),%eax
40005022:	8b 40 1d             	mov    0x1d(%eax),%eax
40005025:	85 c0                	test   %eax,%eax
40005027:	74 09                	je     40005032 <feof+0x32>
40005029:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40005030:	eb 33                	jmp    40005065 <feof+0x65>
40005032:	8b 45 08             	mov    0x8(%ebp),%eax
40005035:	8b 00                	mov    (%eax),%eax
40005037:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000503a:	83 ec 0c             	sub    $0xc,%esp
4000503d:	ff 75 08             	pushl  0x8(%ebp)
40005040:	e8 59 00 00 00       	call   4000509e <fflush>
40005045:	83 c4 10             	add    $0x10,%esp
40005048:	8d 55 fc             	lea    -0x4(%ebp),%edx
4000504b:	8b 45 08             	mov    0x8(%ebp),%eax
4000504e:	8b 40 04             	mov    0x4(%eax),%eax
40005051:	52                   	push   %edx
40005052:	6a 04                	push   $0x4
40005054:	68 85 99 00 40       	push   $0x40009985
40005059:	50                   	push   %eax
4000505a:	e8 5e e4 ff ff       	call   400034bd <rpc_get_dword>
4000505f:	83 c4 10             	add    $0x10,%esp
40005062:	89 45 ec             	mov    %eax,-0x14(%ebp)
40005065:	8b 45 ec             	mov    -0x14(%ebp),%eax
40005068:	c9                   	leave  
40005069:	c3                   	ret    

4000506a <ferror>:
4000506a:	55                   	push   %ebp
4000506b:	89 e5                	mov    %esp,%ebp
4000506d:	b8 00 00 00 00       	mov    $0x0,%eax
40005072:	c9                   	leave  
40005073:	c3                   	ret    

40005074 <clearerr>:
40005074:	55                   	push   %ebp
40005075:	89 e5                	mov    %esp,%ebp
40005077:	c9                   	leave  
40005078:	c3                   	ret    

40005079 <rewind>:
40005079:	55                   	push   %ebp
4000507a:	89 e5                	mov    %esp,%ebp
4000507c:	83 ec 08             	sub    $0x8,%esp
4000507f:	83 ec 04             	sub    $0x4,%esp
40005082:	6a 00                	push   $0x0
40005084:	6a 00                	push   $0x0
40005086:	ff 75 08             	pushl  0x8(%ebp)
40005089:	e8 62 fe ff ff       	call   40004ef0 <fseek>
4000508e:	83 c4 10             	add    $0x10,%esp
40005091:	ff 75 08             	pushl  0x8(%ebp)
40005094:	e8 db ff ff ff       	call   40005074 <clearerr>
40005099:	83 c4 04             	add    $0x4,%esp
4000509c:	c9                   	leave  
4000509d:	c3                   	ret    

4000509e <fflush>:
4000509e:	55                   	push   %ebp
4000509f:	89 e5                	mov    %esp,%ebp
400050a1:	83 ec 18             	sub    $0x18,%esp
400050a4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
400050a8:	74 0a                	je     400050b4 <fflush+0x16>
400050aa:	8b 45 08             	mov    0x8(%ebp),%eax
400050ad:	8b 40 04             	mov    0x4(%eax),%eax
400050b0:	85 c0                	test   %eax,%eax
400050b2:	75 09                	jne    400050bd <fflush+0x1f>
400050b4:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
400050bb:	eb 7e                	jmp    4000513b <fflush+0x9d>
400050bd:	8b 45 08             	mov    0x8(%ebp),%eax
400050c0:	8a 40 1c             	mov    0x1c(%eax),%al
400050c3:	84 c0                	test   %al,%al
400050c5:	74 1e                	je     400050e5 <fflush+0x47>
400050c7:	8b 45 08             	mov    0x8(%ebp),%eax
400050ca:	8b 40 10             	mov    0x10(%eax),%eax
400050cd:	85 c0                	test   %eax,%eax
400050cf:	74 14                	je     400050e5 <fflush+0x47>
400050d1:	8b 45 08             	mov    0x8(%ebp),%eax
400050d4:	8b 40 14             	mov    0x14(%eax),%eax
400050d7:	85 c0                	test   %eax,%eax
400050d9:	74 0a                	je     400050e5 <fflush+0x47>
400050db:	8b 45 08             	mov    0x8(%ebp),%eax
400050de:	8b 40 18             	mov    0x18(%eax),%eax
400050e1:	85 c0                	test   %eax,%eax
400050e3:	75 09                	jne    400050ee <fflush+0x50>
400050e5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400050ec:	eb 4d                	jmp    4000513b <fflush+0x9d>
400050ee:	8b 45 08             	mov    0x8(%ebp),%eax
400050f1:	8b 50 18             	mov    0x18(%eax),%edx
400050f4:	8b 45 08             	mov    0x8(%ebp),%eax
400050f7:	8b 40 10             	mov    0x10(%eax),%eax
400050fa:	ff 75 08             	pushl  0x8(%ebp)
400050fd:	52                   	push   %edx
400050fe:	6a 01                	push   $0x1
40005100:	50                   	push   %eax
40005101:	e8 62 fa ff ff       	call   40004b68 <io_write>
40005106:	83 c4 10             	add    $0x10,%esp
40005109:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000510c:	8b 45 08             	mov    0x8(%ebp),%eax
4000510f:	8b 40 18             	mov    0x18(%eax),%eax
40005112:	3b 45 fc             	cmp    -0x4(%ebp),%eax
40005115:	75 13                	jne    4000512a <fflush+0x8c>
40005117:	8b 45 08             	mov    0x8(%ebp),%eax
4000511a:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
40005121:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40005128:	eb 11                	jmp    4000513b <fflush+0x9d>
4000512a:	8b 45 08             	mov    0x8(%ebp),%eax
4000512d:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
40005134:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
4000513b:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000513e:	c9                   	leave  
4000513f:	c3                   	ret    

40005140 <fpurge>:
40005140:	55                   	push   %ebp
40005141:	89 e5                	mov    %esp,%ebp
40005143:	8b 45 08             	mov    0x8(%ebp),%eax
40005146:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
4000514d:	b8 00 00 00 00       	mov    $0x0,%eax
40005152:	c9                   	leave  
40005153:	c3                   	ret    

40005154 <setvbuf>:
40005154:	55                   	push   %ebp
40005155:	89 e5                	mov    %esp,%ebp
40005157:	83 ec 08             	sub    $0x8,%esp
4000515a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
4000515e:	75 0c                	jne    4000516c <setvbuf+0x18>
40005160:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
40005167:	e9 be 00 00 00       	jmp    4000522a <setvbuf+0xd6>
4000516c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
40005170:	75 1d                	jne    4000518f <setvbuf+0x3b>
40005172:	8b 45 08             	mov    0x8(%ebp),%eax
40005175:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
4000517c:	8b 45 08             	mov    0x8(%ebp),%eax
4000517f:	c6 40 1c 00          	movb   $0x0,0x1c(%eax)
40005183:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
4000518a:	e9 9b 00 00 00       	jmp    4000522a <setvbuf+0xd6>
4000518f:	8b 45 10             	mov    0x10(%ebp),%eax
40005192:	89 45 f8             	mov    %eax,-0x8(%ebp)
40005195:	83 7d f8 02          	cmpl   $0x2,-0x8(%ebp)
40005199:	74 35                	je     400051d0 <setvbuf+0x7c>
4000519b:	83 7d f8 03          	cmpl   $0x3,-0x8(%ebp)
4000519f:	74 54                	je     400051f5 <setvbuf+0xa1>
400051a1:	83 7d f8 01          	cmpl   $0x1,-0x8(%ebp)
400051a5:	74 02                	je     400051a9 <setvbuf+0x55>
400051a7:	eb 71                	jmp    4000521a <setvbuf+0xc6>
400051a9:	8b 45 08             	mov    0x8(%ebp),%eax
400051ac:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
400051b3:	8b 45 08             	mov    0x8(%ebp),%eax
400051b6:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
400051bd:	8b 45 08             	mov    0x8(%ebp),%eax
400051c0:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
400051c7:	8b 45 08             	mov    0x8(%ebp),%eax
400051ca:	c6 40 1c 00          	movb   $0x0,0x1c(%eax)
400051ce:	eb 53                	jmp    40005223 <setvbuf+0xcf>
400051d0:	8b 55 08             	mov    0x8(%ebp),%edx
400051d3:	8b 45 0c             	mov    0xc(%ebp),%eax
400051d6:	89 42 10             	mov    %eax,0x10(%edx)
400051d9:	8b 45 08             	mov    0x8(%ebp),%eax
400051dc:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
400051e3:	8b 55 08             	mov    0x8(%ebp),%edx
400051e6:	8b 45 14             	mov    0x14(%ebp),%eax
400051e9:	89 42 14             	mov    %eax,0x14(%edx)
400051ec:	8b 45 08             	mov    0x8(%ebp),%eax
400051ef:	c6 40 1c 01          	movb   $0x1,0x1c(%eax)
400051f3:	eb 2e                	jmp    40005223 <setvbuf+0xcf>
400051f5:	8b 55 08             	mov    0x8(%ebp),%edx
400051f8:	8b 45 0c             	mov    0xc(%ebp),%eax
400051fb:	89 42 10             	mov    %eax,0x10(%edx)
400051fe:	8b 45 08             	mov    0x8(%ebp),%eax
40005201:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
40005208:	8b 55 08             	mov    0x8(%ebp),%edx
4000520b:	8b 45 14             	mov    0x14(%ebp),%eax
4000520e:	89 42 14             	mov    %eax,0x14(%edx)
40005211:	8b 45 08             	mov    0x8(%ebp),%eax
40005214:	c6 40 1c 02          	movb   $0x2,0x1c(%eax)
40005218:	eb 09                	jmp    40005223 <setvbuf+0xcf>
4000521a:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
40005221:	eb 07                	jmp    4000522a <setvbuf+0xd6>
40005223:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
4000522a:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000522d:	c9                   	leave  
4000522e:	c3                   	ret    

4000522f <remove>:
4000522f:	55                   	push   %ebp
40005230:	89 e5                	mov    %esp,%ebp
40005232:	83 ec 08             	sub    $0x8,%esp
40005235:	83 ec 08             	sub    $0x8,%esp
40005238:	ff 75 08             	pushl  0x8(%ebp)
4000523b:	68 90 99 00 40       	push   $0x40009990
40005240:	e8 f4 10 00 00       	call   40006339 <printf>
40005245:	83 c4 10             	add    $0x10,%esp
40005248:	b8 00 00 00 00       	mov    $0x0,%eax
4000524d:	c9                   	leave  
4000524e:	c3                   	ret    

4000524f <tmpfile>:
4000524f:	55                   	push   %ebp
40005250:	89 e5                	mov    %esp,%ebp
40005252:	83 ec 08             	sub    $0x8,%esp
40005255:	83 ec 08             	sub    $0x8,%esp
40005258:	68 d6 99 00 40       	push   $0x400099d6
4000525d:	68 da 99 00 40       	push   $0x400099da
40005262:	e8 71 f2 ff ff       	call   400044d8 <fopen>
40005267:	83 c4 10             	add    $0x10,%esp
4000526a:	c9                   	leave  
4000526b:	c3                   	ret    

4000526c <divmod>:
int ata_drv_identify(struct ata_device* dev)
{
    uint8_t buffer[ATA_SECTOR_SIZE];

    // Request vorbereiten
    struct ata_request request = {
4000526c:	55                   	push   %ebp
4000526d:	89 e5                	mov    %esp,%ebp
4000526f:	53                   	push   %ebx
40005270:	83 ec 24             	sub    $0x24,%esp
40005273:	8b 45 08             	mov    0x8(%ebp),%eax
40005276:	89 45 e0             	mov    %eax,-0x20(%ebp)
40005279:	8b 45 0c             	mov    0xc(%ebp),%eax
4000527c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
4000527f:	8b 45 10             	mov    0x10(%ebp),%eax
40005282:	ba 00 00 00 00       	mov    $0x0,%edx
40005287:	52                   	push   %edx
40005288:	50                   	push   %eax
40005289:	ff 75 e4             	pushl  -0x1c(%ebp)
4000528c:	ff 75 e0             	pushl  -0x20(%ebp)
4000528f:	e8 c8 41 00 00       	call   4000945c <__udivdi3>
40005294:	83 c4 10             	add    $0x10,%esp
40005297:	89 45 e8             	mov    %eax,-0x18(%ebp)
4000529a:	89 55 ec             	mov    %edx,-0x14(%ebp)
        .protocol = PIO,
4000529d:	8b 45 10             	mov    0x10(%ebp),%eax
400052a0:	ba 00 00 00 00       	mov    $0x0,%edx
400052a5:	8b 4d e0             	mov    -0x20(%ebp),%ecx
400052a8:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
400052ab:	52                   	push   %edx
400052ac:	50                   	push   %eax
400052ad:	53                   	push   %ebx
400052ae:	51                   	push   %ecx
400052af:	e8 d0 42 00 00       	call   40009584 <__umoddi3>
400052b4:	83 c4 10             	add    $0x10,%esp
400052b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
400052ba:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
400052be:	74 08                	je     400052c8 <divmod+0x5c>
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,
400052c0:	8b 55 14             	mov    0x14(%ebp),%edx
400052c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
400052c6:	89 02                	mov    %eax,(%edx)

        .error = 0
    };
400052c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
400052cb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    
400052ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400052d1:	c9                   	leave  
400052d2:	c3                   	ret    

400052d3 <ulltoa>:
    // Ein ATA-Geraet
    dev->atapi = 0;

    // TODO: Informationen verarbeiten

    return 1;
400052d3:	55                   	push   %ebp
400052d4:	89 e5                	mov    %esp,%ebp
400052d6:	83 ec 38             	sub    $0x38,%esp
400052d9:	8b 45 08             	mov    0x8(%ebp),%eax
400052dc:	89 45 d8             	mov    %eax,-0x28(%ebp)
400052df:	8b 45 0c             	mov    0xc(%ebp),%eax
400052e2:	89 45 dc             	mov    %eax,-0x24(%ebp)
}
400052e5:	8b 45 10             	mov    0x10(%ebp),%eax
400052e8:	89 45 e8             	mov    %eax,-0x18(%ebp)

400052eb:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
400052ef:	74 09                	je     400052fa <ulltoa+0x27>
400052f1:	c7 45 d0 e8 99 00 40 	movl   $0x400099e8,-0x30(%ebp)
400052f8:	eb 07                	jmp    40005301 <ulltoa+0x2e>
400052fa:	c7 45 d0 0c 9a 00 40 	movl   $0x40009a0c,-0x30(%ebp)
40005301:	8b 45 d0             	mov    -0x30(%ebp),%eax
40005304:	89 45 ec             	mov    %eax,-0x14(%ebp)
/**
 * Sektoren von einem ATA-Geraet lesen
 *
 * @param start LBA des Startsektors
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
40005307:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
4000530b:	76 06                	jbe    40005313 <ulltoa+0x40>
4000530d:	83 7d 14 24          	cmpl   $0x24,0x14(%ebp)
40005311:	76 0b                	jbe    4000531e <ulltoa+0x4b>
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
40005313:	8b 45 10             	mov    0x10(%ebp),%eax
40005316:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40005319:	e9 8b 00 00 00       	jmp    400053a9 <ulltoa+0xd6>
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
{
4000531e:	8b 45 d8             	mov    -0x28(%ebp),%eax
40005321:	8b 55 dc             	mov    -0x24(%ebp),%edx
40005324:	89 45 f0             	mov    %eax,-0x10(%ebp)
40005327:	89 55 f4             	mov    %edx,-0xc(%ebp)
    int result = 1;
4000532a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    struct ata_request request;
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
    // muss unter Umstaenden mehrmals gelesen werden.
40005331:	ff 45 fc             	incl   -0x4(%ebp)
    uint16_t current_count;
40005334:	6a 00                	push   $0x0
40005336:	ff 75 14             	pushl  0x14(%ebp)
40005339:	ff 75 f4             	pushl  -0xc(%ebp)
4000533c:	ff 75 f0             	pushl  -0x10(%ebp)
4000533f:	e8 28 ff ff ff       	call   4000526c <divmod>
40005344:	83 c4 10             	add    $0x10,%esp
40005347:	89 45 f0             	mov    %eax,-0x10(%ebp)
4000534a:	89 55 f4             	mov    %edx,-0xc(%ebp)
    void* current_buffer = buffer;
    uint64_t lba = start;
4000534d:	8b 45 f0             	mov    -0x10(%ebp),%eax
40005350:	0b 45 f4             	or     -0xc(%ebp),%eax
40005353:	85 c0                	test   %eax,%eax
40005355:	75 da                	jne    40005331 <ulltoa+0x5e>

    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;
40005357:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000535a:	01 45 e8             	add    %eax,-0x18(%ebp)

4000535d:	8b 45 e8             	mov    -0x18(%ebp),%eax
40005360:	c6 00 00             	movb   $0x0,(%eax)
    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
40005363:	8b 45 d8             	mov    -0x28(%ebp),%eax
40005366:	8b 55 dc             	mov    -0x24(%ebp),%edx
40005369:	89 45 f0             	mov    %eax,-0x10(%ebp)
4000536c:	89 55 f4             	mov    %edx,-0xc(%ebp)
        if (count_left > 256) {
            current_count = 256;
        } else {
4000536f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
40005372:	50                   	push   %eax
40005373:	ff 75 14             	pushl  0x14(%ebp)
40005376:	ff 75 f4             	pushl  -0xc(%ebp)
40005379:	ff 75 f0             	pushl  -0x10(%ebp)
4000537c:	e8 eb fe ff ff       	call   4000526c <divmod>
40005381:	83 c4 10             	add    $0x10,%esp
40005384:	89 45 f0             	mov    %eax,-0x10(%ebp)
40005387:	89 55 f4             	mov    %edx,-0xc(%ebp)
            current_count = count_left;
4000538a:	ff 4d e8             	decl   -0x18(%ebp)
4000538d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40005390:	03 45 ec             	add    -0x14(%ebp),%eax
40005393:	8a 10                	mov    (%eax),%dl
40005395:	8b 45 e8             	mov    -0x18(%ebp),%eax
40005398:	88 10                	mov    %dl,(%eax)
        }
        
4000539a:	ff 4d fc             	decl   -0x4(%ebp)
4000539d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
400053a1:	75 cc                	jne    4000536f <ulltoa+0x9c>
        // Request vorbereiten
        request.dev = dev;
400053a3:	8b 45 10             	mov    0x10(%ebp),%eax
400053a6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
400053a9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
        // TODO: DMA, UltraDMA...
400053ac:	c9                   	leave  
400053ad:	c3                   	ret    

400053ae <jprintf_putc>:
        request.registers.ata.command = READ_SECTORS;
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
        // 0 steht.
        request.registers.ata.count = (uint8_t) current_count;
400053ae:	55                   	push   %ebp
400053af:	89 e5                	mov    %esp,%ebp
400053b1:	83 ec 08             	sub    $0x8,%esp
400053b4:	8b 45 0c             	mov    0xc(%ebp),%eax
400053b7:	88 45 fc             	mov    %al,-0x4(%ebp)
        request.registers.ata.lba = lba;
400053ba:	8b 45 08             	mov    0x8(%ebp),%eax
400053bd:	8b 00                	mov    (%eax),%eax
400053bf:	85 c0                	test   %eax,%eax
400053c1:	74 1e                	je     400053e1 <jprintf_putc+0x33>

        request.block_count = current_count;
400053c3:	8b 45 08             	mov    0x8(%ebp),%eax
400053c6:	8b 08                	mov    (%eax),%ecx
400053c8:	0f be 55 fc          	movsbl -0x4(%ebp),%edx
400053cc:	8b 45 08             	mov    0x8(%ebp),%eax
400053cf:	8b 40 08             	mov    0x8(%eax),%eax
400053d2:	83 ec 08             	sub    $0x8,%esp
400053d5:	52                   	push   %edx
400053d6:	50                   	push   %eax
400053d7:	ff d1                	call   *%ecx
400053d9:	83 c4 10             	add    $0x10,%esp
400053dc:	89 45 f8             	mov    %eax,-0x8(%ebp)
400053df:	eb 07                	jmp    400053e8 <jprintf_putc+0x3a>
        request.block_size = ATA_SECTOR_SIZE;
        request.blocks_done = 0;
        request.buffer = current_buffer;
400053e1:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
400053e8:	8b 45 f8             	mov    -0x8(%ebp),%eax

400053eb:	c9                   	leave  
400053ec:	c3                   	ret    

400053ed <jprintf_putsn>:
            break;
        }

        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
        current_buffer += current_count * ATA_SECTOR_SIZE;
        count_left -= current_count;
400053ed:	55                   	push   %ebp
400053ee:	89 e5                	mov    %esp,%ebp
400053f0:	83 ec 18             	sub    $0x18,%esp
        lba += current_count;
400053f3:	8b 45 08             	mov    0x8(%ebp),%eax
400053f6:	8b 40 04             	mov    0x4(%eax),%eax
400053f9:	85 c0                	test   %eax,%eax
400053fb:	74 20                	je     4000541d <jprintf_putsn+0x30>
    }

400053fd:	8b 45 08             	mov    0x8(%ebp),%eax
40005400:	8b 50 04             	mov    0x4(%eax),%edx
40005403:	8b 45 08             	mov    0x8(%ebp),%eax
40005406:	8b 40 08             	mov    0x8(%eax),%eax
40005409:	83 ec 04             	sub    $0x4,%esp
4000540c:	ff 75 10             	pushl  0x10(%ebp)
4000540f:	ff 75 0c             	pushl  0xc(%ebp)
40005412:	50                   	push   %eax
40005413:	ff d2                	call   *%edx
40005415:	83 c4 10             	add    $0x10,%esp
40005418:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000541b:	eb 50                	jmp    4000546d <jprintf_putsn+0x80>
    return result;
}

4000541d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40005424:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
4000542b:	eb 20                	jmp    4000544d <jprintf_putsn+0x60>
4000542d:	8b 45 f8             	mov    -0x8(%ebp),%eax
40005430:	03 45 0c             	add    0xc(%ebp),%eax
40005433:	8a 00                	mov    (%eax),%al
40005435:	0f be c0             	movsbl %al,%eax
40005438:	83 ec 08             	sub    $0x8,%esp
4000543b:	50                   	push   %eax
4000543c:	ff 75 08             	pushl  0x8(%ebp)
4000543f:	e8 6a ff ff ff       	call   400053ae <jprintf_putc>
40005444:	83 c4 10             	add    $0x10,%esp
40005447:	01 45 fc             	add    %eax,-0x4(%ebp)
4000544a:	ff 45 f8             	incl   -0x8(%ebp)

4000544d:	8b 45 f8             	mov    -0x8(%ebp),%eax
40005450:	03 45 0c             	add    0xc(%ebp),%eax
40005453:	8a 00                	mov    (%eax),%al
40005455:	84 c0                	test   %al,%al
40005457:	74 0e                	je     40005467 <jprintf_putsn+0x7a>
40005459:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000545c:	3b 45 10             	cmp    0x10(%ebp),%eax
4000545f:	7c cc                	jl     4000542d <jprintf_putsn+0x40>
40005461:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
40005465:	74 c6                	je     4000542d <jprintf_putsn+0x40>
40005467:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000546a:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000546d:	8b 45 ec             	mov    -0x14(%ebp),%eax
40005470:	c9                   	leave  
40005471:	c3                   	ret    

40005472 <jvprintf>:
40005472:	55                   	push   %ebp
40005473:	89 e5                	mov    %esp,%ebp
40005475:	81 ec 38 01 00 00    	sub    $0x138,%esp
4000547b:	c7 85 58 ff ff ff 00 	movl   $0x0,-0xa8(%ebp)
40005482:	00 00 00 
40005485:	e9 e3 0d 00 00       	jmp    4000626d <jvprintf+0xdfb>
4000548a:	8b 45 0c             	mov    0xc(%ebp),%eax
4000548d:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
40005493:	eb 07                	jmp    4000549c <jvprintf+0x2a>
40005495:	8b 45 0c             	mov    0xc(%ebp),%eax
40005498:	40                   	inc    %eax
40005499:	89 45 0c             	mov    %eax,0xc(%ebp)
4000549c:	8b 45 0c             	mov    0xc(%ebp),%eax
4000549f:	8a 00                	mov    (%eax),%al
400054a1:	3c 25                	cmp    $0x25,%al
400054a3:	74 09                	je     400054ae <jvprintf+0x3c>
400054a5:	8b 45 0c             	mov    0xc(%ebp),%eax
400054a8:	8a 00                	mov    (%eax),%al
400054aa:	84 c0                	test   %al,%al
400054ac:	75 e7                	jne    40005495 <jvprintf+0x23>
400054ae:	8b 45 0c             	mov    0xc(%ebp),%eax
400054b1:	89 c2                	mov    %eax,%edx
400054b3:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
400054b9:	89 d1                	mov    %edx,%ecx
400054bb:	29 c1                	sub    %eax,%ecx
400054bd:	89 c8                	mov    %ecx,%eax
400054bf:	83 ec 04             	sub    $0x4,%esp
400054c2:	50                   	push   %eax
400054c3:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
400054c9:	ff 75 08             	pushl  0x8(%ebp)
400054cc:	e8 1c ff ff ff       	call   400053ed <jprintf_putsn>
400054d1:	83 c4 10             	add    $0x10,%esp
400054d4:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
400054da:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
400054e1:	79 11                	jns    400054f4 <jvprintf+0x82>
400054e3:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
400054e9:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
400054ef:	e9 92 0d 00 00       	jmp    40006286 <jvprintf+0xe14>
400054f4:	8b 45 0c             	mov    0xc(%ebp),%eax
400054f7:	89 c2                	mov    %eax,%edx
400054f9:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
400054ff:	89 d1                	mov    %edx,%ecx
40005501:	29 c1                	sub    %eax,%ecx
40005503:	89 c8                	mov    %ecx,%eax
40005505:	83 f8 ff             	cmp    $0xffffffff,%eax
40005508:	74 32                	je     4000553c <jvprintf+0xca>
4000550a:	8b 45 0c             	mov    0xc(%ebp),%eax
4000550d:	89 c2                	mov    %eax,%edx
4000550f:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
40005515:	89 d1                	mov    %edx,%ecx
40005517:	29 c1                	sub    %eax,%ecx
40005519:	89 c8                	mov    %ecx,%eax
4000551b:	3b 85 6c ff ff ff    	cmp    -0x94(%ebp),%eax
40005521:	74 19                	je     4000553c <jvprintf+0xca>
40005523:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
40005529:	8b 95 58 ff ff ff    	mov    -0xa8(%ebp),%edx
4000552f:	01 c2                	add    %eax,%edx
40005531:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
40005537:	e9 4a 0d 00 00       	jmp    40006286 <jvprintf+0xe14>
4000553c:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
40005542:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005548:	8b 45 0c             	mov    0xc(%ebp),%eax
4000554b:	8a 00                	mov    (%eax),%al
4000554d:	84 c0                	test   %al,%al
4000554f:	0f 84 25 0d 00 00    	je     4000627a <jvprintf+0xe08>
40005555:	8b 45 0c             	mov    0xc(%ebp),%eax
40005558:	40                   	inc    %eax
40005559:	89 45 0c             	mov    %eax,0xc(%ebp)
4000555c:	8b 45 0c             	mov    0xc(%ebp),%eax
4000555f:	8a 00                	mov    (%eax),%al
40005561:	3c 25                	cmp    $0x25,%al
40005563:	75 69                	jne    400055ce <jvprintf+0x15c>
40005565:	8b 45 0c             	mov    0xc(%ebp),%eax
40005568:	8a 00                	mov    (%eax),%al
4000556a:	0f be c0             	movsbl %al,%eax
4000556d:	83 ec 08             	sub    $0x8,%esp
40005570:	50                   	push   %eax
40005571:	ff 75 08             	pushl  0x8(%ebp)
40005574:	e8 35 fe ff ff       	call   400053ae <jprintf_putc>
40005579:	83 c4 10             	add    $0x10,%esp
4000557c:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
40005582:	83 bd 70 ff ff ff 00 	cmpl   $0x0,-0x90(%ebp)
40005589:	79 11                	jns    4000559c <jvprintf+0x12a>
4000558b:	8b 8d 70 ff ff ff    	mov    -0x90(%ebp),%ecx
40005591:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%ebp)
40005597:	e9 ea 0c 00 00       	jmp    40006286 <jvprintf+0xe14>
4000559c:	83 bd 70 ff ff ff 00 	cmpl   $0x0,-0x90(%ebp)
400055a3:	75 11                	jne    400055b6 <jvprintf+0x144>
400055a5:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
400055ab:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
400055b1:	e9 d0 0c 00 00       	jmp    40006286 <jvprintf+0xe14>
400055b6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
400055bc:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
400055c2:	8b 45 0c             	mov    0xc(%ebp),%eax
400055c5:	40                   	inc    %eax
400055c6:	89 45 0c             	mov    %eax,0xc(%ebp)
400055c9:	e9 9f 0c 00 00       	jmp    4000626d <jvprintf+0xdfb>
400055ce:	c6 85 5f ff ff ff 00 	movb   $0x0,-0xa1(%ebp)
400055d5:	c7 85 60 ff ff ff 00 	movl   $0x0,-0xa0(%ebp)
400055dc:	00 00 00 
400055df:	c7 85 64 ff ff ff ff 	movl   $0xffffffff,-0x9c(%ebp)
400055e6:	ff ff ff 
400055e9:	c7 85 68 ff ff ff 20 	movl   $0x20,-0x98(%ebp)
400055f0:	00 00 00 
400055f3:	8b 45 0c             	mov    0xc(%ebp),%eax
400055f6:	8a 00                	mov    (%eax),%al
400055f8:	0f be c0             	movsbl %al,%eax
400055fb:	83 e8 20             	sub    $0x20,%eax
400055fe:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
40005604:	83 bd e0 fe ff ff 10 	cmpl   $0x10,-0x120(%ebp)
4000560b:	77 21                	ja     4000562e <jvprintf+0x1bc>
4000560d:	8b 95 e0 fe ff ff    	mov    -0x120(%ebp),%edx
40005613:	8b 04 95 30 9a 00 40 	mov    0x40009a30(,%edx,4),%eax
4000561a:	ff e0                	jmp    *%eax
4000561c:	8b 45 0c             	mov    0xc(%ebp),%eax
4000561f:	8a 00                	mov    (%eax),%al
40005621:	88 85 5f ff ff ff    	mov    %al,-0xa1(%ebp)
40005627:	8b 45 0c             	mov    0xc(%ebp),%eax
4000562a:	40                   	inc    %eax
4000562b:	89 45 0c             	mov    %eax,0xc(%ebp)
4000562e:	8b 45 0c             	mov    0xc(%ebp),%eax
40005631:	8a 00                	mov    (%eax),%al
40005633:	0f be c0             	movsbl %al,%eax
40005636:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
4000563c:	83 bd e8 fe ff ff 2a 	cmpl   $0x2a,-0x118(%ebp)
40005643:	74 34                	je     40005679 <jvprintf+0x207>
40005645:	83 bd e8 fe ff ff 2a 	cmpl   $0x2a,-0x118(%ebp)
4000564c:	7c 45                	jl     40005693 <jvprintf+0x221>
4000564e:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
40005654:	83 e8 30             	sub    $0x30,%eax
40005657:	83 f8 09             	cmp    $0x9,%eax
4000565a:	77 37                	ja     40005693 <jvprintf+0x221>
4000565c:	8d 45 0c             	lea    0xc(%ebp),%eax
4000565f:	8b 55 0c             	mov    0xc(%ebp),%edx
40005662:	83 ec 04             	sub    $0x4,%esp
40005665:	6a 0a                	push   $0xa
40005667:	50                   	push   %eax
40005668:	52                   	push   %edx
40005669:	e8 76 37 00 00       	call   40008de4 <strtol>
4000566e:	83 c4 10             	add    $0x10,%esp
40005671:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
40005677:	eb 1a                	jmp    40005693 <jvprintf+0x221>
40005679:	8b 55 10             	mov    0x10(%ebp),%edx
4000567c:	8d 42 04             	lea    0x4(%edx),%eax
4000567f:	89 45 10             	mov    %eax,0x10(%ebp)
40005682:	89 d0                	mov    %edx,%eax
40005684:	8b 00                	mov    (%eax),%eax
40005686:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
4000568c:	8b 45 0c             	mov    0xc(%ebp),%eax
4000568f:	40                   	inc    %eax
40005690:	89 45 0c             	mov    %eax,0xc(%ebp)
40005693:	8b 45 0c             	mov    0xc(%ebp),%eax
40005696:	8a 00                	mov    (%eax),%al
40005698:	3c 2e                	cmp    $0x2e,%al
4000569a:	75 6c                	jne    40005708 <jvprintf+0x296>
4000569c:	8b 45 0c             	mov    0xc(%ebp),%eax
4000569f:	40                   	inc    %eax
400056a0:	89 45 0c             	mov    %eax,0xc(%ebp)
400056a3:	8b 45 0c             	mov    0xc(%ebp),%eax
400056a6:	8a 00                	mov    (%eax),%al
400056a8:	0f be c0             	movsbl %al,%eax
400056ab:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
400056b1:	83 bd ec fe ff ff 2a 	cmpl   $0x2a,-0x114(%ebp)
400056b8:	74 34                	je     400056ee <jvprintf+0x27c>
400056ba:	83 bd ec fe ff ff 2a 	cmpl   $0x2a,-0x114(%ebp)
400056c1:	7c 45                	jl     40005708 <jvprintf+0x296>
400056c3:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
400056c9:	83 e8 30             	sub    $0x30,%eax
400056cc:	83 f8 09             	cmp    $0x9,%eax
400056cf:	77 37                	ja     40005708 <jvprintf+0x296>
400056d1:	8d 45 0c             	lea    0xc(%ebp),%eax
400056d4:	8b 55 0c             	mov    0xc(%ebp),%edx
400056d7:	83 ec 04             	sub    $0x4,%esp
400056da:	6a 0a                	push   $0xa
400056dc:	50                   	push   %eax
400056dd:	52                   	push   %edx
400056de:	e8 01 37 00 00       	call   40008de4 <strtol>
400056e3:	83 c4 10             	add    $0x10,%esp
400056e6:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
400056ec:	eb 1a                	jmp    40005708 <jvprintf+0x296>
400056ee:	8b 55 10             	mov    0x10(%ebp),%edx
400056f1:	8d 42 04             	lea    0x4(%edx),%eax
400056f4:	89 45 10             	mov    %eax,0x10(%ebp)
400056f7:	89 d0                	mov    %edx,%eax
400056f9:	8b 00                	mov    (%eax),%eax
400056fb:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
40005701:	8b 45 0c             	mov    0xc(%ebp),%eax
40005704:	40                   	inc    %eax
40005705:	89 45 0c             	mov    %eax,0xc(%ebp)
40005708:	8b 45 0c             	mov    0xc(%ebp),%eax
4000570b:	8a 00                	mov    (%eax),%al
4000570d:	0f be c0             	movsbl %al,%eax
40005710:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
40005716:	83 bd f0 fe ff ff 68 	cmpl   $0x68,-0x110(%ebp)
4000571d:	74 14                	je     40005733 <jvprintf+0x2c1>
4000571f:	83 bd f0 fe ff ff 6c 	cmpl   $0x6c,-0x110(%ebp)
40005726:	74 38                	je     40005760 <jvprintf+0x2ee>
40005728:	83 bd f0 fe ff ff 4c 	cmpl   $0x4c,-0x110(%ebp)
4000572f:	74 5c                	je     4000578d <jvprintf+0x31b>
40005731:	eb 61                	jmp    40005794 <jvprintf+0x322>
40005733:	c7 85 68 ff ff ff 10 	movl   $0x10,-0x98(%ebp)
4000573a:	00 00 00 
4000573d:	8b 45 0c             	mov    0xc(%ebp),%eax
40005740:	40                   	inc    %eax
40005741:	89 45 0c             	mov    %eax,0xc(%ebp)
40005744:	8b 45 0c             	mov    0xc(%ebp),%eax
40005747:	8a 00                	mov    (%eax),%al
40005749:	3c 68                	cmp    $0x68,%al
4000574b:	75 47                	jne    40005794 <jvprintf+0x322>
4000574d:	c7 85 68 ff ff ff 08 	movl   $0x8,-0x98(%ebp)
40005754:	00 00 00 
40005757:	8b 45 0c             	mov    0xc(%ebp),%eax
4000575a:	40                   	inc    %eax
4000575b:	89 45 0c             	mov    %eax,0xc(%ebp)
4000575e:	eb 34                	jmp    40005794 <jvprintf+0x322>
40005760:	c7 85 68 ff ff ff 20 	movl   $0x20,-0x98(%ebp)
40005767:	00 00 00 
4000576a:	8b 45 0c             	mov    0xc(%ebp),%eax
4000576d:	40                   	inc    %eax
4000576e:	89 45 0c             	mov    %eax,0xc(%ebp)
40005771:	8b 45 0c             	mov    0xc(%ebp),%eax
40005774:	8a 00                	mov    (%eax),%al
40005776:	3c 6c                	cmp    $0x6c,%al
40005778:	75 1a                	jne    40005794 <jvprintf+0x322>
4000577a:	c7 85 68 ff ff ff 40 	movl   $0x40,-0x98(%ebp)
40005781:	00 00 00 
40005784:	8b 45 0c             	mov    0xc(%ebp),%eax
40005787:	40                   	inc    %eax
40005788:	89 45 0c             	mov    %eax,0xc(%ebp)
4000578b:	eb 07                	jmp    40005794 <jvprintf+0x322>
4000578d:	8b 45 0c             	mov    0xc(%ebp),%eax
40005790:	40                   	inc    %eax
40005791:	89 45 0c             	mov    %eax,0xc(%ebp)
40005794:	8b 45 0c             	mov    0xc(%ebp),%eax
40005797:	8a 00                	mov    (%eax),%al
40005799:	0f be c0             	movsbl %al,%eax
4000579c:	83 e8 58             	sub    $0x58,%eax
4000579f:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
400057a5:	83 bd dc fe ff ff 20 	cmpl   $0x20,-0x124(%ebp)
400057ac:	0f 87 bb 0a 00 00    	ja     4000626d <jvprintf+0xdfb>
400057b2:	8b 8d dc fe ff ff    	mov    -0x124(%ebp),%ecx
400057b8:	8b 04 8d 74 9a 00 40 	mov    0x40009a74(,%ecx,4),%eax
400057bf:	ff e0                	jmp    *%eax
400057c1:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
400057c8:	00 00 00 
400057cb:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
400057d2:	00 00 00 
400057d5:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
400057db:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
400057e1:	83 bd d8 fe ff ff 10 	cmpl   $0x10,-0x128(%ebp)
400057e8:	74 28                	je     40005812 <jvprintf+0x3a0>
400057ea:	83 bd d8 fe ff ff 10 	cmpl   $0x10,-0x128(%ebp)
400057f1:	77 0b                	ja     400057fe <jvprintf+0x38c>
400057f3:	83 bd d8 fe ff ff 08 	cmpl   $0x8,-0x128(%ebp)
400057fa:	74 16                	je     40005812 <jvprintf+0x3a0>
400057fc:	eb 50                	jmp    4000584e <jvprintf+0x3dc>
400057fe:	83 bd d8 fe ff ff 20 	cmpl   $0x20,-0x128(%ebp)
40005805:	74 0b                	je     40005812 <jvprintf+0x3a0>
40005807:	83 bd d8 fe ff ff 40 	cmpl   $0x40,-0x128(%ebp)
4000580e:	74 22                	je     40005832 <jvprintf+0x3c0>
40005810:	eb 3c                	jmp    4000584e <jvprintf+0x3dc>
40005812:	8b 55 10             	mov    0x10(%ebp),%edx
40005815:	8d 42 04             	lea    0x4(%edx),%eax
40005818:	89 45 10             	mov    %eax,0x10(%ebp)
4000581b:	89 d0                	mov    %edx,%eax
4000581d:	8b 00                	mov    (%eax),%eax
4000581f:	ba 00 00 00 00       	mov    $0x0,%edx
40005824:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
4000582a:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
40005830:	eb 1c                	jmp    4000584e <jvprintf+0x3dc>
40005832:	8b 55 10             	mov    0x10(%ebp),%edx
40005835:	8d 42 08             	lea    0x8(%edx),%eax
40005838:	89 45 10             	mov    %eax,0x10(%ebp)
4000583b:	89 d0                	mov    %edx,%eax
4000583d:	8b 50 04             	mov    0x4(%eax),%edx
40005840:	8b 00                	mov    (%eax),%eax
40005842:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
40005848:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
4000584e:	8b 45 0c             	mov    0xc(%ebp),%eax
40005851:	8a 00                	mov    (%eax),%al
40005853:	3c 58                	cmp    $0x58,%al
40005855:	0f 94 c0             	sete   %al
40005858:	0f b6 c0             	movzbl %al,%eax
4000585b:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
40005861:	8b 45 0c             	mov    0xc(%ebp),%eax
40005864:	8a 00                	mov    (%eax),%al
40005866:	3c 70                	cmp    $0x70,%al
40005868:	74 3f                	je     400058a9 <jvprintf+0x437>
4000586a:	8b 45 0c             	mov    0xc(%ebp),%eax
4000586d:	8a 00                	mov    (%eax),%al
4000586f:	3c 78                	cmp    $0x78,%al
40005871:	74 36                	je     400058a9 <jvprintf+0x437>
40005873:	8b 45 0c             	mov    0xc(%ebp),%eax
40005876:	8a 00                	mov    (%eax),%al
40005878:	3c 58                	cmp    $0x58,%al
4000587a:	74 2d                	je     400058a9 <jvprintf+0x437>
4000587c:	8b 45 0c             	mov    0xc(%ebp),%eax
4000587f:	8a 00                	mov    (%eax),%al
40005881:	3c 6f                	cmp    $0x6f,%al
40005883:	75 0c                	jne    40005891 <jvprintf+0x41f>
40005885:	c7 85 fc fe ff ff 08 	movl   $0x8,-0x104(%ebp)
4000588c:	00 00 00 
4000588f:	eb 0a                	jmp    4000589b <jvprintf+0x429>
40005891:	c7 85 fc fe ff ff 0a 	movl   $0xa,-0x104(%ebp)
40005898:	00 00 00 
4000589b:	8b 95 fc fe ff ff    	mov    -0x104(%ebp),%edx
400058a1:	89 95 f8 fe ff ff    	mov    %edx,-0x108(%ebp)
400058a7:	eb 0a                	jmp    400058b3 <jvprintf+0x441>
400058a9:	c7 85 f8 fe ff ff 10 	movl   $0x10,-0x108(%ebp)
400058b0:	00 00 00 
400058b3:	83 ec 0c             	sub    $0xc,%esp
400058b6:	ff b5 f4 fe ff ff    	pushl  -0x10c(%ebp)
400058bc:	ff b5 f8 fe ff ff    	pushl  -0x108(%ebp)
400058c2:	8d 85 11 ff ff ff    	lea    -0xef(%ebp),%eax
400058c8:	50                   	push   %eax
400058c9:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
400058cf:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
400058d5:	e8 f9 f9 ff ff       	call   400052d3 <ulltoa>
400058da:	83 c4 20             	add    $0x20,%esp
400058dd:	c7 85 74 ff ff ff 01 	movl   $0x1,-0x8c(%ebp)
400058e4:	00 00 00 
400058e7:	e9 10 01 00 00       	jmp    400059fc <jvprintf+0x58a>
400058ec:	c7 45 80 00 00 00 00 	movl   $0x0,-0x80(%ebp)
400058f3:	c7 45 84 00 00 00 00 	movl   $0x0,-0x7c(%ebp)
400058fa:	8b 8d 68 ff ff ff    	mov    -0x98(%ebp),%ecx
40005900:	89 8d d4 fe ff ff    	mov    %ecx,-0x12c(%ebp)
40005906:	83 bd d4 fe ff ff 10 	cmpl   $0x10,-0x12c(%ebp)
4000590d:	74 28                	je     40005937 <jvprintf+0x4c5>
4000590f:	83 bd d4 fe ff ff 10 	cmpl   $0x10,-0x12c(%ebp)
40005916:	77 0b                	ja     40005923 <jvprintf+0x4b1>
40005918:	83 bd d4 fe ff ff 08 	cmpl   $0x8,-0x12c(%ebp)
4000591f:	74 16                	je     40005937 <jvprintf+0x4c5>
40005921:	eb 40                	jmp    40005963 <jvprintf+0x4f1>
40005923:	83 bd d4 fe ff ff 20 	cmpl   $0x20,-0x12c(%ebp)
4000592a:	74 0b                	je     40005937 <jvprintf+0x4c5>
4000592c:	83 bd d4 fe ff ff 40 	cmpl   $0x40,-0x12c(%ebp)
40005933:	74 18                	je     4000594d <jvprintf+0x4db>
40005935:	eb 2c                	jmp    40005963 <jvprintf+0x4f1>
40005937:	8b 55 10             	mov    0x10(%ebp),%edx
4000593a:	8d 42 04             	lea    0x4(%edx),%eax
4000593d:	89 45 10             	mov    %eax,0x10(%ebp)
40005940:	89 d0                	mov    %edx,%eax
40005942:	8b 00                	mov    (%eax),%eax
40005944:	99                   	cltd   
40005945:	89 45 80             	mov    %eax,-0x80(%ebp)
40005948:	89 55 84             	mov    %edx,-0x7c(%ebp)
4000594b:	eb 16                	jmp    40005963 <jvprintf+0x4f1>
4000594d:	8b 55 10             	mov    0x10(%ebp),%edx
40005950:	8d 42 08             	lea    0x8(%edx),%eax
40005953:	89 45 10             	mov    %eax,0x10(%ebp)
40005956:	89 d0                	mov    %edx,%eax
40005958:	8b 50 04             	mov    0x4(%eax),%edx
4000595b:	8b 00                	mov    (%eax),%eax
4000595d:	89 45 80             	mov    %eax,-0x80(%ebp)
40005960:	89 55 84             	mov    %edx,-0x7c(%ebp)
40005963:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
40005967:	79 31                	jns    4000599a <jvprintf+0x528>
40005969:	c6 85 11 ff ff ff 2d 	movb   $0x2d,-0xef(%ebp)
40005970:	8d 85 11 ff ff ff    	lea    -0xef(%ebp),%eax
40005976:	8d 48 01             	lea    0x1(%eax),%ecx
40005979:	8b 45 80             	mov    -0x80(%ebp),%eax
4000597c:	8b 55 84             	mov    -0x7c(%ebp),%edx
4000597f:	f7 d8                	neg    %eax
40005981:	83 d2 00             	adc    $0x0,%edx
40005984:	f7 da                	neg    %edx
40005986:	83 ec 0c             	sub    $0xc,%esp
40005989:	6a 00                	push   $0x0
4000598b:	6a 0a                	push   $0xa
4000598d:	51                   	push   %ecx
4000598e:	52                   	push   %edx
4000598f:	50                   	push   %eax
40005990:	e8 3e f9 ff ff       	call   400052d3 <ulltoa>
40005995:	83 c4 20             	add    $0x20,%esp
40005998:	eb 1e                	jmp    400059b8 <jvprintf+0x546>
4000599a:	8b 55 80             	mov    -0x80(%ebp),%edx
4000599d:	8b 4d 84             	mov    -0x7c(%ebp),%ecx
400059a0:	83 ec 0c             	sub    $0xc,%esp
400059a3:	6a 00                	push   $0x0
400059a5:	6a 0a                	push   $0xa
400059a7:	8d 85 11 ff ff ff    	lea    -0xef(%ebp),%eax
400059ad:	50                   	push   %eax
400059ae:	51                   	push   %ecx
400059af:	52                   	push   %edx
400059b0:	e8 1e f9 ff ff       	call   400052d3 <ulltoa>
400059b5:	83 c4 20             	add    $0x20,%esp
400059b8:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
400059bc:	78 28                	js     400059e6 <jvprintf+0x574>
400059be:	c7 85 00 ff ff ff 01 	movl   $0x1,-0x100(%ebp)
400059c5:	00 00 00 
400059c8:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
400059cc:	7f 22                	jg     400059f0 <jvprintf+0x57e>
400059ce:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
400059d2:	78 06                	js     400059da <jvprintf+0x568>
400059d4:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
400059d8:	77 16                	ja     400059f0 <jvprintf+0x57e>
400059da:	c7 85 00 ff ff ff 00 	movl   $0x0,-0x100(%ebp)
400059e1:	00 00 00 
400059e4:	eb 0a                	jmp    400059f0 <jvprintf+0x57e>
400059e6:	c7 85 00 ff ff ff ff 	movl   $0xffffffff,-0x100(%ebp)
400059ed:	ff ff ff 
400059f0:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
400059f6:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
400059fc:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
40005a03:	0f 84 ba 03 00 00    	je     40005dc3 <jvprintf+0x951>
40005a09:	83 ec 0c             	sub    $0xc,%esp
40005a0c:	8d 85 11 ff ff ff    	lea    -0xef(%ebp),%eax
40005a12:	50                   	push   %eax
40005a13:	e8 5c 38 00 00       	call   40009274 <strlen>
40005a18:	83 c4 10             	add    $0x10,%esp
40005a1b:	89 45 8c             	mov    %eax,-0x74(%ebp)
40005a1e:	0f be 95 5f ff ff ff 	movsbl -0xa1(%ebp),%edx
40005a25:	89 95 04 ff ff ff    	mov    %edx,-0xfc(%ebp)
40005a2b:	83 bd 04 ff ff ff 30 	cmpl   $0x30,-0xfc(%ebp)
40005a32:	0f 87 4f 03 00 00    	ja     40005d87 <jvprintf+0x915>
40005a38:	8b 8d 04 ff ff ff    	mov    -0xfc(%ebp),%ecx
40005a3e:	8b 04 8d f8 9a 00 40 	mov    0x40009af8(,%ecx,4),%eax
40005a45:	ff e0                	jmp    *%eax
40005a47:	83 ec 08             	sub    $0x8,%esp
40005a4a:	6a 20                	push   $0x20
40005a4c:	ff 75 08             	pushl  0x8(%ebp)
40005a4f:	e8 5a f9 ff ff       	call   400053ae <jprintf_putc>
40005a54:	83 c4 10             	add    $0x10,%esp
40005a57:	89 45 90             	mov    %eax,-0x70(%ebp)
40005a5a:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
40005a5e:	79 0e                	jns    40005a6e <jvprintf+0x5fc>
40005a60:	8b 45 90             	mov    -0x70(%ebp),%eax
40005a63:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
40005a69:	e9 18 08 00 00       	jmp    40006286 <jvprintf+0xe14>
40005a6e:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
40005a72:	75 11                	jne    40005a85 <jvprintf+0x613>
40005a74:	8b 95 58 ff ff ff    	mov    -0xa8(%ebp),%edx
40005a7a:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
40005a80:	e9 01 08 00 00       	jmp    40006286 <jvprintf+0xe14>
40005a85:	8b 45 90             	mov    -0x70(%ebp),%eax
40005a88:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005a8e:	ff 45 8c             	incl   -0x74(%ebp)
40005a91:	8b 45 8c             	mov    -0x74(%ebp),%eax
40005a94:	3b 85 60 ff ff ff    	cmp    -0xa0(%ebp),%eax
40005a9a:	72 ab                	jb     40005a47 <jvprintf+0x5d5>
40005a9c:	83 ec 04             	sub    $0x4,%esp
40005a9f:	6a ff                	push   $0xffffffff
40005aa1:	8d 85 11 ff ff ff    	lea    -0xef(%ebp),%eax
40005aa7:	50                   	push   %eax
40005aa8:	ff 75 08             	pushl  0x8(%ebp)
40005aab:	e8 3d f9 ff ff       	call   400053ed <jprintf_putsn>
40005ab0:	83 c4 10             	add    $0x10,%esp
40005ab3:	89 45 94             	mov    %eax,-0x6c(%ebp)
40005ab6:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
40005aba:	79 0e                	jns    40005aca <jvprintf+0x658>
40005abc:	8b 4d 94             	mov    -0x6c(%ebp),%ecx
40005abf:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%ebp)
40005ac5:	e9 bc 07 00 00       	jmp    40006286 <jvprintf+0xe14>
40005aca:	8b 45 94             	mov    -0x6c(%ebp),%eax
40005acd:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005ad3:	e9 ec 03 00 00       	jmp    40005ec4 <jvprintf+0xa52>
40005ad8:	83 ec 04             	sub    $0x4,%esp
40005adb:	6a ff                	push   $0xffffffff
40005add:	8d 85 11 ff ff ff    	lea    -0xef(%ebp),%eax
40005ae3:	50                   	push   %eax
40005ae4:	ff 75 08             	pushl  0x8(%ebp)
40005ae7:	e8 01 f9 ff ff       	call   400053ed <jprintf_putsn>
40005aec:	83 c4 10             	add    $0x10,%esp
40005aef:	89 45 98             	mov    %eax,-0x68(%ebp)
40005af2:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
40005af6:	79 0e                	jns    40005b06 <jvprintf+0x694>
40005af8:	8b 45 98             	mov    -0x68(%ebp),%eax
40005afb:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
40005b01:	e9 80 07 00 00       	jmp    40006286 <jvprintf+0xe14>
40005b06:	8b 45 98             	mov    -0x68(%ebp),%eax
40005b09:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005b0f:	eb 4a                	jmp    40005b5b <jvprintf+0x6e9>
40005b11:	83 ec 08             	sub    $0x8,%esp
40005b14:	6a 20                	push   $0x20
40005b16:	ff 75 08             	pushl  0x8(%ebp)
40005b19:	e8 90 f8 ff ff       	call   400053ae <jprintf_putc>
40005b1e:	83 c4 10             	add    $0x10,%esp
40005b21:	89 45 9c             	mov    %eax,-0x64(%ebp)
40005b24:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
40005b28:	79 0e                	jns    40005b38 <jvprintf+0x6c6>
40005b2a:	8b 55 9c             	mov    -0x64(%ebp),%edx
40005b2d:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
40005b33:	e9 4e 07 00 00       	jmp    40006286 <jvprintf+0xe14>
40005b38:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
40005b3c:	75 11                	jne    40005b4f <jvprintf+0x6dd>
40005b3e:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
40005b44:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%ebp)
40005b4a:	e9 37 07 00 00       	jmp    40006286 <jvprintf+0xe14>
40005b4f:	8b 45 9c             	mov    -0x64(%ebp),%eax
40005b52:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005b58:	ff 45 8c             	incl   -0x74(%ebp)
40005b5b:	8b 45 8c             	mov    -0x74(%ebp),%eax
40005b5e:	3b 85 60 ff ff ff    	cmp    -0xa0(%ebp),%eax
40005b64:	72 ab                	jb     40005b11 <jvprintf+0x69f>
40005b66:	e9 59 03 00 00       	jmp    40005ec4 <jvprintf+0xa52>
40005b6b:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
40005b72:	0f 89 93 00 00 00    	jns    40005c0b <jvprintf+0x799>
40005b78:	83 ec 08             	sub    $0x8,%esp
40005b7b:	6a 2d                	push   $0x2d
40005b7d:	ff 75 08             	pushl  0x8(%ebp)
40005b80:	e8 29 f8 ff ff       	call   400053ae <jprintf_putc>
40005b85:	83 c4 10             	add    $0x10,%esp
40005b88:	89 45 a0             	mov    %eax,-0x60(%ebp)
40005b8b:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
40005b8f:	79 0e                	jns    40005b9f <jvprintf+0x72d>
40005b91:	8b 45 a0             	mov    -0x60(%ebp),%eax
40005b94:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
40005b9a:	e9 e7 06 00 00       	jmp    40006286 <jvprintf+0xe14>
40005b9f:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
40005ba3:	75 11                	jne    40005bb6 <jvprintf+0x744>
40005ba5:	8b 95 58 ff ff ff    	mov    -0xa8(%ebp),%edx
40005bab:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
40005bb1:	e9 d0 06 00 00       	jmp    40006286 <jvprintf+0xe14>
40005bb6:	8b 45 a0             	mov    -0x60(%ebp),%eax
40005bb9:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005bbf:	eb 4a                	jmp    40005c0b <jvprintf+0x799>
40005bc1:	83 ec 08             	sub    $0x8,%esp
40005bc4:	6a 30                	push   $0x30
40005bc6:	ff 75 08             	pushl  0x8(%ebp)
40005bc9:	e8 e0 f7 ff ff       	call   400053ae <jprintf_putc>
40005bce:	83 c4 10             	add    $0x10,%esp
40005bd1:	89 45 a4             	mov    %eax,-0x5c(%ebp)
40005bd4:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
40005bd8:	79 0e                	jns    40005be8 <jvprintf+0x776>
40005bda:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
40005bdd:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%ebp)
40005be3:	e9 9e 06 00 00       	jmp    40006286 <jvprintf+0xe14>
40005be8:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
40005bec:	75 11                	jne    40005bff <jvprintf+0x78d>
40005bee:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
40005bf4:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
40005bfa:	e9 87 06 00 00       	jmp    40006286 <jvprintf+0xe14>
40005bff:	8b 45 a4             	mov    -0x5c(%ebp),%eax
40005c02:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005c08:	ff 45 8c             	incl   -0x74(%ebp)
40005c0b:	8b 45 8c             	mov    -0x74(%ebp),%eax
40005c0e:	3b 85 60 ff ff ff    	cmp    -0xa0(%ebp),%eax
40005c14:	72 ab                	jb     40005bc1 <jvprintf+0x74f>
40005c16:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
40005c1d:	79 3d                	jns    40005c5c <jvprintf+0x7ea>
40005c1f:	8d 85 11 ff ff ff    	lea    -0xef(%ebp),%eax
40005c25:	40                   	inc    %eax
40005c26:	83 ec 04             	sub    $0x4,%esp
40005c29:	6a ff                	push   $0xffffffff
40005c2b:	50                   	push   %eax
40005c2c:	ff 75 08             	pushl  0x8(%ebp)
40005c2f:	e8 b9 f7 ff ff       	call   400053ed <jprintf_putsn>
40005c34:	83 c4 10             	add    $0x10,%esp
40005c37:	89 45 a8             	mov    %eax,-0x58(%ebp)
40005c3a:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
40005c3e:	79 0e                	jns    40005c4e <jvprintf+0x7dc>
40005c40:	8b 55 a8             	mov    -0x58(%ebp),%edx
40005c43:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
40005c49:	e9 38 06 00 00       	jmp    40006286 <jvprintf+0xe14>
40005c4e:	8b 45 a8             	mov    -0x58(%ebp),%eax
40005c51:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005c57:	e9 68 02 00 00       	jmp    40005ec4 <jvprintf+0xa52>
40005c5c:	83 ec 04             	sub    $0x4,%esp
40005c5f:	6a ff                	push   $0xffffffff
40005c61:	8d 85 11 ff ff ff    	lea    -0xef(%ebp),%eax
40005c67:	50                   	push   %eax
40005c68:	ff 75 08             	pushl  0x8(%ebp)
40005c6b:	e8 7d f7 ff ff       	call   400053ed <jprintf_putsn>
40005c70:	83 c4 10             	add    $0x10,%esp
40005c73:	89 45 ac             	mov    %eax,-0x54(%ebp)
40005c76:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
40005c7a:	79 0e                	jns    40005c8a <jvprintf+0x818>
40005c7c:	8b 4d ac             	mov    -0x54(%ebp),%ecx
40005c7f:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%ebp)
40005c85:	e9 fc 05 00 00       	jmp    40006286 <jvprintf+0xe14>
40005c8a:	8b 45 ac             	mov    -0x54(%ebp),%eax
40005c8d:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005c93:	e9 2c 02 00 00       	jmp    40005ec4 <jvprintf+0xa52>
40005c98:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
40005c9f:	78 4f                	js     40005cf0 <jvprintf+0x87e>
40005ca1:	ff 45 8c             	incl   -0x74(%ebp)
40005ca4:	eb 4a                	jmp    40005cf0 <jvprintf+0x87e>
40005ca6:	83 ec 08             	sub    $0x8,%esp
40005ca9:	6a 20                	push   $0x20
40005cab:	ff 75 08             	pushl  0x8(%ebp)
40005cae:	e8 fb f6 ff ff       	call   400053ae <jprintf_putc>
40005cb3:	83 c4 10             	add    $0x10,%esp
40005cb6:	89 45 b0             	mov    %eax,-0x50(%ebp)
40005cb9:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
40005cbd:	79 0e                	jns    40005ccd <jvprintf+0x85b>
40005cbf:	8b 45 b0             	mov    -0x50(%ebp),%eax
40005cc2:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
40005cc8:	e9 b9 05 00 00       	jmp    40006286 <jvprintf+0xe14>
40005ccd:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
40005cd1:	75 11                	jne    40005ce4 <jvprintf+0x872>
40005cd3:	8b 95 58 ff ff ff    	mov    -0xa8(%ebp),%edx
40005cd9:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
40005cdf:	e9 a2 05 00 00       	jmp    40006286 <jvprintf+0xe14>
40005ce4:	8b 45 b0             	mov    -0x50(%ebp),%eax
40005ce7:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005ced:	ff 45 8c             	incl   -0x74(%ebp)
40005cf0:	8b 45 8c             	mov    -0x74(%ebp),%eax
40005cf3:	3b 85 60 ff ff ff    	cmp    -0xa0(%ebp),%eax
40005cf9:	72 ab                	jb     40005ca6 <jvprintf+0x834>
40005cfb:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
40005d02:	78 47                	js     40005d4b <jvprintf+0x8d9>
40005d04:	83 ec 08             	sub    $0x8,%esp
40005d07:	6a 2b                	push   $0x2b
40005d09:	ff 75 08             	pushl  0x8(%ebp)
40005d0c:	e8 9d f6 ff ff       	call   400053ae <jprintf_putc>
40005d11:	83 c4 10             	add    $0x10,%esp
40005d14:	89 45 b4             	mov    %eax,-0x4c(%ebp)
40005d17:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
40005d1b:	79 0e                	jns    40005d2b <jvprintf+0x8b9>
40005d1d:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
40005d20:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%ebp)
40005d26:	e9 5b 05 00 00       	jmp    40006286 <jvprintf+0xe14>
40005d2b:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
40005d2f:	75 11                	jne    40005d42 <jvprintf+0x8d0>
40005d31:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
40005d37:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
40005d3d:	e9 44 05 00 00       	jmp    40006286 <jvprintf+0xe14>
40005d42:	8b 45 b4             	mov    -0x4c(%ebp),%eax
40005d45:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005d4b:	83 ec 04             	sub    $0x4,%esp
40005d4e:	6a ff                	push   $0xffffffff
40005d50:	8d 85 11 ff ff ff    	lea    -0xef(%ebp),%eax
40005d56:	50                   	push   %eax
40005d57:	ff 75 08             	pushl  0x8(%ebp)
40005d5a:	e8 8e f6 ff ff       	call   400053ed <jprintf_putsn>
40005d5f:	83 c4 10             	add    $0x10,%esp
40005d62:	89 45 b8             	mov    %eax,-0x48(%ebp)
40005d65:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
40005d69:	79 0e                	jns    40005d79 <jvprintf+0x907>
40005d6b:	8b 55 b8             	mov    -0x48(%ebp),%edx
40005d6e:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
40005d74:	e9 0d 05 00 00       	jmp    40006286 <jvprintf+0xe14>
40005d79:	8b 45 b8             	mov    -0x48(%ebp),%eax
40005d7c:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005d82:	e9 3d 01 00 00       	jmp    40005ec4 <jvprintf+0xa52>
40005d87:	83 ec 04             	sub    $0x4,%esp
40005d8a:	6a ff                	push   $0xffffffff
40005d8c:	8d 85 11 ff ff ff    	lea    -0xef(%ebp),%eax
40005d92:	50                   	push   %eax
40005d93:	ff 75 08             	pushl  0x8(%ebp)
40005d96:	e8 52 f6 ff ff       	call   400053ed <jprintf_putsn>
40005d9b:	83 c4 10             	add    $0x10,%esp
40005d9e:	89 45 bc             	mov    %eax,-0x44(%ebp)
40005da1:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
40005da5:	79 0e                	jns    40005db5 <jvprintf+0x943>
40005da7:	8b 4d bc             	mov    -0x44(%ebp),%ecx
40005daa:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%ebp)
40005db0:	e9 d1 04 00 00       	jmp    40006286 <jvprintf+0xe14>
40005db5:	8b 45 bc             	mov    -0x44(%ebp),%eax
40005db8:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005dbe:	e9 01 01 00 00       	jmp    40005ec4 <jvprintf+0xa52>
40005dc3:	0f be 85 5f ff ff ff 	movsbl -0xa1(%ebp),%eax
40005dca:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%ebp)
40005dd0:	83 bd 08 ff ff ff 20 	cmpl   $0x20,-0xf8(%ebp)
40005dd7:	74 64                	je     40005e3d <jvprintf+0x9cb>
40005dd9:	83 bd 08 ff ff ff 2b 	cmpl   $0x2b,-0xf8(%ebp)
40005de0:	74 05                	je     40005de7 <jvprintf+0x975>
40005de2:	e9 a6 00 00 00       	jmp    40005e8d <jvprintf+0xa1b>
40005de7:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
40005dee:	0f 88 99 00 00 00    	js     40005e8d <jvprintf+0xa1b>
40005df4:	83 ec 08             	sub    $0x8,%esp
40005df7:	6a 2b                	push   $0x2b
40005df9:	ff 75 08             	pushl  0x8(%ebp)
40005dfc:	e8 ad f5 ff ff       	call   400053ae <jprintf_putc>
40005e01:	83 c4 10             	add    $0x10,%esp
40005e04:	89 45 c0             	mov    %eax,-0x40(%ebp)
40005e07:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
40005e0b:	79 0e                	jns    40005e1b <jvprintf+0x9a9>
40005e0d:	8b 55 c0             	mov    -0x40(%ebp),%edx
40005e10:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
40005e16:	e9 6b 04 00 00       	jmp    40006286 <jvprintf+0xe14>
40005e1b:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
40005e1f:	75 11                	jne    40005e32 <jvprintf+0x9c0>
40005e21:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
40005e27:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%ebp)
40005e2d:	e9 54 04 00 00       	jmp    40006286 <jvprintf+0xe14>
40005e32:	8b 45 c0             	mov    -0x40(%ebp),%eax
40005e35:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005e3b:	eb 50                	jmp    40005e8d <jvprintf+0xa1b>
40005e3d:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
40005e44:	78 47                	js     40005e8d <jvprintf+0xa1b>
40005e46:	83 ec 08             	sub    $0x8,%esp
40005e49:	6a 20                	push   $0x20
40005e4b:	ff 75 08             	pushl  0x8(%ebp)
40005e4e:	e8 5b f5 ff ff       	call   400053ae <jprintf_putc>
40005e53:	83 c4 10             	add    $0x10,%esp
40005e56:	89 45 c4             	mov    %eax,-0x3c(%ebp)
40005e59:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
40005e5d:	79 0e                	jns    40005e6d <jvprintf+0x9fb>
40005e5f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
40005e62:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
40005e68:	e9 19 04 00 00       	jmp    40006286 <jvprintf+0xe14>
40005e6d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
40005e71:	75 11                	jne    40005e84 <jvprintf+0xa12>
40005e73:	8b 95 58 ff ff ff    	mov    -0xa8(%ebp),%edx
40005e79:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
40005e7f:	e9 02 04 00 00       	jmp    40006286 <jvprintf+0xe14>
40005e84:	8b 45 c4             	mov    -0x3c(%ebp),%eax
40005e87:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005e8d:	83 ec 04             	sub    $0x4,%esp
40005e90:	6a ff                	push   $0xffffffff
40005e92:	8d 85 11 ff ff ff    	lea    -0xef(%ebp),%eax
40005e98:	50                   	push   %eax
40005e99:	ff 75 08             	pushl  0x8(%ebp)
40005e9c:	e8 4c f5 ff ff       	call   400053ed <jprintf_putsn>
40005ea1:	83 c4 10             	add    $0x10,%esp
40005ea4:	89 45 c8             	mov    %eax,-0x38(%ebp)
40005ea7:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
40005eab:	79 0e                	jns    40005ebb <jvprintf+0xa49>
40005ead:	8b 4d c8             	mov    -0x38(%ebp),%ecx
40005eb0:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%ebp)
40005eb6:	e9 cb 03 00 00       	jmp    40006286 <jvprintf+0xe14>
40005ebb:	8b 45 c8             	mov    -0x38(%ebp),%eax
40005ebe:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005ec4:	8b 45 0c             	mov    0xc(%ebp),%eax
40005ec7:	40                   	inc    %eax
40005ec8:	89 45 0c             	mov    %eax,0xc(%ebp)
40005ecb:	e9 9d 03 00 00       	jmp    4000626d <jvprintf+0xdfb>
40005ed0:	8b 55 10             	mov    0x10(%ebp),%edx
40005ed3:	8d 42 04             	lea    0x4(%edx),%eax
40005ed6:	89 45 10             	mov    %eax,0x10(%ebp)
40005ed9:	89 d0                	mov    %edx,%eax
40005edb:	8b 00                	mov    (%eax),%eax
40005edd:	88 45 cf             	mov    %al,-0x31(%ebp)
40005ee0:	0f be 45 cf          	movsbl -0x31(%ebp),%eax
40005ee4:	83 ec 08             	sub    $0x8,%esp
40005ee7:	50                   	push   %eax
40005ee8:	ff 75 08             	pushl  0x8(%ebp)
40005eeb:	e8 be f4 ff ff       	call   400053ae <jprintf_putc>
40005ef0:	83 c4 10             	add    $0x10,%esp
40005ef3:	89 45 d0             	mov    %eax,-0x30(%ebp)
40005ef6:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
40005efa:	79 0e                	jns    40005f0a <jvprintf+0xa98>
40005efc:	8b 45 d0             	mov    -0x30(%ebp),%eax
40005eff:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
40005f05:	e9 7c 03 00 00       	jmp    40006286 <jvprintf+0xe14>
40005f0a:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
40005f0e:	75 11                	jne    40005f21 <jvprintf+0xaaf>
40005f10:	8b 95 58 ff ff ff    	mov    -0xa8(%ebp),%edx
40005f16:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
40005f1c:	e9 65 03 00 00       	jmp    40006286 <jvprintf+0xe14>
40005f21:	8b 45 d0             	mov    -0x30(%ebp),%eax
40005f24:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40005f2a:	8b 45 0c             	mov    0xc(%ebp),%eax
40005f2d:	40                   	inc    %eax
40005f2e:	89 45 0c             	mov    %eax,0xc(%ebp)
40005f31:	e9 37 03 00 00       	jmp    4000626d <jvprintf+0xdfb>
40005f36:	8b 55 10             	mov    0x10(%ebp),%edx
40005f39:	8d 42 04             	lea    0x4(%edx),%eax
40005f3c:	89 45 10             	mov    %eax,0x10(%ebp)
40005f3f:	89 d0                	mov    %edx,%eax
40005f41:	8b 00                	mov    (%eax),%eax
40005f43:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40005f46:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
40005f4d:	0f 84 e3 02 00 00    	je     40006236 <jvprintf+0xdc4>
40005f53:	83 ec 0c             	sub    $0xc,%esp
40005f56:	ff 75 d4             	pushl  -0x2c(%ebp)
40005f59:	e8 16 33 00 00       	call   40009274 <strlen>
40005f5e:	83 c4 10             	add    $0x10,%esp
40005f61:	89 45 d8             	mov    %eax,-0x28(%ebp)
40005f64:	0f be 8d 5f ff ff ff 	movsbl -0xa1(%ebp),%ecx
40005f6b:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
40005f71:	83 bd 0c ff ff ff 2d 	cmpl   $0x2d,-0xf4(%ebp)
40005f78:	74 3a                	je     40005fb4 <jvprintf+0xb42>
40005f7a:	83 bd 0c ff ff ff 2d 	cmpl   $0x2d,-0xf4(%ebp)
40005f81:	7f 1f                	jg     40005fa2 <jvprintf+0xb30>
40005f83:	83 bd 0c ff ff ff 00 	cmpl   $0x0,-0xf4(%ebp)
40005f8a:	0f 84 98 01 00 00    	je     40006128 <jvprintf+0xcb6>
40005f90:	83 bd 0c ff ff ff 20 	cmpl   $0x20,-0xf4(%ebp)
40005f97:	0f 84 8b 01 00 00    	je     40006128 <jvprintf+0xcb6>
40005f9d:	e9 40 02 00 00       	jmp    400061e2 <jvprintf+0xd70>
40005fa2:	83 bd 0c ff ff ff 30 	cmpl   $0x30,-0xf4(%ebp)
40005fa9:	0f 84 bf 00 00 00    	je     4000606e <jvprintf+0xbfc>
40005faf:	e9 2e 02 00 00       	jmp    400061e2 <jvprintf+0xd70>
40005fb4:	83 ec 04             	sub    $0x4,%esp
40005fb7:	ff 75 d8             	pushl  -0x28(%ebp)
40005fba:	ff 75 d4             	pushl  -0x2c(%ebp)
40005fbd:	ff 75 08             	pushl  0x8(%ebp)
40005fc0:	e8 28 f4 ff ff       	call   400053ed <jprintf_putsn>
40005fc5:	83 c4 10             	add    $0x10,%esp
40005fc8:	89 45 e0             	mov    %eax,-0x20(%ebp)
40005fcb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
40005fcf:	79 0e                	jns    40005fdf <jvprintf+0xb6d>
40005fd1:	8b 45 e0             	mov    -0x20(%ebp),%eax
40005fd4:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
40005fda:	e9 a7 02 00 00       	jmp    40006286 <jvprintf+0xe14>
40005fdf:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
40005fe3:	74 1e                	je     40006003 <jvprintf+0xb91>
40005fe5:	8b 45 e0             	mov    -0x20(%ebp),%eax
40005fe8:	3b 45 d8             	cmp    -0x28(%ebp),%eax
40005feb:	74 16                	je     40006003 <jvprintf+0xb91>
40005fed:	8b 45 e0             	mov    -0x20(%ebp),%eax
40005ff0:	8b 95 58 ff ff ff    	mov    -0xa8(%ebp),%edx
40005ff6:	01 c2                	add    %eax,%edx
40005ff8:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
40005ffe:	e9 83 02 00 00       	jmp    40006286 <jvprintf+0xe14>
40006003:	8b 45 e0             	mov    -0x20(%ebp),%eax
40006006:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
4000600c:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000600f:	89 45 dc             	mov    %eax,-0x24(%ebp)
40006012:	eb 4a                	jmp    4000605e <jvprintf+0xbec>
40006014:	83 ec 08             	sub    $0x8,%esp
40006017:	6a 20                	push   $0x20
40006019:	ff 75 08             	pushl  0x8(%ebp)
4000601c:	e8 8d f3 ff ff       	call   400053ae <jprintf_putc>
40006021:	83 c4 10             	add    $0x10,%esp
40006024:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40006027:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
4000602b:	79 0e                	jns    4000603b <jvprintf+0xbc9>
4000602d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40006030:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%ebp)
40006036:	e9 4b 02 00 00       	jmp    40006286 <jvprintf+0xe14>
4000603b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
4000603f:	75 11                	jne    40006052 <jvprintf+0xbe0>
40006041:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
40006047:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
4000604d:	e9 34 02 00 00       	jmp    40006286 <jvprintf+0xe14>
40006052:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40006055:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
4000605b:	ff 45 dc             	incl   -0x24(%ebp)
4000605e:	8b 45 dc             	mov    -0x24(%ebp),%eax
40006061:	3b 85 60 ff ff ff    	cmp    -0xa0(%ebp),%eax
40006067:	72 ab                	jb     40006014 <jvprintf+0xba2>
40006069:	e9 f8 01 00 00       	jmp    40006266 <jvprintf+0xdf4>
4000606e:	8b 45 d8             	mov    -0x28(%ebp),%eax
40006071:	89 45 dc             	mov    %eax,-0x24(%ebp)
40006074:	eb 4a                	jmp    400060c0 <jvprintf+0xc4e>
40006076:	83 ec 08             	sub    $0x8,%esp
40006079:	6a 30                	push   $0x30
4000607b:	ff 75 08             	pushl  0x8(%ebp)
4000607e:	e8 2b f3 ff ff       	call   400053ae <jprintf_putc>
40006083:	83 c4 10             	add    $0x10,%esp
40006086:	89 45 e8             	mov    %eax,-0x18(%ebp)
40006089:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
4000608d:	79 0e                	jns    4000609d <jvprintf+0xc2b>
4000608f:	8b 55 e8             	mov    -0x18(%ebp),%edx
40006092:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
40006098:	e9 e9 01 00 00       	jmp    40006286 <jvprintf+0xe14>
4000609d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
400060a1:	75 11                	jne    400060b4 <jvprintf+0xc42>
400060a3:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
400060a9:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%ebp)
400060af:	e9 d2 01 00 00       	jmp    40006286 <jvprintf+0xe14>
400060b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
400060b7:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
400060bd:	ff 45 dc             	incl   -0x24(%ebp)
400060c0:	8b 45 dc             	mov    -0x24(%ebp),%eax
400060c3:	3b 85 60 ff ff ff    	cmp    -0xa0(%ebp),%eax
400060c9:	72 ab                	jb     40006076 <jvprintf+0xc04>
400060cb:	83 ec 04             	sub    $0x4,%esp
400060ce:	ff 75 d8             	pushl  -0x28(%ebp)
400060d1:	ff 75 d4             	pushl  -0x2c(%ebp)
400060d4:	ff 75 08             	pushl  0x8(%ebp)
400060d7:	e8 11 f3 ff ff       	call   400053ed <jprintf_putsn>
400060dc:	83 c4 10             	add    $0x10,%esp
400060df:	89 45 ec             	mov    %eax,-0x14(%ebp)
400060e2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
400060e6:	79 0e                	jns    400060f6 <jvprintf+0xc84>
400060e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
400060eb:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
400060f1:	e9 90 01 00 00       	jmp    40006286 <jvprintf+0xe14>
400060f6:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
400060fa:	74 1e                	je     4000611a <jvprintf+0xca8>
400060fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
400060ff:	3b 45 d8             	cmp    -0x28(%ebp),%eax
40006102:	74 16                	je     4000611a <jvprintf+0xca8>
40006104:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006107:	8b 95 58 ff ff ff    	mov    -0xa8(%ebp),%edx
4000610d:	01 c2                	add    %eax,%edx
4000610f:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
40006115:	e9 6c 01 00 00       	jmp    40006286 <jvprintf+0xe14>
4000611a:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000611d:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40006123:	e9 3e 01 00 00       	jmp    40006266 <jvprintf+0xdf4>
40006128:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000612b:	89 45 dc             	mov    %eax,-0x24(%ebp)
4000612e:	eb 4a                	jmp    4000617a <jvprintf+0xd08>
40006130:	83 ec 08             	sub    $0x8,%esp
40006133:	6a 20                	push   $0x20
40006135:	ff 75 08             	pushl  0x8(%ebp)
40006138:	e8 71 f2 ff ff       	call   400053ae <jprintf_putc>
4000613d:	83 c4 10             	add    $0x10,%esp
40006140:	89 45 f0             	mov    %eax,-0x10(%ebp)
40006143:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
40006147:	79 0e                	jns    40006157 <jvprintf+0xce5>
40006149:	8b 4d f0             	mov    -0x10(%ebp),%ecx
4000614c:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%ebp)
40006152:	e9 2f 01 00 00       	jmp    40006286 <jvprintf+0xe14>
40006157:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
4000615b:	75 11                	jne    4000616e <jvprintf+0xcfc>
4000615d:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
40006163:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
40006169:	e9 18 01 00 00       	jmp    40006286 <jvprintf+0xe14>
4000616e:	8b 45 f0             	mov    -0x10(%ebp),%eax
40006171:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40006177:	ff 45 dc             	incl   -0x24(%ebp)
4000617a:	8b 45 dc             	mov    -0x24(%ebp),%eax
4000617d:	3b 85 60 ff ff ff    	cmp    -0xa0(%ebp),%eax
40006183:	72 ab                	jb     40006130 <jvprintf+0xcbe>
40006185:	83 ec 04             	sub    $0x4,%esp
40006188:	ff 75 d8             	pushl  -0x28(%ebp)
4000618b:	ff 75 d4             	pushl  -0x2c(%ebp)
4000618e:	ff 75 08             	pushl  0x8(%ebp)
40006191:	e8 57 f2 ff ff       	call   400053ed <jprintf_putsn>
40006196:	83 c4 10             	add    $0x10,%esp
40006199:	89 45 f4             	mov    %eax,-0xc(%ebp)
4000619c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
400061a0:	79 0e                	jns    400061b0 <jvprintf+0xd3e>
400061a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
400061a5:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
400061ab:	e9 d6 00 00 00       	jmp    40006286 <jvprintf+0xe14>
400061b0:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
400061b4:	74 1e                	je     400061d4 <jvprintf+0xd62>
400061b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
400061b9:	3b 45 d8             	cmp    -0x28(%ebp),%eax
400061bc:	74 16                	je     400061d4 <jvprintf+0xd62>
400061be:	8b 45 f4             	mov    -0xc(%ebp),%eax
400061c1:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
400061c7:	01 c1                	add    %eax,%ecx
400061c9:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%ebp)
400061cf:	e9 b2 00 00 00       	jmp    40006286 <jvprintf+0xe14>
400061d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
400061d7:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
400061dd:	e9 84 00 00 00       	jmp    40006266 <jvprintf+0xdf4>
400061e2:	83 ec 04             	sub    $0x4,%esp
400061e5:	ff 75 d8             	pushl  -0x28(%ebp)
400061e8:	ff 75 d4             	pushl  -0x2c(%ebp)
400061eb:	ff 75 08             	pushl  0x8(%ebp)
400061ee:	e8 fa f1 ff ff       	call   400053ed <jprintf_putsn>
400061f3:	83 c4 10             	add    $0x10,%esp
400061f6:	89 45 f8             	mov    %eax,-0x8(%ebp)
400061f9:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
400061fd:	79 0b                	jns    4000620a <jvprintf+0xd98>
400061ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
40006202:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
40006208:	eb 7c                	jmp    40006286 <jvprintf+0xe14>
4000620a:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
4000620e:	74 1b                	je     4000622b <jvprintf+0xdb9>
40006210:	8b 45 f8             	mov    -0x8(%ebp),%eax
40006213:	3b 45 d8             	cmp    -0x28(%ebp),%eax
40006216:	74 13                	je     4000622b <jvprintf+0xdb9>
40006218:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000621b:	8b 95 58 ff ff ff    	mov    -0xa8(%ebp),%edx
40006221:	01 c2                	add    %eax,%edx
40006223:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
40006229:	eb 5b                	jmp    40006286 <jvprintf+0xe14>
4000622b:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000622e:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40006234:	eb 30                	jmp    40006266 <jvprintf+0xdf4>
40006236:	83 ec 04             	sub    $0x4,%esp
40006239:	6a ff                	push   $0xffffffff
4000623b:	ff 75 d4             	pushl  -0x2c(%ebp)
4000623e:	ff 75 08             	pushl  0x8(%ebp)
40006241:	e8 a7 f1 ff ff       	call   400053ed <jprintf_putsn>
40006246:	83 c4 10             	add    $0x10,%esp
40006249:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000624c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40006250:	79 0b                	jns    4000625d <jvprintf+0xdeb>
40006252:	8b 4d fc             	mov    -0x4(%ebp),%ecx
40006255:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%ebp)
4000625b:	eb 29                	jmp    40006286 <jvprintf+0xe14>
4000625d:	8b 45 fc             	mov    -0x4(%ebp),%eax
40006260:	01 85 58 ff ff ff    	add    %eax,-0xa8(%ebp)
40006266:	8b 45 0c             	mov    0xc(%ebp),%eax
40006269:	40                   	inc    %eax
4000626a:	89 45 0c             	mov    %eax,0xc(%ebp)
4000626d:	8b 45 0c             	mov    0xc(%ebp),%eax
40006270:	8a 00                	mov    (%eax),%al
40006272:	84 c0                	test   %al,%al
40006274:	0f 85 10 f2 ff ff    	jne    4000548a <jvprintf+0x18>
4000627a:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
40006280:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
40006286:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
4000628c:	c9                   	leave  
4000628d:	c3                   	ret    
4000628e:	90                   	nop    
4000628f:	90                   	nop    

40006290 <printf_putc>:
#include <stdlib.h>

#include "cdi.h"
#include "cdi/storage.h"
#include "cdi/misc.h"
#include "cdi/io.h"
40006290:	55                   	push   %ebp
40006291:	89 e5                	mov    %esp,%ebp
40006293:	83 ec 08             	sub    $0x8,%esp
40006296:	8b 45 0c             	mov    0xc(%ebp),%eax
40006299:	88 45 fc             	mov    %al,-0x4(%ebp)

4000629c:	0f be 45 fc          	movsbl -0x4(%ebp),%eax
400062a0:	83 ec 0c             	sub    $0xc,%esp
400062a3:	50                   	push   %eax
400062a4:	e8 38 03 00 00       	call   400065e1 <putchar>
400062a9:	83 c4 10             	add    $0x10,%esp
#include "device.h"

400062ac:	b8 01 00 00 00       	mov    $0x1,%eax

400062b1:	c9                   	leave  
400062b2:	c3                   	ret    

400062b3 <printf_putsn>:
/**
 * ATA-Geraet identifizieren
 *
400062b3:	55                   	push   %ebp
400062b4:	89 e5                	mov    %esp,%ebp
400062b6:	83 ec 18             	sub    $0x18,%esp
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
400062b9:	83 ec 0c             	sub    $0xc,%esp
400062bc:	ff 75 0c             	pushl  0xc(%ebp)
400062bf:	e8 b0 2f 00 00       	call   40009274 <strlen>
400062c4:	83 c4 10             	add    $0x10,%esp
400062c7:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
int ata_drv_identify(struct ata_device* dev)
400062ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
400062cd:	3b 45 10             	cmp    0x10(%ebp),%eax
400062d0:	7e 06                	jle    400062d8 <printf_putsn+0x25>
400062d2:	83 7d 10 ff          	cmpl   $0xffffffff,0x10(%ebp)
400062d6:	75 17                	jne    400062ef <printf_putsn+0x3c>
{
    uint8_t buffer[ATA_SECTOR_SIZE];
400062d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
400062db:	83 ec 08             	sub    $0x8,%esp
400062de:	ff 75 0c             	pushl  0xc(%ebp)
400062e1:	50                   	push   %eax
400062e2:	e8 f5 01 00 00       	call   400064dc <putsn>
400062e7:	83 c4 10             	add    $0x10,%esp
400062ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
400062ed:	eb 15                	jmp    40006304 <printf_putsn+0x51>

    // Request vorbereiten
    struct ata_request request = {
        .dev = dev,
400062ef:	8b 45 10             	mov    0x10(%ebp),%eax
400062f2:	83 ec 08             	sub    $0x8,%esp
400062f5:	ff 75 0c             	pushl  0xc(%ebp)
400062f8:	50                   	push   %eax
400062f9:	e8 de 01 00 00       	call   400064dc <putsn>
400062fe:	83 c4 10             	add    $0x10,%esp
40006301:	89 45 ec             	mov    %eax,-0x14(%ebp)
40006304:	8b 45 ec             	mov    -0x14(%ebp),%eax

        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,
40006307:	c9                   	leave  
40006308:	c3                   	ret    

40006309 <vprintf>:

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
40006309:	55                   	push   %ebp
4000630a:	89 e5                	mov    %esp,%ebp
4000630c:	57                   	push   %edi
4000630d:	56                   	push   %esi
4000630e:	83 ec 10             	sub    $0x10,%esp
        .registers.ata.command = IDENTIFY_DEVICE,
40006311:	8d 7d ec             	lea    -0x14(%ebp),%edi
40006314:	be bc 9b 00 40       	mov    $0x40009bbc,%esi
40006319:	fc                   	cld    
4000631a:	a5                   	movsl  %ds:(%esi),%es:(%edi)
4000631b:	a5                   	movsl  %ds:(%esi),%es:(%edi)
4000631c:	a5                   	movsl  %ds:(%esi),%es:(%edi)
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
4000631d:	83 ec 04             	sub    $0x4,%esp
40006320:	ff 75 0c             	pushl  0xc(%ebp)
40006323:	ff 75 08             	pushl  0x8(%ebp)
40006326:	8d 45 ec             	lea    -0x14(%ebp),%eax
40006329:	50                   	push   %eax
4000632a:	e8 43 f1 ff ff       	call   40005472 <jvprintf>
4000632f:	83 c4 10             	add    $0x10,%esp
        .buffer = buffer,
40006332:	8d 65 f8             	lea    -0x8(%ebp),%esp
40006335:	5e                   	pop    %esi
40006336:	5f                   	pop    %edi
40006337:	c9                   	leave  
40006338:	c3                   	ret    

40006339 <printf>:

        .error = 0
    };
40006339:	55                   	push   %ebp
4000633a:	89 e5                	mov    %esp,%ebp
4000633c:	83 ec 18             	sub    $0x18,%esp
    
    // Request starten
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
4000633f:	8d 45 0c             	lea    0xc(%ebp),%eax
40006342:	89 45 f8             	mov    %eax,-0x8(%ebp)
        // IDENTIFY PACKET DEVICE probieren.
40006345:	8b 45 f8             	mov    -0x8(%ebp),%eax
40006348:	83 ec 08             	sub    $0x8,%esp
4000634b:	50                   	push   %eax
4000634c:	ff 75 08             	pushl  0x8(%ebp)
4000634f:	e8 b5 ff ff ff       	call   40006309 <vprintf>
40006354:	83 c4 10             	add    $0x10,%esp
40006357:	89 45 fc             	mov    %eax,-0x4(%ebp)
        return atapi_drv_identify(dev);
    }
        
4000635a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    // Ein ATA-Geraet
4000635d:	c9                   	leave  
4000635e:	c3                   	ret    
4000635f:	90                   	nop    

40006360 <stdio_init>:
#include "device.h"


/**
 * ATA-Geraet identifizieren
 *
40006360:	55                   	push   %ebp
40006361:	89 e5                	mov    %esp,%ebp
40006363:	81 ec 98 00 00 00    	sub    $0x98,%esp
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
 */
int ata_drv_identify(struct ata_device* dev)
{
    uint8_t buffer[ATA_SECTOR_SIZE];

40006369:	83 ec 08             	sub    $0x8,%esp
4000636c:	68 c8 9b 00 40       	push   $0x40009bc8
40006371:	68 ca 9b 00 40       	push   $0x40009bca
40006376:	e8 5d e1 ff ff       	call   400044d8 <fopen>
4000637b:	83 c4 10             	add    $0x10,%esp
4000637e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    // Request vorbereiten
40006381:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40006385:	75 0c                	jne    40006393 <stdio_init+0x33>
    struct ata_request request = {
        .dev = dev,
40006387:	c7 05 00 a6 00 40 00 	movl   $0x0,0x4000a600
4000638e:	00 00 00 
40006391:	eb 51                	jmp    400063e4 <stdio_init+0x84>

        .flags.direction = READ,
        .flags.poll = 1,
40006393:	ff 75 f8             	pushl  -0x8(%ebp)
40006396:	68 80 00 00 00       	push   $0x80
4000639b:	6a 01                	push   $0x1
4000639d:	8d 85 77 ff ff ff    	lea    -0x89(%ebp),%eax
400063a3:	50                   	push   %eax
400063a4:	e8 68 e3 ff ff       	call   40004711 <fread>
400063a9:	83 c4 10             	add    $0x10,%esp
400063ac:	89 45 fc             	mov    %eax,-0x4(%ebp)
        .flags.lba = 0,
400063af:	8b 45 fc             	mov    -0x4(%ebp),%eax
400063b2:	c6 84 05 77 ff ff ff 	movb   $0x0,-0x89(%ebp,%eax,1)
400063b9:	00 

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
400063ba:	83 ec 08             	sub    $0x8,%esp
400063bd:	68 d9 9b 00 40       	push   $0x40009bd9
400063c2:	8d 85 77 ff ff ff    	lea    -0x89(%ebp),%eax
400063c8:	50                   	push   %eax
400063c9:	e8 0a e1 ff ff       	call   400044d8 <fopen>
400063ce:	83 c4 10             	add    $0x10,%esp
400063d1:	a3 00 a6 00 40       	mov    %eax,0x4000a600
        .registers.ata.command = IDENTIFY_DEVICE,
400063d6:	83 ec 0c             	sub    $0xc,%esp
400063d9:	ff 75 f8             	pushl  -0x8(%ebp)
400063dc:	e8 d9 e2 ff ff       	call   400046ba <fclose>
400063e1:	83 c4 10             	add    $0x10,%esp
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

400063e4:	83 ec 08             	sub    $0x8,%esp
400063e7:	68 c8 9b 00 40       	push   $0x40009bc8
400063ec:	68 dc 9b 00 40       	push   $0x40009bdc
400063f1:	e8 e2 e0 ff ff       	call   400044d8 <fopen>
400063f6:	83 c4 10             	add    $0x10,%esp
400063f9:	89 45 f8             	mov    %eax,-0x8(%ebp)
        .error = 0
400063fc:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40006400:	75 0c                	jne    4000640e <stdio_init+0xae>
    };
    
40006402:	c7 05 04 a6 00 40 00 	movl   $0x0,0x4000a604
40006409:	00 00 00 
4000640c:	eb 51                	jmp    4000645f <stdio_init+0xff>
    // Request starten
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
4000640e:	ff 75 f8             	pushl  -0x8(%ebp)
40006411:	68 80 00 00 00       	push   $0x80
40006416:	6a 01                	push   $0x1
40006418:	8d 85 77 ff ff ff    	lea    -0x89(%ebp),%eax
4000641e:	50                   	push   %eax
4000641f:	e8 ed e2 ff ff       	call   40004711 <fread>
40006424:	83 c4 10             	add    $0x10,%esp
40006427:	89 45 fc             	mov    %eax,-0x4(%ebp)
        // IDENTIFY PACKET DEVICE probieren.
4000642a:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000642d:	c6 84 05 77 ff ff ff 	movb   $0x0,-0x89(%ebp,%eax,1)
40006434:	00 
        return atapi_drv_identify(dev);
    }
        
40006435:	83 ec 08             	sub    $0x8,%esp
40006438:	68 ec 9b 00 40       	push   $0x40009bec
4000643d:	8d 85 77 ff ff ff    	lea    -0x89(%ebp),%eax
40006443:	50                   	push   %eax
40006444:	e8 8f e0 ff ff       	call   400044d8 <fopen>
40006449:	83 c4 10             	add    $0x10,%esp
4000644c:	a3 04 a6 00 40       	mov    %eax,0x4000a604
    // Ein ATA-Geraet
40006451:	83 ec 0c             	sub    $0xc,%esp
40006454:	ff 75 f8             	pushl  -0x8(%ebp)
40006457:	e8 5e e2 ff ff       	call   400046ba <fclose>
4000645c:	83 c4 10             	add    $0x10,%esp
    dev->atapi = 0;

    // TODO: Informationen verarbeiten

4000645f:	83 ec 08             	sub    $0x8,%esp
40006462:	68 c8 9b 00 40       	push   $0x40009bc8
40006467:	68 ee 9b 00 40       	push   $0x40009bee
4000646c:	e8 67 e0 ff ff       	call   400044d8 <fopen>
40006471:	83 c4 10             	add    $0x10,%esp
40006474:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return 1;
40006477:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
4000647b:	75 0c                	jne    40006489 <stdio_init+0x129>
}

4000647d:	c7 05 08 a6 00 40 00 	movl   $0x0,0x4000a608
40006484:	00 00 00 
40006487:	eb 51                	jmp    400064da <stdio_init+0x17a>
/**
 * Sektoren von einem ATA-Geraet lesen
 *
40006489:	ff 75 f8             	pushl  -0x8(%ebp)
4000648c:	68 80 00 00 00       	push   $0x80
40006491:	6a 01                	push   $0x1
40006493:	8d 85 77 ff ff ff    	lea    -0x89(%ebp),%eax
40006499:	50                   	push   %eax
4000649a:	e8 72 e2 ff ff       	call   40004711 <fread>
4000649f:	83 c4 10             	add    $0x10,%esp
400064a2:	89 45 fc             	mov    %eax,-0x4(%ebp)
 * @param start LBA des Startsektors
400064a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
400064a8:	c6 84 05 77 ff ff ff 	movb   $0x0,-0x89(%ebp,%eax,1)
400064af:	00 
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
400064b0:	83 ec 08             	sub    $0x8,%esp
400064b3:	68 ec 9b 00 40       	push   $0x40009bec
400064b8:	8d 85 77 ff ff ff    	lea    -0x89(%ebp),%eax
400064be:	50                   	push   %eax
400064bf:	e8 14 e0 ff ff       	call   400044d8 <fopen>
400064c4:	83 c4 10             	add    $0x10,%esp
400064c7:	a3 08 a6 00 40       	mov    %eax,0x4000a608
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
400064cc:	83 ec 0c             	sub    $0xc,%esp
400064cf:	ff 75 f8             	pushl  -0x8(%ebp)
400064d2:	e8 e3 e1 ff ff       	call   400046ba <fclose>
400064d7:	83 c4 10             	add    $0x10,%esp
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
400064da:	c9                   	leave  
400064db:	c3                   	ret    

400064dc <putsn>:
    uint16_t current_count;
    void* current_buffer = buffer;
    uint64_t lba = start;

    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;
400064dc:	55                   	push   %ebp
400064dd:	89 e5                	mov    %esp,%ebp
400064df:	83 ec 08             	sub    $0x8,%esp

400064e2:	a1 04 a6 00 40       	mov    0x4000a604,%eax
400064e7:	85 c0                	test   %eax,%eax
400064e9:	75 19                	jne    40006504 <putsn+0x28>
    // Solange wie noch Sektoren uebrig sind, wird gelesen
400064eb:	83 ec 08             	sub    $0x8,%esp
400064ee:	ff 75 0c             	pushl  0xc(%ebp)
400064f1:	ff 75 08             	pushl  0x8(%ebp)
400064f4:	e8 97 06 00 00       	call   40006b90 <syscall_putsn>
400064f9:	83 c4 10             	add    $0x10,%esp
    while (count_left > 0) {
400064fc:	8b 45 08             	mov    0x8(%ebp),%eax
400064ff:	89 45 fc             	mov    %eax,-0x4(%ebp)
40006502:	eb 2a                	jmp    4000652e <putsn+0x52>
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
        if (count_left > 256) {
40006504:	a1 04 a6 00 40       	mov    0x4000a604,%eax
40006509:	50                   	push   %eax
4000650a:	6a 01                	push   $0x1
4000650c:	ff 75 08             	pushl  0x8(%ebp)
4000650f:	ff 75 0c             	pushl  0xc(%ebp)
40006512:	e8 76 e7 ff ff       	call   40004c8d <fwrite>
40006517:	83 c4 10             	add    $0x10,%esp
4000651a:	83 f8 ff             	cmp    $0xffffffff,%eax
4000651d:	75 09                	jne    40006528 <putsn+0x4c>
            current_count = 256;
4000651f:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
40006526:	eb 06                	jmp    4000652e <putsn+0x52>
        } else {
            current_count = count_left;
40006528:	8b 45 08             	mov    0x8(%ebp),%eax
4000652b:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000652e:	8b 45 fc             	mov    -0x4(%ebp),%eax
        }
        
        // Request vorbereiten
40006531:	c9                   	leave  
40006532:	c3                   	ret    

40006533 <puts>:
        request.flags.ata = 0;
        request.flags.lba = 1;

        request.registers.ata.command = READ_SECTORS;
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
40006533:	55                   	push   %ebp
40006534:	89 e5                	mov    %esp,%ebp
40006536:	83 ec 08             	sub    $0x8,%esp
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
40006539:	83 ec 0c             	sub    $0xc,%esp
4000653c:	ff 75 08             	pushl  0x8(%ebp)
4000653f:	e8 30 2d 00 00       	call   40009274 <strlen>
40006544:	83 c4 10             	add    $0x10,%esp
40006547:	83 ec 08             	sub    $0x8,%esp
4000654a:	ff 75 08             	pushl  0x8(%ebp)
4000654d:	50                   	push   %eax
4000654e:	e8 89 ff ff ff       	call   400064dc <putsn>
40006553:	83 c4 10             	add    $0x10,%esp
40006556:	83 f8 ff             	cmp    $0xffffffff,%eax
40006559:	75 09                	jne    40006564 <puts+0x31>
        // 0 steht.
4000655b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
40006562:	eb 31                	jmp    40006595 <puts+0x62>
        request.registers.ata.count = (uint8_t) current_count;
        request.registers.ata.lba = lba;
40006564:	a1 04 a6 00 40       	mov    0x4000a604,%eax
40006569:	85 c0                	test   %eax,%eax
4000656b:	75 14                	jne    40006581 <puts+0x4e>

4000656d:	83 ec 08             	sub    $0x8,%esp
40006570:	68 fe 9b 00 40       	push   $0x40009bfe
40006575:	6a 01                	push   $0x1
40006577:	e8 14 06 00 00       	call   40006b90 <syscall_putsn>
4000657c:	83 c4 10             	add    $0x10,%esp
4000657f:	eb 0d                	jmp    4000658e <puts+0x5b>
        request.block_count = current_count;
        request.block_size = ATA_SECTOR_SIZE;
40006581:	83 ec 0c             	sub    $0xc,%esp
40006584:	6a 0a                	push   $0xa
40006586:	e8 56 00 00 00       	call   400065e1 <putchar>
4000658b:	83 c4 10             	add    $0x10,%esp
        request.blocks_done = 0;
        request.buffer = current_buffer;

4000658e:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
40006595:	8b 45 fc             	mov    -0x4(%ebp),%eax
        request.error = NO_ERROR;
40006598:	c9                   	leave  
40006599:	c3                   	ret    

4000659a <putc>:
            result = 0;
            break;
        }

        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
        current_buffer += current_count * ATA_SECTOR_SIZE;
4000659a:	55                   	push   %ebp
4000659b:	89 e5                	mov    %esp,%ebp
4000659d:	83 ec 18             	sub    $0x18,%esp
        count_left -= current_count;
400065a0:	a1 04 a6 00 40       	mov    0x4000a604,%eax
400065a5:	85 c0                	test   %eax,%eax
400065a7:	75 1f                	jne    400065c8 <putc+0x2e>
        lba += current_count;
    }
400065a9:	8b 45 08             	mov    0x8(%ebp),%eax
400065ac:	88 45 ff             	mov    %al,-0x1(%ebp)

400065af:	83 ec 08             	sub    $0x8,%esp
400065b2:	8d 45 ff             	lea    -0x1(%ebp),%eax
400065b5:	50                   	push   %eax
400065b6:	6a 01                	push   $0x1
400065b8:	e8 d3 05 00 00       	call   40006b90 <syscall_putsn>
400065bd:	83 c4 10             	add    $0x10,%esp
    return result;
}

400065c0:	8b 45 08             	mov    0x8(%ebp),%eax
400065c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
400065c6:	eb 14                	jmp    400065dc <putc+0x42>
    }

    return result;
}

400065c8:	83 ec 08             	sub    $0x8,%esp
400065cb:	ff 75 0c             	pushl  0xc(%ebp)
400065ce:	ff 75 08             	pushl  0x8(%ebp)
400065d1:	e8 90 e8 ff ff       	call   40004e66 <fputc>
400065d6:	83 c4 10             	add    $0x10,%esp
400065d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
400065dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
400065df:	c9                   	leave  
400065e0:	c3                   	ret    

400065e1 <putchar>:
400065e1:	55                   	push   %ebp
400065e2:	89 e5                	mov    %esp,%ebp
400065e4:	83 ec 18             	sub    $0x18,%esp
400065e7:	a1 04 a6 00 40       	mov    0x4000a604,%eax
400065ec:	85 c0                	test   %eax,%eax
400065ee:	75 1f                	jne    4000660f <putchar+0x2e>
400065f0:	8b 45 08             	mov    0x8(%ebp),%eax
400065f3:	88 45 ff             	mov    %al,-0x1(%ebp)
400065f6:	83 ec 08             	sub    $0x8,%esp
400065f9:	8d 45 ff             	lea    -0x1(%ebp),%eax
400065fc:	50                   	push   %eax
400065fd:	6a 01                	push   $0x1
400065ff:	e8 8c 05 00 00       	call   40006b90 <syscall_putsn>
40006604:	83 c4 10             	add    $0x10,%esp
40006607:	8b 45 08             	mov    0x8(%ebp),%eax
4000660a:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000660d:	eb 17                	jmp    40006626 <putchar+0x45>
4000660f:	a1 04 a6 00 40       	mov    0x4000a604,%eax
40006614:	83 ec 08             	sub    $0x8,%esp
40006617:	50                   	push   %eax
40006618:	ff 75 08             	pushl  0x8(%ebp)
4000661b:	e8 46 e8 ff ff       	call   40004e66 <fputc>
40006620:	83 c4 10             	add    $0x10,%esp
40006623:	89 45 ec             	mov    %eax,-0x14(%ebp)
40006626:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006629:	c9                   	leave  
4000662a:	c3                   	ret    

4000662b <getc>:
4000662b:	55                   	push   %ebp
4000662c:	89 e5                	mov    %esp,%ebp
4000662e:	83 ec 08             	sub    $0x8,%esp
40006631:	83 ec 0c             	sub    $0xc,%esp
40006634:	ff 75 08             	pushl  0x8(%ebp)
40006637:	e8 b6 e3 ff ff       	call   400049f2 <fgetc>
4000663c:	83 c4 10             	add    $0x10,%esp
4000663f:	c9                   	leave  
40006640:	c3                   	ret    

40006641 <getchar>:
40006641:	55                   	push   %ebp
40006642:	89 e5                	mov    %esp,%ebp
40006644:	83 ec 08             	sub    $0x8,%esp
40006647:	a1 00 a6 00 40       	mov    0x4000a600,%eax
4000664c:	83 ec 0c             	sub    $0xc,%esp
4000664f:	50                   	push   %eax
40006650:	e8 9d e3 ff ff       	call   400049f2 <fgetc>
40006655:	83 c4 10             	add    $0x10,%esp
40006658:	c9                   	leave  
40006659:	c3                   	ret    

4000665a <gets>:
4000665a:	55                   	push   %ebp
4000665b:	89 e5                	mov    %esp,%ebp
4000665d:	83 ec 18             	sub    $0x18,%esp
40006660:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40006667:	eb 67                	jmp    400066d0 <gets+0x76>
40006669:	e8 d3 ff ff ff       	call   40006641 <getchar>
4000666e:	89 45 fc             	mov    %eax,-0x4(%ebp)
40006671:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%ebp)
40006675:	75 35                	jne    400066ac <gets+0x52>
40006677:	a1 00 a6 00 40       	mov    0x4000a600,%eax
4000667c:	83 ec 0c             	sub    $0xc,%esp
4000667f:	50                   	push   %eax
40006680:	e8 e5 e9 ff ff       	call   4000506a <ferror>
40006685:	83 c4 10             	add    $0x10,%esp
40006688:	85 c0                	test   %eax,%eax
4000668a:	74 09                	je     40006695 <gets+0x3b>
4000668c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40006693:	eb 5f                	jmp    400066f4 <gets+0x9a>
40006695:	a1 00 a6 00 40       	mov    0x4000a600,%eax
4000669a:	83 ec 0c             	sub    $0xc,%esp
4000669d:	50                   	push   %eax
4000669e:	e8 5d e9 ff ff       	call   40005000 <feof>
400066a3:	83 c4 10             	add    $0x10,%esp
400066a6:	85 c0                	test   %eax,%eax
400066a8:	75 3b                	jne    400066e5 <gets+0x8b>
400066aa:	eb 24                	jmp    400066d0 <gets+0x76>
400066ac:	83 ec 0c             	sub    $0xc,%esp
400066af:	ff 75 fc             	pushl  -0x4(%ebp)
400066b2:	e8 2a ff ff ff       	call   400065e1 <putchar>
400066b7:	83 c4 10             	add    $0x10,%esp
400066ba:	83 7d fc 0a          	cmpl   $0xa,-0x4(%ebp)
400066be:	74 25                	je     400066e5 <gets+0x8b>
400066c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
400066c3:	89 c2                	mov    %eax,%edx
400066c5:	03 55 08             	add    0x8(%ebp),%edx
400066c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
400066cb:	88 02                	mov    %al,(%edx)
400066cd:	ff 45 f8             	incl   -0x8(%ebp)
400066d0:	a1 00 a6 00 40       	mov    0x4000a600,%eax
400066d5:	83 ec 0c             	sub    $0xc,%esp
400066d8:	50                   	push   %eax
400066d9:	e8 8c e9 ff ff       	call   4000506a <ferror>
400066de:	83 c4 10             	add    $0x10,%esp
400066e1:	85 c0                	test   %eax,%eax
400066e3:	74 84                	je     40006669 <gets+0xf>
400066e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
400066e8:	03 45 08             	add    0x8(%ebp),%eax
400066eb:	c6 00 00             	movb   $0x0,(%eax)
400066ee:	8b 45 08             	mov    0x8(%ebp),%eax
400066f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
400066f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
400066f7:	c9                   	leave  
400066f8:	c3                   	ret    

400066f9 <perror>:
400066f9:	55                   	push   %ebp
400066fa:	89 e5                	mov    %esp,%ebp
400066fc:	83 ec 08             	sub    $0x8,%esp
400066ff:	a1 28 a8 00 40       	mov    0x4000a828,%eax
40006704:	83 ec 04             	sub    $0x4,%esp
40006707:	50                   	push   %eax
40006708:	ff 75 08             	pushl  0x8(%ebp)
4000670b:	68 00 9c 00 40       	push   $0x40009c00
40006710:	e8 24 fc ff ff       	call   40006339 <printf>
40006715:	83 c4 10             	add    $0x10,%esp
40006718:	c9                   	leave  
40006719:	c3                   	ret    
4000671a:	90                   	nop    
4000671b:	90                   	nop    

4000671c <lostio_type_directory_use_as>:
 *              Sollte vom Elternprozess geerbt werden)
 * @param args Pointer auf die Kommandozeilen-Parameter
 * @param parent Prozessnummer des Elternprozesses, dem der neue Task
 *          untergeordenet werden soll, oder 0 fuer den aktuellen Prozess.
 *
 * @return Prozessnummer
4000671c:	55                   	push   %ebp
4000671d:	89 e5                	mov    %esp,%ebp
4000671f:	83 ec 18             	sub    $0x18,%esp
40006722:	8b 45 08             	mov    0x8(%ebp),%eax
40006725:	88 45 ec             	mov    %al,-0x14(%ebp)
 */
40006728:	83 ec 0c             	sub    $0xc,%esp
4000672b:	6a 28                	push   $0x28
4000672d:	e8 a6 1b 00 00       	call   400082d8 <malloc>
40006732:	83 c4 10             	add    $0x10,%esp
40006735:	89 45 fc             	mov    %eax,-0x4(%ebp)
pid_t create_process(dword initial_eip, uid_t uid, const char* args, pid_t parent)
{
40006738:	8b 55 fc             	mov    -0x4(%ebp),%edx
4000673b:	8a 45 ec             	mov    -0x14(%ebp),%al
4000673e:	88 02                	mov    %al,(%edx)
    pid_t pid;
40006740:	8b 45 fc             	mov    -0x4(%ebp),%eax
40006743:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

4000674a:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000674d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    asm(
40006754:	8b 45 fc             	mov    -0x4(%ebp),%eax
40006757:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
        "pushl %5;"
4000675e:	8b 45 fc             	mov    -0x4(%ebp),%eax
40006761:	c7 40 10 bf 67 00 40 	movl   $0x400067bf,0x10(%eax)
        "pushl %4;"
40006768:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000676b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
        "pushl %3;"
40006772:	8b 45 fc             	mov    -0x4(%ebp),%eax
40006775:	c7 40 18 d6 69 00 40 	movl   $0x400069d6,0x18(%eax)
        "pushl %2;"
4000677c:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000677f:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
        "mov %1, %%eax;"
40006786:	8b 45 fc             	mov    -0x4(%ebp),%eax
40006789:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
        "int $0x30;"
40006790:	8b 45 fc             	mov    -0x4(%ebp),%eax
40006793:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
        "add $0x10, %%esp;"
        : "=a" (pid) : "i" (SYSCALL_PM_CREATE_PROCESS), "r" (initial_eip), "r" (uid), "r" (args), "r" (parent));
4000679a:	83 ec 0c             	sub    $0xc,%esp
4000679d:	ff 75 fc             	pushl  -0x4(%ebp)
400067a0:	e8 3f d2 ff ff       	call   400039e4 <lostio_register_typehandle>
400067a5:	83 c4 10             	add    $0x10,%esp
    return pid;
400067a8:	c9                   	leave  
400067a9:	c3                   	ret    

400067aa <lostio_type_directory_use>:


/**
 * Den aktuellen Prozess beenden. TODO: Sollte auch mit Kinderprozessen
 * moeglich sein.
 */
400067aa:	55                   	push   %ebp
400067ab:	89 e5                	mov    %esp,%ebp
400067ad:	83 ec 08             	sub    $0x8,%esp
void destroy_process()
400067b0:	83 ec 0c             	sub    $0xc,%esp
400067b3:	6a 01                	push   $0x1
400067b5:	e8 62 ff ff ff       	call   4000671c <lostio_type_directory_use_as>
400067ba:	83 c4 10             	add    $0x10,%esp
{
400067bd:	c9                   	leave  
400067be:	c3                   	ret    

400067bf <dir_read>:
            "int $0x30;"
        : : "i" (SYSCALL_PM_EXIT_PROCESS));
}


/**
400067bf:	55                   	push   %ebp
400067c0:	89 e5                	mov    %esp,%ebp
400067c2:	57                   	push   %edi
400067c3:	56                   	push   %esi
400067c4:	53                   	push   %ebx
400067c5:	83 ec 4c             	sub    $0x4c,%esp
 * Pointer auf die Kommandozeilen-Argumente vom Kernel holen. Diese werden
 * einfach als normaler String zurueckgegeben. Das Parsen ist sache des
 * Prozesses.
 *
 * @return Pointer auf den Argument-String
 */
400067c8:	8b 45 14             	mov    0x14(%ebp),%eax
400067cb:	89 45 e0             	mov    %eax,-0x20(%ebp)
char* get_cmdline()
{
400067ce:	8b 45 0c             	mov    0xc(%ebp),%eax
400067d1:	8b 48 10             	mov    0x10(%eax),%ecx
400067d4:	8b 58 14             	mov    0x14(%eax),%ebx
400067d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
400067da:	ba 00 00 00 00       	mov    $0x0,%edx
400067df:	89 ce                	mov    %ecx,%esi
400067e1:	89 df                	mov    %ebx,%edi
400067e3:	01 c6                	add    %eax,%esi
400067e5:	11 d7                	adc    %edx,%edi
400067e7:	89 75 b0             	mov    %esi,-0x50(%ebp)
400067ea:	89 7d b4             	mov    %edi,-0x4c(%ebp)
400067ed:	8b 45 0c             	mov    0xc(%ebp),%eax
400067f0:	8b 40 1c             	mov    0x1c(%eax),%eax
400067f3:	8b 50 08             	mov    0x8(%eax),%edx
400067f6:	8b 48 0c             	mov    0xc(%eax),%ecx
400067f9:	89 55 b8             	mov    %edx,-0x48(%ebp)
400067fc:	89 4d bc             	mov    %ecx,-0x44(%ebp)
400067ff:	8b 4d bc             	mov    -0x44(%ebp),%ecx
40006802:	39 4d b4             	cmp    %ecx,-0x4c(%ebp)
40006805:	72 30                	jb     40006837 <dir_read+0x78>
40006807:	8b 75 bc             	mov    -0x44(%ebp),%esi
4000680a:	39 75 b4             	cmp    %esi,-0x4c(%ebp)
4000680d:	77 08                	ja     40006817 <dir_read+0x58>
4000680f:	8b 7d b8             	mov    -0x48(%ebp),%edi
40006812:	39 7d b0             	cmp    %edi,-0x50(%ebp)
40006815:	76 20                	jbe    40006837 <dir_read+0x78>
    char* result;
    asm(
40006817:	8b 45 0c             	mov    0xc(%ebp),%eax
4000681a:	8b 40 1c             	mov    0x1c(%eax),%eax
4000681d:	8b 50 0c             	mov    0xc(%eax),%edx
40006820:	8b 40 08             	mov    0x8(%eax),%eax
40006823:	89 c1                	mov    %eax,%ecx
40006825:	8b 45 0c             	mov    0xc(%ebp),%eax
40006828:	8b 50 14             	mov    0x14(%eax),%edx
4000682b:	8b 40 10             	mov    0x10(%eax),%eax
4000682e:	89 ca                	mov    %ecx,%edx
40006830:	29 c2                	sub    %eax,%edx
40006832:	89 d0                	mov    %edx,%eax
40006834:	89 45 e0             	mov    %eax,-0x20(%ebp)
        "mov %1, %%eax;"
        "int $0x30;"
        : "=a" (result) : "i" (SYSCALL_PM_GET_CMDLINE));

40006837:	8b 55 e0             	mov    -0x20(%ebp),%edx
4000683a:	89 d0                	mov    %edx,%eax
4000683c:	c1 e0 03             	shl    $0x3,%eax
4000683f:	01 d0                	add    %edx,%eax
40006841:	c1 e0 05             	shl    $0x5,%eax
40006844:	89 45 e0             	mov    %eax,-0x20(%ebp)
    return result;
40006847:	8b 45 e0             	mov    -0x20(%ebp),%eax
4000684a:	83 ec 0c             	sub    $0xc,%esp
4000684d:	50                   	push   %eax
4000684e:	e8 85 1a 00 00       	call   400082d8 <malloc>
40006853:	83 c4 10             	add    $0x10,%esp
40006856:	89 45 dc             	mov    %eax,-0x24(%ebp)
}
40006859:	8b 45 dc             	mov    -0x24(%ebp),%eax
4000685c:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000685f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40006866:	e9 9f 00 00 00       	jmp    4000690a <dir_read+0x14b>
4000686b:	8b 45 0c             	mov    0xc(%ebp),%eax
4000686e:	8b 50 14             	mov    0x14(%eax),%edx
40006871:	8b 40 10             	mov    0x10(%eax),%eax
40006874:	89 c2                	mov    %eax,%edx
40006876:	8b 45 e8             	mov    -0x18(%ebp),%eax
40006879:	8d 04 02             	lea    (%edx,%eax,1),%eax
4000687c:	89 c2                	mov    %eax,%edx
4000687e:	8b 45 0c             	mov    0xc(%ebp),%eax
40006881:	8b 40 1c             	mov    0x1c(%eax),%eax
40006884:	8b 40 20             	mov    0x20(%eax),%eax
40006887:	83 ec 08             	sub    $0x8,%esp
4000688a:	52                   	push   %edx
4000688b:	50                   	push   %eax
4000688c:	e8 fc 15 00 00       	call   40007e8d <list_get_element_at>
40006891:	83 c4 10             	add    $0x10,%esp
40006894:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40006897:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000689a:	8b 50 0c             	mov    0xc(%eax),%edx
4000689d:	8b 40 08             	mov    0x8(%eax),%eax
400068a0:	8b 4d ec             	mov    -0x14(%ebp),%ecx
400068a3:	89 81 00 01 00 00    	mov    %eax,0x100(%ecx)
400068a9:	89 91 04 01 00 00    	mov    %edx,0x104(%ecx)
400068af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400068b2:	8b 40 04             	mov    0x4(%eax),%eax
400068b5:	83 ec 0c             	sub    $0xc,%esp
400068b8:	50                   	push   %eax
400068b9:	e8 b6 29 00 00       	call   40009274 <strlen>
400068be:	83 c4 10             	add    $0x10,%esp
400068c1:	8d 50 01             	lea    0x1(%eax),%edx
400068c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400068c7:	8b 40 04             	mov    0x4(%eax),%eax
400068ca:	8b 4d ec             	mov    -0x14(%ebp),%ecx
400068cd:	83 ec 04             	sub    $0x4,%esp
400068d0:	52                   	push   %edx
400068d1:	50                   	push   %eax
400068d2:	51                   	push   %ecx
400068d3:	e8 90 26 00 00       	call   40008f68 <memcpy>
400068d8:	83 c4 10             	add    $0x10,%esp
400068db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400068de:	8b 40 1c             	mov    0x1c(%eax),%eax
400068e1:	25 00 00 02 00       	and    $0x20000,%eax
400068e6:	85 c0                	test   %eax,%eax
400068e8:	74 0c                	je     400068f6 <dir_read+0x137>
400068ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
400068ed:	c6 80 ff 00 00 00 02 	movb   $0x2,0xff(%eax)
400068f4:	eb 0a                	jmp    40006900 <dir_read+0x141>
400068f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
400068f9:	c6 80 ff 00 00 00 01 	movb   $0x1,0xff(%eax)
40006900:	81 45 ec 20 01 00 00 	addl   $0x120,-0x14(%ebp)
    return result;
}
40006907:	ff 45 e8             	incl   -0x18(%ebp)
4000690a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
4000690d:	8b 55 e0             	mov    -0x20(%ebp),%edx
40006910:	c7 45 ac 39 8e e3 38 	movl   $0x38e38e39,-0x54(%ebp)
40006917:	8b 45 ac             	mov    -0x54(%ebp),%eax
4000691a:	f7 e2                	mul    %edx
4000691c:	89 d0                	mov    %edx,%eax
4000691e:	c1 e8 06             	shr    $0x6,%eax
40006921:	39 c1                	cmp    %eax,%ecx
40006923:	0f 82 42 ff ff ff    	jb     4000686b <dir_read+0xac>
40006929:	8b 45 0c             	mov    0xc(%ebp),%eax
4000692c:	8b 48 10             	mov    0x10(%eax),%ecx
4000692f:	8b 58 14             	mov    0x14(%eax),%ebx
40006932:	8b 55 e0             	mov    -0x20(%ebp),%edx
40006935:	c7 45 ac 39 8e e3 38 	movl   $0x38e38e39,-0x54(%ebp)
4000693c:	8b 45 ac             	mov    -0x54(%ebp),%eax
4000693f:	f7 e2                	mul    %edx
40006941:	89 d0                	mov    %edx,%eax
40006943:	c1 e8 06             	shr    $0x6,%eax
40006946:	ba 00 00 00 00       	mov    $0x0,%edx
4000694b:	01 c8                	add    %ecx,%eax
4000694d:	11 da                	adc    %ebx,%edx
4000694f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40006952:	89 41 10             	mov    %eax,0x10(%ecx)
40006955:	89 51 14             	mov    %edx,0x14(%ecx)
40006958:	8b 45 0c             	mov    0xc(%ebp),%eax
4000695b:	8b 50 10             	mov    0x10(%eax),%edx
4000695e:	8b 48 14             	mov    0x14(%eax),%ecx
40006961:	89 55 c0             	mov    %edx,-0x40(%ebp)
40006964:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
40006967:	8b 45 0c             	mov    0xc(%ebp),%eax
4000696a:	8b 40 1c             	mov    0x1c(%eax),%eax
4000696d:	8b 70 08             	mov    0x8(%eax),%esi
40006970:	8b 78 0c             	mov    0xc(%eax),%edi
40006973:	89 75 c8             	mov    %esi,-0x38(%ebp)
40006976:	89 7d cc             	mov    %edi,-0x34(%ebp)
40006979:	8b 7d cc             	mov    -0x34(%ebp),%edi
4000697c:	39 7d c4             	cmp    %edi,-0x3c(%ebp)
4000697f:	72 26                	jb     400069a7 <dir_read+0x1e8>
40006981:	8b 45 cc             	mov    -0x34(%ebp),%eax
40006984:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
40006987:	77 08                	ja     40006991 <dir_read+0x1d2>
40006989:	8b 55 c8             	mov    -0x38(%ebp),%edx
4000698c:	39 55 c0             	cmp    %edx,-0x40(%ebp)
4000698f:	72 16                	jb     400069a7 <dir_read+0x1e8>
40006991:	8b 45 0c             	mov    0xc(%ebp),%eax
40006994:	8b 40 08             	mov    0x8(%eax),%eax
40006997:	89 c2                	mov    %eax,%edx
40006999:	81 ca 00 00 01 00    	or     $0x10000,%edx
4000699f:	8b 45 0c             	mov    0xc(%ebp),%eax
400069a2:	89 50 08             	mov    %edx,0x8(%eax)
400069a5:	eb 14                	jmp    400069bb <dir_read+0x1fc>
400069a7:	8b 45 0c             	mov    0xc(%ebp),%eax
400069aa:	8b 40 08             	mov    0x8(%eax),%eax
400069ad:	89 c2                	mov    %eax,%edx
400069af:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
400069b5:	8b 45 0c             	mov    0xc(%ebp),%eax
400069b8:	89 50 08             	mov    %edx,0x8(%eax)
400069bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
400069be:	8b 55 e0             	mov    -0x20(%ebp),%edx
400069c1:	8b 4d 08             	mov    0x8(%ebp),%ecx
400069c4:	89 01                	mov    %eax,(%ecx)
400069c6:	89 51 04             	mov    %edx,0x4(%ecx)
400069c9:	8b 45 08             	mov    0x8(%ebp),%eax
400069cc:	8d 65 f4             	lea    -0xc(%ebp),%esp
400069cf:	5b                   	pop    %ebx
400069d0:	5e                   	pop    %esi
400069d1:	5f                   	pop    %edi
400069d2:	c9                   	leave  
400069d3:	c2 04 00             	ret    $0x4

400069d6 <dir_seek>:
400069d6:	55                   	push   %ebp
400069d7:	89 e5                	mov    %esp,%ebp
400069d9:	57                   	push   %edi
400069da:	56                   	push   %esi
400069db:	53                   	push   %ebx
400069dc:	83 ec 34             	sub    $0x34,%esp
400069df:	8b 45 10             	mov    0x10(%ebp),%eax
400069e2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
400069e5:	83 7d c4 01          	cmpl   $0x1,-0x3c(%ebp)
400069e9:	74 67                	je     40006a52 <dir_seek+0x7c>
400069eb:	83 7d c4 02          	cmpl   $0x2,-0x3c(%ebp)
400069ef:	0f 84 d0 00 00 00    	je     40006ac5 <dir_seek+0xef>
400069f5:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
400069f9:	74 05                	je     40006a00 <dir_seek+0x2a>
400069fb:	e9 da 00 00 00       	jmp    40006ada <dir_seek+0x104>
40006a00:	8b 45 0c             	mov    0xc(%ebp),%eax
40006a03:	89 45 c8             	mov    %eax,-0x38(%ebp)
40006a06:	99                   	cltd   
40006a07:	89 55 cc             	mov    %edx,-0x34(%ebp)
40006a0a:	8b 45 08             	mov    0x8(%ebp),%eax
40006a0d:	8b 40 1c             	mov    0x1c(%eax),%eax
40006a10:	8b 70 08             	mov    0x8(%eax),%esi
40006a13:	8b 78 0c             	mov    0xc(%eax),%edi
40006a16:	89 75 d0             	mov    %esi,-0x30(%ebp)
40006a19:	89 7d d4             	mov    %edi,-0x2c(%ebp)
40006a1c:	8b 7d d4             	mov    -0x2c(%ebp),%edi
40006a1f:	39 7d cc             	cmp    %edi,-0x34(%ebp)
40006a22:	72 1c                	jb     40006a40 <dir_seek+0x6a>
40006a24:	8b 45 d4             	mov    -0x2c(%ebp),%eax
40006a27:	39 45 cc             	cmp    %eax,-0x34(%ebp)
40006a2a:	77 08                	ja     40006a34 <dir_seek+0x5e>
40006a2c:	8b 55 d0             	mov    -0x30(%ebp),%edx
40006a2f:	39 55 c8             	cmp    %edx,-0x38(%ebp)
40006a32:	76 0c                	jbe    40006a40 <dir_seek+0x6a>
40006a34:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
40006a3b:	e9 ec 00 00 00       	jmp    40006b2c <dir_seek+0x156>
40006a40:	8b 45 0c             	mov    0xc(%ebp),%eax
40006a43:	99                   	cltd   
40006a44:	8b 4d 08             	mov    0x8(%ebp),%ecx
40006a47:	89 41 10             	mov    %eax,0x10(%ecx)
40006a4a:	89 51 14             	mov    %edx,0x14(%ecx)
40006a4d:	e9 88 00 00 00       	jmp    40006ada <dir_seek+0x104>
40006a52:	8b 45 0c             	mov    0xc(%ebp),%eax
40006a55:	89 c1                	mov    %eax,%ecx
40006a57:	89 c3                	mov    %eax,%ebx
40006a59:	c1 fb 1f             	sar    $0x1f,%ebx
40006a5c:	8b 45 08             	mov    0x8(%ebp),%eax
40006a5f:	8b 50 14             	mov    0x14(%eax),%edx
40006a62:	8b 40 10             	mov    0x10(%eax),%eax
40006a65:	89 ce                	mov    %ecx,%esi
40006a67:	89 df                	mov    %ebx,%edi
40006a69:	01 c6                	add    %eax,%esi
40006a6b:	11 d7                	adc    %edx,%edi
40006a6d:	89 75 e0             	mov    %esi,-0x20(%ebp)
40006a70:	89 7d e4             	mov    %edi,-0x1c(%ebp)
40006a73:	8b 45 08             	mov    0x8(%ebp),%eax
40006a76:	8b 40 1c             	mov    0x1c(%eax),%eax
40006a79:	8b 50 08             	mov    0x8(%eax),%edx
40006a7c:	8b 48 0c             	mov    0xc(%eax),%ecx
40006a7f:	89 55 e8             	mov    %edx,-0x18(%ebp)
40006a82:	89 4d ec             	mov    %ecx,-0x14(%ebp)
40006a85:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40006a88:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
40006a8b:	72 1c                	jb     40006aa9 <dir_seek+0xd3>
40006a8d:	8b 75 ec             	mov    -0x14(%ebp),%esi
40006a90:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
40006a93:	77 08                	ja     40006a9d <dir_seek+0xc7>
40006a95:	8b 7d e8             	mov    -0x18(%ebp),%edi
40006a98:	39 7d e0             	cmp    %edi,-0x20(%ebp)
40006a9b:	76 0c                	jbe    40006aa9 <dir_seek+0xd3>
40006a9d:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
40006aa4:	e9 83 00 00 00       	jmp    40006b2c <dir_seek+0x156>
40006aa9:	8b 45 08             	mov    0x8(%ebp),%eax
40006aac:	8b 48 10             	mov    0x10(%eax),%ecx
40006aaf:	8b 58 14             	mov    0x14(%eax),%ebx
40006ab2:	8b 45 0c             	mov    0xc(%ebp),%eax
40006ab5:	99                   	cltd   
40006ab6:	01 c8                	add    %ecx,%eax
40006ab8:	11 da                	adc    %ebx,%edx
40006aba:	8b 4d 08             	mov    0x8(%ebp),%ecx
40006abd:	89 41 10             	mov    %eax,0x10(%ecx)
40006ac0:	89 51 14             	mov    %edx,0x14(%ecx)
40006ac3:	eb 15                	jmp    40006ada <dir_seek+0x104>
40006ac5:	8b 45 08             	mov    0x8(%ebp),%eax
40006ac8:	8b 40 1c             	mov    0x1c(%eax),%eax
40006acb:	8b 50 0c             	mov    0xc(%eax),%edx
40006ace:	8b 40 08             	mov    0x8(%eax),%eax
40006ad1:	8b 4d 08             	mov    0x8(%ebp),%ecx
40006ad4:	89 41 10             	mov    %eax,0x10(%ecx)
40006ad7:	89 51 14             	mov    %edx,0x14(%ecx)
40006ada:	8b 45 08             	mov    0x8(%ebp),%eax
40006add:	8b 48 10             	mov    0x10(%eax),%ecx
40006ae0:	8b 58 14             	mov    0x14(%eax),%ebx
40006ae3:	8b 45 08             	mov    0x8(%ebp),%eax
40006ae6:	8b 40 1c             	mov    0x1c(%eax),%eax
40006ae9:	8b 50 0c             	mov    0xc(%eax),%edx
40006aec:	8b 40 08             	mov    0x8(%eax),%eax
40006aef:	89 de                	mov    %ebx,%esi
40006af1:	31 d6                	xor    %edx,%esi
40006af3:	31 c8                	xor    %ecx,%eax
40006af5:	09 f0                	or     %esi,%eax
40006af7:	85 c0                	test   %eax,%eax
40006af9:	75 16                	jne    40006b11 <dir_seek+0x13b>
40006afb:	8b 45 08             	mov    0x8(%ebp),%eax
40006afe:	8b 40 08             	mov    0x8(%eax),%eax
40006b01:	89 c2                	mov    %eax,%edx
40006b03:	81 ca 00 00 01 00    	or     $0x10000,%edx
40006b09:	8b 45 08             	mov    0x8(%ebp),%eax
40006b0c:	89 50 08             	mov    %edx,0x8(%eax)
40006b0f:	eb 14                	jmp    40006b25 <dir_seek+0x14f>
40006b11:	8b 45 08             	mov    0x8(%ebp),%eax
40006b14:	8b 40 08             	mov    0x8(%eax),%eax
40006b17:	89 c2                	mov    %eax,%edx
40006b19:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
40006b1f:	8b 45 08             	mov    0x8(%ebp),%eax
40006b22:	89 50 08             	mov    %edx,0x8(%eax)
40006b25:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
40006b2c:	8b 45 dc             	mov    -0x24(%ebp),%eax
40006b2f:	83 c4 34             	add    $0x34,%esp
40006b32:	5b                   	pop    %ebx
40006b33:	5e                   	pop    %esi
40006b34:	5f                   	pop    %edi
40006b35:	c9                   	leave  
40006b36:	c3                   	ret    
40006b37:	90                   	nop    

40006b38 <add_intr_handler>:
/*
 * Copyright (c) 2007 Kevin Wolf
 *
 * This program is free software. It comes without any warranty, to
 * the extent permitted by applicable law. You can redistribute it 
40006b38:	55                   	push   %ebp
40006b39:	89 e5                	mov    %esp,%ebp
 * and/or modify it under the terms of the Do What The Fuck You Want 
40006b3b:	8b 45 08             	mov    0x8(%ebp),%eax
40006b3e:	50                   	push   %eax
40006b3f:	b8 34 00 00 00       	mov    $0x34,%eax
40006b44:	cd 30                	int    $0x30
40006b46:	83 c4 04             	add    $0x4,%esp
 * To Public License, Version 2, as published by Sam Hocevar. See
 * http://sam.zoy.org/projects/COPYING.WTFPL for more details.
 */  

#ifndef _CDI_IO_H_
#define _CDI_IO_H_
40006b49:	c9                   	leave  
40006b4a:	c3                   	ret    
40006b4b:	90                   	nop    

40006b4c <get_tick_count>:
    return result;
}


/**
 * Neuen Prozess erstellen. Dieser ist solange blockiert, bis er mit
40006b4c:	55                   	push   %ebp
40006b4d:	89 e5                	mov    %esp,%ebp
40006b4f:	57                   	push   %edi
40006b50:	56                   	push   %esi
40006b51:	53                   	push   %ebx
40006b52:	83 ec 10             	sub    $0x10,%esp
 * unblock_task erloest wird. Waerend dieser Zeit kann der Elternprozess Mit
 * Hilfe von init_child_page Einzelne Seiten in den Adressraum des neuen
40006b55:	b8 28 00 00 00       	mov    $0x28,%eax
40006b5a:	cd 30                	int    $0x30
40006b5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
40006b5f:	89 55 f0             	mov    %edx,-0x10(%ebp)
 * Prozesses mappen.
 *
 * @param initial_eip Der Einsprungspunkt an dem der Prozess seine Arbeit
 *                      beginnen soll.
 * @param uid Die Benutzernummer unter der der Neue Prozess laufen soll (FIXME:
 *              Sollte vom Elternprozess geerbt werden)
40006b62:	8b 75 ec             	mov    -0x14(%ebp),%esi
40006b65:	bf 00 00 00 00       	mov    $0x0,%edi
40006b6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
40006b6d:	ba 00 00 00 00       	mov    $0x0,%edx
40006b72:	89 c1                	mov    %eax,%ecx
40006b74:	89 d3                	mov    %edx,%ebx
40006b76:	89 cb                	mov    %ecx,%ebx
40006b78:	b9 00 00 00 00       	mov    $0x0,%ecx
40006b7d:	89 f0                	mov    %esi,%eax
40006b7f:	09 c8                	or     %ecx,%eax
40006b81:	89 fa                	mov    %edi,%edx
40006b83:	09 da                	or     %ebx,%edx
 * @param args Pointer auf die Kommandozeilen-Parameter
40006b85:	83 c4 10             	add    $0x10,%esp
40006b88:	5b                   	pop    %ebx
40006b89:	5e                   	pop    %esi
40006b8a:	5f                   	pop    %edi
40006b8b:	c9                   	leave  
40006b8c:	c3                   	ret    
40006b8d:	90                   	nop    
40006b8e:	90                   	nop    
40006b8f:	90                   	nop    

40006b90 <syscall_putsn>:
/*  
 * Copyright (c) 2007 The tyndur Project. All rights reserved.
 *
40006b90:	55                   	push   %ebp
40006b91:	89 e5                	mov    %esp,%ebp
 * This code is derived from software contributed to the tyndur Project
 * by Antoine Kaufmann.
40006b93:	8b 55 08             	mov    0x8(%ebp),%edx
40006b96:	8b 45 0c             	mov    0xc(%ebp),%eax
40006b99:	50                   	push   %eax
40006b9a:	52                   	push   %edx
40006b9b:	b8 00 00 00 00       	mov    $0x0,%eax
40006ba0:	cd 30                	int    $0x30
40006ba2:	83 c4 08             	add    $0x8,%esp
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
40006ba5:	b8 01 00 00 00       	mov    $0x1,%eax
 *    notice, this list of conditions and the following disclaimer in the
40006baa:	c9                   	leave  
40006bab:	c3                   	ret    

40006bac <create_shared_memory>:
/*
 * Copyright (c) 2007 Kevin Wolf
 *
 * This program is free software. It comes without any warranty, to
 * the extent permitted by applicable law. You can redistribute it 
40006bac:	55                   	push   %ebp
40006bad:	89 e5                	mov    %esp,%ebp
40006baf:	83 ec 10             	sub    $0x10,%esp
 * and/or modify it under the terms of the Do What The Fuck You Want 
 * To Public License, Version 2, as published by Sam Hocevar. See
 * http://sam.zoy.org/projects/COPYING.WTFPL for more details.
40006bb2:	8b 45 08             	mov    0x8(%ebp),%eax
40006bb5:	50                   	push   %eax
40006bb6:	b8 3f 00 00 00       	mov    $0x3f,%eax
40006bbb:	cd 30                	int    $0x30
40006bbd:	83 c4 08             	add    $0x8,%esp
40006bc0:	89 45 fc             	mov    %eax,-0x4(%ebp)

#ifndef _CDI_IO_H_
#define _CDI_IO_H_

#include <stdint.h>

40006bc3:	8b 45 fc             	mov    -0x4(%ebp),%eax
static inline uint16_t cdi_inw(uint16_t _port)
40006bc6:	c9                   	leave  
40006bc7:	c3                   	ret    

40006bc8 <open_shared_memory>:
{
	uint16_t result;
40006bc8:	55                   	push   %ebp
40006bc9:	89 e5                	mov    %esp,%ebp
40006bcb:	83 ec 10             	sub    $0x10,%esp
	__asm__ ("inw %1, %0" : "=a" (result) : "Nd" (_port));
	return result;
}
40006bce:	8b 45 08             	mov    0x8(%ebp),%eax
40006bd1:	50                   	push   %eax
40006bd2:	b8 40 00 00 00       	mov    $0x40,%eax
40006bd7:	cd 30                	int    $0x30
40006bd9:	83 c4 04             	add    $0x4,%esp
40006bdc:	89 45 fc             	mov    %eax,-0x4(%ebp)
static inline uint8_t cdi_inb(uint16_t _port)
{
	uint8_t result;
	__asm__ ("inb %1, %0" : "=a" (result) : "Nd" (_port));
	return result;
}
40006bdf:	8b 45 fc             	mov    -0x4(%ebp),%eax

40006be2:	c9                   	leave  
40006be3:	c3                   	ret    

40006be4 <close_shared_memory>:
static inline uint32_t cdi_inl(uint16_t _port)
{
40006be4:	55                   	push   %ebp
40006be5:	89 e5                	mov    %esp,%ebp
	uint32_t result;
40006be7:	8b 45 08             	mov    0x8(%ebp),%eax
40006bea:	50                   	push   %eax
40006beb:	b8 41 00 00 00       	mov    $0x41,%eax
40006bf0:	cd 30                	int    $0x30
40006bf2:	83 c4 04             	add    $0x4,%esp
	__asm__ ("inl %1, %0" : "=a" (result) : "Nd" (_port));
	return result;
}



40006bf5:	c9                   	leave  
40006bf6:	c3                   	ret    
40006bf7:	90                   	nop    

40006bf8 <lostio_sync_dispatch>:
        .dev = dev,

        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,

40006bf8:	55                   	push   %ebp
40006bf9:	89 e5                	mov    %esp,%ebp
40006bfb:	57                   	push   %edi
40006bfc:	56                   	push   %esi
40006bfd:	53                   	push   %ebx
40006bfe:	83 ec 2c             	sub    $0x2c,%esp
        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
40006c01:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
40006c08:	a1 0c a6 00 40       	mov    0x4000a60c,%eax
40006c0d:	85 c0                	test   %eax,%eax
40006c0f:	0f 84 b6 00 00 00    	je     40006ccb <lostio_sync_dispatch+0xd3>
        .buffer = buffer,

        .error = 0
    };
40006c15:	e9 90 00 00 00       	jmp    40006caa <lostio_sync_dispatch+0xb2>
    
    // Request starten
40006c1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006c1d:	8b 00                	mov    (%eax),%eax
40006c1f:	8b 40 1c             	mov    0x1c(%eax),%eax
40006c22:	8b 48 08             	mov    0x8(%eax),%ecx
40006c25:	8b 58 0c             	mov    0xc(%eax),%ebx
40006c28:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006c2b:	8b 00                	mov    (%eax),%eax
40006c2d:	8b 50 14             	mov    0x14(%eax),%edx
40006c30:	8b 40 10             	mov    0x10(%eax),%eax
40006c33:	89 ce                	mov    %ecx,%esi
40006c35:	89 df                	mov    %ebx,%edi
40006c37:	29 c6                	sub    %eax,%esi
40006c39:	19 d7                	sbb    %edx,%edi
40006c3b:	89 75 d0             	mov    %esi,-0x30(%ebp)
40006c3e:	89 7d d4             	mov    %edi,-0x2c(%ebp)
40006c41:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006c44:	8b 50 08             	mov    0x8(%eax),%edx
40006c47:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006c4a:	8b 40 0c             	mov    0xc(%eax),%eax
40006c4d:	0f af c2             	imul   %edx,%eax
40006c50:	89 45 d8             	mov    %eax,-0x28(%ebp)
40006c53:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
40006c5a:	8b 7d dc             	mov    -0x24(%ebp),%edi
40006c5d:	39 7d d4             	cmp    %edi,-0x2c(%ebp)
40006c60:	72 45                	jb     40006ca7 <lostio_sync_dispatch+0xaf>
40006c62:	8b 45 dc             	mov    -0x24(%ebp),%eax
40006c65:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
40006c68:	77 08                	ja     40006c72 <lostio_sync_dispatch+0x7a>
40006c6a:	8b 75 d8             	mov    -0x28(%ebp),%esi
40006c6d:	39 75 d0             	cmp    %esi,-0x30(%ebp)
40006c70:	72 35                	jb     40006ca7 <lostio_sync_dispatch+0xaf>
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
40006c72:	8b 55 ec             	mov    -0x14(%ebp),%edx
40006c75:	83 c2 04             	add    $0x4,%edx
40006c78:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006c7b:	8b 48 14             	mov    0x14(%eax),%ecx
40006c7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006c81:	8b 40 18             	mov    0x18(%eax),%eax
40006c84:	52                   	push   %edx
40006c85:	6a 10                	push   $0x10
40006c87:	51                   	push   %ecx
40006c88:	50                   	push   %eax
40006c89:	e8 44 03 00 00       	call   40006fd2 <rpc_io_read>
40006c8e:	83 c4 10             	add    $0x10,%esp
    }
        
    // Ein ATA-Geraet
40006c91:	a1 0c a6 00 40       	mov    0x4000a60c,%eax
40006c96:	83 ec 08             	sub    $0x8,%esp
40006c99:	ff 75 e8             	pushl  -0x18(%ebp)
40006c9c:	50                   	push   %eax
40006c9d:	e8 d7 12 00 00       	call   40007f79 <list_remove>
40006ca2:	83 c4 10             	add    $0x10,%esp
40006ca5:	eb 03                	jmp    40006caa <lostio_sync_dispatch+0xb2>
    dev->atapi = 0;

40006ca7:	ff 45 e8             	incl   -0x18(%ebp)
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

        .error = 0
    };
40006caa:	a1 0c a6 00 40       	mov    0x4000a60c,%eax
40006caf:	83 ec 08             	sub    $0x8,%esp
40006cb2:	ff 75 e8             	pushl  -0x18(%ebp)
40006cb5:	50                   	push   %eax
40006cb6:	e8 d2 11 00 00       	call   40007e8d <list_get_element_at>
40006cbb:	83 c4 10             	add    $0x10,%esp
40006cbe:	89 45 ec             	mov    %eax,-0x14(%ebp)
40006cc1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
40006cc5:	0f 85 4f ff ff ff    	jne    40006c1a <lostio_sync_dispatch+0x22>
    // Ein ATA-Geraet
    dev->atapi = 0;

    // TODO: Informationen verarbeiten

    return 1;
40006ccb:	8d 65 f4             	lea    -0xc(%ebp),%esp
40006cce:	5b                   	pop    %ebx
40006ccf:	5e                   	pop    %esi
40006cd0:	5f                   	pop    %edi
40006cd1:	c9                   	leave  
40006cd2:	c3                   	ret    

40006cd3 <lostio_sync_read_wait>:
 * @param start LBA des Startsektors
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
 */
40006cd3:	55                   	push   %ebp
40006cd4:	89 e5                	mov    %esp,%ebp
40006cd6:	83 ec 18             	sub    $0x18,%esp
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
40006cd9:	83 ec 0c             	sub    $0xc,%esp
40006cdc:	6a 1c                	push   $0x1c
40006cde:	e8 f5 15 00 00       	call   400082d8 <malloc>
40006ce3:	83 c4 10             	add    $0x10,%esp
40006ce6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* buffer)
{
40006ce9:	a1 0c a6 00 40       	mov    0x4000a60c,%eax
40006cee:	85 c0                	test   %eax,%eax
40006cf0:	75 0a                	jne    40006cfc <lostio_sync_read_wait+0x29>
    int result = 1;
40006cf2:	e8 29 0f 00 00       	call   40007c20 <list_create>
40006cf7:	a3 0c a6 00 40       	mov    %eax,0x4000a60c
    struct ata_request request;
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
    // muss unter Umstaenden mehrmals gelesen werden.
40006cfc:	8b 55 fc             	mov    -0x4(%ebp),%edx
40006cff:	8b 45 0c             	mov    0xc(%ebp),%eax
40006d02:	89 42 18             	mov    %eax,0x18(%edx)
    uint16_t current_count;
40006d05:	8b 55 fc             	mov    -0x4(%ebp),%edx
40006d08:	8b 45 10             	mov    0x10(%ebp),%eax
40006d0b:	89 42 14             	mov    %eax,0x14(%edx)
    void* current_buffer = buffer;
    uint64_t lba = start;

    // Anzahl der Sektoren die noch uebrig sind
40006d0e:	8b 45 fc             	mov    -0x4(%ebp),%eax
40006d11:	83 c0 04             	add    $0x4,%eax
40006d14:	83 ec 04             	sub    $0x4,%esp
40006d17:	6a 10                	push   $0x10
40006d19:	ff 75 14             	pushl  0x14(%ebp)
40006d1c:	50                   	push   %eax
40006d1d:	e8 46 22 00 00       	call   40008f68 <memcpy>
40006d22:	83 c4 10             	add    $0x10,%esp
    size_t count_left = count;

40006d25:	8b 55 fc             	mov    -0x4(%ebp),%edx
40006d28:	8b 45 08             	mov    0x8(%ebp),%eax
40006d2b:	89 02                	mov    %eax,(%edx)
    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
40006d2d:	a1 0c a6 00 40       	mov    0x4000a60c,%eax
40006d32:	83 ec 08             	sub    $0x8,%esp
40006d35:	ff 75 fc             	pushl  -0x4(%ebp)
40006d38:	50                   	push   %eax
40006d39:	e8 8e 0f 00 00       	call   40007ccc <list_push>
40006d3e:	83 c4 10             	add    $0x10,%esp
40006d41:	a3 0c a6 00 40       	mov    %eax,0x4000a60c
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
40006d46:	c9                   	leave  
40006d47:	c3                   	ret    

40006d48 <syscall_timer>:

#include <stdio.h>
#include <stdlib.h>

#include "cdi.h"
#include "cdi/storage.h"
40006d48:	55                   	push   %ebp
40006d49:	89 e5                	mov    %esp,%ebp
#include "cdi/misc.h"
40006d4b:	b8 46 00 00 00       	mov    $0x46,%eax
40006d50:	ff 75 0c             	pushl  0xc(%ebp)
40006d53:	ff 75 08             	pushl  0x8(%ebp)
40006d56:	cd 30                	int    $0x30
40006d58:	83 c4 08             	add    $0x8,%esp

#include "device.h"


/**
 * ATA-Geraet identifizieren
40006d5b:	c9                   	leave  
40006d5c:	c3                   	ret    
40006d5d:	90                   	nop    
40006d5e:	90                   	nop    
40006d5f:	90                   	nop    

40006d60 <rpc_io_open>:
        .flags.poll = 1,
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
40006d60:	55                   	push   %ebp
40006d61:	89 e5                	mov    %esp,%ebp
40006d63:	53                   	push   %ebx
40006d64:	83 ec 74             	sub    $0x74,%esp
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
40006d67:	83 ec 04             	sub    $0x4,%esp
40006d6a:	6a 25                	push   $0x25
40006d6c:	6a 00                	push   $0x0
40006d6e:	8d 45 b3             	lea    -0x4d(%ebp),%eax
40006d71:	50                   	push   %eax
40006d72:	e8 9d 23 00 00       	call   40009114 <memset>
40006d77:	83 c4 10             	add    $0x10,%esp
        .buffer = buffer,

        .error = 0
    };
40006d7a:	8b 45 14             	mov    0x14(%ebp),%eax
40006d7d:	83 c0 05             	add    $0x5,%eax
40006d80:	89 45 dc             	mov    %eax,-0x24(%ebp)
    
    // Request starten
40006d83:	8b 45 14             	mov    0x14(%ebp),%eax
40006d86:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (!ata_request(&request)) {
40006d89:	8b 45 14             	mov    0x14(%ebp),%eax
40006d8c:	40                   	inc    %eax
40006d8d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
40006d90:	8b 45 14             	mov    0x14(%ebp),%eax
40006d93:	83 c0 2a             	add    $0x2a,%eax
40006d96:	89 45 e8             	mov    %eax,-0x18(%ebp)
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
40006d99:	e8 92 af ff ff       	call   40001d30 <get_pid>
40006d9e:	89 45 b7             	mov    %eax,-0x49(%ebp)
    }
        
40006da1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40006da4:	8b 10                	mov    (%eax),%edx
40006da6:	8b 45 e0             	mov    -0x20(%ebp),%eax
40006da9:	8a 00                	mov    (%eax),%al
40006dab:	0f b6 c0             	movzbl %al,%eax
40006dae:	ff 75 dc             	pushl  -0x24(%ebp)
40006db1:	52                   	push   %edx
40006db2:	50                   	push   %eax
40006db3:	ff 75 e8             	pushl  -0x18(%ebp)
40006db6:	e8 66 08 00 00       	call   40007621 <lostio_open>
40006dbb:	83 c4 10             	add    $0x10,%esp
40006dbe:	89 45 ec             	mov    %eax,-0x14(%ebp)
    // Ein ATA-Geraet
    dev->atapi = 0;
40006dc1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
40006dc5:	75 20                	jne    40006de7 <rpc_io_open+0x87>

    // TODO: Informationen verarbeiten
40006dc7:	c7 45 b7 00 00 00 00 	movl   $0x0,-0x49(%ebp)

40006dce:	8d 45 b3             	lea    -0x4d(%ebp),%eax
40006dd1:	50                   	push   %eax
40006dd2:	6a 25                	push   $0x25
40006dd4:	ff 75 0c             	pushl  0xc(%ebp)
40006dd7:	ff 75 08             	pushl  0x8(%ebp)
40006dda:	e8 70 c8 ff ff       	call   4000364f <rpc_send_response>
40006ddf:	83 c4 10             	add    $0x10,%esp
40006de2:	e9 97 01 00 00       	jmp    40006f7e <rpc_io_open+0x21e>
    return 1;
}

/**
 * Sektoren von einem ATA-Geraet lesen
 *
40006de7:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006dea:	8b 40 1c             	mov    0x1c(%eax),%eax
40006ded:	8b 40 1c             	mov    0x1c(%eax),%eax
40006df0:	25 00 00 04 00       	and    $0x40000,%eax
40006df5:	85 c0                	test   %eax,%eax
40006df7:	0f 84 45 01 00 00    	je     40006f42 <rpc_io_open+0x1e2>
40006dfd:	8b 45 e0             	mov    -0x20(%ebp),%eax
40006e00:	8a 00                	mov    (%eax),%al
40006e02:	0f b6 c0             	movzbl %al,%eax
40006e05:	83 e0 40             	and    $0x40,%eax
40006e08:	85 c0                	test   %eax,%eax
40006e0a:	0f 85 32 01 00 00    	jne    40006f42 <rpc_io_open+0x1e2>
 * @param start LBA des Startsektors
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
 */
40006e10:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
40006e17:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006e1a:	8b 40 1c             	mov    0x1c(%eax),%eax
40006e1d:	8a 00                	mov    (%eax),%al
40006e1f:	0f b6 c0             	movzbl %al,%eax
40006e22:	83 ec 0c             	sub    $0xc,%esp
40006e25:	50                   	push   %eax
40006e26:	e8 74 cb ff ff       	call   4000399f <get_typehandle>
40006e2b:	83 c4 10             	add    $0x10,%esp
40006e2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
{
40006e31:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
40006e35:	74 0a                	je     40006e41 <rpc_io_open+0xe1>
40006e37:	8b 45 f0             	mov    -0x10(%ebp),%eax
40006e3a:	8b 40 10             	mov    0x10(%eax),%eax
40006e3d:	85 c0                	test   %eax,%eax
40006e3f:	75 0c                	jne    40006e4d <rpc_io_open+0xed>
    int result = 1;
40006e41:	c7 45 b3 00 00 00 00 	movl   $0x0,-0x4d(%ebp)
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
{
40006e48:	e9 0f 01 00 00       	jmp    40006f5c <rpc_io_open+0x1fc>
    int result = 1;
    struct ata_request request;
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
    // muss unter Umstaenden mehrmals gelesen werden.
40006e4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
40006e50:	8b 50 10             	mov    0x10(%eax),%edx
40006e53:	8d 45 a8             	lea    -0x58(%ebp),%eax
40006e56:	68 00 04 00 00       	push   $0x400
40006e5b:	6a 01                	push   $0x1
40006e5d:	ff 75 ec             	pushl  -0x14(%ebp)
40006e60:	50                   	push   %eax
40006e61:	ff d2                	call   *%edx
40006e63:	83 c4 0c             	add    $0xc,%esp
    uint16_t current_count;
    void* current_buffer = buffer;
40006e66:	8b 45 ac             	mov    -0x54(%ebp),%eax
40006e69:	85 c0                	test   %eax,%eax
40006e6b:	0f 84 eb 00 00 00    	je     40006f5c <rpc_io_open+0x1fc>
40006e71:	89 e0                	mov    %esp,%eax
40006e73:	89 45 98             	mov    %eax,-0x68(%ebp)
    uint64_t lba = start;
40006e76:	8b 45 a8             	mov    -0x58(%ebp),%eax
40006e79:	89 45 f4             	mov    %eax,-0xc(%ebp)

40006e7c:	83 ec 0c             	sub    $0xc,%esp
40006e7f:	ff 75 f4             	pushl  -0xc(%ebp)
40006e82:	e8 ed 23 00 00       	call   40009274 <strlen>
40006e87:	83 c4 10             	add    $0x10,%esp
40006e8a:	83 c0 02             	add    $0x2,%eax
40006e8d:	83 c0 0f             	add    $0xf,%eax
40006e90:	83 c0 0f             	add    $0xf,%eax
40006e93:	c1 e8 04             	shr    $0x4,%eax
40006e96:	c1 e0 04             	shl    $0x4,%eax
40006e99:	29 c4                	sub    %eax,%esp
40006e9b:	89 65 94             	mov    %esp,-0x6c(%ebp)
40006e9e:	8b 45 94             	mov    -0x6c(%ebp),%eax
40006ea1:	83 c0 0f             	add    $0xf,%eax
40006ea4:	c1 e8 04             	shr    $0x4,%eax
40006ea7:	c1 e0 04             	shl    $0x4,%eax
40006eaa:	89 45 94             	mov    %eax,-0x6c(%ebp)
40006ead:	8b 45 94             	mov    -0x6c(%ebp),%eax
40006eb0:	89 45 d8             	mov    %eax,-0x28(%ebp)
    // Anzahl der Sektoren die noch uebrig sind
40006eb3:	8b 45 e0             	mov    -0x20(%ebp),%eax
40006eb6:	8a 00                	mov    (%eax),%al
40006eb8:	88 c2                	mov    %al,%dl
40006eba:	8b 45 d8             	mov    -0x28(%ebp),%eax
40006ebd:	88 10                	mov    %dl,(%eax)
    size_t count_left = count;
40006ebf:	83 ec 0c             	sub    $0xc,%esp
40006ec2:	ff 75 f4             	pushl  -0xc(%ebp)
40006ec5:	e8 aa 23 00 00       	call   40009274 <strlen>
40006eca:	83 c4 10             	add    $0x10,%esp
40006ecd:	8d 50 01             	lea    0x1(%eax),%edx
40006ed0:	8b 45 d8             	mov    -0x28(%ebp),%eax
40006ed3:	40                   	inc    %eax
40006ed4:	83 ec 04             	sub    $0x4,%esp
40006ed7:	52                   	push   %edx
40006ed8:	ff 75 f4             	pushl  -0xc(%ebp)
40006edb:	50                   	push   %eax
40006edc:	e8 87 20 00 00       	call   40008f68 <memcpy>
40006ee1:	83 c4 10             	add    $0x10,%esp

    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
40006ee4:	8b 5d d8             	mov    -0x28(%ebp),%ebx
40006ee7:	83 ec 0c             	sub    $0xc,%esp
40006eea:	ff 75 f4             	pushl  -0xc(%ebp)
40006eed:	e8 82 23 00 00       	call   40009274 <strlen>
40006ef2:	83 c4 10             	add    $0x10,%esp
40006ef5:	83 c0 02             	add    $0x2,%eax
40006ef8:	53                   	push   %ebx
40006ef9:	50                   	push   %eax
40006efa:	68 0e 9c 00 40       	push   $0x40009c0e
40006eff:	6a 01                	push   $0x1
40006f01:	e8 27 c7 ff ff       	call   4000362d <rpc_get_response>
40006f06:	83 c4 10             	add    $0x10,%esp
40006f09:	89 45 f8             	mov    %eax,-0x8(%ebp)
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
40006f0c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40006f10:	74 0a                	je     40006f1c <rpc_io_open+0x1bc>
40006f12:	8b 45 f8             	mov    -0x8(%ebp),%eax
40006f15:	8b 40 0c             	mov    0xc(%eax),%eax
40006f18:	85 c0                	test   %eax,%eax
40006f1a:	75 09                	jne    40006f25 <rpc_io_open+0x1c5>
        if (count_left > 256) {
40006f1c:	c7 45 b3 00 00 00 00 	movl   $0x0,-0x4d(%ebp)
    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;

    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
40006f23:	eb 18                	jmp    40006f3d <rpc_io_open+0x1dd>
        if (count_left > 256) {
            current_count = 256;
        } else {
40006f25:	8b 45 f8             	mov    -0x8(%ebp),%eax
40006f28:	8b 40 0c             	mov    0xc(%eax),%eax
40006f2b:	83 ec 04             	sub    $0x4,%esp
40006f2e:	6a 25                	push   $0x25
40006f30:	50                   	push   %eax
40006f31:	8d 45 b3             	lea    -0x4d(%ebp),%eax
40006f34:	50                   	push   %eax
40006f35:	e8 2e 20 00 00       	call   40008f68 <memcpy>
40006f3a:	83 c4 10             	add    $0x10,%esp
40006f3d:	8b 65 98             	mov    -0x68(%ebp),%esp
    return 1;
}

/**
 * Sektoren von einem ATA-Geraet lesen
 *
40006f40:	eb 1a                	jmp    40006f5c <rpc_io_open+0x1fc>
        } else {
            current_count = count_left;
        }
        
        // Request vorbereiten
        request.dev = dev;
40006f42:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006f45:	8b 00                	mov    (%eax),%eax
40006f47:	89 45 b3             	mov    %eax,-0x4d(%ebp)
        // TODO: DMA, UltraDMA...
40006f4a:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006f4d:	8b 40 1c             	mov    0x1c(%eax),%eax
40006f50:	8b 50 18             	mov    0x18(%eax),%edx
40006f53:	8b 40 14             	mov    0x14(%eax),%eax
40006f56:	89 45 bb             	mov    %eax,-0x45(%ebp)
40006f59:	89 55 bf             	mov    %edx,-0x41(%ebp)
        request.protocol = PIO;
        request.flags.direction = READ;
        // FIXME
40006f5c:	8b 45 b3             	mov    -0x4d(%ebp),%eax
40006f5f:	85 c0                	test   %eax,%eax
40006f61:	75 07                	jne    40006f6a <rpc_io_open+0x20a>
        request.flags.poll = 1;
        request.flags.ata = 0;
40006f63:	c7 45 b7 00 00 00 00 	movl   $0x0,-0x49(%ebp)
        request.flags.lba = 1;

        request.registers.ata.command = READ_SECTORS;
40006f6a:	8d 45 b3             	lea    -0x4d(%ebp),%eax
40006f6d:	50                   	push   %eax
40006f6e:	6a 25                	push   $0x25
40006f70:	ff 75 0c             	pushl  0xc(%ebp)
40006f73:	ff 75 08             	pushl  0x8(%ebp)
40006f76:	e8 d4 c6 ff ff       	call   4000364f <rpc_send_response>
40006f7b:	83 c4 10             	add    $0x10,%esp
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
40006f7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40006f81:	c9                   	leave  
40006f82:	c3                   	ret    

40006f83 <rpc_io_close>:
        request.registers.ata.lba = lba;

        request.block_count = current_count;
        request.block_size = ATA_SECTOR_SIZE;
        request.blocks_done = 0;
        request.buffer = current_buffer;
40006f83:	55                   	push   %ebp
40006f84:	89 e5                	mov    %esp,%ebp
40006f86:	83 ec 18             	sub    $0x18,%esp

40006f89:	8b 45 14             	mov    0x14(%ebp),%eax
40006f8c:	89 45 fc             	mov    %eax,-0x4(%ebp)
        request.error = NO_ERROR;
        
        // TODO: LBA48
40006f8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
40006f92:	8b 00                	mov    (%eax),%eax
40006f94:	83 ec 08             	sub    $0x8,%esp
40006f97:	50                   	push   %eax
40006f98:	ff 75 08             	pushl  0x8(%ebp)
40006f9b:	e8 89 09 00 00       	call   40007929 <lostio_close>
40006fa0:	83 c4 10             	add    $0x10,%esp
40006fa3:	83 f8 01             	cmp    $0x1,%eax
40006fa6:	75 15                	jne    40006fbd <rpc_io_close+0x3a>
        // TODO: CHS
        
40006fa8:	83 ec 04             	sub    $0x4,%esp
40006fab:	6a 00                	push   $0x0
40006fad:	ff 75 0c             	pushl  0xc(%ebp)
40006fb0:	ff 75 08             	pushl  0x8(%ebp)
40006fb3:	e8 bb c6 ff ff       	call   40003673 <rpc_send_dword_response>
40006fb8:	83 c4 10             	add    $0x10,%esp
40006fbb:	eb 13                	jmp    40006fd0 <rpc_io_close+0x4d>
        // Request ausfuehren
        if (!ata_request(&request)) {
            result = 0;
            break;
40006fbd:	83 ec 04             	sub    $0x4,%esp
40006fc0:	6a ff                	push   $0xffffffff
40006fc2:	ff 75 0c             	pushl  0xc(%ebp)
40006fc5:	ff 75 08             	pushl  0x8(%ebp)
40006fc8:	e8 a6 c6 ff ff       	call   40003673 <rpc_send_dword_response>
40006fcd:	83 c4 10             	add    $0x10,%esp
        }

        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
40006fd0:	c9                   	leave  
40006fd1:	c3                   	ret    

40006fd2 <rpc_io_read>:
        count_left -= current_count;
        lba += current_count;
    }

    return result;
}
40006fd2:	55                   	push   %ebp
40006fd3:	89 e5                	mov    %esp,%ebp
40006fd5:	53                   	push   %ebx
40006fd6:	83 ec 24             	sub    $0x24,%esp

40006fd9:	8b 45 14             	mov    0x14(%ebp),%eax
40006fdc:	89 45 ec             	mov    %eax,-0x14(%ebp)
40006fdf:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006fe2:	8b 00                	mov    (%eax),%eax
40006fe4:	83 ec 08             	sub    $0x8,%esp
40006fe7:	50                   	push   %eax
40006fe8:	ff 75 08             	pushl  0x8(%ebp)
40006feb:	e8 4f ca ff ff       	call   40003a3f <get_filehandle>
40006ff0:	83 c4 10             	add    $0x10,%esp
40006ff3:	89 45 f0             	mov    %eax,-0x10(%ebp)
40006ff6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
40006ffa:	75 28                	jne    40007024 <rpc_io_read+0x52>
40006ffc:	83 ec 0c             	sub    $0xc,%esp
40006fff:	68 17 9c 00 40       	push   $0x40009c17
40007004:	e8 2a f5 ff ff       	call   40006533 <puts>
40007009:	83 c4 10             	add    $0x10,%esp
4000700c:	83 ec 04             	sub    $0x4,%esp
4000700f:	6a 00                	push   $0x0
40007011:	ff 75 0c             	pushl  0xc(%ebp)
40007014:	ff 75 08             	pushl  0x8(%ebp)
40007017:	e8 57 c6 ff ff       	call   40003673 <rpc_send_dword_response>
4000701c:	83 c4 10             	add    $0x10,%esp
4000701f:	e9 08 01 00 00       	jmp    4000712c <rpc_io_read+0x15a>
40007024:	8b 45 f0             	mov    -0x10(%ebp),%eax
40007027:	8b 40 1c             	mov    0x1c(%eax),%eax
4000702a:	8a 00                	mov    (%eax),%al
4000702c:	0f b6 c0             	movzbl %al,%eax
4000702f:	83 ec 0c             	sub    $0xc,%esp
40007032:	50                   	push   %eax
40007033:	e8 67 c9 ff ff       	call   4000399f <get_typehandle>
40007038:	83 c4 10             	add    $0x10,%esp
4000703b:	89 45 f4             	mov    %eax,-0xc(%ebp)
4000703e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
40007042:	0f 84 d1 00 00 00    	je     40007119 <rpc_io_read+0x147>
40007048:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000704b:	8b 40 10             	mov    0x10(%eax),%eax
4000704e:	85 c0                	test   %eax,%eax
40007050:	0f 84 c3 00 00 00    	je     40007119 <rpc_io_read+0x147>
40007056:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007059:	8b 58 10             	mov    0x10(%eax),%ebx
4000705c:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000705f:	8b 50 08             	mov    0x8(%eax),%edx
40007062:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007065:	8b 40 04             	mov    0x4(%eax),%eax
40007068:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
4000706b:	52                   	push   %edx
4000706c:	50                   	push   %eax
4000706d:	ff 75 f0             	pushl  -0x10(%ebp)
40007070:	51                   	push   %ecx
40007071:	ff d3                	call   *%ebx
40007073:	83 c4 0c             	add    $0xc,%esp
40007076:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007079:	8b 40 0c             	mov    0xc(%eax),%eax
4000707c:	85 c0                	test   %eax,%eax
4000707e:	75 1b                	jne    4000709b <rpc_io_read+0xc9>
40007080:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40007083:	8b 55 e8             	mov    -0x18(%ebp),%edx
40007086:	50                   	push   %eax
40007087:	52                   	push   %edx
40007088:	ff 75 0c             	pushl  0xc(%ebp)
4000708b:	ff 75 08             	pushl  0x8(%ebp)
4000708e:	e8 bc c5 ff ff       	call   4000364f <rpc_send_response>
40007093:	83 c4 10             	add    $0x10,%esp
40007096:	e9 91 00 00 00       	jmp    4000712c <rpc_io_read+0x15a>
4000709b:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000709e:	8b 40 0c             	mov    0xc(%eax),%eax
400070a1:	83 ec 0c             	sub    $0xc,%esp
400070a4:	50                   	push   %eax
400070a5:	e8 1e fb ff ff       	call   40006bc8 <open_shared_memory>
400070aa:	83 c4 10             	add    $0x10,%esp
400070ad:	89 45 f8             	mov    %eax,-0x8(%ebp)
400070b0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
400070b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
400070b6:	8b 50 04             	mov    0x4(%eax),%edx
400070b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
400070bc:	8b 40 08             	mov    0x8(%eax),%eax
400070bf:	0f af c2             	imul   %edx,%eax
400070c2:	39 c1                	cmp    %eax,%ecx
400070c4:	76 12                	jbe    400070d8 <rpc_io_read+0x106>
400070c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
400070c9:	8b 50 04             	mov    0x4(%eax),%edx
400070cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
400070cf:	8b 40 08             	mov    0x8(%eax),%eax
400070d2:	0f af c2             	imul   %edx,%eax
400070d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
400070d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
400070db:	8b 55 e4             	mov    -0x1c(%ebp),%edx
400070de:	83 ec 04             	sub    $0x4,%esp
400070e1:	50                   	push   %eax
400070e2:	52                   	push   %edx
400070e3:	ff 75 f8             	pushl  -0x8(%ebp)
400070e6:	e8 7d 1e 00 00       	call   40008f68 <memcpy>
400070eb:	83 c4 10             	add    $0x10,%esp
400070ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
400070f1:	8b 40 0c             	mov    0xc(%eax),%eax
400070f4:	83 ec 0c             	sub    $0xc,%esp
400070f7:	50                   	push   %eax
400070f8:	e8 e7 fa ff ff       	call   40006be4 <close_shared_memory>
400070fd:	83 c4 10             	add    $0x10,%esp
40007100:	8d 45 e4             	lea    -0x1c(%ebp),%eax
40007103:	83 c0 04             	add    $0x4,%eax
40007106:	50                   	push   %eax
40007107:	6a 04                	push   $0x4
40007109:	ff 75 0c             	pushl  0xc(%ebp)
4000710c:	ff 75 08             	pushl  0x8(%ebp)
4000710f:	e8 3b c5 ff ff       	call   4000364f <rpc_send_response>
40007114:	83 c4 10             	add    $0x10,%esp
40007117:	eb 13                	jmp    4000712c <rpc_io_read+0x15a>
40007119:	83 ec 04             	sub    $0x4,%esp
4000711c:	6a 00                	push   $0x0
4000711e:	ff 75 0c             	pushl  0xc(%ebp)
40007121:	ff 75 08             	pushl  0x8(%ebp)
40007124:	e8 4a c5 ff ff       	call   40003673 <rpc_send_dword_response>
40007129:	83 c4 10             	add    $0x10,%esp
4000712c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
4000712f:	c9                   	leave  
40007130:	c3                   	ret    

40007131 <rpc_io_write>:
40007131:	55                   	push   %ebp
40007132:	89 e5                	mov    %esp,%ebp
40007134:	83 ec 28             	sub    $0x28,%esp
40007137:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000713e:	8b 45 14             	mov    0x14(%ebp),%eax
40007141:	89 45 f0             	mov    %eax,-0x10(%ebp)
40007144:	8b 45 f0             	mov    -0x10(%ebp),%eax
40007147:	8b 00                	mov    (%eax),%eax
40007149:	83 ec 08             	sub    $0x8,%esp
4000714c:	50                   	push   %eax
4000714d:	ff 75 08             	pushl  0x8(%ebp)
40007150:	e8 ea c8 ff ff       	call   40003a3f <get_filehandle>
40007155:	83 c4 10             	add    $0x10,%esp
40007158:	89 45 f4             	mov    %eax,-0xc(%ebp)
4000715b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
4000715f:	74 1a                	je     4000717b <rpc_io_write+0x4a>
40007161:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007164:	8b 40 1c             	mov    0x1c(%eax),%eax
40007167:	8a 00                	mov    (%eax),%al
40007169:	0f b6 c0             	movzbl %al,%eax
4000716c:	83 ec 0c             	sub    $0xc,%esp
4000716f:	50                   	push   %eax
40007170:	e8 2a c8 ff ff       	call   4000399f <get_typehandle>
40007175:	83 c4 10             	add    $0x10,%esp
40007178:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000717b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
4000717f:	0f 84 d6 00 00 00    	je     4000725b <rpc_io_write+0x12a>
40007185:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007188:	8b 40 14             	mov    0x14(%eax),%eax
4000718b:	85 c0                	test   %eax,%eax
4000718d:	0f 84 c8 00 00 00    	je     4000725b <rpc_io_write+0x12a>
40007193:	8b 45 f0             	mov    -0x10(%ebp),%eax
40007196:	8b 40 0c             	mov    0xc(%eax),%eax
40007199:	85 c0                	test   %eax,%eax
4000719b:	75 3a                	jne    400071d7 <rpc_io_write+0xa6>
4000719d:	8b 45 f0             	mov    -0x10(%ebp),%eax
400071a0:	83 c0 10             	add    $0x10,%eax
400071a3:	89 45 f8             	mov    %eax,-0x8(%ebp)
400071a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
400071a9:	8b 50 04             	mov    0x4(%eax),%edx
400071ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
400071af:	8b 40 08             	mov    0x8(%eax),%eax
400071b2:	0f af d0             	imul   %eax,%edx
400071b5:	8b 45 10             	mov    0x10(%ebp),%eax
400071b8:	83 e8 10             	sub    $0x10,%eax
400071bb:	39 c2                	cmp    %eax,%edx
400071bd:	76 2d                	jbe    400071ec <rpc_io_write+0xbb>
400071bf:	83 ec 04             	sub    $0x4,%esp
400071c2:	6a ff                	push   $0xffffffff
400071c4:	ff 75 0c             	pushl  0xc(%ebp)
400071c7:	ff 75 08             	pushl  0x8(%ebp)
400071ca:	e8 a4 c4 ff ff       	call   40003673 <rpc_send_dword_response>
400071cf:	83 c4 10             	add    $0x10,%esp
400071d2:	e9 97 00 00 00       	jmp    4000726e <rpc_io_write+0x13d>
400071d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
400071da:	8b 40 0c             	mov    0xc(%eax),%eax
400071dd:	83 ec 0c             	sub    $0xc,%esp
400071e0:	50                   	push   %eax
400071e1:	e8 e2 f9 ff ff       	call   40006bc8 <open_shared_memory>
400071e6:	83 c4 10             	add    $0x10,%esp
400071e9:	89 45 f8             	mov    %eax,-0x8(%ebp)
400071ec:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
400071f0:	75 15                	jne    40007207 <rpc_io_write+0xd6>
400071f2:	83 ec 04             	sub    $0x4,%esp
400071f5:	6a ff                	push   $0xffffffff
400071f7:	ff 75 0c             	pushl  0xc(%ebp)
400071fa:	ff 75 08             	pushl  0x8(%ebp)
400071fd:	e8 71 c4 ff ff       	call   40003673 <rpc_send_dword_response>
40007202:	83 c4 10             	add    $0x10,%esp
40007205:	eb 67                	jmp    4000726e <rpc_io_write+0x13d>
40007207:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000720a:	8b 48 14             	mov    0x14(%eax),%ecx
4000720d:	8b 45 f0             	mov    -0x10(%ebp),%eax
40007210:	8b 50 08             	mov    0x8(%eax),%edx
40007213:	8b 45 f0             	mov    -0x10(%ebp),%eax
40007216:	8b 40 04             	mov    0x4(%eax),%eax
40007219:	ff 75 f8             	pushl  -0x8(%ebp)
4000721c:	52                   	push   %edx
4000721d:	50                   	push   %eax
4000721e:	ff 75 f4             	pushl  -0xc(%ebp)
40007221:	ff d1                	call   *%ecx
40007223:	83 c4 10             	add    $0x10,%esp
40007226:	89 45 fc             	mov    %eax,-0x4(%ebp)
40007229:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000722c:	8b 40 0c             	mov    0xc(%eax),%eax
4000722f:	85 c0                	test   %eax,%eax
40007231:	74 12                	je     40007245 <rpc_io_write+0x114>
40007233:	8b 45 f0             	mov    -0x10(%ebp),%eax
40007236:	8b 40 0c             	mov    0xc(%eax),%eax
40007239:	83 ec 0c             	sub    $0xc,%esp
4000723c:	50                   	push   %eax
4000723d:	e8 a2 f9 ff ff       	call   40006be4 <close_shared_memory>
40007242:	83 c4 10             	add    $0x10,%esp
40007245:	83 ec 04             	sub    $0x4,%esp
40007248:	ff 75 fc             	pushl  -0x4(%ebp)
4000724b:	ff 75 0c             	pushl  0xc(%ebp)
4000724e:	ff 75 08             	pushl  0x8(%ebp)
40007251:	e8 1d c4 ff ff       	call   40003673 <rpc_send_dword_response>
40007256:	83 c4 10             	add    $0x10,%esp
40007259:	eb 13                	jmp    4000726e <rpc_io_write+0x13d>
4000725b:	83 ec 04             	sub    $0x4,%esp
4000725e:	6a ff                	push   $0xffffffff
40007260:	ff 75 0c             	pushl  0xc(%ebp)
40007263:	ff 75 08             	pushl  0x8(%ebp)
40007266:	e8 08 c4 ff ff       	call   40003673 <rpc_send_dword_response>
4000726b:	83 c4 10             	add    $0x10,%esp
4000726e:	c9                   	leave  
4000726f:	c3                   	ret    

40007270 <rpc_io_seek>:
40007270:	55                   	push   %ebp
40007271:	89 e5                	mov    %esp,%ebp
40007273:	83 ec 18             	sub    $0x18,%esp
40007276:	8b 45 14             	mov    0x14(%ebp),%eax
40007279:	89 45 f0             	mov    %eax,-0x10(%ebp)
4000727c:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000727f:	8b 00                	mov    (%eax),%eax
40007281:	83 ec 08             	sub    $0x8,%esp
40007284:	50                   	push   %eax
40007285:	ff 75 08             	pushl  0x8(%ebp)
40007288:	e8 b2 c7 ff ff       	call   40003a3f <get_filehandle>
4000728d:	83 c4 10             	add    $0x10,%esp
40007290:	89 45 f4             	mov    %eax,-0xc(%ebp)
40007293:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
40007297:	75 15                	jne    400072ae <rpc_io_seek+0x3e>
40007299:	83 ec 04             	sub    $0x4,%esp
4000729c:	6a ff                	push   $0xffffffff
4000729e:	ff 75 0c             	pushl  0xc(%ebp)
400072a1:	ff 75 08             	pushl  0x8(%ebp)
400072a4:	e8 ca c3 ff ff       	call   40003673 <rpc_send_dword_response>
400072a9:	83 c4 10             	add    $0x10,%esp
400072ac:	eb 76                	jmp    40007324 <rpc_io_seek+0xb4>
400072ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
400072b1:	8b 40 1c             	mov    0x1c(%eax),%eax
400072b4:	8a 00                	mov    (%eax),%al
400072b6:	0f b6 c0             	movzbl %al,%eax
400072b9:	83 ec 0c             	sub    $0xc,%esp
400072bc:	50                   	push   %eax
400072bd:	e8 dd c6 ff ff       	call   4000399f <get_typehandle>
400072c2:	83 c4 10             	add    $0x10,%esp
400072c5:	89 45 f8             	mov    %eax,-0x8(%ebp)
400072c8:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
400072cc:	74 43                	je     40007311 <rpc_io_seek+0xa1>
400072ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
400072d1:	8b 40 18             	mov    0x18(%eax),%eax
400072d4:	85 c0                	test   %eax,%eax
400072d6:	74 39                	je     40007311 <rpc_io_seek+0xa1>
400072d8:	8b 45 f8             	mov    -0x8(%ebp),%eax
400072db:	8b 48 18             	mov    0x18(%eax),%ecx
400072de:	8b 45 f0             	mov    -0x10(%ebp),%eax
400072e1:	8b 50 08             	mov    0x8(%eax),%edx
400072e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
400072e7:	8b 40 04             	mov    0x4(%eax),%eax
400072ea:	83 ec 04             	sub    $0x4,%esp
400072ed:	52                   	push   %edx
400072ee:	50                   	push   %eax
400072ef:	ff 75 f4             	pushl  -0xc(%ebp)
400072f2:	ff d1                	call   *%ecx
400072f4:	83 c4 10             	add    $0x10,%esp
400072f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
400072fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
400072fd:	83 ec 04             	sub    $0x4,%esp
40007300:	50                   	push   %eax
40007301:	ff 75 0c             	pushl  0xc(%ebp)
40007304:	ff 75 08             	pushl  0x8(%ebp)
40007307:	e8 67 c3 ff ff       	call   40003673 <rpc_send_dword_response>
4000730c:	83 c4 10             	add    $0x10,%esp
4000730f:	eb 13                	jmp    40007324 <rpc_io_seek+0xb4>
40007311:	83 ec 04             	sub    $0x4,%esp
40007314:	6a ff                	push   $0xffffffff
40007316:	ff 75 0c             	pushl  0xc(%ebp)
40007319:	ff 75 08             	pushl  0x8(%ebp)
4000731c:	e8 52 c3 ff ff       	call   40003673 <rpc_send_dword_response>
40007321:	83 c4 10             	add    $0x10,%esp
40007324:	c9                   	leave  
40007325:	c3                   	ret    

40007326 <rpc_io_eof>:
40007326:	55                   	push   %ebp
40007327:	89 e5                	mov    %esp,%ebp
40007329:	83 ec 18             	sub    $0x18,%esp
4000732c:	8b 45 14             	mov    0x14(%ebp),%eax
4000732f:	89 45 f8             	mov    %eax,-0x8(%ebp)
40007332:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007335:	8b 00                	mov    (%eax),%eax
40007337:	83 ec 08             	sub    $0x8,%esp
4000733a:	50                   	push   %eax
4000733b:	ff 75 08             	pushl  0x8(%ebp)
4000733e:	e8 fc c6 ff ff       	call   40003a3f <get_filehandle>
40007343:	83 c4 10             	add    $0x10,%esp
40007346:	89 45 fc             	mov    %eax,-0x4(%ebp)
40007349:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
4000734d:	74 24                	je     40007373 <rpc_io_eof+0x4d>
4000734f:	8b 45 fc             	mov    -0x4(%ebp),%eax
40007352:	8b 40 08             	mov    0x8(%eax),%eax
40007355:	25 00 00 01 00       	and    $0x10000,%eax
4000735a:	85 c0                	test   %eax,%eax
4000735c:	74 15                	je     40007373 <rpc_io_eof+0x4d>
4000735e:	83 ec 04             	sub    $0x4,%esp
40007361:	6a ff                	push   $0xffffffff
40007363:	ff 75 0c             	pushl  0xc(%ebp)
40007366:	ff 75 08             	pushl  0x8(%ebp)
40007369:	e8 05 c3 ff ff       	call   40003673 <rpc_send_dword_response>
4000736e:	83 c4 10             	add    $0x10,%esp
40007371:	eb 13                	jmp    40007386 <rpc_io_eof+0x60>
40007373:	83 ec 04             	sub    $0x4,%esp
40007376:	6a 00                	push   $0x0
40007378:	ff 75 0c             	pushl  0xc(%ebp)
4000737b:	ff 75 08             	pushl  0x8(%ebp)
4000737e:	e8 f0 c2 ff ff       	call   40003673 <rpc_send_dword_response>
40007383:	83 c4 10             	add    $0x10,%esp
40007386:	c9                   	leave  
40007387:	c3                   	ret    

40007388 <rpc_io_tell>:
40007388:	55                   	push   %ebp
40007389:	89 e5                	mov    %esp,%ebp
4000738b:	83 ec 18             	sub    $0x18,%esp
4000738e:	8b 45 14             	mov    0x14(%ebp),%eax
40007391:	89 45 f8             	mov    %eax,-0x8(%ebp)
40007394:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007397:	8b 00                	mov    (%eax),%eax
40007399:	83 ec 08             	sub    $0x8,%esp
4000739c:	50                   	push   %eax
4000739d:	ff 75 08             	pushl  0x8(%ebp)
400073a0:	e8 9a c6 ff ff       	call   40003a3f <get_filehandle>
400073a5:	83 c4 10             	add    $0x10,%esp
400073a8:	89 45 fc             	mov    %eax,-0x4(%ebp)
400073ab:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
400073af:	74 11                	je     400073c2 <rpc_io_tell+0x3a>
400073b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
400073b4:	8b 50 14             	mov    0x14(%eax),%edx
400073b7:	8b 40 10             	mov    0x10(%eax),%eax
400073ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
400073bd:	89 55 f4             	mov    %edx,-0xc(%ebp)
400073c0:	eb 0e                	jmp    400073d0 <rpc_io_tell+0x48>
400073c2:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
400073c9:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
400073d0:	8d 45 f0             	lea    -0x10(%ebp),%eax
400073d3:	50                   	push   %eax
400073d4:	6a 08                	push   $0x8
400073d6:	ff 75 0c             	pushl  0xc(%ebp)
400073d9:	ff 75 08             	pushl  0x8(%ebp)
400073dc:	e8 6e c2 ff ff       	call   4000364f <rpc_send_response>
400073e1:	83 c4 10             	add    $0x10,%esp
400073e4:	c9                   	leave  
400073e5:	c3                   	ret    

400073e6 <rpc_io_link>:
400073e6:	55                   	push   %ebp
400073e7:	89 e5                	mov    %esp,%ebp
400073e9:	83 ec 28             	sub    $0x28,%esp
400073ec:	8b 45 14             	mov    0x14(%ebp),%eax
400073ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
400073f2:	83 7d 10 0b          	cmpl   $0xb,0x10(%ebp)
400073f6:	76 34                	jbe    4000742c <rpc_io_link+0x46>
400073f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
400073fb:	8b 40 08             	mov    0x8(%eax),%eax
400073fe:	83 c0 0c             	add    $0xc,%eax
40007401:	3b 45 10             	cmp    0x10(%ebp),%eax
40007404:	77 26                	ja     4000742c <rpc_io_link+0x46>
40007406:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007409:	8b 40 08             	mov    0x8(%eax),%eax
4000740c:	40                   	inc    %eax
4000740d:	8b 55 ec             	mov    -0x14(%ebp),%edx
40007410:	83 c2 0c             	add    $0xc,%edx
40007413:	83 ec 08             	sub    $0x8,%esp
40007416:	50                   	push   %eax
40007417:	52                   	push   %edx
40007418:	e8 cf 05 00 00       	call   400079ec <strnlen>
4000741d:	83 c4 10             	add    $0x10,%esp
40007420:	89 c2                	mov    %eax,%edx
40007422:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007425:	8b 40 08             	mov    0x8(%eax),%eax
40007428:	39 c2                	cmp    %eax,%edx
4000742a:	74 18                	je     40007444 <rpc_io_link+0x5e>
4000742c:	83 ec 04             	sub    $0x4,%esp
4000742f:	6a fd                	push   $0xfffffffd
40007431:	ff 75 0c             	pushl  0xc(%ebp)
40007434:	ff 75 08             	pushl  0x8(%ebp)
40007437:	e8 5b c2 ff ff       	call   40003697 <rpc_send_int_response>
4000743c:	83 c4 10             	add    $0x10,%esp
4000743f:	e9 ce 00 00 00       	jmp    40007512 <rpc_io_link+0x12c>
40007444:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007447:	8b 00                	mov    (%eax),%eax
40007449:	83 ec 08             	sub    $0x8,%esp
4000744c:	50                   	push   %eax
4000744d:	ff 75 08             	pushl  0x8(%ebp)
40007450:	e8 ea c5 ff ff       	call   40003a3f <get_filehandle>
40007455:	83 c4 10             	add    $0x10,%esp
40007458:	89 45 f0             	mov    %eax,-0x10(%ebp)
4000745b:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000745e:	8b 40 04             	mov    0x4(%eax),%eax
40007461:	83 ec 08             	sub    $0x8,%esp
40007464:	50                   	push   %eax
40007465:	ff 75 08             	pushl  0x8(%ebp)
40007468:	e8 d2 c5 ff ff       	call   40003a3f <get_filehandle>
4000746d:	83 c4 10             	add    $0x10,%esp
40007470:	89 45 f4             	mov    %eax,-0xc(%ebp)
40007473:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
40007477:	74 06                	je     4000747f <rpc_io_link+0x99>
40007479:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
4000747d:	75 15                	jne    40007494 <rpc_io_link+0xae>
4000747f:	83 ec 04             	sub    $0x4,%esp
40007482:	6a ff                	push   $0xffffffff
40007484:	ff 75 0c             	pushl  0xc(%ebp)
40007487:	ff 75 08             	pushl  0x8(%ebp)
4000748a:	e8 08 c2 ff ff       	call   40003697 <rpc_send_int_response>
4000748f:	83 c4 10             	add    $0x10,%esp
40007492:	eb 7e                	jmp    40007512 <rpc_io_link+0x12c>
40007494:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007497:	8b 40 1c             	mov    0x1c(%eax),%eax
4000749a:	8a 00                	mov    (%eax),%al
4000749c:	0f b6 c0             	movzbl %al,%eax
4000749f:	83 ec 0c             	sub    $0xc,%esp
400074a2:	50                   	push   %eax
400074a3:	e8 f7 c4 ff ff       	call   4000399f <get_typehandle>
400074a8:	83 c4 10             	add    $0x10,%esp
400074ab:	89 45 f8             	mov    %eax,-0x8(%ebp)
400074ae:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
400074b2:	74 4b                	je     400074ff <rpc_io_link+0x119>
400074b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
400074b7:	8b 40 20             	mov    0x20(%eax),%eax
400074ba:	85 c0                	test   %eax,%eax
400074bc:	74 41                	je     400074ff <rpc_io_link+0x119>
400074be:	8b 45 f8             	mov    -0x8(%ebp),%eax
400074c1:	8b 50 20             	mov    0x20(%eax),%edx
400074c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
400074c7:	83 c0 0c             	add    $0xc,%eax
400074ca:	83 ec 04             	sub    $0x4,%esp
400074cd:	50                   	push   %eax
400074ce:	ff 75 f4             	pushl  -0xc(%ebp)
400074d1:	ff 75 f0             	pushl  -0x10(%ebp)
400074d4:	ff d2                	call   *%edx
400074d6:	83 c4 10             	add    $0x10,%esp
400074d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
400074dc:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
400074e0:	74 07                	je     400074e9 <rpc_io_link+0x103>
400074e2:	c7 45 fc fc ff ff ff 	movl   $0xfffffffc,-0x4(%ebp)
400074e9:	83 ec 04             	sub    $0x4,%esp
400074ec:	ff 75 fc             	pushl  -0x4(%ebp)
400074ef:	ff 75 0c             	pushl  0xc(%ebp)
400074f2:	ff 75 08             	pushl  0x8(%ebp)
400074f5:	e8 9d c1 ff ff       	call   40003697 <rpc_send_int_response>
400074fa:	83 c4 10             	add    $0x10,%esp
400074fd:	eb 13                	jmp    40007512 <rpc_io_link+0x12c>
400074ff:	83 ec 04             	sub    $0x4,%esp
40007502:	6a fe                	push   $0xfffffffe
40007504:	ff 75 0c             	pushl  0xc(%ebp)
40007507:	ff 75 08             	pushl  0x8(%ebp)
4000750a:	e8 88 c1 ff ff       	call   40003697 <rpc_send_int_response>
4000750f:	83 c4 10             	add    $0x10,%esp
40007512:	c9                   	leave  
40007513:	c3                   	ret    

40007514 <rpc_io_unlink>:
40007514:	55                   	push   %ebp
40007515:	89 e5                	mov    %esp,%ebp
40007517:	83 ec 18             	sub    $0x18,%esp
4000751a:	8b 45 14             	mov    0x14(%ebp),%eax
4000751d:	89 45 f0             	mov    %eax,-0x10(%ebp)
40007520:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
40007524:	76 34                	jbe    4000755a <rpc_io_unlink+0x46>
40007526:	8b 45 f0             	mov    -0x10(%ebp),%eax
40007529:	8b 40 04             	mov    0x4(%eax),%eax
4000752c:	83 c0 08             	add    $0x8,%eax
4000752f:	3b 45 10             	cmp    0x10(%ebp),%eax
40007532:	77 26                	ja     4000755a <rpc_io_unlink+0x46>
40007534:	8b 45 f0             	mov    -0x10(%ebp),%eax
40007537:	8b 40 04             	mov    0x4(%eax),%eax
4000753a:	40                   	inc    %eax
4000753b:	8b 55 f0             	mov    -0x10(%ebp),%edx
4000753e:	83 c2 08             	add    $0x8,%edx
40007541:	83 ec 08             	sub    $0x8,%esp
40007544:	50                   	push   %eax
40007545:	52                   	push   %edx
40007546:	e8 a1 04 00 00       	call   400079ec <strnlen>
4000754b:	83 c4 10             	add    $0x10,%esp
4000754e:	89 c2                	mov    %eax,%edx
40007550:	8b 45 f0             	mov    -0x10(%ebp),%eax
40007553:	8b 40 04             	mov    0x4(%eax),%eax
40007556:	39 c2                	cmp    %eax,%edx
40007558:	74 18                	je     40007572 <rpc_io_unlink+0x5e>
4000755a:	83 ec 04             	sub    $0x4,%esp
4000755d:	6a fd                	push   $0xfffffffd
4000755f:	ff 75 0c             	pushl  0xc(%ebp)
40007562:	ff 75 08             	pushl  0x8(%ebp)
40007565:	e8 2d c1 ff ff       	call   40003697 <rpc_send_int_response>
4000756a:	83 c4 10             	add    $0x10,%esp
4000756d:	e9 ad 00 00 00       	jmp    4000761f <rpc_io_unlink+0x10b>
40007572:	8b 45 f0             	mov    -0x10(%ebp),%eax
40007575:	8b 00                	mov    (%eax),%eax
40007577:	83 ec 08             	sub    $0x8,%esp
4000757a:	50                   	push   %eax
4000757b:	ff 75 08             	pushl  0x8(%ebp)
4000757e:	e8 bc c4 ff ff       	call   40003a3f <get_filehandle>
40007583:	83 c4 10             	add    $0x10,%esp
40007586:	89 45 f4             	mov    %eax,-0xc(%ebp)
40007589:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
4000758d:	75 15                	jne    400075a4 <rpc_io_unlink+0x90>
4000758f:	83 ec 04             	sub    $0x4,%esp
40007592:	6a ff                	push   $0xffffffff
40007594:	ff 75 0c             	pushl  0xc(%ebp)
40007597:	ff 75 08             	pushl  0x8(%ebp)
4000759a:	e8 f8 c0 ff ff       	call   40003697 <rpc_send_int_response>
4000759f:	83 c4 10             	add    $0x10,%esp
400075a2:	eb 7b                	jmp    4000761f <rpc_io_unlink+0x10b>
400075a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
400075a7:	8b 40 1c             	mov    0x1c(%eax),%eax
400075aa:	8a 00                	mov    (%eax),%al
400075ac:	0f b6 c0             	movzbl %al,%eax
400075af:	83 ec 0c             	sub    $0xc,%esp
400075b2:	50                   	push   %eax
400075b3:	e8 e7 c3 ff ff       	call   4000399f <get_typehandle>
400075b8:	83 c4 10             	add    $0x10,%esp
400075bb:	89 45 f8             	mov    %eax,-0x8(%ebp)
400075be:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
400075c2:	74 48                	je     4000760c <rpc_io_unlink+0xf8>
400075c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
400075c7:	8b 40 20             	mov    0x20(%eax),%eax
400075ca:	85 c0                	test   %eax,%eax
400075cc:	74 3e                	je     4000760c <rpc_io_unlink+0xf8>
400075ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
400075d1:	8b 50 24             	mov    0x24(%eax),%edx
400075d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
400075d7:	83 c0 08             	add    $0x8,%eax
400075da:	83 ec 08             	sub    $0x8,%esp
400075dd:	50                   	push   %eax
400075de:	ff 75 f4             	pushl  -0xc(%ebp)
400075e1:	ff d2                	call   *%edx
400075e3:	83 c4 10             	add    $0x10,%esp
400075e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
400075e9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
400075ed:	74 07                	je     400075f6 <rpc_io_unlink+0xe2>
400075ef:	c7 45 fc fc ff ff ff 	movl   $0xfffffffc,-0x4(%ebp)
400075f6:	83 ec 04             	sub    $0x4,%esp
400075f9:	ff 75 fc             	pushl  -0x4(%ebp)
400075fc:	ff 75 0c             	pushl  0xc(%ebp)
400075ff:	ff 75 08             	pushl  0x8(%ebp)
40007602:	e8 90 c0 ff ff       	call   40003697 <rpc_send_int_response>
40007607:	83 c4 10             	add    $0x10,%esp
4000760a:	eb 13                	jmp    4000761f <rpc_io_unlink+0x10b>
4000760c:	83 ec 04             	sub    $0x4,%esp
4000760f:	6a fe                	push   $0xfffffffe
40007611:	ff 75 0c             	pushl  0xc(%ebp)
40007614:	ff 75 08             	pushl  0x8(%ebp)
40007617:	e8 7b c0 ff ff       	call   40003697 <rpc_send_int_response>
4000761c:	83 c4 10             	add    $0x10,%esp
4000761f:	c9                   	leave  
40007620:	c3                   	ret    

40007621 <lostio_open>:
40007621:	55                   	push   %ebp
40007622:	89 e5                	mov    %esp,%ebp
40007624:	83 ec 28             	sub    $0x28,%esp
40007627:	8b 45 0c             	mov    0xc(%ebp),%eax
4000762a:	88 45 dc             	mov    %al,-0x24(%ebp)
4000762d:	8b 45 08             	mov    0x8(%ebp),%eax
40007630:	83 ec 0c             	sub    $0xc,%esp
40007633:	50                   	push   %eax
40007634:	e8 bf c5 ff ff       	call   40003bf8 <vfstree_get_node_by_path>
40007639:	83 c4 10             	add    $0x10,%esp
4000763c:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000763f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
40007643:	0f 85 02 01 00 00    	jne    4000774b <lostio_open+0x12a>
40007649:	8b 45 08             	mov    0x8(%ebp),%eax
4000764c:	83 ec 0c             	sub    $0xc,%esp
4000764f:	50                   	push   %eax
40007650:	e8 2b c4 ff ff       	call   40003a80 <vfstree_dirname>
40007655:	83 c4 10             	add    $0x10,%esp
40007658:	89 45 f8             	mov    %eax,-0x8(%ebp)
4000765b:	83 ec 0c             	sub    $0xc,%esp
4000765e:	ff 75 f8             	pushl  -0x8(%ebp)
40007661:	e8 92 c5 ff ff       	call   40003bf8 <vfstree_get_node_by_path>
40007666:	83 c4 10             	add    $0x10,%esp
40007669:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000766c:	83 ec 0c             	sub    $0xc,%esp
4000766f:	ff 75 f8             	pushl  -0x8(%ebp)
40007672:	e8 38 13 00 00       	call   400089af <free>
40007677:	83 c4 10             	add    $0x10,%esp
4000767a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
4000767e:	74 61                	je     400076e1 <lostio_open+0xc0>
40007680:	8b 45 fc             	mov    -0x4(%ebp),%eax
40007683:	8a 00                	mov    (%eax),%al
40007685:	0f b6 c0             	movzbl %al,%eax
40007688:	83 ec 0c             	sub    $0xc,%esp
4000768b:	50                   	push   %eax
4000768c:	e8 0e c3 ff ff       	call   4000399f <get_typehandle>
40007691:	83 c4 10             	add    $0x10,%esp
40007694:	89 45 f0             	mov    %eax,-0x10(%ebp)
40007697:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
4000769b:	74 38                	je     400076d5 <lostio_open+0xb4>
4000769d:	8b 45 f0             	mov    -0x10(%ebp),%eax
400076a0:	8b 40 04             	mov    0x4(%eax),%eax
400076a3:	85 c0                	test   %eax,%eax
400076a5:	74 2e                	je     400076d5 <lostio_open+0xb4>
400076a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
400076aa:	8b 50 04             	mov    0x4(%eax),%edx
400076ad:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
400076b1:	ff 75 14             	pushl  0x14(%ebp)
400076b4:	ff 75 10             	pushl  0x10(%ebp)
400076b7:	50                   	push   %eax
400076b8:	8d 45 08             	lea    0x8(%ebp),%eax
400076bb:	50                   	push   %eax
400076bc:	ff d2                	call   *%edx
400076be:	83 c4 10             	add    $0x10,%esp
400076c1:	85 c0                	test   %eax,%eax
400076c3:	0f 85 82 00 00 00    	jne    4000774b <lostio_open+0x12a>
400076c9:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
400076d0:	e9 4f 02 00 00       	jmp    40007924 <lostio_open+0x303>
400076d5:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
400076dc:	e9 43 02 00 00       	jmp    40007924 <lostio_open+0x303>
400076e1:	83 ec 0c             	sub    $0xc,%esp
400076e4:	6a 00                	push   $0x0
400076e6:	e8 b4 c2 ff ff       	call   4000399f <get_typehandle>
400076eb:	83 c4 10             	add    $0x10,%esp
400076ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
400076f1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
400076f5:	74 0a                	je     40007701 <lostio_open+0xe0>
400076f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
400076fa:	8b 40 04             	mov    0x4(%eax),%eax
400076fd:	85 c0                	test   %eax,%eax
400076ff:	75 20                	jne    40007721 <lostio_open+0x100>
40007701:	8b 45 08             	mov    0x8(%ebp),%eax
40007704:	83 ec 08             	sub    $0x8,%esp
40007707:	50                   	push   %eax
40007708:	68 31 9c 00 40       	push   $0x40009c31
4000770d:	e8 27 ec ff ff       	call   40006339 <printf>
40007712:	83 c4 10             	add    $0x10,%esp
40007715:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
4000771c:	e9 03 02 00 00       	jmp    40007924 <lostio_open+0x303>
40007721:	8b 45 f0             	mov    -0x10(%ebp),%eax
40007724:	8b 50 04             	mov    0x4(%eax),%edx
40007727:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
4000772b:	ff 75 14             	pushl  0x14(%ebp)
4000772e:	ff 75 10             	pushl  0x10(%ebp)
40007731:	50                   	push   %eax
40007732:	8d 45 08             	lea    0x8(%ebp),%eax
40007735:	50                   	push   %eax
40007736:	ff d2                	call   *%edx
40007738:	83 c4 10             	add    $0x10,%esp
4000773b:	85 c0                	test   %eax,%eax
4000773d:	75 0c                	jne    4000774b <lostio_open+0x12a>
4000773f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
40007746:	e9 d9 01 00 00       	jmp    40007924 <lostio_open+0x303>
4000774b:	8b 45 08             	mov    0x8(%ebp),%eax
4000774e:	83 ec 0c             	sub    $0xc,%esp
40007751:	50                   	push   %eax
40007752:	e8 a1 c4 ff ff       	call   40003bf8 <vfstree_get_node_by_path>
40007757:	83 c4 10             	add    $0x10,%esp
4000775a:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000775d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
40007761:	74 77                	je     400077da <lostio_open+0x1b9>
40007763:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
40007767:	83 e0 10             	and    $0x10,%eax
4000776a:	85 c0                	test   %eax,%eax
4000776c:	74 1b                	je     40007789 <lostio_open+0x168>
4000776e:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007771:	8b 40 1c             	mov    0x1c(%eax),%eax
40007774:	25 00 00 02 00       	and    $0x20000,%eax
40007779:	85 c0                	test   %eax,%eax
4000777b:	75 0c                	jne    40007789 <lostio_open+0x168>
4000777d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
40007784:	e9 9b 01 00 00       	jmp    40007924 <lostio_open+0x303>
40007789:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000778c:	8a 00                	mov    (%eax),%al
4000778e:	0f b6 c0             	movzbl %al,%eax
40007791:	83 ec 0c             	sub    $0xc,%esp
40007794:	50                   	push   %eax
40007795:	e8 05 c2 ff ff       	call   4000399f <get_typehandle>
4000779a:	83 c4 10             	add    $0x10,%esp
4000779d:	89 45 f0             	mov    %eax,-0x10(%ebp)
400077a0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
400077a4:	74 34                	je     400077da <lostio_open+0x1b9>
400077a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
400077a9:	8b 40 08             	mov    0x8(%eax),%eax
400077ac:	85 c0                	test   %eax,%eax
400077ae:	74 2a                	je     400077da <lostio_open+0x1b9>
400077b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
400077b3:	8b 50 08             	mov    0x8(%eax),%edx
400077b6:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
400077ba:	ff 75 14             	pushl  0x14(%ebp)
400077bd:	ff 75 10             	pushl  0x10(%ebp)
400077c0:	50                   	push   %eax
400077c1:	8d 45 08             	lea    0x8(%ebp),%eax
400077c4:	50                   	push   %eax
400077c5:	ff d2                	call   *%edx
400077c7:	83 c4 10             	add    $0x10,%esp
400077ca:	85 c0                	test   %eax,%eax
400077cc:	75 0c                	jne    400077da <lostio_open+0x1b9>
400077ce:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
400077d5:	e9 4a 01 00 00       	jmp    40007924 <lostio_open+0x303>
400077da:	8b 45 08             	mov    0x8(%ebp),%eax
400077dd:	83 ec 0c             	sub    $0xc,%esp
400077e0:	50                   	push   %eax
400077e1:	e8 12 c4 ff ff       	call   40003bf8 <vfstree_get_node_by_path>
400077e6:	83 c4 10             	add    $0x10,%esp
400077e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
400077ec:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
400077f0:	75 0c                	jne    400077fe <lostio_open+0x1dd>
400077f2:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
400077f9:	e9 26 01 00 00       	jmp    40007924 <lostio_open+0x303>
400077fe:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
40007802:	83 e0 10             	and    $0x10,%eax
40007805:	85 c0                	test   %eax,%eax
40007807:	74 1b                	je     40007824 <lostio_open+0x203>
40007809:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000780c:	8b 40 1c             	mov    0x1c(%eax),%eax
4000780f:	25 00 00 02 00       	and    $0x20000,%eax
40007814:	85 c0                	test   %eax,%eax
40007816:	75 0c                	jne    40007824 <lostio_open+0x203>
40007818:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
4000781f:	e9 00 01 00 00       	jmp    40007924 <lostio_open+0x303>
40007824:	83 ec 0c             	sub    $0xc,%esp
40007827:	6a 20                	push   $0x20
40007829:	e8 aa 0a 00 00       	call   400082d8 <malloc>
4000782e:	83 c4 10             	add    $0x10,%esp
40007831:	89 45 f4             	mov    %eax,-0xc(%ebp)
40007834:	8b 15 50 a0 00 40    	mov    0x4000a050,%edx
4000783a:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000783d:	89 10                	mov    %edx,(%eax)
4000783f:	8d 42 01             	lea    0x1(%edx),%eax
40007842:	a3 50 a0 00 40       	mov    %eax,0x4000a050
40007847:	8b 55 f4             	mov    -0xc(%ebp),%edx
4000784a:	8b 45 10             	mov    0x10(%ebp),%eax
4000784d:	89 42 04             	mov    %eax,0x4(%edx)
40007850:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
40007854:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007857:	89 50 08             	mov    %edx,0x8(%eax)
4000785a:	83 ec 0c             	sub    $0xc,%esp
4000785d:	6a 25                	push   $0x25
4000785f:	e8 74 0a 00 00       	call   400082d8 <malloc>
40007864:	83 c4 10             	add    $0x10,%esp
40007867:	89 c2                	mov    %eax,%edx
40007869:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000786c:	89 50 0c             	mov    %edx,0xc(%eax)
4000786f:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007872:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
40007879:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
40007880:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007883:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
4000788a:	8b 55 f4             	mov    -0xc(%ebp),%edx
4000788d:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007890:	89 42 1c             	mov    %eax,0x1c(%edx)
40007893:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007896:	8b 40 0c             	mov    0xc(%eax),%eax
40007899:	83 ec 04             	sub    $0x4,%esp
4000789c:	6a 25                	push   $0x25
4000789e:	ff 75 14             	pushl  0x14(%ebp)
400078a1:	50                   	push   %eax
400078a2:	e8 c1 16 00 00       	call   40008f68 <memcpy>
400078a7:	83 c4 10             	add    $0x10,%esp
400078aa:	a1 e4 a7 00 40       	mov    0x4000a7e4,%eax
400078af:	83 ec 08             	sub    $0x8,%esp
400078b2:	ff 75 f4             	pushl  -0xc(%ebp)
400078b5:	50                   	push   %eax
400078b6:	e8 11 04 00 00       	call   40007ccc <list_push>
400078bb:	83 c4 10             	add    $0x10,%esp
400078be:	a3 e4 a7 00 40       	mov    %eax,0x4000a7e4
400078c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
400078c6:	8b 50 0c             	mov    0xc(%eax),%edx
400078c9:	8b 40 08             	mov    0x8(%eax),%eax
400078cc:	09 d0                	or     %edx,%eax
400078ce:	85 c0                	test   %eax,%eax
400078d0:	75 14                	jne    400078e6 <lostio_open+0x2c5>
400078d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
400078d5:	8b 40 08             	mov    0x8(%eax),%eax
400078d8:	89 c2                	mov    %eax,%edx
400078da:	81 ca 00 00 01 00    	or     $0x10000,%edx
400078e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
400078e3:	89 50 08             	mov    %edx,0x8(%eax)
400078e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
400078e9:	8a 00                	mov    (%eax),%al
400078eb:	0f b6 c0             	movzbl %al,%eax
400078ee:	83 ec 0c             	sub    $0xc,%esp
400078f1:	50                   	push   %eax
400078f2:	e8 a8 c0 ff ff       	call   4000399f <get_typehandle>
400078f7:	83 c4 10             	add    $0x10,%esp
400078fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
400078fd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
40007901:	74 1b                	je     4000791e <lostio_open+0x2fd>
40007903:	8b 45 f0             	mov    -0x10(%ebp),%eax
40007906:	8b 40 0c             	mov    0xc(%eax),%eax
40007909:	85 c0                	test   %eax,%eax
4000790b:	74 11                	je     4000791e <lostio_open+0x2fd>
4000790d:	8b 45 f0             	mov    -0x10(%ebp),%eax
40007910:	8b 40 0c             	mov    0xc(%eax),%eax
40007913:	83 ec 0c             	sub    $0xc,%esp
40007916:	ff 75 f4             	pushl  -0xc(%ebp)
40007919:	ff d0                	call   *%eax
4000791b:	83 c4 10             	add    $0x10,%esp
4000791e:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007921:	89 45 d8             	mov    %eax,-0x28(%ebp)
40007924:	8b 45 d8             	mov    -0x28(%ebp),%eax
40007927:	c9                   	leave  
40007928:	c3                   	ret    

40007929 <lostio_close>:
40007929:	55                   	push   %ebp
4000792a:	89 e5                	mov    %esp,%ebp
4000792c:	83 ec 18             	sub    $0x18,%esp
4000792f:	e8 64 b8 ff ff       	call   40003198 <p>
40007934:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
4000793b:	eb 0d                	jmp    4000794a <lostio_close+0x21>
4000793d:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007940:	8b 00                	mov    (%eax),%eax
40007942:	3b 45 0c             	cmp    0xc(%ebp),%eax
40007945:	74 20                	je     40007967 <lostio_close+0x3e>
40007947:	ff 45 fc             	incl   -0x4(%ebp)
4000794a:	a1 e4 a7 00 40       	mov    0x4000a7e4,%eax
4000794f:	83 ec 08             	sub    $0x8,%esp
40007952:	ff 75 fc             	pushl  -0x4(%ebp)
40007955:	50                   	push   %eax
40007956:	e8 32 05 00 00       	call   40007e8d <list_get_element_at>
4000795b:	83 c4 10             	add    $0x10,%esp
4000795e:	89 45 f4             	mov    %eax,-0xc(%ebp)
40007961:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
40007965:	75 d6                	jne    4000793d <lostio_close+0x14>
40007967:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
4000796b:	75 0e                	jne    4000797b <lostio_close+0x52>
4000796d:	e8 32 b8 ff ff       	call   400031a4 <v>
40007972:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007979:	eb 69                	jmp    400079e4 <lostio_close+0xbb>
4000797b:	a1 e4 a7 00 40       	mov    0x4000a7e4,%eax
40007980:	83 ec 08             	sub    $0x8,%esp
40007983:	ff 75 fc             	pushl  -0x4(%ebp)
40007986:	50                   	push   %eax
40007987:	e8 ed 05 00 00       	call   40007f79 <list_remove>
4000798c:	83 c4 10             	add    $0x10,%esp
4000798f:	e8 10 b8 ff ff       	call   400031a4 <v>
40007994:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007997:	8b 40 1c             	mov    0x1c(%eax),%eax
4000799a:	8a 00                	mov    (%eax),%al
4000799c:	0f b6 c0             	movzbl %al,%eax
4000799f:	83 ec 0c             	sub    $0xc,%esp
400079a2:	50                   	push   %eax
400079a3:	e8 f7 bf ff ff       	call   4000399f <get_typehandle>
400079a8:	83 c4 10             	add    $0x10,%esp
400079ab:	89 45 f8             	mov    %eax,-0x8(%ebp)
400079ae:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
400079b2:	74 1b                	je     400079cf <lostio_close+0xa6>
400079b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
400079b7:	8b 40 1c             	mov    0x1c(%eax),%eax
400079ba:	85 c0                	test   %eax,%eax
400079bc:	74 11                	je     400079cf <lostio_close+0xa6>
400079be:	8b 45 f8             	mov    -0x8(%ebp),%eax
400079c1:	8b 40 1c             	mov    0x1c(%eax),%eax
400079c4:	83 ec 0c             	sub    $0xc,%esp
400079c7:	ff 75 f4             	pushl  -0xc(%ebp)
400079ca:	ff d0                	call   *%eax
400079cc:	83 c4 10             	add    $0x10,%esp
400079cf:	83 ec 0c             	sub    $0xc,%esp
400079d2:	ff 75 f4             	pushl  -0xc(%ebp)
400079d5:	e8 d5 0f 00 00       	call   400089af <free>
400079da:	83 c4 10             	add    $0x10,%esp
400079dd:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
400079e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
400079e7:	c9                   	leave  
400079e8:	c3                   	ret    
400079e9:	90                   	nop    
400079ea:	90                   	nop    
400079eb:	90                   	nop    

400079ec <strnlen>:
 */

#include <stdio.h>
#include <stdlib.h>

#include "cdi.h"
400079ec:	55                   	push   %ebp
400079ed:	89 e5                	mov    %esp,%ebp
400079ef:	83 ec 10             	sub    $0x10,%esp
#include "cdi/storage.h"
400079f2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
#include "cdi/misc.h"
#include "cdi/io.h"
400079f9:	eb 03                	jmp    400079fe <strnlen+0x12>

400079fb:	ff 45 fc             	incl   -0x4(%ebp)
#include <stdlib.h>

#include "cdi.h"
#include "cdi/storage.h"
#include "cdi/misc.h"
#include "cdi/io.h"
400079fe:	8b 45 08             	mov    0x8(%ebp),%eax
40007a01:	8a 00                	mov    (%eax),%al
40007a03:	84 c0                	test   %al,%al
40007a05:	0f 95 c0             	setne  %al
40007a08:	ff 45 08             	incl   0x8(%ebp)
40007a0b:	83 f0 01             	xor    $0x1,%eax
40007a0e:	84 c0                	test   %al,%al
40007a10:	75 09                	jne    40007a1b <strnlen+0x2f>
40007a12:	ff 4d 0c             	decl   0xc(%ebp)
40007a15:	83 7d 0c ff          	cmpl   $0xffffffff,0xc(%ebp)
40007a19:	75 e0                	jne    400079fb <strnlen+0xf>

#include "device.h"


40007a1b:	8b 45 fc             	mov    -0x4(%ebp),%eax
/**
40007a1e:	c9                   	leave  
40007a1f:	c3                   	ret    

40007a20 <itoa>:
 * ATA-Geraet identifizieren
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
 */
40007a20:	55                   	push   %ebp
40007a21:	89 e5                	mov    %esp,%ebp
40007a23:	83 ec 30             	sub    $0x30,%esp
int ata_drv_identify(struct ata_device* dev)
{
40007a26:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    uint8_t buffer[ATA_SECTOR_SIZE];

    // Request vorbereiten
    struct ata_request request = {
40007a2d:	8b 45 08             	mov    0x8(%ebp),%eax
40007a30:	ba 00 00 00 00       	mov    $0x0,%edx
40007a35:	f7 75 10             	divl   0x10(%ebp)
40007a38:	89 55 fc             	mov    %edx,-0x4(%ebp)
        .dev = dev,
40007a3b:	83 7d fc 09          	cmpl   $0x9,-0x4(%ebp)
40007a3f:	77 12                	ja     40007a53 <itoa+0x33>
40007a41:	8b 55 f4             	mov    -0xc(%ebp),%edx
40007a44:	8b 45 fc             	mov    -0x4(%ebp),%eax
40007a47:	83 c0 30             	add    $0x30,%eax
40007a4a:	88 44 15 d3          	mov    %al,-0x2d(%ebp,%edx,1)
40007a4e:	ff 45 f4             	incl   -0xc(%ebp)
40007a51:	eb 10                	jmp    40007a63 <itoa+0x43>

40007a53:	8b 55 f4             	mov    -0xc(%ebp),%edx
40007a56:	8b 45 fc             	mov    -0x4(%ebp),%eax
40007a59:	83 c0 37             	add    $0x37,%eax
40007a5c:	88 44 15 d3          	mov    %al,-0x2d(%ebp,%edx,1)
40007a60:	ff 45 f4             	incl   -0xc(%ebp)
        .flags.direction = READ,
40007a63:	8b 45 08             	mov    0x8(%ebp),%eax
40007a66:	ba 00 00 00 00       	mov    $0x0,%edx
40007a6b:	f7 75 10             	divl   0x10(%ebp)
40007a6e:	89 45 08             	mov    %eax,0x8(%ebp)
40007a71:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
40007a75:	75 b6                	jne    40007a2d <itoa+0xd>
        .flags.poll = 1,
40007a77:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007a7a:	c6 44 05 d3 00       	movb   $0x0,-0x2d(%ebp,%eax,1)
        .flags.lba = 0,

40007a7f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
40007a86:	eb 18                	jmp    40007aa0 <itoa+0x80>
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
40007a88:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007a8b:	89 c2                	mov    %eax,%edx
40007a8d:	03 55 0c             	add    0xc(%ebp),%edx
40007a90:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007a93:	48                   	dec    %eax
40007a94:	8a 44 05 d3          	mov    -0x2d(%ebp,%eax,1),%al
40007a98:	88 02                	mov    %al,(%edx)
        .block_count = 1,
40007a9a:	ff 45 f8             	incl   -0x8(%ebp)

        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
40007a9d:	ff 4d f4             	decl   -0xc(%ebp)
40007aa0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
40007aa4:	75 e2                	jne    40007a88 <itoa+0x68>
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,
40007aa6:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007aa9:	03 45 0c             	add    0xc(%ebp),%eax
40007aac:	c6 00 00             	movb   $0x0,(%eax)

40007aaf:	c9                   	leave  
40007ab0:	c3                   	ret    

40007ab1 <atoi>:
        .error = 0
    };
40007ab1:	55                   	push   %ebp
40007ab2:	89 e5                	mov    %esp,%ebp
40007ab4:	83 ec 14             	sub    $0x14,%esp
    
40007ab7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    // Request starten
40007abe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
40007ac5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40007acc:	eb 3d                	jmp    40007b0b <atoi+0x5a>
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
40007ace:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007ad1:	03 45 08             	add    0x8(%ebp),%eax
40007ad4:	8a 00                	mov    (%eax),%al
40007ad6:	3c 2f                	cmp    $0x2f,%al
40007ad8:	7e 3d                	jle    40007b17 <atoi+0x66>
40007ada:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007add:	03 45 08             	add    0x8(%ebp),%eax
40007ae0:	8a 00                	mov    (%eax),%al
40007ae2:	3c 39                	cmp    $0x39,%al
40007ae4:	7f 31                	jg     40007b17 <atoi+0x66>
    }
        
40007ae6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
40007aea:	75 09                	jne    40007af5 <atoi+0x44>
40007aec:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
40007af3:	eb 10                	jmp    40007b05 <atoi+0x54>
    // Ein ATA-Geraet
40007af5:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007af8:	89 c2                	mov    %eax,%edx
40007afa:	c1 e2 02             	shl    $0x2,%edx
40007afd:	01 c2                	add    %eax,%edx
40007aff:	8d 04 12             	lea    (%edx,%edx,1),%eax
40007b02:	89 45 f4             	mov    %eax,-0xc(%ebp)
    dev->atapi = 0;
40007b05:	ff 45 f0             	incl   -0x10(%ebp)
        .error = 0
    };
    
    // Request starten
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
40007b08:	ff 45 f8             	incl   -0x8(%ebp)
40007b0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007b0e:	03 45 08             	add    0x8(%ebp),%eax
40007b11:	8a 00                	mov    (%eax),%al
40007b13:	84 c0                	test   %al,%al
40007b15:	75 b7                	jne    40007ace <atoi+0x1d>
    }
        
    // Ein ATA-Geraet
    dev->atapi = 0;

    // TODO: Informationen verarbeiten
40007b17:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

40007b1e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40007b25:	eb 2f                	jmp    40007b56 <atoi+0xa5>
    return 1;
}
40007b27:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007b2a:	03 45 08             	add    0x8(%ebp),%eax
40007b2d:	8a 00                	mov    (%eax),%al
40007b2f:	0f be c0             	movsbl %al,%eax
40007b32:	83 e8 30             	sub    $0x30,%eax
40007b35:	0f af 45 f4          	imul   -0xc(%ebp),%eax
40007b39:	01 45 fc             	add    %eax,-0x4(%ebp)

40007b3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
40007b3f:	c7 45 ec cd cc cc cc 	movl   $0xcccccccd,-0x14(%ebp)
40007b46:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007b49:	f7 e2                	mul    %edx
40007b4b:	89 d0                	mov    %edx,%eax
40007b4d:	c1 e8 03             	shr    $0x3,%eax
40007b50:	89 45 f4             	mov    %eax,-0xc(%ebp)
        
    // Ein ATA-Geraet
    dev->atapi = 0;

    // TODO: Informationen verarbeiten

40007b53:	ff 45 f8             	incl   -0x8(%ebp)
40007b56:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007b59:	3b 45 f0             	cmp    -0x10(%ebp),%eax
40007b5c:	72 c9                	jb     40007b27 <atoi+0x76>
    return 1;
}

/**
 * Sektoren von einem ATA-Geraet lesen
40007b5e:	8b 45 fc             	mov    -0x4(%ebp),%eax
 *
40007b61:	c9                   	leave  
40007b62:	c3                   	ret    

40007b63 <atol>:
 * @param start LBA des Startsektors
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
40007b63:	55                   	push   %ebp
40007b64:	89 e5                	mov    %esp,%ebp
40007b66:	83 ec 14             	sub    $0x14,%esp
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
40007b69:	8b 45 08             	mov    0x8(%ebp),%eax
40007b6c:	8a 00                	mov    (%eax),%al
40007b6e:	84 c0                	test   %al,%al
40007b70:	75 0c                	jne    40007b7e <atol+0x1b>
 */
40007b72:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007b79:	e9 9d 00 00 00       	jmp    40007c1b <atol+0xb8>
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
40007b7e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
{
    int result = 1;
40007b85:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    struct ata_request request;
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
40007b8c:	8b 45 08             	mov    0x8(%ebp),%eax
40007b8f:	8a 00                	mov    (%eax),%al
40007b91:	3c 2d                	cmp    $0x2d,%al
40007b93:	75 0c                	jne    40007ba1 <atol+0x3e>
    // muss unter Umstaenden mehrmals gelesen werden.
40007b95:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    uint16_t current_count;
40007b9c:	ff 45 08             	incl   0x8(%ebp)
40007b9f:	eb 5c                	jmp    40007bfd <atol+0x9a>
    void* current_buffer = buffer;
40007ba1:	8b 45 08             	mov    0x8(%ebp),%eax
40007ba4:	8a 00                	mov    (%eax),%al
40007ba6:	3c 2b                	cmp    $0x2b,%al
40007ba8:	75 53                	jne    40007bfd <atol+0x9a>
    uint64_t lba = start;
40007baa:	ff 45 08             	incl   0x8(%ebp)

    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;
40007bad:	eb 4e                	jmp    40007bfd <atol+0x9a>

    // Solange wie noch Sektoren uebrig sind, wird gelesen
40007baf:	8b 45 08             	mov    0x8(%ebp),%eax
40007bb2:	8a 00                	mov    (%eax),%al
40007bb4:	88 45 ff             	mov    %al,-0x1(%ebp)
    while (count_left > 0) {
40007bb7:	80 7d ff 2f          	cmpb   $0x2f,-0x1(%ebp)
40007bbb:	7e 29                	jle    40007be6 <atol+0x83>
40007bbd:	80 7d ff 39          	cmpb   $0x39,-0x1(%ebp)
40007bc1:	7f 23                	jg     40007be6 <atol+0x83>
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
40007bc3:	ff 45 f8             	incl   -0x8(%ebp)
        if (count_left > 256) {
            current_count = 256;
40007bc6:	8b 55 f4             	mov    -0xc(%ebp),%edx
40007bc9:	89 d0                	mov    %edx,%eax
40007bcb:	c1 e0 02             	shl    $0x2,%eax
40007bce:	01 d0                	add    %edx,%eax
40007bd0:	d1 e0                	shl    %eax
40007bd2:	89 c2                	mov    %eax,%edx
40007bd4:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
40007bd8:	8d 04 02             	lea    (%edx,%eax,1),%eax
40007bdb:	83 e8 30             	sub    $0x30,%eax
40007bde:	89 45 f4             	mov    %eax,-0xc(%ebp)
            current_count = count_left;
        }
        
        // Request vorbereiten
        request.dev = dev;
        // TODO: DMA, UltraDMA...
40007be1:	ff 45 08             	incl   0x8(%ebp)
40007be4:	eb 17                	jmp    40007bfd <atol+0x9a>
    while (count_left > 0) {
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
        if (count_left > 256) {
            current_count = 256;
        } else {
            current_count = count_left;
40007be6:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40007bea:	75 09                	jne    40007bf5 <atol+0x92>
        }
40007bec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007bf3:	eb 26                	jmp    40007c1b <atol+0xb8>
        
        // Request vorbereiten
40007bf5:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007bf8:	89 45 ec             	mov    %eax,-0x14(%ebp)
40007bfb:	eb 1e                	jmp    40007c1b <atol+0xb8>
    uint16_t current_count;
    void* current_buffer = buffer;
    uint64_t lba = start;

    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;
40007bfd:	8b 45 08             	mov    0x8(%ebp),%eax
40007c00:	8a 00                	mov    (%eax),%al
40007c02:	84 c0                	test   %al,%al
40007c04:	75 a9                	jne    40007baf <atol+0x4c>
        // Request vorbereiten
        request.dev = dev;
        // TODO: DMA, UltraDMA...
        request.protocol = PIO;
        request.flags.direction = READ;
        // FIXME
40007c06:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40007c0a:	75 09                	jne    40007c15 <atol+0xb2>
        request.flags.poll = 1;
40007c0c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007c13:	eb 06                	jmp    40007c1b <atol+0xb8>
        request.flags.ata = 0;
        request.flags.lba = 1;
40007c15:	8b 45 f4             	mov    -0xc(%ebp),%eax
40007c18:	89 45 ec             	mov    %eax,-0x14(%ebp)
40007c1b:	8b 45 ec             	mov    -0x14(%ebp),%eax

40007c1e:	c9                   	leave  
40007c1f:	c3                   	ret    

40007c20 <list_create>:

    // Request vorbereiten
    struct ata_request request = {
        .dev = dev,

        .flags.direction = READ,
40007c20:	55                   	push   %ebp
40007c21:	89 e5                	mov    %esp,%ebp
40007c23:	83 ec 18             	sub    $0x18,%esp
        .flags.poll = 1,
40007c26:	83 ec 0c             	sub    $0xc,%esp
40007c29:	6a 08                	push   $0x8
40007c2b:	e8 a8 06 00 00       	call   400082d8 <malloc>
40007c30:	83 c4 10             	add    $0x10,%esp
40007c33:	89 45 fc             	mov    %eax,-0x4(%ebp)
        .flags.lba = 0,
40007c36:	8b 45 fc             	mov    -0x4(%ebp),%eax
40007c39:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

40007c3f:	8b 45 fc             	mov    -0x4(%ebp),%eax
40007c42:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
40007c49:	8b 45 fc             	mov    -0x4(%ebp),%eax
        .registers.ata.command = IDENTIFY_DEVICE,
40007c4c:	c9                   	leave  
40007c4d:	c3                   	ret    

40007c4e <list_destroy>:
        .block_count = 1,
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

        .error = 0
    };
40007c4e:	55                   	push   %ebp
40007c4f:	89 e5                	mov    %esp,%ebp
40007c51:	83 ec 08             	sub    $0x8,%esp
    
    // Request starten
40007c54:	83 ec 0c             	sub    $0xc,%esp
40007c57:	ff 75 08             	pushl  0x8(%ebp)
40007c5a:	e8 dc 00 00 00       	call   40007d3b <list_pop>
40007c5f:	83 c4 10             	add    $0x10,%esp
40007c62:	85 c0                	test   %eax,%eax
40007c64:	75 ee                	jne    40007c54 <list_destroy+0x6>
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
        // IDENTIFY PACKET DEVICE probieren.
40007c66:	83 ec 0c             	sub    $0xc,%esp
40007c69:	ff 75 08             	pushl  0x8(%ebp)
40007c6c:	e8 3e 0d 00 00       	call   400089af <free>
40007c71:	83 c4 10             	add    $0x10,%esp
        return atapi_drv_identify(dev);
40007c74:	c9                   	leave  
40007c75:	c3                   	ret    

40007c76 <list_is_empty>:
    }
        
    // Ein ATA-Geraet
    dev->atapi = 0;

    // TODO: Informationen verarbeiten
40007c76:	55                   	push   %ebp
40007c77:	89 e5                	mov    %esp,%ebp
40007c79:	83 ec 04             	sub    $0x4,%esp

40007c7c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
40007c80:	74 09                	je     40007c8b <list_is_empty+0x15>
40007c82:	8b 45 08             	mov    0x8(%ebp),%eax
40007c85:	8b 00                	mov    (%eax),%eax
40007c87:	85 c0                	test   %eax,%eax
40007c89:	75 09                	jne    40007c94 <list_is_empty+0x1e>
40007c8b:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
40007c92:	eb 07                	jmp    40007c9b <list_is_empty+0x25>
40007c94:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40007c9b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    return 1;
40007c9e:	c9                   	leave  
40007c9f:	c3                   	ret    

40007ca0 <list_size>:
}

/**
 * Sektoren von einem ATA-Geraet lesen
 *
 * @param start LBA des Startsektors
40007ca0:	55                   	push   %ebp
40007ca1:	89 e5                	mov    %esp,%ebp
40007ca3:	83 ec 04             	sub    $0x4,%esp
 * @param count Anzahl der Sektoren
40007ca6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
40007caa:	74 09                	je     40007cb5 <list_size+0x15>
40007cac:	8b 45 08             	mov    0x8(%ebp),%eax
40007caf:	8b 00                	mov    (%eax),%eax
40007cb1:	85 c0                	test   %eax,%eax
40007cb3:	75 09                	jne    40007cbe <list_size+0x1e>
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
40007cb5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40007cbc:	eb 09                	jmp    40007cc7 <list_size+0x27>
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
40007cbe:	8b 45 08             	mov    0x8(%ebp),%eax
40007cc1:	8b 40 04             	mov    0x4(%eax),%eax
40007cc4:	89 45 fc             	mov    %eax,-0x4(%ebp)
40007cc7:	8b 45 fc             	mov    -0x4(%ebp),%eax
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
40007cca:	c9                   	leave  
40007ccb:	c3                   	ret    

40007ccc <list_push>:
    uint16_t current_count;
    void* current_buffer = buffer;
    uint64_t lba = start;

    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;
40007ccc:	55                   	push   %ebp
40007ccd:	89 e5                	mov    %esp,%ebp
40007ccf:	83 ec 18             	sub    $0x18,%esp

40007cd2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
40007cd6:	75 09                	jne    40007ce1 <list_push+0x15>
    // Solange wie noch Sektoren uebrig sind, wird gelesen
40007cd8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007cdf:	eb 55                	jmp    40007d36 <list_push+0x6a>
    while (count_left > 0) {
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
        if (count_left > 256) {
40007ce1:	83 ec 0c             	sub    $0xc,%esp
40007ce4:	6a 08                	push   $0x8
40007ce6:	e8 ed 05 00 00       	call   400082d8 <malloc>
40007ceb:	83 c4 10             	add    $0x10,%esp
40007cee:	89 45 fc             	mov    %eax,-0x4(%ebp)
            current_count = 256;
40007cf1:	8b 55 fc             	mov    -0x4(%ebp),%edx
40007cf4:	8b 45 0c             	mov    0xc(%ebp),%eax
40007cf7:	89 42 04             	mov    %eax,0x4(%edx)
        } else {
40007cfa:	8b 45 08             	mov    0x8(%ebp),%eax
40007cfd:	8b 10                	mov    (%eax),%edx
40007cff:	8b 45 fc             	mov    -0x4(%ebp),%eax
40007d02:	89 10                	mov    %edx,(%eax)
            current_count = count_left;
40007d04:	8b 55 08             	mov    0x8(%ebp),%edx
40007d07:	8b 45 fc             	mov    -0x4(%ebp),%eax
40007d0a:	89 02                	mov    %eax,(%edx)
        }
40007d0c:	8b 45 08             	mov    0x8(%ebp),%eax
40007d0f:	8b 40 04             	mov    0x4(%eax),%eax
40007d12:	8d 50 01             	lea    0x1(%eax),%edx
40007d15:	8b 45 08             	mov    0x8(%ebp),%eax
40007d18:	89 50 04             	mov    %edx,0x4(%eax)
        
        // Request vorbereiten
40007d1b:	a1 10 a6 00 40       	mov    0x4000a610,%eax
40007d20:	3b 45 08             	cmp    0x8(%ebp),%eax
40007d23:	75 0b                	jne    40007d30 <list_push+0x64>
        request.dev = dev;
40007d25:	a1 14 a6 00 40       	mov    0x4000a614,%eax
40007d2a:	40                   	inc    %eax
40007d2b:	a3 14 a6 00 40       	mov    %eax,0x4000a614
        // TODO: DMA, UltraDMA...
        request.protocol = PIO;
        request.flags.direction = READ;
40007d30:	8b 45 08             	mov    0x8(%ebp),%eax
40007d33:	89 45 ec             	mov    %eax,-0x14(%ebp)
40007d36:	8b 45 ec             	mov    -0x14(%ebp),%eax
        // FIXME
40007d39:	c9                   	leave  
40007d3a:	c3                   	ret    

40007d3b <list_pop>:
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
        // 0 steht.
        request.registers.ata.count = (uint8_t) current_count;
        request.registers.ata.lba = lba;
40007d3b:	55                   	push   %ebp
40007d3c:	89 e5                	mov    %esp,%ebp
40007d3e:	83 ec 18             	sub    $0x18,%esp

        request.block_count = current_count;
        request.block_size = ATA_SECTOR_SIZE;
        request.blocks_done = 0;
40007d41:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
40007d45:	75 09                	jne    40007d50 <list_pop+0x15>
        request.buffer = current_buffer;
40007d47:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007d4e:	eb 7e                	jmp    40007dce <list_pop+0x93>

        request.error = NO_ERROR;
        
40007d50:	8b 45 08             	mov    0x8(%ebp),%eax
40007d53:	8b 00                	mov    (%eax),%eax
40007d55:	85 c0                	test   %eax,%eax
40007d57:	74 3e                	je     40007d97 <list_pop+0x5c>
        // TODO: LBA48
40007d59:	8b 45 08             	mov    0x8(%ebp),%eax
40007d5c:	8b 00                	mov    (%eax),%eax
40007d5e:	8b 40 04             	mov    0x4(%eax),%eax
40007d61:	89 45 fc             	mov    %eax,-0x4(%ebp)
        // TODO: CHS
        
40007d64:	8b 45 08             	mov    0x8(%ebp),%eax
40007d67:	8b 00                	mov    (%eax),%eax
40007d69:	89 45 f8             	mov    %eax,-0x8(%ebp)
        // Request ausfuehren
40007d6c:	8b 45 08             	mov    0x8(%ebp),%eax
40007d6f:	8b 00                	mov    (%eax),%eax
40007d71:	8b 10                	mov    (%eax),%edx
40007d73:	8b 45 08             	mov    0x8(%ebp),%eax
40007d76:	89 10                	mov    %edx,(%eax)
        if (!ata_request(&request)) {
40007d78:	83 ec 0c             	sub    $0xc,%esp
40007d7b:	ff 75 f8             	pushl  -0x8(%ebp)
40007d7e:	e8 2c 0c 00 00       	call   400089af <free>
40007d83:	83 c4 10             	add    $0x10,%esp
            result = 0;
            break;
40007d86:	8b 45 08             	mov    0x8(%ebp),%eax
40007d89:	8b 40 04             	mov    0x4(%eax),%eax
40007d8c:	8d 50 ff             	lea    -0x1(%eax),%edx
40007d8f:	8b 45 08             	mov    0x8(%ebp),%eax
40007d92:	89 50 04             	mov    %edx,0x4(%eax)
40007d95:	eb 07                	jmp    40007d9e <list_pop+0x63>
        }

40007d97:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
        current_buffer += current_count * ATA_SECTOR_SIZE;
        count_left -= current_count;
40007d9e:	a1 10 a6 00 40       	mov    0x4000a610,%eax
40007da3:	3b 45 08             	cmp    0x8(%ebp),%eax
40007da6:	75 20                	jne    40007dc8 <list_pop+0x8d>
        lba += current_count;
40007da8:	a1 14 a6 00 40       	mov    0x4000a614,%eax
40007dad:	85 c0                	test   %eax,%eax
40007daf:	75 0c                	jne    40007dbd <list_pop+0x82>
    }
40007db1:	c7 05 10 a6 00 40 00 	movl   $0x0,0x4000a610
40007db8:	00 00 00 
40007dbb:	eb 0b                	jmp    40007dc8 <list_pop+0x8d>

    return result;
40007dbd:	a1 14 a6 00 40       	mov    0x4000a614,%eax
40007dc2:	48                   	dec    %eax
40007dc3:	a3 14 a6 00 40       	mov    %eax,0x4000a614
}

40007dc8:	8b 45 fc             	mov    -0x4(%ebp),%eax
40007dcb:	89 45 ec             	mov    %eax,-0x14(%ebp)
40007dce:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007dd1:	c9                   	leave  
40007dd2:	c3                   	ret    

40007dd3 <list_get_node_at>:
40007dd3:	55                   	push   %ebp
40007dd4:	89 e5                	mov    %esp,%ebp
40007dd6:	83 ec 14             	sub    $0x14,%esp
40007dd9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
40007ddd:	74 0f                	je     40007dee <list_get_node_at+0x1b>
40007ddf:	8b 45 08             	mov    0x8(%ebp),%eax
40007de2:	8b 00                	mov    (%eax),%eax
40007de4:	85 c0                	test   %eax,%eax
40007de6:	74 06                	je     40007dee <list_get_node_at+0x1b>
40007de8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
40007dec:	79 0c                	jns    40007dfa <list_get_node_at+0x27>
40007dee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007df5:	e9 8e 00 00 00       	jmp    40007e88 <list_get_node_at+0xb5>
40007dfa:	c7 05 10 a6 00 40 00 	movl   $0x0,0x4000a610
40007e01:	00 00 00 
40007e04:	8b 45 08             	mov    0x8(%ebp),%eax
40007e07:	8b 00                	mov    (%eax),%eax
40007e09:	89 45 f8             	mov    %eax,-0x8(%ebp)
40007e0c:	8b 45 0c             	mov    0xc(%ebp),%eax
40007e0f:	89 45 fc             	mov    %eax,-0x4(%ebp)
40007e12:	a1 10 a6 00 40       	mov    0x4000a610,%eax
40007e17:	85 c0                	test   %eax,%eax
40007e19:	74 46                	je     40007e61 <list_get_node_at+0x8e>
40007e1b:	a1 10 a6 00 40       	mov    0x4000a610,%eax
40007e20:	3b 45 08             	cmp    0x8(%ebp),%eax
40007e23:	75 3c                	jne    40007e61 <list_get_node_at+0x8e>
40007e25:	a1 14 a6 00 40       	mov    0x4000a614,%eax
40007e2a:	3b 45 0c             	cmp    0xc(%ebp),%eax
40007e2d:	7f 32                	jg     40007e61 <list_get_node_at+0x8e>
40007e2f:	a1 18 a6 00 40       	mov    0x4000a618,%eax
40007e34:	85 c0                	test   %eax,%eax
40007e36:	74 29                	je     40007e61 <list_get_node_at+0x8e>
40007e38:	a1 14 a6 00 40       	mov    0x4000a614,%eax
40007e3d:	29 45 fc             	sub    %eax,-0x4(%ebp)
40007e40:	a1 18 a6 00 40       	mov    0x4000a618,%eax
40007e45:	89 45 f8             	mov    %eax,-0x8(%ebp)
40007e48:	eb 17                	jmp    40007e61 <list_get_node_at+0x8e>
40007e4a:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007e4d:	8b 00                	mov    (%eax),%eax
40007e4f:	89 45 f8             	mov    %eax,-0x8(%ebp)
40007e52:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40007e56:	75 09                	jne    40007e61 <list_get_node_at+0x8e>
40007e58:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007e5f:	eb 27                	jmp    40007e88 <list_get_node_at+0xb5>
40007e61:	ff 4d fc             	decl   -0x4(%ebp)
40007e64:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%ebp)
40007e68:	75 e0                	jne    40007e4a <list_get_node_at+0x77>
40007e6a:	8b 45 08             	mov    0x8(%ebp),%eax
40007e6d:	a3 10 a6 00 40       	mov    %eax,0x4000a610
40007e72:	8b 45 0c             	mov    0xc(%ebp),%eax
40007e75:	a3 14 a6 00 40       	mov    %eax,0x4000a614
40007e7a:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007e7d:	a3 18 a6 00 40       	mov    %eax,0x4000a618
40007e82:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007e85:	89 45 ec             	mov    %eax,-0x14(%ebp)
40007e88:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007e8b:	c9                   	leave  
40007e8c:	c3                   	ret    

40007e8d <list_get_element_at>:
40007e8d:	55                   	push   %ebp
40007e8e:	89 e5                	mov    %esp,%ebp
40007e90:	83 ec 14             	sub    $0x14,%esp
40007e93:	ff 75 0c             	pushl  0xc(%ebp)
40007e96:	ff 75 08             	pushl  0x8(%ebp)
40007e99:	e8 35 ff ff ff       	call   40007dd3 <list_get_node_at>
40007e9e:	83 c4 08             	add    $0x8,%esp
40007ea1:	89 45 fc             	mov    %eax,-0x4(%ebp)
40007ea4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40007ea8:	74 0b                	je     40007eb5 <list_get_element_at+0x28>
40007eaa:	8b 45 fc             	mov    -0x4(%ebp),%eax
40007ead:	8b 40 04             	mov    0x4(%eax),%eax
40007eb0:	89 45 ec             	mov    %eax,-0x14(%ebp)
40007eb3:	eb 07                	jmp    40007ebc <list_get_element_at+0x2f>
40007eb5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007ebc:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007ebf:	c9                   	leave  
40007ec0:	c3                   	ret    

40007ec1 <list_insert>:
40007ec1:	55                   	push   %ebp
40007ec2:	89 e5                	mov    %esp,%ebp
40007ec4:	83 ec 18             	sub    $0x18,%esp
40007ec7:	83 ec 0c             	sub    $0xc,%esp
40007eca:	6a 08                	push   $0x8
40007ecc:	e8 07 04 00 00       	call   400082d8 <malloc>
40007ed1:	83 c4 10             	add    $0x10,%esp
40007ed4:	89 45 f8             	mov    %eax,-0x8(%ebp)
40007ed7:	8b 55 f8             	mov    -0x8(%ebp),%edx
40007eda:	8b 45 10             	mov    0x10(%ebp),%eax
40007edd:	89 42 04             	mov    %eax,0x4(%edx)
40007ee0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
40007ee4:	75 0c                	jne    40007ef2 <list_insert+0x31>
40007ee6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007eed:	e9 82 00 00 00       	jmp    40007f74 <list_insert+0xb3>
40007ef2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
40007ef6:	74 36                	je     40007f2e <list_insert+0x6d>
40007ef8:	8b 45 0c             	mov    0xc(%ebp),%eax
40007efb:	48                   	dec    %eax
40007efc:	50                   	push   %eax
40007efd:	ff 75 08             	pushl  0x8(%ebp)
40007f00:	e8 ce fe ff ff       	call   40007dd3 <list_get_node_at>
40007f05:	83 c4 08             	add    $0x8,%esp
40007f08:	89 45 fc             	mov    %eax,-0x4(%ebp)
40007f0b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40007f0f:	75 09                	jne    40007f1a <list_insert+0x59>
40007f11:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007f18:	eb 5a                	jmp    40007f74 <list_insert+0xb3>
40007f1a:	8b 45 fc             	mov    -0x4(%ebp),%eax
40007f1d:	8b 10                	mov    (%eax),%edx
40007f1f:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007f22:	89 10                	mov    %edx,(%eax)
40007f24:	8b 55 fc             	mov    -0x4(%ebp),%edx
40007f27:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007f2a:	89 02                	mov    %eax,(%edx)
40007f2c:	eb 12                	jmp    40007f40 <list_insert+0x7f>
40007f2e:	8b 45 08             	mov    0x8(%ebp),%eax
40007f31:	8b 10                	mov    (%eax),%edx
40007f33:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007f36:	89 10                	mov    %edx,(%eax)
40007f38:	8b 55 08             	mov    0x8(%ebp),%edx
40007f3b:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007f3e:	89 02                	mov    %eax,(%edx)
40007f40:	8b 45 08             	mov    0x8(%ebp),%eax
40007f43:	8b 40 04             	mov    0x4(%eax),%eax
40007f46:	8d 50 01             	lea    0x1(%eax),%edx
40007f49:	8b 45 08             	mov    0x8(%ebp),%eax
40007f4c:	89 50 04             	mov    %edx,0x4(%eax)
40007f4f:	a1 10 a6 00 40       	mov    0x4000a610,%eax
40007f54:	3b 45 08             	cmp    0x8(%ebp),%eax
40007f57:	75 15                	jne    40007f6e <list_insert+0xad>
40007f59:	a1 14 a6 00 40       	mov    0x4000a614,%eax
40007f5e:	3b 45 0c             	cmp    0xc(%ebp),%eax
40007f61:	7c 0b                	jl     40007f6e <list_insert+0xad>
40007f63:	a1 14 a6 00 40       	mov    0x4000a614,%eax
40007f68:	40                   	inc    %eax
40007f69:	a3 14 a6 00 40       	mov    %eax,0x4000a614
40007f6e:	8b 45 08             	mov    0x8(%ebp),%eax
40007f71:	89 45 ec             	mov    %eax,-0x14(%ebp)
40007f74:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007f77:	c9                   	leave  
40007f78:	c3                   	ret    

40007f79 <list_remove>:
40007f79:	55                   	push   %ebp
40007f7a:	89 e5                	mov    %esp,%ebp
40007f7c:	83 ec 18             	sub    $0x18,%esp
40007f7f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
40007f83:	75 0c                	jne    40007f91 <list_remove+0x18>
40007f85:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007f8c:	e9 e4 00 00 00       	jmp    40008075 <list_remove+0xfc>
40007f91:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
40007f95:	74 59                	je     40007ff0 <list_remove+0x77>
40007f97:	8b 45 0c             	mov    0xc(%ebp),%eax
40007f9a:	48                   	dec    %eax
40007f9b:	50                   	push   %eax
40007f9c:	ff 75 08             	pushl  0x8(%ebp)
40007f9f:	e8 2f fe ff ff       	call   40007dd3 <list_get_node_at>
40007fa4:	83 c4 08             	add    $0x8,%esp
40007fa7:	89 45 fc             	mov    %eax,-0x4(%ebp)
40007faa:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40007fae:	74 09                	je     40007fb9 <list_remove+0x40>
40007fb0:	8b 45 fc             	mov    -0x4(%ebp),%eax
40007fb3:	8b 00                	mov    (%eax),%eax
40007fb5:	85 c0                	test   %eax,%eax
40007fb7:	75 0c                	jne    40007fc5 <list_remove+0x4c>
40007fb9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007fc0:	e9 b0 00 00 00       	jmp    40008075 <list_remove+0xfc>
40007fc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
40007fc8:	8b 00                	mov    (%eax),%eax
40007fca:	89 45 f8             	mov    %eax,-0x8(%ebp)
40007fcd:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007fd0:	8b 10                	mov    (%eax),%edx
40007fd2:	8b 45 fc             	mov    -0x4(%ebp),%eax
40007fd5:	89 10                	mov    %edx,(%eax)
40007fd7:	8b 45 f8             	mov    -0x8(%ebp),%eax
40007fda:	8b 40 04             	mov    0x4(%eax),%eax
40007fdd:	89 45 f4             	mov    %eax,-0xc(%ebp)
40007fe0:	83 ec 0c             	sub    $0xc,%esp
40007fe3:	ff 75 f8             	pushl  -0x8(%ebp)
40007fe6:	e8 c4 09 00 00       	call   400089af <free>
40007feb:	83 c4 10             	add    $0x10,%esp
40007fee:	eb 3b                	jmp    4000802b <list_remove+0xb2>
40007ff0:	8b 45 08             	mov    0x8(%ebp),%eax
40007ff3:	8b 00                	mov    (%eax),%eax
40007ff5:	85 c0                	test   %eax,%eax
40007ff7:	75 09                	jne    40008002 <list_remove+0x89>
40007ff9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40008000:	eb 73                	jmp    40008075 <list_remove+0xfc>
40008002:	8b 45 08             	mov    0x8(%ebp),%eax
40008005:	8b 00                	mov    (%eax),%eax
40008007:	89 45 f8             	mov    %eax,-0x8(%ebp)
4000800a:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000800d:	8b 10                	mov    (%eax),%edx
4000800f:	8b 45 08             	mov    0x8(%ebp),%eax
40008012:	89 10                	mov    %edx,(%eax)
40008014:	8b 45 f8             	mov    -0x8(%ebp),%eax
40008017:	8b 40 04             	mov    0x4(%eax),%eax
4000801a:	89 45 f4             	mov    %eax,-0xc(%ebp)
4000801d:	83 ec 0c             	sub    $0xc,%esp
40008020:	ff 75 f8             	pushl  -0x8(%ebp)
40008023:	e8 87 09 00 00       	call   400089af <free>
40008028:	83 c4 10             	add    $0x10,%esp
4000802b:	8b 45 08             	mov    0x8(%ebp),%eax
4000802e:	8b 40 04             	mov    0x4(%eax),%eax
40008031:	8d 50 ff             	lea    -0x1(%eax),%edx
40008034:	8b 45 08             	mov    0x8(%ebp),%eax
40008037:	89 50 04             	mov    %edx,0x4(%eax)
4000803a:	a1 10 a6 00 40       	mov    0x4000a610,%eax
4000803f:	3b 45 08             	cmp    0x8(%ebp),%eax
40008042:	75 2b                	jne    4000806f <list_remove+0xf6>
40008044:	a1 14 a6 00 40       	mov    0x4000a614,%eax
40008049:	3b 45 0c             	cmp    0xc(%ebp),%eax
4000804c:	7e 0d                	jle    4000805b <list_remove+0xe2>
4000804e:	a1 14 a6 00 40       	mov    0x4000a614,%eax
40008053:	48                   	dec    %eax
40008054:	a3 14 a6 00 40       	mov    %eax,0x4000a614
40008059:	eb 14                	jmp    4000806f <list_remove+0xf6>
4000805b:	a1 14 a6 00 40       	mov    0x4000a614,%eax
40008060:	3b 45 0c             	cmp    0xc(%ebp),%eax
40008063:	75 0a                	jne    4000806f <list_remove+0xf6>
40008065:	c7 05 10 a6 00 40 00 	movl   $0x0,0x4000a610
4000806c:	00 00 00 
4000806f:	8b 45 f4             	mov    -0xc(%ebp),%eax
40008072:	89 45 ec             	mov    %eax,-0x14(%ebp)
40008075:	8b 45 ec             	mov    -0x14(%ebp),%eax
40008078:	c9                   	leave  
40008079:	c3                   	ret    
4000807a:	90                   	nop    
4000807b:	90                   	nop    

4000807c <liballoc_lock>:
    size_t count_left = count;

    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
        if (count_left > 256) {
4000807c:	55                   	push   %ebp
4000807d:	89 e5                	mov    %esp,%ebp
4000807f:	83 ec 08             	sub    $0x8,%esp
            current_count = 256;
        } else {
40008082:	e8 11 b1 ff ff       	call   40003198 <p>
            current_count = count_left;
40008087:	b8 00 00 00 00       	mov    $0x0,%eax
        }
4000808c:	c9                   	leave  
4000808d:	c3                   	ret    

4000808e <liballoc_unlock>:
        
        // Request vorbereiten
        request.dev = dev;
4000808e:	55                   	push   %ebp
4000808f:	89 e5                	mov    %esp,%ebp
40008091:	83 ec 08             	sub    $0x8,%esp
        // TODO: DMA, UltraDMA...
        request.protocol = PIO;
40008094:	e8 0b b1 ff ff       	call   400031a4 <v>
        request.flags.direction = READ;
40008099:	b8 00 00 00 00       	mov    $0x0,%eax
        // FIXME
4000809e:	c9                   	leave  
4000809f:	c3                   	ret    

400080a0 <liballoc_alloc>:
        request.flags.poll = 1;
        request.flags.ata = 0;
        request.flags.lba = 1;

        request.registers.ata.command = READ_SECTORS;
400080a0:	55                   	push   %ebp
400080a1:	89 e5                	mov    %esp,%ebp
400080a3:	83 ec 18             	sub    $0x18,%esp
        // Achtung: Beim casten nach uint8_t wird bei 256 Sektoren eine 0.
400080a6:	8b 45 08             	mov    0x8(%ebp),%eax
400080a9:	c1 e0 0c             	shl    $0xc,%eax
400080ac:	83 ec 08             	sub    $0x8,%esp
400080af:	6a 00                	push   $0x0
400080b1:	50                   	push   %eax
400080b2:	e8 f4 ac ff ff       	call   40002dab <mem_allocate>
400080b7:	83 c4 10             	add    $0x10,%esp
400080ba:	89 45 fc             	mov    %eax,-0x4(%ebp)
        // Das macht aber nichts, da in der Spezifikation festgelegt ist,
        // dass 256 Sektoren gelesen werden sollen, wenn im count-Register
        // 0 steht.
        request.registers.ata.count = (uint8_t) current_count;
        request.registers.ata.lba = lba;
400080bd:	8b 45 08             	mov    0x8(%ebp),%eax
400080c0:	c1 e0 0a             	shl    $0xa,%eax
400080c3:	83 ec 04             	sub    $0x4,%esp
400080c6:	50                   	push   %eax
400080c7:	68 ef be ad de       	push   $0xdeadbeef
400080cc:	ff 75 fc             	pushl  -0x4(%ebp)
400080cf:	e8 56 00 00 00       	call   4000812a <liballoc_fill_dword>
400080d4:	83 c4 10             	add    $0x10,%esp

        request.block_count = current_count;
        request.block_size = ATA_SECTOR_SIZE;
400080d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
        request.blocks_done = 0;
400080da:	c9                   	leave  
400080db:	c3                   	ret    

400080dc <liballoc_free>:
        request.buffer = current_buffer;

        request.error = NO_ERROR;
400080dc:	55                   	push   %ebp
400080dd:	89 e5                	mov    %esp,%ebp
400080df:	83 ec 08             	sub    $0x8,%esp
        
400080e2:	8b 45 0c             	mov    0xc(%ebp),%eax
400080e5:	c1 e0 0c             	shl    $0xc,%eax
400080e8:	83 ec 08             	sub    $0x8,%esp
400080eb:	50                   	push   %eax
400080ec:	ff 75 08             	pushl  0x8(%ebp)
400080ef:	e8 f8 ac ff ff       	call   40002dec <mem_free>
400080f4:	83 c4 10             	add    $0x10,%esp
        // TODO: LBA48
400080f7:	c9                   	leave  
400080f8:	c3                   	ret    

400080f9 <init_memory_manager>:
        // TODO: CHS
        
        // Request ausfuehren
400080f9:	55                   	push   %ebp
400080fa:	89 e5                	mov    %esp,%ebp
        if (!ata_request(&request)) {
            result = 0;
400080fc:	c9                   	leave  
400080fd:	c3                   	ret    

400080fe <liballoc_memset>:
            break;
        }

        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
        current_buffer += current_count * ATA_SECTOR_SIZE;
        count_left -= current_count;
400080fe:	55                   	push   %ebp
400080ff:	89 e5                	mov    %esp,%ebp
40008101:	83 ec 10             	sub    $0x10,%esp
        lba += current_count;
    }
40008104:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
4000810b:	eb 10                	jmp    4000811d <liballoc_memset+0x1f>

4000810d:	8b 55 08             	mov    0x8(%ebp),%edx
40008110:	8b 45 fc             	mov    -0x4(%ebp),%eax
40008113:	01 c2                	add    %eax,%edx
40008115:	8b 45 0c             	mov    0xc(%ebp),%eax
40008118:	88 02                	mov    %al,(%edx)

        // Pufferpointer und Anzahl der uebrigen Blocks anpassen
        current_buffer += current_count * ATA_SECTOR_SIZE;
        count_left -= current_count;
        lba += current_count;
    }
4000811a:	ff 45 fc             	incl   -0x4(%ebp)
4000811d:	8b 45 fc             	mov    -0x4(%ebp),%eax
40008120:	3b 45 10             	cmp    0x10(%ebp),%eax
40008123:	72 e8                	jb     4000810d <liballoc_memset+0xf>

    return result;
}
40008125:	8b 45 08             	mov    0x8(%ebp),%eax

40008128:	c9                   	leave  
40008129:	c3                   	ret    

4000812a <liballoc_fill_dword>:
4000812a:	55                   	push   %ebp
4000812b:	89 e5                	mov    %esp,%ebp
4000812d:	83 ec 10             	sub    $0x10,%esp
40008130:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40008137:	eb 15                	jmp    4000814e <liballoc_fill_dword+0x24>
40008139:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000813c:	c1 e0 02             	shl    $0x2,%eax
4000813f:	89 c2                	mov    %eax,%edx
40008141:	8b 45 08             	mov    0x8(%ebp),%eax
40008144:	01 c2                	add    %eax,%edx
40008146:	8b 45 0c             	mov    0xc(%ebp),%eax
40008149:	89 02                	mov    %eax,(%edx)

4000814b:	ff 45 fc             	incl   -0x4(%ebp)
4000814e:	8b 45 fc             	mov    -0x4(%ebp),%eax
40008151:	3b 45 10             	cmp    0x10(%ebp),%eax
40008154:	72 e3                	jb     40008139 <liballoc_fill_dword+0xf>
40008156:	8b 45 08             	mov    0x8(%ebp),%eax
40008159:	c9                   	leave  
4000815a:	c3                   	ret    

4000815b <liballoc_memcpy>:
4000815b:	55                   	push   %ebp
4000815c:	89 e5                	mov    %esp,%ebp
4000815e:	83 ec 10             	sub    $0x10,%esp
40008161:	8b 45 08             	mov    0x8(%ebp),%eax
40008164:	89 45 f8             	mov    %eax,-0x8(%ebp)
40008167:	8b 45 0c             	mov    0xc(%ebp),%eax
4000816a:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000816d:	eb 16                	jmp    40008185 <liballoc_memcpy+0x2a>
4000816f:	8b 45 fc             	mov    -0x4(%ebp),%eax
40008172:	8b 10                	mov    (%eax),%edx
40008174:	8b 45 f8             	mov    -0x8(%ebp),%eax
40008177:	89 10                	mov    %edx,(%eax)
40008179:	83 45 f8 04          	addl   $0x4,-0x8(%ebp)
4000817d:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
40008181:	83 6d 10 04          	subl   $0x4,0x10(%ebp)
40008185:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
40008189:	77 e4                	ja     4000816f <liballoc_memcpy+0x14>
4000818b:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000818e:	89 45 f0             	mov    %eax,-0x10(%ebp)
40008191:	8b 45 fc             	mov    -0x4(%ebp),%eax
40008194:	89 45 f4             	mov    %eax,-0xc(%ebp)
40008197:	eb 13                	jmp    400081ac <liballoc_memcpy+0x51>
40008199:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000819c:	8a 10                	mov    (%eax),%dl
4000819e:	8b 45 f0             	mov    -0x10(%ebp),%eax
400081a1:	88 10                	mov    %dl,(%eax)
400081a3:	ff 45 f0             	incl   -0x10(%ebp)
400081a6:	ff 45 f4             	incl   -0xc(%ebp)
400081a9:	ff 4d 10             	decl   0x10(%ebp)
400081ac:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
400081b0:	75 e7                	jne    40008199 <liballoc_memcpy+0x3e>
400081b2:	8b 45 08             	mov    0x8(%ebp),%eax
400081b5:	c9                   	leave  
400081b6:	c3                   	ret    

400081b7 <allocate_new_page>:
400081b7:	55                   	push   %ebp
400081b8:	89 e5                	mov    %esp,%ebp
400081ba:	53                   	push   %ebx
400081bb:	83 ec 14             	sub    $0x14,%esp
400081be:	8b 45 08             	mov    0x8(%ebp),%eax
400081c1:	83 c0 18             	add    $0x18,%eax
400081c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
400081c7:	83 45 f4 18          	addl   $0x18,-0xc(%ebp)
400081cb:	a1 54 a0 00 40       	mov    0x4000a054,%eax
400081d0:	89 c2                	mov    %eax,%edx
400081d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
400081d5:	89 d1                	mov    %edx,%ecx
400081d7:	ba 00 00 00 00       	mov    $0x0,%edx
400081dc:	f7 f1                	div    %ecx
400081de:	89 d0                	mov    %edx,%eax
400081e0:	85 c0                	test   %eax,%eax
400081e2:	75 18                	jne    400081fc <allocate_new_page+0x45>
400081e4:	a1 54 a0 00 40       	mov    0x4000a054,%eax
400081e9:	89 c2                	mov    %eax,%edx
400081eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
400081ee:	89 d1                	mov    %edx,%ecx
400081f0:	ba 00 00 00 00       	mov    $0x0,%edx
400081f5:	f7 f1                	div    %ecx
400081f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
400081fa:	eb 17                	jmp    40008213 <allocate_new_page+0x5c>
400081fc:	a1 54 a0 00 40       	mov    0x4000a054,%eax
40008201:	89 c2                	mov    %eax,%edx
40008203:	8b 45 f4             	mov    -0xc(%ebp),%eax
40008206:	89 d1                	mov    %edx,%ecx
40008208:	ba 00 00 00 00       	mov    $0x0,%edx
4000820d:	f7 f1                	div    %ecx
4000820f:	40                   	inc    %eax
40008210:	89 45 f4             	mov    %eax,-0xc(%ebp)
40008213:	a1 58 a0 00 40       	mov    0x4000a058,%eax
40008218:	3b 45 f4             	cmp    -0xc(%ebp),%eax
4000821b:	76 08                	jbe    40008225 <allocate_new_page+0x6e>
4000821d:	a1 58 a0 00 40       	mov    0x4000a058,%eax
40008222:	89 45 f4             	mov    %eax,-0xc(%ebp)
40008225:	8b 45 f4             	mov    -0xc(%ebp),%eax
40008228:	83 ec 0c             	sub    $0xc,%esp
4000822b:	50                   	push   %eax
4000822c:	e8 6f fe ff ff       	call   400080a0 <liballoc_alloc>
40008231:	83 c4 10             	add    $0x10,%esp
40008234:	89 45 f8             	mov    %eax,-0x8(%ebp)
40008237:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
4000823b:	75 25                	jne    40008262 <allocate_new_page+0xab>
4000823d:	a1 38 a6 00 40       	mov    0x4000a638,%eax
40008242:	8b 15 3c a6 00 40    	mov    0x4000a63c,%edx
40008248:	83 c0 01             	add    $0x1,%eax
4000824b:	83 d2 00             	adc    $0x0,%edx
4000824e:	a3 38 a6 00 40       	mov    %eax,0x4000a638
40008253:	89 15 3c a6 00 40    	mov    %edx,0x4000a63c
40008259:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40008260:	eb 6e                	jmp    400082d0 <allocate_new_page+0x119>
40008262:	8b 45 f8             	mov    -0x8(%ebp),%eax
40008265:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
4000826b:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000826e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
40008275:	8b 55 f8             	mov    -0x8(%ebp),%edx
40008278:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000827b:	89 42 08             	mov    %eax,0x8(%edx)
4000827e:	a1 54 a0 00 40       	mov    0x4000a054,%eax
40008283:	89 c2                	mov    %eax,%edx
40008285:	0f af 55 f4          	imul   -0xc(%ebp),%edx
40008289:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000828c:	89 50 0c             	mov    %edx,0xc(%eax)
4000828f:	8b 45 f8             	mov    -0x8(%ebp),%eax
40008292:	c7 40 10 18 00 00 00 	movl   $0x18,0x10(%eax)
40008299:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000829c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
400082a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
400082a6:	8b 40 0c             	mov    0xc(%eax),%eax
400082a9:	89 c1                	mov    %eax,%ecx
400082ab:	bb 00 00 00 00       	mov    $0x0,%ebx
400082b0:	a1 28 a6 00 40       	mov    0x4000a628,%eax
400082b5:	8b 15 2c a6 00 40    	mov    0x4000a62c,%edx
400082bb:	01 c8                	add    %ecx,%eax
400082bd:	11 da                	adc    %ebx,%edx
400082bf:	a3 28 a6 00 40       	mov    %eax,0x4000a628
400082c4:	89 15 2c a6 00 40    	mov    %edx,0x4000a62c
400082ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
400082cd:	89 45 e8             	mov    %eax,-0x18(%ebp)
400082d0:	8b 45 e8             	mov    -0x18(%ebp),%eax
400082d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400082d6:	c9                   	leave  
400082d7:	c3                   	ret    

400082d8 <malloc>:
400082d8:	55                   	push   %ebp
400082d9:	89 e5                	mov    %esp,%ebp
400082db:	53                   	push   %ebx
400082dc:	83 ec 64             	sub    $0x64,%esp
400082df:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
400082e6:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
400082ed:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
400082f4:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
400082fb:	8b 45 08             	mov    0x8(%ebp),%eax
400082fe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40008301:	83 45 e4 06          	addl   $0x6,-0x1c(%ebp)
40008305:	e8 72 fd ff ff       	call   4000807c <liballoc_lock>
4000830a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
4000830e:	75 36                	jne    40008346 <malloc+0x6e>
40008310:	a1 38 a6 00 40       	mov    0x4000a638,%eax
40008315:	8b 15 3c a6 00 40    	mov    0x4000a63c,%edx
4000831b:	83 c0 01             	add    $0x1,%eax
4000831e:	83 d2 00             	adc    $0x0,%edx
40008321:	a3 38 a6 00 40       	mov    %eax,0x4000a638
40008326:	89 15 3c a6 00 40    	mov    %edx,0x4000a63c
4000832c:	e8 5d fd ff ff       	call   4000808e <liballoc_unlock>
40008331:	83 ec 0c             	sub    $0xc,%esp
40008334:	6a 01                	push   $0x1
40008336:	e8 9d ff ff ff       	call   400082d8 <malloc>
4000833b:	83 c4 10             	add    $0x10,%esp
4000833e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
40008341:	e9 61 06 00 00       	jmp    400089a7 <malloc+0x6cf>
40008346:	a1 20 a6 00 40       	mov    0x4000a620,%eax
4000834b:	85 c0                	test   %eax,%eax
4000834d:	75 2d                	jne    4000837c <malloc+0xa4>
4000834f:	83 ec 0c             	sub    $0xc,%esp
40008352:	ff 75 e4             	pushl  -0x1c(%ebp)
40008355:	e8 5d fe ff ff       	call   400081b7 <allocate_new_page>
4000835a:	83 c4 10             	add    $0x10,%esp
4000835d:	a3 20 a6 00 40       	mov    %eax,0x4000a620
40008362:	a1 20 a6 00 40       	mov    0x4000a620,%eax
40008367:	85 c0                	test   %eax,%eax
40008369:	75 11                	jne    4000837c <malloc+0xa4>
4000836b:	e8 1e fd ff ff       	call   4000808e <liballoc_unlock>
40008370:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
40008377:	e9 2b 06 00 00       	jmp    400089a7 <malloc+0x6cf>
4000837c:	a1 20 a6 00 40       	mov    0x4000a620,%eax
40008381:	89 45 d8             	mov    %eax,-0x28(%ebp)
40008384:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
4000838b:	a1 24 a6 00 40       	mov    0x4000a624,%eax
40008390:	85 c0                	test   %eax,%eax
40008392:	0f 84 f9 05 00 00    	je     40008991 <malloc+0x6b9>
40008398:	a1 24 a6 00 40       	mov    0x4000a624,%eax
4000839d:	8b 50 0c             	mov    0xc(%eax),%edx
400083a0:	a1 24 a6 00 40       	mov    0x4000a624,%eax
400083a5:	8b 40 10             	mov    0x10(%eax),%eax
400083a8:	89 d1                	mov    %edx,%ecx
400083aa:	29 c1                	sub    %eax,%ecx
400083ac:	89 c8                	mov    %ecx,%eax
400083ae:	ba 00 00 00 00       	mov    $0x0,%edx
400083b3:	89 45 c8             	mov    %eax,-0x38(%ebp)
400083b6:	89 55 cc             	mov    %edx,-0x34(%ebp)
400083b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400083bc:	83 c0 18             	add    $0x18,%eax
400083bf:	89 45 a8             	mov    %eax,-0x58(%ebp)
400083c2:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
400083c9:	8b 45 ac             	mov    -0x54(%ebp),%eax
400083cc:	3b 45 cc             	cmp    -0x34(%ebp),%eax
400083cf:	0f 87 bc 05 00 00    	ja     40008991 <malloc+0x6b9>
400083d5:	8b 55 ac             	mov    -0x54(%ebp),%edx
400083d8:	3b 55 cc             	cmp    -0x34(%ebp),%edx
400083db:	72 0c                	jb     400083e9 <malloc+0x111>
400083dd:	8b 4d a8             	mov    -0x58(%ebp),%ecx
400083e0:	3b 4d c8             	cmp    -0x38(%ebp),%ecx
400083e3:	0f 83 a8 05 00 00    	jae    40008991 <malloc+0x6b9>
400083e9:	a1 24 a6 00 40       	mov    0x4000a624,%eax
400083ee:	89 45 d8             	mov    %eax,-0x28(%ebp)
400083f1:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
400083f8:	e9 94 05 00 00       	jmp    40008991 <malloc+0x6b9>
400083fd:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008400:	8b 50 0c             	mov    0xc(%eax),%edx
40008403:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008406:	8b 40 10             	mov    0x10(%eax),%eax
40008409:	89 d1                	mov    %edx,%ecx
4000840b:	29 c1                	sub    %eax,%ecx
4000840d:	89 c8                	mov    %ecx,%eax
4000840f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40008412:	8b 45 d4             	mov    -0x2c(%ebp),%eax
40008415:	ba 00 00 00 00       	mov    $0x0,%edx
4000841a:	89 45 b0             	mov    %eax,-0x50(%ebp)
4000841d:	89 55 b4             	mov    %edx,-0x4c(%ebp)
40008420:	8b 55 b4             	mov    -0x4c(%ebp),%edx
40008423:	3b 55 cc             	cmp    -0x34(%ebp),%edx
40008426:	72 26                	jb     4000844e <malloc+0x176>
40008428:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
4000842b:	3b 4d cc             	cmp    -0x34(%ebp),%ecx
4000842e:	77 08                	ja     40008438 <malloc+0x160>
40008430:	8b 45 b0             	mov    -0x50(%ebp),%eax
40008433:	3b 45 c8             	cmp    -0x38(%ebp),%eax
40008436:	76 16                	jbe    4000844e <malloc+0x176>
40008438:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000843b:	a3 24 a6 00 40       	mov    %eax,0x4000a624
40008440:	8b 45 d4             	mov    -0x2c(%ebp),%eax
40008443:	ba 00 00 00 00       	mov    $0x0,%edx
40008448:	89 45 c8             	mov    %eax,-0x38(%ebp)
4000844b:	89 55 cc             	mov    %edx,-0x34(%ebp)
4000844e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008451:	83 c0 18             	add    $0x18,%eax
40008454:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
40008457:	76 6a                	jbe    400084c3 <malloc+0x1eb>
40008459:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000845c:	8b 40 04             	mov    0x4(%eax),%eax
4000845f:	85 c0                	test   %eax,%eax
40008461:	74 0e                	je     40008471 <malloc+0x199>
40008463:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008466:	8b 40 04             	mov    0x4(%eax),%eax
40008469:	89 45 d8             	mov    %eax,-0x28(%ebp)
4000846c:	e9 20 05 00 00       	jmp    40008991 <malloc+0x6b9>
40008471:	83 7d c4 01          	cmpl   $0x1,-0x3c(%ebp)
40008475:	75 14                	jne    4000848b <malloc+0x1b3>
40008477:	a1 20 a6 00 40       	mov    0x4000a620,%eax
4000847c:	89 45 d8             	mov    %eax,-0x28(%ebp)
4000847f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
40008486:	e9 06 05 00 00       	jmp    40008991 <malloc+0x6b9>
4000848b:	83 ec 0c             	sub    $0xc,%esp
4000848e:	ff 75 e4             	pushl  -0x1c(%ebp)
40008491:	e8 21 fd ff ff       	call   400081b7 <allocate_new_page>
40008496:	83 c4 10             	add    $0x10,%esp
40008499:	89 c2                	mov    %eax,%edx
4000849b:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000849e:	89 50 04             	mov    %edx,0x4(%eax)
400084a1:	8b 45 d8             	mov    -0x28(%ebp),%eax
400084a4:	8b 40 04             	mov    0x4(%eax),%eax
400084a7:	85 c0                	test   %eax,%eax
400084a9:	0f 84 ec 04 00 00    	je     4000899b <malloc+0x6c3>
400084af:	8b 45 d8             	mov    -0x28(%ebp),%eax
400084b2:	8b 50 04             	mov    0x4(%eax),%edx
400084b5:	8b 45 d8             	mov    -0x28(%ebp),%eax
400084b8:	89 02                	mov    %eax,(%edx)
400084ba:	8b 45 d8             	mov    -0x28(%ebp),%eax
400084bd:	8b 40 04             	mov    0x4(%eax),%eax
400084c0:	89 45 d8             	mov    %eax,-0x28(%ebp)
400084c3:	8b 45 d8             	mov    -0x28(%ebp),%eax
400084c6:	8b 40 14             	mov    0x14(%eax),%eax
400084c9:	85 c0                	test   %eax,%eax
400084cb:	0f 85 e5 00 00 00    	jne    400085b6 <malloc+0x2de>
400084d1:	8b 45 d8             	mov    -0x28(%ebp),%eax
400084d4:	83 c0 18             	add    $0x18,%eax
400084d7:	89 c2                	mov    %eax,%edx
400084d9:	8b 45 d8             	mov    -0x28(%ebp),%eax
400084dc:	89 50 14             	mov    %edx,0x14(%eax)
400084df:	8b 45 d8             	mov    -0x28(%ebp),%eax
400084e2:	8b 40 14             	mov    0x14(%eax),%eax
400084e5:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
400084ec:	8b 45 d8             	mov    -0x28(%ebp),%eax
400084ef:	8b 40 14             	mov    0x14(%eax),%eax
400084f2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
400084f8:	8b 45 d8             	mov    -0x28(%ebp),%eax
400084fb:	8b 40 14             	mov    0x14(%eax),%eax
400084fe:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
40008505:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008508:	8b 50 14             	mov    0x14(%eax),%edx
4000850b:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000850e:	89 42 08             	mov    %eax,0x8(%edx)
40008511:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008514:	8b 50 14             	mov    0x14(%eax),%edx
40008517:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000851a:	89 42 10             	mov    %eax,0x10(%edx)
4000851d:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008520:	8b 50 14             	mov    0x14(%eax),%edx
40008523:	8b 45 08             	mov    0x8(%ebp),%eax
40008526:	89 42 14             	mov    %eax,0x14(%edx)
40008529:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000852c:	8b 40 10             	mov    0x10(%eax),%eax
4000852f:	03 45 e4             	add    -0x1c(%ebp),%eax
40008532:	8d 50 18             	lea    0x18(%eax),%edx
40008535:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008538:	89 50 10             	mov    %edx,0x10(%eax)
4000853b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
4000853e:	bb 00 00 00 00       	mov    $0x0,%ebx
40008543:	a1 30 a6 00 40       	mov    0x4000a630,%eax
40008548:	8b 15 34 a6 00 40    	mov    0x4000a634,%edx
4000854e:	01 c8                	add    %ecx,%eax
40008550:	11 da                	adc    %ebx,%edx
40008552:	a3 30 a6 00 40       	mov    %eax,0x4000a630
40008557:	89 15 34 a6 00 40    	mov    %edx,0x4000a634
4000855d:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008560:	8b 40 14             	mov    0x14(%eax),%eax
40008563:	83 c0 18             	add    $0x18,%eax
40008566:	89 45 d0             	mov    %eax,-0x30(%ebp)
40008569:	8b 45 d0             	mov    -0x30(%ebp),%eax
4000856c:	83 c0 02             	add    $0x2,%eax
4000856f:	89 45 d0             	mov    %eax,-0x30(%ebp)
40008572:	8b 45 d0             	mov    -0x30(%ebp),%eax
40008575:	83 e0 03             	and    $0x3,%eax
40008578:	89 45 e8             	mov    %eax,-0x18(%ebp)
4000857b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
4000857f:	74 14                	je     40008595 <malloc+0x2bd>
40008581:	b8 04 00 00 00       	mov    $0x4,%eax
40008586:	2b 45 e8             	sub    -0x18(%ebp),%eax
40008589:	89 45 e8             	mov    %eax,-0x18(%ebp)
4000858c:	8b 45 d0             	mov    -0x30(%ebp),%eax
4000858f:	03 45 e8             	add    -0x18(%ebp),%eax
40008592:	89 45 d0             	mov    %eax,-0x30(%ebp)
40008595:	8b 45 d0             	mov    -0x30(%ebp),%eax
40008598:	83 e8 02             	sub    $0x2,%eax
4000859b:	89 c2                	mov    %eax,%edx
4000859d:	8b 45 e8             	mov    -0x18(%ebp),%eax
400085a0:	83 c0 02             	add    $0x2,%eax
400085a3:	66 89 02             	mov    %ax,(%edx)
400085a6:	e8 e3 fa ff ff       	call   4000808e <liballoc_unlock>
400085ab:	8b 55 d0             	mov    -0x30(%ebp),%edx
400085ae:	89 55 a4             	mov    %edx,-0x5c(%ebp)
400085b1:	e9 f1 03 00 00       	jmp    400089a7 <malloc+0x6cf>
400085b6:	8b 45 d8             	mov    -0x28(%ebp),%eax
400085b9:	8b 40 14             	mov    0x14(%eax),%eax
400085bc:	89 c2                	mov    %eax,%edx
400085be:	8b 45 d8             	mov    -0x28(%ebp),%eax
400085c1:	89 d1                	mov    %edx,%ecx
400085c3:	29 c1                	sub    %eax,%ecx
400085c5:	89 c8                	mov    %ecx,%eax
400085c7:	83 e8 18             	sub    $0x18,%eax
400085ca:	89 45 d4             	mov    %eax,-0x2c(%ebp)
400085cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400085d0:	83 c0 18             	add    $0x18,%eax
400085d3:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
400085d6:	0f 87 f7 00 00 00    	ja     400086d3 <malloc+0x3fb>
400085dc:	8b 45 d8             	mov    -0x28(%ebp),%eax
400085df:	8b 50 14             	mov    0x14(%eax),%edx
400085e2:	8b 45 d8             	mov    -0x28(%ebp),%eax
400085e5:	83 c0 18             	add    $0x18,%eax
400085e8:	89 02                	mov    %eax,(%edx)
400085ea:	8b 45 d8             	mov    -0x28(%ebp),%eax
400085ed:	8b 40 14             	mov    0x14(%eax),%eax
400085f0:	8b 10                	mov    (%eax),%edx
400085f2:	8b 45 d8             	mov    -0x28(%ebp),%eax
400085f5:	8b 40 14             	mov    0x14(%eax),%eax
400085f8:	89 42 04             	mov    %eax,0x4(%edx)
400085fb:	8b 45 d8             	mov    -0x28(%ebp),%eax
400085fe:	8b 40 14             	mov    0x14(%eax),%eax
40008601:	8b 10                	mov    (%eax),%edx
40008603:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008606:	89 50 14             	mov    %edx,0x14(%eax)
40008609:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000860c:	8b 40 14             	mov    0x14(%eax),%eax
4000860f:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
40008616:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008619:	8b 40 14             	mov    0x14(%eax),%eax
4000861c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
40008622:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008625:	8b 50 14             	mov    0x14(%eax),%edx
40008628:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000862b:	89 42 08             	mov    %eax,0x8(%edx)
4000862e:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008631:	8b 50 14             	mov    0x14(%eax),%edx
40008634:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008637:	89 42 10             	mov    %eax,0x10(%edx)
4000863a:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000863d:	8b 50 14             	mov    0x14(%eax),%edx
40008640:	8b 45 08             	mov    0x8(%ebp),%eax
40008643:	89 42 14             	mov    %eax,0x14(%edx)
40008646:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008649:	8b 40 10             	mov    0x10(%eax),%eax
4000864c:	03 45 e4             	add    -0x1c(%ebp),%eax
4000864f:	8d 50 18             	lea    0x18(%eax),%edx
40008652:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008655:	89 50 10             	mov    %edx,0x10(%eax)
40008658:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
4000865b:	bb 00 00 00 00       	mov    $0x0,%ebx
40008660:	a1 30 a6 00 40       	mov    0x4000a630,%eax
40008665:	8b 15 34 a6 00 40    	mov    0x4000a634,%edx
4000866b:	01 c8                	add    %ecx,%eax
4000866d:	11 da                	adc    %ebx,%edx
4000866f:	a3 30 a6 00 40       	mov    %eax,0x4000a630
40008674:	89 15 34 a6 00 40    	mov    %edx,0x4000a634
4000867a:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000867d:	8b 40 14             	mov    0x14(%eax),%eax
40008680:	83 c0 18             	add    $0x18,%eax
40008683:	89 45 d0             	mov    %eax,-0x30(%ebp)
40008686:	8b 45 d0             	mov    -0x30(%ebp),%eax
40008689:	83 c0 02             	add    $0x2,%eax
4000868c:	89 45 d0             	mov    %eax,-0x30(%ebp)
4000868f:	8b 45 d0             	mov    -0x30(%ebp),%eax
40008692:	83 e0 03             	and    $0x3,%eax
40008695:	89 45 ec             	mov    %eax,-0x14(%ebp)
40008698:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
4000869c:	74 14                	je     400086b2 <malloc+0x3da>
4000869e:	b8 04 00 00 00       	mov    $0x4,%eax
400086a3:	2b 45 ec             	sub    -0x14(%ebp),%eax
400086a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
400086a9:	8b 45 d0             	mov    -0x30(%ebp),%eax
400086ac:	03 45 ec             	add    -0x14(%ebp),%eax
400086af:	89 45 d0             	mov    %eax,-0x30(%ebp)
400086b2:	8b 45 d0             	mov    -0x30(%ebp),%eax
400086b5:	83 e8 02             	sub    $0x2,%eax
400086b8:	89 c2                	mov    %eax,%edx
400086ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
400086bd:	83 c0 02             	add    $0x2,%eax
400086c0:	66 89 02             	mov    %ax,(%edx)
400086c3:	e8 c6 f9 ff ff       	call   4000808e <liballoc_unlock>
400086c8:	8b 45 d0             	mov    -0x30(%ebp),%eax
400086cb:	89 45 a4             	mov    %eax,-0x5c(%ebp)
400086ce:	e9 d4 02 00 00       	jmp    400089a7 <malloc+0x6cf>
400086d3:	8b 45 d8             	mov    -0x28(%ebp),%eax
400086d6:	8b 40 14             	mov    0x14(%eax),%eax
400086d9:	89 45 dc             	mov    %eax,-0x24(%ebp)
400086dc:	e9 51 02 00 00       	jmp    40008932 <malloc+0x65a>
400086e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
400086e4:	8b 40 04             	mov    0x4(%eax),%eax
400086e7:	85 c0                	test   %eax,%eax
400086e9:	0f 85 18 01 00 00    	jne    40008807 <malloc+0x52f>
400086ef:	8b 45 d8             	mov    -0x28(%ebp),%eax
400086f2:	8b 50 0c             	mov    0xc(%eax),%edx
400086f5:	8b 45 d8             	mov    -0x28(%ebp),%eax
400086f8:	8d 04 02             	lea    (%edx,%eax,1),%eax
400086fb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
400086fe:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008701:	8b 50 10             	mov    0x10(%eax),%edx
40008704:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008707:	01 c2                	add    %eax,%edx
40008709:	8b 45 d4             	mov    -0x2c(%ebp),%eax
4000870c:	29 d0                	sub    %edx,%eax
4000870e:	83 e8 18             	sub    $0x18,%eax
40008711:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40008714:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008717:	83 c0 18             	add    $0x18,%eax
4000871a:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
4000871d:	0f 87 e4 00 00 00    	ja     40008807 <malloc+0x52f>
40008723:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008726:	8b 50 10             	mov    0x10(%eax),%edx
40008729:	8b 45 dc             	mov    -0x24(%ebp),%eax
4000872c:	8d 04 02             	lea    (%edx,%eax,1),%eax
4000872f:	83 c0 18             	add    $0x18,%eax
40008732:	89 c2                	mov    %eax,%edx
40008734:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008737:	89 50 04             	mov    %edx,0x4(%eax)
4000873a:	8b 45 dc             	mov    -0x24(%ebp),%eax
4000873d:	8b 50 04             	mov    0x4(%eax),%edx
40008740:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008743:	89 02                	mov    %eax,(%edx)
40008745:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008748:	8b 40 04             	mov    0x4(%eax),%eax
4000874b:	89 45 dc             	mov    %eax,-0x24(%ebp)
4000874e:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008751:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
40008758:	8b 45 dc             	mov    -0x24(%ebp),%eax
4000875b:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
40008762:	8b 55 dc             	mov    -0x24(%ebp),%edx
40008765:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008768:	89 42 08             	mov    %eax,0x8(%edx)
4000876b:	8b 55 dc             	mov    -0x24(%ebp),%edx
4000876e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008771:	89 42 10             	mov    %eax,0x10(%edx)
40008774:	8b 55 dc             	mov    -0x24(%ebp),%edx
40008777:	8b 45 08             	mov    0x8(%ebp),%eax
4000877a:	89 42 14             	mov    %eax,0x14(%edx)
4000877d:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008780:	8b 40 10             	mov    0x10(%eax),%eax
40008783:	03 45 e4             	add    -0x1c(%ebp),%eax
40008786:	8d 50 18             	lea    0x18(%eax),%edx
40008789:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000878c:	89 50 10             	mov    %edx,0x10(%eax)
4000878f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40008792:	bb 00 00 00 00       	mov    $0x0,%ebx
40008797:	a1 30 a6 00 40       	mov    0x4000a630,%eax
4000879c:	8b 15 34 a6 00 40    	mov    0x4000a634,%edx
400087a2:	01 c8                	add    %ecx,%eax
400087a4:	11 da                	adc    %ebx,%edx
400087a6:	a3 30 a6 00 40       	mov    %eax,0x4000a630
400087ab:	89 15 34 a6 00 40    	mov    %edx,0x4000a634
400087b1:	8b 45 dc             	mov    -0x24(%ebp),%eax
400087b4:	83 c0 18             	add    $0x18,%eax
400087b7:	89 45 d0             	mov    %eax,-0x30(%ebp)
400087ba:	8b 45 d0             	mov    -0x30(%ebp),%eax
400087bd:	83 c0 02             	add    $0x2,%eax
400087c0:	89 45 d0             	mov    %eax,-0x30(%ebp)
400087c3:	8b 45 d0             	mov    -0x30(%ebp),%eax
400087c6:	83 e0 03             	and    $0x3,%eax
400087c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
400087cc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
400087d0:	74 14                	je     400087e6 <malloc+0x50e>
400087d2:	b8 04 00 00 00       	mov    $0x4,%eax
400087d7:	2b 45 f0             	sub    -0x10(%ebp),%eax
400087da:	89 45 f0             	mov    %eax,-0x10(%ebp)
400087dd:	8b 45 d0             	mov    -0x30(%ebp),%eax
400087e0:	03 45 f0             	add    -0x10(%ebp),%eax
400087e3:	89 45 d0             	mov    %eax,-0x30(%ebp)
400087e6:	8b 45 d0             	mov    -0x30(%ebp),%eax
400087e9:	83 e8 02             	sub    $0x2,%eax
400087ec:	89 c2                	mov    %eax,%edx
400087ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
400087f1:	83 c0 02             	add    $0x2,%eax
400087f4:	66 89 02             	mov    %ax,(%edx)
400087f7:	e8 92 f8 ff ff       	call   4000808e <liballoc_unlock>
400087fc:	8b 55 d0             	mov    -0x30(%ebp),%edx
400087ff:	89 55 a4             	mov    %edx,-0x5c(%ebp)
40008802:	e9 a0 01 00 00       	jmp    400089a7 <malloc+0x6cf>
40008807:	8b 45 dc             	mov    -0x24(%ebp),%eax
4000880a:	8b 40 04             	mov    0x4(%eax),%eax
4000880d:	85 c0                	test   %eax,%eax
4000880f:	0f 84 14 01 00 00    	je     40008929 <malloc+0x651>
40008815:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008818:	8b 40 04             	mov    0x4(%eax),%eax
4000881b:	89 c2                	mov    %eax,%edx
4000881d:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008820:	29 c2                	sub    %eax,%edx
40008822:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008825:	8b 40 10             	mov    0x10(%eax),%eax
40008828:	89 d1                	mov    %edx,%ecx
4000882a:	29 c1                	sub    %eax,%ecx
4000882c:	89 c8                	mov    %ecx,%eax
4000882e:	83 e8 18             	sub    $0x18,%eax
40008831:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40008834:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008837:	83 c0 18             	add    $0x18,%eax
4000883a:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
4000883d:	0f 87 e6 00 00 00    	ja     40008929 <malloc+0x651>
40008843:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008846:	8b 50 10             	mov    0x10(%eax),%edx
40008849:	8b 45 dc             	mov    -0x24(%ebp),%eax
4000884c:	8d 04 02             	lea    (%edx,%eax,1),%eax
4000884f:	83 c0 18             	add    $0x18,%eax
40008852:	89 45 e0             	mov    %eax,-0x20(%ebp)
40008855:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008858:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
4000885f:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008862:	8b 50 04             	mov    0x4(%eax),%edx
40008865:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008868:	89 50 04             	mov    %edx,0x4(%eax)
4000886b:	8b 55 e0             	mov    -0x20(%ebp),%edx
4000886e:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008871:	89 02                	mov    %eax,(%edx)
40008873:	8b 55 e0             	mov    -0x20(%ebp),%edx
40008876:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008879:	89 42 10             	mov    %eax,0x10(%edx)
4000887c:	8b 55 e0             	mov    -0x20(%ebp),%edx
4000887f:	8b 45 08             	mov    0x8(%ebp),%eax
40008882:	89 42 14             	mov    %eax,0x14(%edx)
40008885:	8b 55 e0             	mov    -0x20(%ebp),%edx
40008888:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000888b:	89 42 08             	mov    %eax,0x8(%edx)
4000888e:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008891:	8b 50 04             	mov    0x4(%eax),%edx
40008894:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008897:	89 02                	mov    %eax,(%edx)
40008899:	8b 55 dc             	mov    -0x24(%ebp),%edx
4000889c:	8b 45 e0             	mov    -0x20(%ebp),%eax
4000889f:	89 42 04             	mov    %eax,0x4(%edx)
400088a2:	8b 45 d8             	mov    -0x28(%ebp),%eax
400088a5:	8b 40 10             	mov    0x10(%eax),%eax
400088a8:	03 45 e4             	add    -0x1c(%ebp),%eax
400088ab:	8d 50 18             	lea    0x18(%eax),%edx
400088ae:	8b 45 d8             	mov    -0x28(%ebp),%eax
400088b1:	89 50 10             	mov    %edx,0x10(%eax)
400088b4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
400088b7:	bb 00 00 00 00       	mov    $0x0,%ebx
400088bc:	a1 30 a6 00 40       	mov    0x4000a630,%eax
400088c1:	8b 15 34 a6 00 40    	mov    0x4000a634,%edx
400088c7:	01 c8                	add    %ecx,%eax
400088c9:	11 da                	adc    %ebx,%edx
400088cb:	a3 30 a6 00 40       	mov    %eax,0x4000a630
400088d0:	89 15 34 a6 00 40    	mov    %edx,0x4000a634
400088d6:	8b 45 e0             	mov    -0x20(%ebp),%eax
400088d9:	83 c0 18             	add    $0x18,%eax
400088dc:	89 45 d0             	mov    %eax,-0x30(%ebp)
400088df:	8b 45 d0             	mov    -0x30(%ebp),%eax
400088e2:	83 c0 02             	add    $0x2,%eax
400088e5:	89 45 d0             	mov    %eax,-0x30(%ebp)
400088e8:	8b 45 d0             	mov    -0x30(%ebp),%eax
400088eb:	83 e0 03             	and    $0x3,%eax
400088ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
400088f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
400088f5:	74 14                	je     4000890b <malloc+0x633>
400088f7:	b8 04 00 00 00       	mov    $0x4,%eax
400088fc:	2b 45 f4             	sub    -0xc(%ebp),%eax
400088ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
40008902:	8b 45 d0             	mov    -0x30(%ebp),%eax
40008905:	03 45 f4             	add    -0xc(%ebp),%eax
40008908:	89 45 d0             	mov    %eax,-0x30(%ebp)
4000890b:	8b 45 d0             	mov    -0x30(%ebp),%eax
4000890e:	83 e8 02             	sub    $0x2,%eax
40008911:	89 c2                	mov    %eax,%edx
40008913:	8b 45 f4             	mov    -0xc(%ebp),%eax
40008916:	83 c0 02             	add    $0x2,%eax
40008919:	66 89 02             	mov    %ax,(%edx)
4000891c:	e8 6d f7 ff ff       	call   4000808e <liballoc_unlock>
40008921:	8b 45 d0             	mov    -0x30(%ebp),%eax
40008924:	89 45 a4             	mov    %eax,-0x5c(%ebp)
40008927:	eb 7e                	jmp    400089a7 <malloc+0x6cf>
40008929:	8b 45 dc             	mov    -0x24(%ebp),%eax
4000892c:	8b 40 04             	mov    0x4(%eax),%eax
4000892f:	89 45 dc             	mov    %eax,-0x24(%ebp)
40008932:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
40008936:	0f 85 a5 fd ff ff    	jne    400086e1 <malloc+0x409>
4000893c:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000893f:	8b 40 04             	mov    0x4(%eax),%eax
40008942:	85 c0                	test   %eax,%eax
40008944:	75 42                	jne    40008988 <malloc+0x6b0>
40008946:	83 7d c4 01          	cmpl   $0x1,-0x3c(%ebp)
4000894a:	75 11                	jne    4000895d <malloc+0x685>
4000894c:	a1 20 a6 00 40       	mov    0x4000a620,%eax
40008951:	89 45 d8             	mov    %eax,-0x28(%ebp)
40008954:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
4000895b:	eb 34                	jmp    40008991 <malloc+0x6b9>
4000895d:	83 ec 0c             	sub    $0xc,%esp
40008960:	ff 75 e4             	pushl  -0x1c(%ebp)
40008963:	e8 4f f8 ff ff       	call   400081b7 <allocate_new_page>
40008968:	83 c4 10             	add    $0x10,%esp
4000896b:	89 c2                	mov    %eax,%edx
4000896d:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008970:	89 50 04             	mov    %edx,0x4(%eax)
40008973:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008976:	8b 40 04             	mov    0x4(%eax),%eax
40008979:	85 c0                	test   %eax,%eax
4000897b:	74 1e                	je     4000899b <malloc+0x6c3>
4000897d:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008980:	8b 50 04             	mov    0x4(%eax),%edx
40008983:	8b 45 d8             	mov    -0x28(%ebp),%eax
40008986:	89 02                	mov    %eax,(%edx)
40008988:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000898b:	8b 40 04             	mov    0x4(%eax),%eax
4000898e:	89 45 d8             	mov    %eax,-0x28(%ebp)
40008991:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
40008995:	0f 85 62 fa ff ff    	jne    400083fd <malloc+0x125>
4000899b:	e8 ee f6 ff ff       	call   4000808e <liballoc_unlock>
400089a0:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
400089a7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
400089aa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400089ad:	c9                   	leave  
400089ae:	c3                   	ret    

400089af <free>:
400089af:	55                   	push   %ebp
400089b0:	89 e5                	mov    %esp,%ebp
400089b2:	57                   	push   %edi
400089b3:	56                   	push   %esi
400089b4:	53                   	push   %ebx
400089b5:	83 ec 2c             	sub    $0x2c,%esp
400089b8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
400089bc:	75 21                	jne    400089df <free+0x30>
400089be:	a1 38 a6 00 40       	mov    0x4000a638,%eax
400089c3:	8b 15 3c a6 00 40    	mov    0x4000a63c,%edx
400089c9:	83 c0 01             	add    $0x1,%eax
400089cc:	83 d2 00             	adc    $0x0,%edx
400089cf:	a3 38 a6 00 40       	mov    %eax,0x4000a638
400089d4:	89 15 3c a6 00 40    	mov    %edx,0x4000a63c
400089da:	e9 60 02 00 00       	jmp    40008c3f <free+0x290>
400089df:	8b 45 08             	mov    0x8(%ebp),%eax
400089e2:	83 e8 02             	sub    $0x2,%eax
400089e5:	66 8b 00             	mov    (%eax),%ax
400089e8:	0f b7 c0             	movzwl %ax,%eax
400089eb:	89 45 e8             	mov    %eax,-0x18(%ebp)
400089ee:	83 7d e8 05          	cmpl   $0x5,-0x18(%ebp)
400089f2:	77 09                	ja     400089fd <free+0x4e>
400089f4:	8b 45 08             	mov    0x8(%ebp),%eax
400089f7:	2b 45 e8             	sub    -0x18(%ebp),%eax
400089fa:	89 45 08             	mov    %eax,0x8(%ebp)
400089fd:	e8 7a f6 ff ff       	call   4000807c <liballoc_lock>
40008a02:	8b 45 08             	mov    0x8(%ebp),%eax
40008a05:	83 e8 18             	sub    $0x18,%eax
40008a08:	89 45 e0             	mov    %eax,-0x20(%ebp)
40008a0b:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008a0e:	8b 40 0c             	mov    0xc(%eax),%eax
40008a11:	3d de c0 01 c0       	cmp    $0xc001c0de,%eax
40008a16:	74 78                	je     40008a90 <free+0xe1>
40008a18:	a1 40 a6 00 40       	mov    0x4000a640,%eax
40008a1d:	8b 15 44 a6 00 40    	mov    0x4000a644,%edx
40008a23:	83 c0 01             	add    $0x1,%eax
40008a26:	83 d2 00             	adc    $0x0,%edx
40008a29:	a3 40 a6 00 40       	mov    %eax,0x4000a640
40008a2e:	89 15 44 a6 00 40    	mov    %edx,0x4000a644
40008a34:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008a37:	8b 40 0c             	mov    0xc(%eax),%eax
40008a3a:	25 ff ff ff 00       	and    $0xffffff,%eax
40008a3f:	3d de c0 01 00       	cmp    $0x1c0de,%eax
40008a44:	74 24                	je     40008a6a <free+0xbb>
40008a46:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008a49:	8b 40 0c             	mov    0xc(%eax),%eax
40008a4c:	25 ff ff 00 00       	and    $0xffff,%eax
40008a51:	3d de c0 00 00       	cmp    $0xc0de,%eax
40008a56:	74 12                	je     40008a6a <free+0xbb>
40008a58:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008a5b:	8b 40 0c             	mov    0xc(%eax),%eax
40008a5e:	25 ff 00 00 00       	and    $0xff,%eax
40008a63:	3d de 00 00 00       	cmp    $0xde,%eax
40008a68:	75 1c                	jne    40008a86 <free+0xd7>
40008a6a:	a1 48 a6 00 40       	mov    0x4000a648,%eax
40008a6f:	8b 15 4c a6 00 40    	mov    0x4000a64c,%edx
40008a75:	83 c0 01             	add    $0x1,%eax
40008a78:	83 d2 00             	adc    $0x0,%edx
40008a7b:	a3 48 a6 00 40       	mov    %eax,0x4000a648
40008a80:	89 15 4c a6 00 40    	mov    %edx,0x4000a64c
40008a86:	e8 03 f6 ff ff       	call   4000808e <liballoc_unlock>
40008a8b:	e9 af 01 00 00       	jmp    40008c3f <free+0x290>
40008a90:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008a93:	8b 40 10             	mov    0x10(%eax),%eax
40008a96:	c1 e8 02             	shr    $0x2,%eax
40008a99:	50                   	push   %eax
40008a9a:	68 de c0 0f d0       	push   $0xd00fc0de
40008a9f:	ff 75 08             	pushl  0x8(%ebp)
40008aa2:	e8 83 f6 ff ff       	call   4000812a <liballoc_fill_dword>
40008aa7:	83 c4 0c             	add    $0xc,%esp
40008aaa:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008aad:	8b 40 08             	mov    0x8(%eax),%eax
40008ab0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40008ab3:	8b 0d 30 a6 00 40    	mov    0x4000a630,%ecx
40008ab9:	8b 1d 34 a6 00 40    	mov    0x4000a634,%ebx
40008abf:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008ac2:	8b 40 10             	mov    0x10(%eax),%eax
40008ac5:	ba 00 00 00 00       	mov    $0x0,%edx
40008aca:	89 ce                	mov    %ecx,%esi
40008acc:	89 df                	mov    %ebx,%edi
40008ace:	29 c6                	sub    %eax,%esi
40008ad0:	19 d7                	sbb    %edx,%edi
40008ad2:	89 f0                	mov    %esi,%eax
40008ad4:	89 fa                	mov    %edi,%edx
40008ad6:	a3 30 a6 00 40       	mov    %eax,0x4000a630
40008adb:	89 15 34 a6 00 40    	mov    %edx,0x4000a634
40008ae1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008ae4:	8b 50 10             	mov    0x10(%eax),%edx
40008ae7:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008aea:	8b 40 10             	mov    0x10(%eax),%eax
40008aed:	89 d7                	mov    %edx,%edi
40008aef:	29 c7                	sub    %eax,%edi
40008af1:	89 f8                	mov    %edi,%eax
40008af3:	8d 50 e8             	lea    -0x18(%eax),%edx
40008af6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008af9:	89 50 10             	mov    %edx,0x10(%eax)
40008afc:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008aff:	c7 40 0c ad de ad de 	movl   $0xdeaddead,0xc(%eax)
40008b06:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008b09:	8b 40 04             	mov    0x4(%eax),%eax
40008b0c:	85 c0                	test   %eax,%eax
40008b0e:	74 0d                	je     40008b1d <free+0x16e>
40008b10:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008b13:	8b 50 04             	mov    0x4(%eax),%edx
40008b16:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008b19:	8b 00                	mov    (%eax),%eax
40008b1b:	89 02                	mov    %eax,(%edx)
40008b1d:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008b20:	8b 00                	mov    (%eax),%eax
40008b22:	85 c0                	test   %eax,%eax
40008b24:	74 0e                	je     40008b34 <free+0x185>
40008b26:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008b29:	8b 10                	mov    (%eax),%edx
40008b2b:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008b2e:	8b 40 04             	mov    0x4(%eax),%eax
40008b31:	89 42 04             	mov    %eax,0x4(%edx)
40008b34:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008b37:	8b 00                	mov    (%eax),%eax
40008b39:	85 c0                	test   %eax,%eax
40008b3b:	75 0c                	jne    40008b49 <free+0x19a>
40008b3d:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008b40:	8b 50 04             	mov    0x4(%eax),%edx
40008b43:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008b46:	89 50 14             	mov    %edx,0x14(%eax)
40008b49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008b4c:	8b 40 14             	mov    0x14(%eax),%eax
40008b4f:	85 c0                	test   %eax,%eax
40008b51:	0f 85 9c 00 00 00    	jne    40008bf3 <free+0x244>
40008b57:	a1 20 a6 00 40       	mov    0x4000a620,%eax
40008b5c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
40008b5f:	75 0b                	jne    40008b6c <free+0x1bd>
40008b61:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008b64:	8b 40 04             	mov    0x4(%eax),%eax
40008b67:	a3 20 a6 00 40       	mov    %eax,0x4000a620
40008b6c:	a1 24 a6 00 40       	mov    0x4000a624,%eax
40008b71:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
40008b74:	75 0a                	jne    40008b80 <free+0x1d1>
40008b76:	c7 05 24 a6 00 40 00 	movl   $0x0,0x4000a624
40008b7d:	00 00 00 
40008b80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008b83:	8b 00                	mov    (%eax),%eax
40008b85:	85 c0                	test   %eax,%eax
40008b87:	74 0e                	je     40008b97 <free+0x1e8>
40008b89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008b8c:	8b 10                	mov    (%eax),%edx
40008b8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008b91:	8b 40 04             	mov    0x4(%eax),%eax
40008b94:	89 42 04             	mov    %eax,0x4(%edx)
40008b97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008b9a:	8b 40 04             	mov    0x4(%eax),%eax
40008b9d:	85 c0                	test   %eax,%eax
40008b9f:	74 0d                	je     40008bae <free+0x1ff>
40008ba1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008ba4:	8b 50 04             	mov    0x4(%eax),%edx
40008ba7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008baa:	8b 00                	mov    (%eax),%eax
40008bac:	89 02                	mov    %eax,(%edx)
40008bae:	8b 0d 28 a6 00 40    	mov    0x4000a628,%ecx
40008bb4:	8b 1d 2c a6 00 40    	mov    0x4000a62c,%ebx
40008bba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008bbd:	8b 40 0c             	mov    0xc(%eax),%eax
40008bc0:	ba 00 00 00 00       	mov    $0x0,%edx
40008bc5:	89 ce                	mov    %ecx,%esi
40008bc7:	89 df                	mov    %ebx,%edi
40008bc9:	29 c6                	sub    %eax,%esi
40008bcb:	19 d7                	sbb    %edx,%edi
40008bcd:	89 f0                	mov    %esi,%eax
40008bcf:	89 fa                	mov    %edi,%edx
40008bd1:	a3 28 a6 00 40       	mov    %eax,0x4000a628
40008bd6:	89 15 2c a6 00 40    	mov    %edx,0x4000a62c
40008bdc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008bdf:	8b 40 08             	mov    0x8(%eax),%eax
40008be2:	83 ec 08             	sub    $0x8,%esp
40008be5:	50                   	push   %eax
40008be6:	ff 75 e4             	pushl  -0x1c(%ebp)
40008be9:	e8 ee f4 ff ff       	call   400080dc <liballoc_free>
40008bee:	83 c4 10             	add    $0x10,%esp
40008bf1:	eb 47                	jmp    40008c3a <free+0x28b>
40008bf3:	a1 24 a6 00 40       	mov    0x4000a624,%eax
40008bf8:	85 c0                	test   %eax,%eax
40008bfa:	74 3e                	je     40008c3a <free+0x28b>
40008bfc:	a1 24 a6 00 40       	mov    0x4000a624,%eax
40008c01:	8b 50 0c             	mov    0xc(%eax),%edx
40008c04:	a1 24 a6 00 40       	mov    0x4000a624,%eax
40008c09:	8b 40 10             	mov    0x10(%eax),%eax
40008c0c:	89 d7                	mov    %edx,%edi
40008c0e:	29 c7                	sub    %eax,%edi
40008c10:	89 f8                	mov    %edi,%eax
40008c12:	89 45 ec             	mov    %eax,-0x14(%ebp)
40008c15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008c18:	8b 50 0c             	mov    0xc(%eax),%edx
40008c1b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008c1e:	8b 40 10             	mov    0x10(%eax),%eax
40008c21:	89 d1                	mov    %edx,%ecx
40008c23:	29 c1                	sub    %eax,%ecx
40008c25:	89 c8                	mov    %ecx,%eax
40008c27:	89 45 f0             	mov    %eax,-0x10(%ebp)
40008c2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
40008c2d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
40008c30:	76 08                	jbe    40008c3a <free+0x28b>
40008c32:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008c35:	a3 24 a6 00 40       	mov    %eax,0x4000a624
40008c3a:	e8 4f f4 ff ff       	call   4000808e <liballoc_unlock>
40008c3f:	8d 65 f4             	lea    -0xc(%ebp),%esp
40008c42:	5b                   	pop    %ebx
40008c43:	5e                   	pop    %esi
40008c44:	5f                   	pop    %edi
40008c45:	c9                   	leave  
40008c46:	c3                   	ret    

40008c47 <calloc>:
40008c47:	55                   	push   %ebp
40008c48:	89 e5                	mov    %esp,%ebp
40008c4a:	83 ec 18             	sub    $0x18,%esp
40008c4d:	8b 45 08             	mov    0x8(%ebp),%eax
40008c50:	0f af 45 0c          	imul   0xc(%ebp),%eax
40008c54:	89 45 f8             	mov    %eax,-0x8(%ebp)
40008c57:	8b 45 f8             	mov    -0x8(%ebp),%eax
40008c5a:	83 ec 0c             	sub    $0xc,%esp
40008c5d:	50                   	push   %eax
40008c5e:	e8 75 f6 ff ff       	call   400082d8 <malloc>
40008c63:	83 c4 10             	add    $0x10,%esp
40008c66:	89 45 fc             	mov    %eax,-0x4(%ebp)
40008c69:	8b 45 f8             	mov    -0x8(%ebp),%eax
40008c6c:	50                   	push   %eax
40008c6d:	6a 00                	push   $0x0
40008c6f:	ff 75 fc             	pushl  -0x4(%ebp)
40008c72:	e8 87 f4 ff ff       	call   400080fe <liballoc_memset>
40008c77:	83 c4 0c             	add    $0xc,%esp
40008c7a:	8b 45 fc             	mov    -0x4(%ebp),%eax
40008c7d:	c9                   	leave  
40008c7e:	c3                   	ret    

40008c7f <realloc>:
40008c7f:	55                   	push   %ebp
40008c80:	89 e5                	mov    %esp,%ebp
40008c82:	83 ec 18             	sub    $0x18,%esp
40008c85:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
40008c89:	75 1a                	jne    40008ca5 <realloc+0x26>
40008c8b:	83 ec 0c             	sub    $0xc,%esp
40008c8e:	ff 75 08             	pushl  0x8(%ebp)
40008c91:	e8 19 fd ff ff       	call   400089af <free>
40008c96:	83 c4 10             	add    $0x10,%esp
40008c99:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40008ca0:	e9 39 01 00 00       	jmp    40008dde <realloc+0x15f>
40008ca5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
40008ca9:	75 16                	jne    40008cc1 <realloc+0x42>
40008cab:	83 ec 0c             	sub    $0xc,%esp
40008cae:	ff 75 0c             	pushl  0xc(%ebp)
40008cb1:	e8 22 f6 ff ff       	call   400082d8 <malloc>
40008cb6:	83 c4 10             	add    $0x10,%esp
40008cb9:	89 45 ec             	mov    %eax,-0x14(%ebp)
40008cbc:	e9 1d 01 00 00       	jmp    40008dde <realloc+0x15f>
40008cc1:	8b 45 08             	mov    0x8(%ebp),%eax
40008cc4:	89 45 f0             	mov    %eax,-0x10(%ebp)
40008cc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
40008cca:	83 e8 02             	sub    $0x2,%eax
40008ccd:	66 8b 00             	mov    (%eax),%ax
40008cd0:	0f b7 c0             	movzwl %ax,%eax
40008cd3:	89 45 fc             	mov    %eax,-0x4(%ebp)
40008cd6:	83 7d fc 05          	cmpl   $0x5,-0x4(%ebp)
40008cda:	77 09                	ja     40008ce5 <realloc+0x66>
40008cdc:	8b 45 f0             	mov    -0x10(%ebp),%eax
40008cdf:	2b 45 fc             	sub    -0x4(%ebp),%eax
40008ce2:	89 45 f0             	mov    %eax,-0x10(%ebp)
40008ce5:	e8 92 f3 ff ff       	call   4000807c <liballoc_lock>
40008cea:	8b 45 f0             	mov    -0x10(%ebp),%eax
40008ced:	83 e8 18             	sub    $0x18,%eax
40008cf0:	89 45 f4             	mov    %eax,-0xc(%ebp)
40008cf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
40008cf6:	8b 40 0c             	mov    0xc(%eax),%eax
40008cf9:	3d de c0 01 c0       	cmp    $0xc001c0de,%eax
40008cfe:	74 7c                	je     40008d7c <realloc+0xfd>
40008d00:	a1 40 a6 00 40       	mov    0x4000a640,%eax
40008d05:	8b 15 44 a6 00 40    	mov    0x4000a644,%edx
40008d0b:	83 c0 01             	add    $0x1,%eax
40008d0e:	83 d2 00             	adc    $0x0,%edx
40008d11:	a3 40 a6 00 40       	mov    %eax,0x4000a640
40008d16:	89 15 44 a6 00 40    	mov    %edx,0x4000a644
40008d1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
40008d1f:	8b 40 0c             	mov    0xc(%eax),%eax
40008d22:	25 ff ff ff 00       	and    $0xffffff,%eax
40008d27:	3d de c0 01 00       	cmp    $0x1c0de,%eax
40008d2c:	74 24                	je     40008d52 <realloc+0xd3>
40008d2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
40008d31:	8b 40 0c             	mov    0xc(%eax),%eax
40008d34:	25 ff ff 00 00       	and    $0xffff,%eax
40008d39:	3d de c0 00 00       	cmp    $0xc0de,%eax
40008d3e:	74 12                	je     40008d52 <realloc+0xd3>
40008d40:	8b 45 f4             	mov    -0xc(%ebp),%eax
40008d43:	8b 40 0c             	mov    0xc(%eax),%eax
40008d46:	25 ff 00 00 00       	and    $0xff,%eax
40008d4b:	3d de 00 00 00       	cmp    $0xde,%eax
40008d50:	75 1c                	jne    40008d6e <realloc+0xef>
40008d52:	a1 48 a6 00 40       	mov    0x4000a648,%eax
40008d57:	8b 15 4c a6 00 40    	mov    0x4000a64c,%edx
40008d5d:	83 c0 01             	add    $0x1,%eax
40008d60:	83 d2 00             	adc    $0x0,%edx
40008d63:	a3 48 a6 00 40       	mov    %eax,0x4000a648
40008d68:	89 15 4c a6 00 40    	mov    %edx,0x4000a64c
40008d6e:	e8 1b f3 ff ff       	call   4000808e <liballoc_unlock>
40008d73:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40008d7a:	eb 62                	jmp    40008dde <realloc+0x15f>
40008d7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
40008d7f:	8b 40 14             	mov    0x14(%eax),%eax
40008d82:	89 45 f8             	mov    %eax,-0x8(%ebp)
40008d85:	8b 45 f8             	mov    -0x8(%ebp),%eax
40008d88:	3b 45 0c             	cmp    0xc(%ebp),%eax
40008d8b:	72 16                	jb     40008da3 <realloc+0x124>
40008d8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
40008d90:	8b 45 0c             	mov    0xc(%ebp),%eax
40008d93:	89 42 14             	mov    %eax,0x14(%edx)
40008d96:	e8 f3 f2 ff ff       	call   4000808e <liballoc_unlock>
40008d9b:	8b 45 08             	mov    0x8(%ebp),%eax
40008d9e:	89 45 ec             	mov    %eax,-0x14(%ebp)
40008da1:	eb 3b                	jmp    40008dde <realloc+0x15f>
40008da3:	e8 e6 f2 ff ff       	call   4000808e <liballoc_unlock>
40008da8:	83 ec 0c             	sub    $0xc,%esp
40008dab:	ff 75 0c             	pushl  0xc(%ebp)
40008dae:	e8 25 f5 ff ff       	call   400082d8 <malloc>
40008db3:	83 c4 10             	add    $0x10,%esp
40008db6:	89 45 f0             	mov    %eax,-0x10(%ebp)
40008db9:	ff 75 f8             	pushl  -0x8(%ebp)
40008dbc:	ff 75 08             	pushl  0x8(%ebp)
40008dbf:	ff 75 f0             	pushl  -0x10(%ebp)
40008dc2:	e8 94 f3 ff ff       	call   4000815b <liballoc_memcpy>
40008dc7:	83 c4 0c             	add    $0xc,%esp
40008dca:	83 ec 0c             	sub    $0xc,%esp
40008dcd:	ff 75 08             	pushl  0x8(%ebp)
40008dd0:	e8 da fb ff ff       	call   400089af <free>
40008dd5:	83 c4 10             	add    $0x10,%esp
40008dd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
40008ddb:	89 45 ec             	mov    %eax,-0x14(%ebp)
40008dde:	8b 45 ec             	mov    -0x14(%ebp),%eax
40008de1:	c9                   	leave  
40008de2:	c3                   	ret    
40008de3:	90                   	nop    

40008de4 <strtol>:
/*  
 * Copyright (c) 2007 The tyndur Project. All rights reserved.
 *
 * This code is derived from software contributed to the tyndur Project
 * by Antoine Kaufmann.
40008de4:	55                   	push   %ebp
40008de5:	89 e5                	mov    %esp,%ebp
40008de7:	83 ec 18             	sub    $0x18,%esp
 *
40008dea:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
40008df1:	eb 03                	jmp    40008df6 <strtol+0x12>
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
40008df3:	ff 45 08             	incl   0x8(%ebp)
 * This code is derived from software contributed to the tyndur Project
 * by Antoine Kaufmann.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
40008df6:	8b 45 08             	mov    0x8(%ebp),%eax
40008df9:	8a 00                	mov    (%eax),%al
40008dfb:	3c 20                	cmp    $0x20,%al
40008dfd:	74 f4                	je     40008df3 <strtol+0xf>
40008dff:	8b 45 08             	mov    0x8(%ebp),%eax
40008e02:	8a 00                	mov    (%eax),%al
40008e04:	3c 0a                	cmp    $0xa,%al
40008e06:	74 eb                	je     40008df3 <strtol+0xf>
40008e08:	8b 45 08             	mov    0x8(%ebp),%eax
40008e0b:	8a 00                	mov    (%eax),%al
40008e0d:	3c 09                	cmp    $0x9,%al
40008e0f:	74 e2                	je     40008df3 <strtol+0xf>
40008e11:	8b 45 08             	mov    0x8(%ebp),%eax
40008e14:	8a 00                	mov    (%eax),%al
40008e16:	3c 0d                	cmp    $0xd,%al
40008e18:	74 d9                	je     40008df3 <strtol+0xf>
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
40008e1a:	e9 df 00 00 00       	jmp    40008efe <strtol+0x11a>
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
40008e1f:	8b 45 08             	mov    0x8(%ebp),%eax
40008e22:	8a 00                	mov    (%eax),%al
40008e24:	3c 2f                	cmp    $0x2f,%al
40008e26:	7e 2c                	jle    40008e54 <strtol+0x70>
40008e28:	8b 45 08             	mov    0x8(%ebp),%eax
40008e2b:	8a 00                	mov    (%eax),%al
40008e2d:	3c 39                	cmp    $0x39,%al
40008e2f:	7f 23                	jg     40008e54 <strtol+0x70>
40008e31:	8b 45 08             	mov    0x8(%ebp),%eax
40008e34:	8a 00                	mov    (%eax),%al
40008e36:	0f be c0             	movsbl %al,%eax
40008e39:	83 e8 30             	sub    $0x30,%eax
40008e3c:	3b 45 10             	cmp    0x10(%ebp),%eax
40008e3f:	7d 13                	jge    40008e54 <strtol+0x70>
 *     This product includes software developed by the tyndur Project
 *     and its contributors.
40008e41:	8b 45 08             	mov    0x8(%ebp),%eax
40008e44:	8a 00                	mov    (%eax),%al
40008e46:	0f be c0             	movsbl %al,%eax
40008e49:	83 e8 30             	sub    $0x30,%eax
40008e4c:	89 45 fc             	mov    %eax,-0x4(%ebp)
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
40008e4f:	e9 9a 00 00 00       	jmp    40008eee <strtol+0x10a>
 *     This product includes software developed by the tyndur Project
 *     and its contributors.
 * 4. Neither the name of the tyndur Project nor the names of its
 *    contributors may be used to endorse or promote products derived
40008e54:	8b 45 08             	mov    0x8(%ebp),%eax
40008e57:	8a 00                	mov    (%eax),%al
40008e59:	3c 60                	cmp    $0x60,%al
40008e5b:	7e 09                	jle    40008e66 <strtol+0x82>
40008e5d:	8b 45 08             	mov    0x8(%ebp),%eax
40008e60:	8a 00                	mov    (%eax),%al
40008e62:	3c 7a                	cmp    $0x7a,%al
40008e64:	7e 1a                	jle    40008e80 <strtol+0x9c>
40008e66:	8b 45 08             	mov    0x8(%ebp),%eax
40008e69:	8a 00                	mov    (%eax),%al
40008e6b:	3c 40                	cmp    $0x40,%al
40008e6d:	0f 8e 98 00 00 00    	jle    40008f0b <strtol+0x127>
40008e73:	8b 45 08             	mov    0x8(%ebp),%eax
40008e76:	8a 00                	mov    (%eax),%al
40008e78:	3c 5a                	cmp    $0x5a,%al
40008e7a:	0f 8f 8b 00 00 00    	jg     40008f0b <strtol+0x127>
40008e80:	8b 45 08             	mov    0x8(%ebp),%eax
40008e83:	8a 00                	mov    (%eax),%al
40008e85:	3c 40                	cmp    $0x40,%al
40008e87:	7e 19                	jle    40008ea2 <strtol+0xbe>
40008e89:	8b 45 08             	mov    0x8(%ebp),%eax
40008e8c:	8a 00                	mov    (%eax),%al
40008e8e:	3c 5a                	cmp    $0x5a,%al
40008e90:	7f 10                	jg     40008ea2 <strtol+0xbe>
40008e92:	8b 45 08             	mov    0x8(%ebp),%eax
40008e95:	8a 00                	mov    (%eax),%al
40008e97:	0f be c0             	movsbl %al,%eax
40008e9a:	83 e8 37             	sub    $0x37,%eax
40008e9d:	89 45 e8             	mov    %eax,-0x18(%ebp)
40008ea0:	eb 0e                	jmp    40008eb0 <strtol+0xcc>
40008ea2:	8b 45 08             	mov    0x8(%ebp),%eax
40008ea5:	8a 00                	mov    (%eax),%al
40008ea7:	0f be c0             	movsbl %al,%eax
40008eaa:	83 e8 57             	sub    $0x57,%eax
40008ead:	89 45 e8             	mov    %eax,-0x18(%ebp)
40008eb0:	8b 45 e8             	mov    -0x18(%ebp),%eax
40008eb3:	3b 45 10             	cmp    0x10(%ebp),%eax
40008eb6:	7d 53                	jge    40008f0b <strtol+0x127>
 *    from this software without specific prior written permission.
 *
40008eb8:	8b 45 08             	mov    0x8(%ebp),%eax
40008ebb:	8a 00                	mov    (%eax),%al
40008ebd:	3c 40                	cmp    $0x40,%al
40008ebf:	7e 19                	jle    40008eda <strtol+0xf6>
40008ec1:	8b 45 08             	mov    0x8(%ebp),%eax
40008ec4:	8a 00                	mov    (%eax),%al
40008ec6:	3c 5a                	cmp    $0x5a,%al
40008ec8:	7f 10                	jg     40008eda <strtol+0xf6>
40008eca:	8b 45 08             	mov    0x8(%ebp),%eax
40008ecd:	8a 00                	mov    (%eax),%al
40008ecf:	0f be c0             	movsbl %al,%eax
40008ed2:	83 e8 37             	sub    $0x37,%eax
40008ed5:	89 45 ec             	mov    %eax,-0x14(%ebp)
40008ed8:	eb 0e                	jmp    40008ee8 <strtol+0x104>
40008eda:	8b 45 08             	mov    0x8(%ebp),%eax
40008edd:	8a 00                	mov    (%eax),%al
40008edf:	0f be c0             	movsbl %al,%eax
40008ee2:	83 e8 57             	sub    $0x57,%eax
40008ee5:	89 45 ec             	mov    %eax,-0x14(%ebp)
40008ee8:	8b 45 ec             	mov    -0x14(%ebp),%eax
40008eeb:	89 45 fc             	mov    %eax,-0x4(%ebp)
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
40008eee:	8b 45 f8             	mov    -0x8(%ebp),%eax
40008ef1:	0f af 45 10          	imul   0x10(%ebp),%eax
40008ef5:	03 45 fc             	add    -0x4(%ebp),%eax
40008ef8:	89 45 f8             	mov    %eax,-0x8(%ebp)
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
40008efb:	ff 45 08             	incl   0x8(%ebp)
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
40008efe:	8b 45 08             	mov    0x8(%ebp),%eax
40008f01:	8a 00                	mov    (%eax),%al
40008f03:	84 c0                	test   %al,%al
40008f05:	0f 85 14 ff ff ff    	jne    40008e1f <strtol+0x3b>
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
40008f0b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
40008f0f:	74 08                	je     40008f19 <strtol+0x135>
 */

40008f11:	8b 55 0c             	mov    0xc(%ebp),%edx
40008f14:	8b 45 08             	mov    0x8(%ebp),%eax
40008f17:	89 02                	mov    %eax,(%edx)
#include <stdio.h>
#include <stdlib.h>

40008f19:	8b 45 f8             	mov    -0x8(%ebp),%eax
#include "cdi.h"
40008f1c:	c9                   	leave  
40008f1d:	c3                   	ret    
40008f1e:	90                   	nop    
40008f1f:	90                   	nop    

40008f20 <memchr>:
#include "cdi/storage.h"
#include "cdi/misc.h"
40008f20:	55                   	push   %ebp
40008f21:	89 e5                	mov    %esp,%ebp
40008f23:	83 ec 18             	sub    $0x18,%esp
40008f26:	8b 45 0c             	mov    0xc(%ebp),%eax
40008f29:	88 45 ec             	mov    %al,-0x14(%ebp)
#include "cdi/io.h"
40008f2c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
40008f30:	74 2a                	je     40008f5c <memchr+0x3c>

40008f32:	8b 45 08             	mov    0x8(%ebp),%eax
40008f35:	89 45 fc             	mov    %eax,-0x4(%ebp)
#include "device.h"


40008f38:	8b 45 fc             	mov    -0x4(%ebp),%eax
40008f3b:	8a 00                	mov    (%eax),%al
40008f3d:	3a 45 ec             	cmp    -0x14(%ebp),%al
40008f40:	0f 94 c0             	sete   %al
40008f43:	ff 45 fc             	incl   -0x4(%ebp)
40008f46:	84 c0                	test   %al,%al
40008f48:	74 09                	je     40008f53 <memchr+0x33>
/**
40008f4a:	8b 45 fc             	mov    -0x4(%ebp),%eax
40008f4d:	48                   	dec    %eax
40008f4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
40008f51:	eb 10                	jmp    40008f63 <memchr+0x43>
 * ATA-Geraet identifizieren
40008f53:	ff 4d 10             	decl   0x10(%ebp)
40008f56:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
40008f5a:	75 dc                	jne    40008f38 <memchr+0x18>
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
40008f5c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40008f63:	8b 45 e8             	mov    -0x18(%ebp),%eax
 */
40008f66:	c9                   	leave  
40008f67:	c3                   	ret    

40008f68 <memcpy>:
        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
40008f68:	55                   	push   %ebp
40008f69:	89 e5                	mov    %esp,%ebp
40008f6b:	83 ec 10             	sub    $0x10,%esp
        .registers.ata.command = IDENTIFY_DEVICE,
40008f6e:	8b 45 08             	mov    0x8(%ebp),%eax
40008f71:	89 45 f4             	mov    %eax,-0xc(%ebp)
        .block_count = 1,
40008f74:	8b 45 0c             	mov    0xc(%ebp),%eax
40008f77:	89 45 f8             	mov    %eax,-0x8(%ebp)
        .block_size = ATA_SECTOR_SIZE,
        .buffer = buffer,

40008f7a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
40008f7e:	0f 84 89 01 00 00    	je     4000910d <memcpy+0x1a5>
40008f84:	8b 45 f4             	mov    -0xc(%ebp),%eax
40008f87:	3b 45 f8             	cmp    -0x8(%ebp),%eax
40008f8a:	0f 84 7d 01 00 00    	je     4000910d <memcpy+0x1a5>
    // Request starten
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
    }
40008f90:	8b 45 f4             	mov    -0xc(%ebp),%eax
40008f93:	89 c2                	mov    %eax,%edx
40008f95:	8b 45 f8             	mov    -0x8(%ebp),%eax
40008f98:	39 c2                	cmp    %eax,%edx
40008f9a:	0f 83 bd 00 00 00    	jae    4000905d <memcpy+0xf5>
        
    // Ein ATA-Geraet
    dev->atapi = 0;

40008fa0:	8b 45 f8             	mov    -0x8(%ebp),%eax
40008fa3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    // TODO: Informationen verarbeiten
40008fa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
40008fa9:	0b 45 fc             	or     -0x4(%ebp),%eax
40008fac:	83 e0 01             	and    $0x1,%eax
40008faf:	84 c0                	test   %al,%al
40008fb1:	74 4e                	je     40009001 <memcpy+0x99>

    return 1;
}

/**
40008fb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
40008fb6:	33 45 fc             	xor    -0x4(%ebp),%eax
40008fb9:	83 e0 01             	and    $0x1,%eax
40008fbc:	84 c0                	test   %al,%al
40008fbe:	75 06                	jne    40008fc6 <memcpy+0x5e>
40008fc0:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
40008fc4:	77 08                	ja     40008fce <memcpy+0x66>
 * Sektoren von einem ATA-Geraet lesen
40008fc6:	8b 45 10             	mov    0x10(%ebp),%eax
40008fc9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    // TODO: Informationen verarbeiten

    return 1;
}

/**
40008fcc:	eb 14                	jmp    40008fe2 <memcpy+0x7a>
 * Sektoren von einem ATA-Geraet lesen
 *
 * @param start LBA des Startsektors
40008fce:	8b 45 fc             	mov    -0x4(%ebp),%eax
40008fd1:	83 e0 01             	and    $0x1,%eax
40008fd4:	ba 02 00 00 00       	mov    $0x2,%edx
40008fd9:	89 d1                	mov    %edx,%ecx
40008fdb:	29 c1                	sub    %eax,%ecx
40008fdd:	89 c8                	mov    %ecx,%eax
40008fdf:	89 45 fc             	mov    %eax,-0x4(%ebp)
 * @param count Anzahl der Sektoren
40008fe2:	8b 45 fc             	mov    -0x4(%ebp),%eax
40008fe5:	29 45 10             	sub    %eax,0x10(%ebp)
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
40008fe8:	8b 45 f8             	mov    -0x8(%ebp),%eax
40008feb:	8a 10                	mov    (%eax),%dl
40008fed:	8b 45 f4             	mov    -0xc(%ebp),%eax
40008ff0:	88 10                	mov    %dl,(%eax)
40008ff2:	ff 45 f4             	incl   -0xc(%ebp)
40008ff5:	ff 45 f8             	incl   -0x8(%ebp)
40008ff8:	ff 4d fc             	decl   -0x4(%ebp)
40008ffb:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40008fff:	75 e7                	jne    40008fe8 <memcpy+0x80>
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
40009001:	8b 45 10             	mov    0x10(%ebp),%eax
40009004:	d1 e8                	shr    %eax
40009006:	89 45 fc             	mov    %eax,-0x4(%ebp)
{
40009009:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
4000900d:	74 1d                	je     4000902c <memcpy+0xc4>
4000900f:	8b 45 f4             	mov    -0xc(%ebp),%eax
40009012:	8b 55 f8             	mov    -0x8(%ebp),%edx
40009015:	66 8b 12             	mov    (%edx),%dx
40009018:	66 89 10             	mov    %dx,(%eax)
4000901b:	83 45 f8 02          	addl   $0x2,-0x8(%ebp)
4000901f:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
40009023:	ff 4d fc             	decl   -0x4(%ebp)
40009026:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
4000902a:	75 e3                	jne    4000900f <memcpy+0xa7>
    int result = 1;
4000902c:	8b 45 10             	mov    0x10(%ebp),%eax
4000902f:	83 e0 01             	and    $0x1,%eax
40009032:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct ata_request request;
40009035:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40009039:	0f 84 ce 00 00 00    	je     4000910d <memcpy+0x1a5>
4000903f:	8b 45 f8             	mov    -0x8(%ebp),%eax
40009042:	8a 10                	mov    (%eax),%dl
40009044:	8b 45 f4             	mov    -0xc(%ebp),%eax
40009047:	88 10                	mov    %dl,(%eax)
40009049:	ff 45 f4             	incl   -0xc(%ebp)
4000904c:	ff 45 f8             	incl   -0x8(%ebp)
4000904f:	ff 4d fc             	decl   -0x4(%ebp)
40009052:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40009056:	75 e7                	jne    4000903f <memcpy+0xd7>
40009058:	e9 b0 00 00 00       	jmp    4000910d <memcpy+0x1a5>
    // muss unter Umstaenden mehrmals gelesen werden.
    uint16_t current_count;
    void* current_buffer = buffer;
    uint64_t lba = start;

    // Anzahl der Sektoren die noch uebrig sind
4000905d:	8b 45 10             	mov    0x10(%ebp),%eax
40009060:	01 45 f8             	add    %eax,-0x8(%ebp)
    size_t count_left = count;
40009063:	8b 45 10             	mov    0x10(%ebp),%eax
40009066:	01 45 f4             	add    %eax,-0xc(%ebp)

40009069:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000906c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    // Solange wie noch Sektoren uebrig sind, wird gelesen
4000906f:	8b 45 f4             	mov    -0xc(%ebp),%eax
40009072:	0b 45 fc             	or     -0x4(%ebp),%eax
40009075:	83 e0 01             	and    $0x1,%eax
40009078:	84 c0                	test   %al,%al
4000907a:	74 3e                	je     400090ba <memcpy+0x152>
    while (count_left > 0) {
4000907c:	8b 45 f4             	mov    -0xc(%ebp),%eax
4000907f:	33 45 fc             	xor    -0x4(%ebp),%eax
40009082:	83 e0 01             	and    $0x1,%eax
40009085:	84 c0                	test   %al,%al
40009087:	75 06                	jne    4000908f <memcpy+0x127>
40009089:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
4000908d:	77 08                	ja     40009097 <memcpy+0x12f>
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
4000908f:	8b 45 10             	mov    0x10(%ebp),%eax
40009092:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // Anzahl der Sektoren die noch uebrig sind
    size_t count_left = count;

    // Solange wie noch Sektoren uebrig sind, wird gelesen
    while (count_left > 0) {
40009095:	eb 04                	jmp    4000909b <memcpy+0x133>
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
        if (count_left > 256) {
            current_count = 256;
40009097:	83 65 fc 01          	andl   $0x1,-0x4(%ebp)
        } else {
4000909b:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000909e:	29 45 10             	sub    %eax,0x10(%ebp)
            current_count = count_left;
400090a1:	ff 4d f4             	decl   -0xc(%ebp)
400090a4:	ff 4d f8             	decl   -0x8(%ebp)
400090a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
400090aa:	8a 10                	mov    (%eax),%dl
400090ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
400090af:	88 10                	mov    %dl,(%eax)
400090b1:	ff 4d fc             	decl   -0x4(%ebp)
400090b4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
400090b8:	75 e7                	jne    400090a1 <memcpy+0x139>
        }
        
400090ba:	8b 45 10             	mov    0x10(%ebp),%eax
400090bd:	d1 e8                	shr    %eax
400090bf:	89 45 fc             	mov    %eax,-0x4(%ebp)
        // Request vorbereiten
400090c2:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
400090c6:	74 1d                	je     400090e5 <memcpy+0x17d>
400090c8:	83 6d f8 02          	subl   $0x2,-0x8(%ebp)
400090cc:	83 6d f4 02          	subl   $0x2,-0xc(%ebp)
400090d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
400090d3:	8b 55 f8             	mov    -0x8(%ebp),%edx
400090d6:	66 8b 12             	mov    (%edx),%dx
400090d9:	66 89 10             	mov    %dx,(%eax)
400090dc:	ff 4d fc             	decl   -0x4(%ebp)
400090df:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
400090e3:	75 e3                	jne    400090c8 <memcpy+0x160>
        request.dev = dev;
400090e5:	8b 45 10             	mov    0x10(%ebp),%eax
400090e8:	83 e0 01             	and    $0x1,%eax
400090eb:	89 45 fc             	mov    %eax,-0x4(%ebp)
        // TODO: DMA, UltraDMA...
400090ee:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
400090f2:	74 19                	je     4000910d <memcpy+0x1a5>
400090f4:	ff 4d f4             	decl   -0xc(%ebp)
400090f7:	ff 4d f8             	decl   -0x8(%ebp)
400090fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
400090fd:	8a 10                	mov    (%eax),%dl
400090ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
40009102:	88 10                	mov    %dl,(%eax)
40009104:	ff 4d fc             	decl   -0x4(%ebp)
40009107:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
4000910b:	75 e7                	jne    400090f4 <memcpy+0x18c>
        request.protocol = PIO;
        request.flags.direction = READ;
        // FIXME
        request.flags.poll = 1;
4000910d:	8b 45 08             	mov    0x8(%ebp),%eax
        request.flags.ata = 0;
        request.flags.lba = 1;

        request.registers.ata.command = READ_SECTORS;
40009110:	c9                   	leave  
40009111:	c3                   	ret    
40009112:	90                   	nop    
40009113:	90                   	nop    

40009114 <memset>:
    uint8_t buffer[ATA_SECTOR_SIZE];

    // Request vorbereiten
    struct ata_request request = {
        .dev = dev,

40009114:	55                   	push   %ebp
40009115:	89 e5                	mov    %esp,%ebp
40009117:	83 ec 14             	sub    $0x14,%esp
        .flags.poll = 1,
        .flags.lba = 0,

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
4000911a:	8b 45 08             	mov    0x8(%ebp),%eax
4000911d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
    }
        
40009120:	83 7d 10 0b          	cmpl   $0xb,0x10(%ebp)
40009124:	77 23                	ja     40009149 <memset+0x35>
    // Ein ATA-Geraet
40009126:	eb 10                	jmp    40009138 <memset+0x24>
    dev->atapi = 0;
40009128:	8b 45 0c             	mov    0xc(%ebp),%eax
4000912b:	88 c2                	mov    %al,%dl
4000912d:	8b 45 fc             	mov    -0x4(%ebp),%eax
40009130:	88 10                	mov    %dl,(%eax)
40009132:	ff 45 fc             	incl   -0x4(%ebp)

40009135:	ff 4d 10             	decl   0x10(%ebp)
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
    }
        
    // Ein ATA-Geraet
40009138:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
4000913c:	75 ea                	jne    40009128 <memset+0x14>
    dev->atapi = 0;

    // TODO: Informationen verarbeiten

4000913e:	8b 45 08             	mov    0x8(%ebp),%eax
40009141:	89 45 ec             	mov    %eax,-0x14(%ebp)
40009144:	e9 a0 00 00 00       	jmp    400091e9 <memset+0xd5>
    return 1;
}

/**
40009149:	8b 45 0c             	mov    0xc(%ebp),%eax
4000914c:	0f b6 c0             	movzbl %al,%eax
4000914f:	89 45 f8             	mov    %eax,-0x8(%ebp)
40009152:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40009156:	74 12                	je     4000916a <memset+0x56>
 * Sektoren von einem ATA-Geraet lesen
40009158:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000915b:	c1 e0 08             	shl    $0x8,%eax
4000915e:	09 45 f8             	or     %eax,-0x8(%ebp)
 *
 * @param start LBA des Startsektors
40009161:	8b 45 f8             	mov    -0x8(%ebp),%eax
40009164:	c1 e0 10             	shl    $0x10,%eax
40009167:	09 45 f8             	or     %eax,-0x8(%ebp)
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
{
4000916a:	8b 45 fc             	mov    -0x4(%ebp),%eax
4000916d:	83 e0 03             	and    $0x3,%eax
40009170:	89 45 f4             	mov    %eax,-0xc(%ebp)
40009173:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
40009177:	74 27                	je     400091a0 <memset+0x8c>
    int result = 1;
40009179:	b8 04 00 00 00       	mov    $0x4,%eax
4000917e:	2b 45 f4             	sub    -0xc(%ebp),%eax
40009181:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct ata_request request;
40009184:	8b 45 f4             	mov    -0xc(%ebp),%eax
40009187:	29 45 10             	sub    %eax,0x10(%ebp)
    // Da nicht mehr als 256 Sektoren auf einmal gelesen werden koennen,
    // muss unter Umstaenden mehrmals gelesen werden.
4000918a:	8b 45 0c             	mov    0xc(%ebp),%eax
4000918d:	88 c2                	mov    %al,%dl
4000918f:	8b 45 fc             	mov    -0x4(%ebp),%eax
40009192:	88 10                	mov    %dl,(%eax)
40009194:	ff 45 fc             	incl   -0x4(%ebp)
    uint16_t current_count;
40009197:	ff 4d f4             	decl   -0xc(%ebp)
4000919a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
4000919e:	75 ea                	jne    4000918a <memset+0x76>
    void* current_buffer = buffer;
    uint64_t lba = start;

    // Anzahl der Sektoren die noch uebrig sind
400091a0:	8b 45 10             	mov    0x10(%ebp),%eax
400091a3:	c1 e8 02             	shr    $0x2,%eax
400091a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t count_left = count;

400091a9:	8b 55 fc             	mov    -0x4(%ebp),%edx
400091ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
400091af:	89 02                	mov    %eax,(%edx)
    // Solange wie noch Sektoren uebrig sind, wird gelesen
400091b1:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
    while (count_left > 0) {
400091b5:	ff 4d f4             	decl   -0xc(%ebp)
400091b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
400091bc:	75 eb                	jne    400091a9 <memset+0x95>
        // Entscheiden wieviele Sektoren im aktuellen Durchlauf gelesen werden
        if (count_left > 256) {
            current_count = 256;
400091be:	8b 45 10             	mov    0x10(%ebp),%eax
400091c1:	83 e0 03             	and    $0x3,%eax
400091c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
        } else {
400091c7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
400091cb:	74 16                	je     400091e3 <memset+0xcf>
            current_count = count_left;
        }
400091cd:	8b 45 0c             	mov    0xc(%ebp),%eax
400091d0:	88 c2                	mov    %al,%dl
400091d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
400091d5:	88 10                	mov    %dl,(%eax)
400091d7:	ff 45 fc             	incl   -0x4(%ebp)
        
400091da:	ff 4d f4             	decl   -0xc(%ebp)
400091dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
400091e1:	75 ea                	jne    400091cd <memset+0xb9>
        // Request vorbereiten
400091e3:	8b 45 08             	mov    0x8(%ebp),%eax
400091e6:	89 45 ec             	mov    %eax,-0x14(%ebp)
400091e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
        request.dev = dev;
400091ec:	c9                   	leave  
400091ed:	c3                   	ret    
400091ee:	90                   	nop    
400091ef:	90                   	nop    

400091f0 <strcmp>:
#include <stdlib.h>

#include "cdi.h"
#include "cdi/storage.h"
#include "cdi/misc.h"
#include "cdi/io.h"
400091f0:	55                   	push   %ebp
400091f1:	89 e5                	mov    %esp,%ebp
400091f3:	83 ec 04             	sub    $0x4,%esp

400091f6:	eb 1a                	jmp    40009212 <strcmp+0x22>
#include "device.h"
400091f8:	8b 45 08             	mov    0x8(%ebp),%eax
400091fb:	8a 00                	mov    (%eax),%al
400091fd:	84 c0                	test   %al,%al
400091ff:	0f 94 c0             	sete   %al
40009202:	ff 45 08             	incl   0x8(%ebp)
40009205:	84 c0                	test   %al,%al
40009207:	74 09                	je     40009212 <strcmp+0x22>

40009209:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40009210:	eb 2e                	jmp    40009240 <strcmp+0x50>

#include "cdi.h"
#include "cdi/storage.h"
#include "cdi/misc.h"
#include "cdi/io.h"

40009212:	8b 45 08             	mov    0x8(%ebp),%eax
40009215:	8a 10                	mov    (%eax),%dl
40009217:	8b 45 0c             	mov    0xc(%ebp),%eax
4000921a:	8a 00                	mov    (%eax),%al
4000921c:	38 c2                	cmp    %al,%dl
4000921e:	0f 94 c0             	sete   %al
40009221:	ff 45 0c             	incl   0xc(%ebp)
40009224:	84 c0                	test   %al,%al
40009226:	75 d0                	jne    400091f8 <strcmp+0x8>
#include "device.h"


40009228:	8b 45 08             	mov    0x8(%ebp),%eax
4000922b:	8a 00                	mov    (%eax),%al
4000922d:	0f b6 d0             	movzbl %al,%edx
40009230:	8b 45 0c             	mov    0xc(%ebp),%eax
40009233:	48                   	dec    %eax
40009234:	8a 00                	mov    (%eax),%al
40009236:	0f b6 c0             	movzbl %al,%eax
40009239:	89 d1                	mov    %edx,%ecx
4000923b:	29 c1                	sub    %eax,%ecx
4000923d:	89 4d fc             	mov    %ecx,-0x4(%ebp)
40009240:	8b 45 fc             	mov    -0x4(%ebp),%eax
/**
40009243:	c9                   	leave  
40009244:	c3                   	ret    
40009245:	90                   	nop    
40009246:	90                   	nop    
40009247:	90                   	nop    

40009248 <strcpy>:
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

40009248:	55                   	push   %ebp
40009249:	89 e5                	mov    %esp,%ebp
4000924b:	83 ec 10             	sub    $0x10,%esp
#include <stdio.h>
4000924e:	8b 45 08             	mov    0x8(%ebp),%eax
40009251:	89 45 fc             	mov    %eax,-0x4(%ebp)
#include <stdlib.h>

40009254:	eb 06                	jmp    4000925c <strcpy+0x14>
40009256:	ff 45 0c             	incl   0xc(%ebp)
40009259:	ff 45 08             	incl   0x8(%ebp)
4000925c:	8b 45 0c             	mov    0xc(%ebp),%eax
4000925f:	8a 10                	mov    (%eax),%dl
40009261:	8b 45 08             	mov    0x8(%ebp),%eax
40009264:	88 10                	mov    %dl,(%eax)
40009266:	8b 45 08             	mov    0x8(%ebp),%eax
40009269:	8a 00                	mov    (%eax),%al
4000926b:	84 c0                	test   %al,%al
4000926d:	75 e7                	jne    40009256 <strcpy+0xe>
#include "cdi.h"
4000926f:	8b 45 fc             	mov    -0x4(%ebp),%eax
#include "cdi/storage.h"
40009272:	c9                   	leave  
40009273:	c3                   	ret    

40009274 <strlen>:
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
40009274:	55                   	push   %ebp
40009275:	89 e5                	mov    %esp,%ebp
40009277:	83 ec 10             	sub    $0x10,%esp
#include <stdlib.h>

#include "cdi.h"
4000927a:	8b 45 08             	mov    0x8(%ebp),%eax
4000927d:	89 45 fc             	mov    %eax,-0x4(%ebp)
40009280:	eb 03                	jmp    40009285 <strlen+0x11>
40009282:	ff 45 fc             	incl   -0x4(%ebp)
40009285:	8b 45 fc             	mov    -0x4(%ebp),%eax
40009288:	8a 00                	mov    (%eax),%al
4000928a:	84 c0                	test   %al,%al
4000928c:	75 f4                	jne    40009282 <strlen+0xe>
#include "cdi/storage.h"
4000928e:	8b 55 fc             	mov    -0x4(%ebp),%edx
40009291:	8b 45 08             	mov    0x8(%ebp),%eax
40009294:	89 d1                	mov    %edx,%ecx
40009296:	29 c1                	sub    %eax,%ecx
40009298:	89 c8                	mov    %ecx,%eax
#include "cdi/misc.h"
4000929a:	c9                   	leave  
4000929b:	c3                   	ret    

4000929c <strncmp>:
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <stdlib.h>
4000929c:	55                   	push   %ebp
4000929d:	89 e5                	mov    %esp,%ebp
4000929f:	83 ec 04             	sub    $0x4,%esp

#include "cdi.h"
400092a2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
400092a6:	75 09                	jne    400092b1 <strncmp+0x15>
#include "cdi/storage.h"
400092a8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
400092af:	eb 51                	jmp    40009302 <strncmp+0x66>
#include "cdi/misc.h"
#include "cdi/io.h"
400092b1:	8b 45 08             	mov    0x8(%ebp),%eax
400092b4:	8a 10                	mov    (%eax),%dl
400092b6:	8b 45 0c             	mov    0xc(%ebp),%eax
400092b9:	8a 00                	mov    (%eax),%al
400092bb:	38 c2                	cmp    %al,%dl
400092bd:	0f 95 c0             	setne  %al
400092c0:	ff 45 0c             	incl   0xc(%ebp)
400092c3:	84 c0                	test   %al,%al
400092c5:	74 1a                	je     400092e1 <strncmp+0x45>

400092c7:	8b 45 08             	mov    0x8(%ebp),%eax
400092ca:	8a 00                	mov    (%eax),%al
400092cc:	0f b6 d0             	movzbl %al,%edx
400092cf:	8b 45 0c             	mov    0xc(%ebp),%eax
400092d2:	48                   	dec    %eax
400092d3:	8a 00                	mov    (%eax),%al
400092d5:	0f b6 c0             	movzbl %al,%eax
400092d8:	89 d1                	mov    %edx,%ecx
400092da:	29 c1                	sub    %eax,%ecx
400092dc:	89 4d fc             	mov    %ecx,-0x4(%ebp)
400092df:	eb 21                	jmp    40009302 <strncmp+0x66>
#include "device.h"

400092e1:	8b 45 08             	mov    0x8(%ebp),%eax
400092e4:	8a 00                	mov    (%eax),%al
400092e6:	84 c0                	test   %al,%al
400092e8:	0f 94 c0             	sete   %al
400092eb:	ff 45 08             	incl   0x8(%ebp)
400092ee:	84 c0                	test   %al,%al
400092f0:	75 09                	jne    400092fb <strncmp+0x5f>

/**
400092f2:	ff 4d 10             	decl   0x10(%ebp)
400092f5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
400092f9:	75 b6                	jne    400092b1 <strncmp+0x15>
 * ATA-Geraet identifizieren
400092fb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40009302:	8b 45 fc             	mov    -0x4(%ebp),%eax
 *
40009305:	c9                   	leave  
40009306:	c3                   	ret    
40009307:	90                   	nop    

40009308 <strncpy>:
#include <stdlib.h>

#include "cdi.h"
#include "cdi/storage.h"
#include "cdi/misc.h"
#include "cdi/io.h"
40009308:	55                   	push   %ebp
40009309:	89 e5                	mov    %esp,%ebp
4000930b:	83 ec 10             	sub    $0x10,%esp

4000930e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
40009312:	74 49                	je     4000935d <strncpy+0x55>
#include "device.h"
40009314:	8b 45 08             	mov    0x8(%ebp),%eax
40009317:	89 45 f8             	mov    %eax,-0x8(%ebp)

4000931a:	8b 45 0c             	mov    0xc(%ebp),%eax
4000931d:	89 45 fc             	mov    %eax,-0x4(%ebp)

/**
 * ATA-Geraet identifizieren
40009320:	8b 45 fc             	mov    -0x4(%ebp),%eax
40009323:	8a 10                	mov    (%eax),%dl
40009325:	8b 45 f8             	mov    -0x8(%ebp),%eax
40009328:	88 10                	mov    %dl,(%eax)
4000932a:	8b 45 f8             	mov    -0x8(%ebp),%eax
4000932d:	8a 00                	mov    (%eax),%al
4000932f:	84 c0                	test   %al,%al
40009331:	0f 94 c0             	sete   %al
40009334:	ff 45 f8             	incl   -0x8(%ebp)
40009337:	ff 45 fc             	incl   -0x4(%ebp)
4000933a:	84 c0                	test   %al,%al
4000933c:	74 16                	je     40009354 <strncpy+0x4c>
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
4000933e:	eb 09                	jmp    40009349 <strncpy+0x41>
 */
40009340:	8b 45 f8             	mov    -0x8(%ebp),%eax
40009343:	c6 00 00             	movb   $0x0,(%eax)
40009346:	ff 45 f8             	incl   -0x8(%ebp)


/**
 * ATA-Geraet identifizieren
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
40009349:	ff 4d 10             	decl   0x10(%ebp)
4000934c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
40009350:	75 ee                	jne    40009340 <strncpy+0x38>
 */
int ata_drv_identify(struct ata_device* dev)
40009352:	eb 09                	jmp    4000935d <strncpy+0x55>
{
    uint8_t buffer[ATA_SECTOR_SIZE];
40009354:	ff 4d 10             	decl   0x10(%ebp)
40009357:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
4000935b:	75 c3                	jne    40009320 <strncpy+0x18>

    // Request vorbereiten
4000935d:	8b 45 08             	mov    0x8(%ebp),%eax
    struct ata_request request = {
40009360:	c9                   	leave  
40009361:	c3                   	ret    
40009362:	90                   	nop    
40009363:	90                   	nop    

40009364 <__strtok_r>:


/**
 * ATA-Geraet identifizieren
 *
 * @return 0 Wenn das Geraet erfolgreich identifiziert wurde, != 0 sonst
40009364:	55                   	push   %ebp
40009365:	89 e5                	mov    %esp,%ebp
40009367:	83 ec 14             	sub    $0x14,%esp
 */
int ata_drv_identify(struct ata_device* dev)
{
    uint8_t buffer[ATA_SECTOR_SIZE];
4000936a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
4000936e:	75 1a                	jne    4000938a <__strtok_r+0x26>
40009370:	8b 45 10             	mov    0x10(%ebp),%eax
40009373:	8b 00                	mov    (%eax),%eax
40009375:	89 45 08             	mov    %eax,0x8(%ebp)
40009378:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
4000937c:	75 0c                	jne    4000938a <__strtok_r+0x26>

4000937e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40009385:	e9 b3 00 00 00       	jmp    4000943d <__strtok_r+0xd9>
    // Request vorbereiten
    struct ata_request request = {
        .dev = dev,

        .flags.direction = READ,
        .flags.poll = 1,
4000938a:	8b 45 08             	mov    0x8(%ebp),%eax
4000938d:	8a 00                	mov    (%eax),%al
4000938f:	0f be c0             	movsbl %al,%eax
40009392:	89 45 f8             	mov    %eax,-0x8(%ebp)
40009395:	ff 45 08             	incl   0x8(%ebp)
        .flags.lba = 0,
40009398:	8b 45 0c             	mov    0xc(%ebp),%eax
4000939b:	89 45 f0             	mov    %eax,-0x10(%ebp)
4000939e:	eb 08                	jmp    400093a8 <__strtok_r+0x44>

400093a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
400093a3:	3b 45 fc             	cmp    -0x4(%ebp),%eax
400093a6:	74 e2                	je     4000938a <__strtok_r+0x26>
    struct ata_request request = {
        .dev = dev,

        .flags.direction = READ,
        .flags.poll = 1,
        .flags.lba = 0,
400093a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
400093ab:	8a 00                	mov    (%eax),%al
400093ad:	0f be c0             	movsbl %al,%eax
400093b0:	89 45 fc             	mov    %eax,-0x4(%ebp)
400093b3:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
400093b7:	0f 95 c0             	setne  %al
400093ba:	ff 45 f0             	incl   -0x10(%ebp)
400093bd:	84 c0                	test   %al,%al
400093bf:	75 df                	jne    400093a0 <__strtok_r+0x3c>

        // Die Identifikationsdaten werden ueber PIO DATA IN gelesen
        .protocol = PIO,
        .registers.ata.command = IDENTIFY_DEVICE,
        .block_count = 1,
400093c1:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
400093c5:	75 12                	jne    400093d9 <__strtok_r+0x75>
        .block_size = ATA_SECTOR_SIZE,
400093c7:	8b 45 10             	mov    0x10(%ebp),%eax
400093ca:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        .buffer = buffer,
400093d0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
400093d7:	eb 64                	jmp    4000943d <__strtok_r+0xd9>

        .error = 0
400093d9:	8b 45 08             	mov    0x8(%ebp),%eax
400093dc:	48                   	dec    %eax
400093dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    // Request starten
    if (!ata_request(&request)) {
        // Wenn ein Fehler aufgetreten ist, koennen wir es noch mit einem
        // IDENTIFY PACKET DEVICE probieren.
        return atapi_drv_identify(dev);
400093e0:	8b 45 08             	mov    0x8(%ebp),%eax
400093e3:	8a 00                	mov    (%eax),%al
400093e5:	0f be c0             	movsbl %al,%eax
400093e8:	89 45 f8             	mov    %eax,-0x8(%ebp)
400093eb:	ff 45 08             	incl   0x8(%ebp)
    }
400093ee:	8b 45 0c             	mov    0xc(%ebp),%eax
400093f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
        
    // Ein ATA-Geraet
400093f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
400093f7:	8a 00                	mov    (%eax),%al
400093f9:	0f be c0             	movsbl %al,%eax
400093fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
400093ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
40009402:	3b 45 f8             	cmp    -0x8(%ebp),%eax
40009405:	0f 94 c0             	sete   %al
40009408:	ff 45 f0             	incl   -0x10(%ebp)
4000940b:	84 c0                	test   %al,%al
4000940d:	74 26                	je     40009435 <__strtok_r+0xd1>
    dev->atapi = 0;
4000940f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
40009413:	75 09                	jne    4000941e <__strtok_r+0xba>

40009415:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
4000941c:	eb 07                	jmp    40009425 <__strtok_r+0xc1>
    // TODO: Informationen verarbeiten

4000941e:	8b 45 08             	mov    0x8(%ebp),%eax
40009421:	48                   	dec    %eax
40009422:	c6 00 00             	movb   $0x0,(%eax)
    return 1;
40009425:	8b 55 10             	mov    0x10(%ebp),%edx
40009428:	8b 45 08             	mov    0x8(%ebp),%eax
4000942b:	89 02                	mov    %eax,(%edx)
}
4000942d:	8b 45 f4             	mov    -0xc(%ebp),%eax
40009430:	89 45 ec             	mov    %eax,-0x14(%ebp)
40009433:	eb 08                	jmp    4000943d <__strtok_r+0xd9>

/**
40009435:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
40009439:	75 b9                	jne    400093f4 <__strtok_r+0x90>
 * Sektoren von einem ATA-Geraet lesen
4000943b:	eb a3                	jmp    400093e0 <__strtok_r+0x7c>
4000943d:	8b 45 ec             	mov    -0x14(%ebp),%eax
 *
 * @param start LBA des Startsektors
40009440:	c9                   	leave  
40009441:	c3                   	ret    

40009442 <strtok>:
 * @param count Anzahl der Sektoren
 * @param buffer Pointer auf den Puffer in dem die Daten abgelegt werden sollen
 *
 * @return 1 wenn die Blocks erfolgreich gelesen wurden, 0 sonst
40009442:	55                   	push   %ebp
40009443:	89 e5                	mov    %esp,%ebp
 */
int ata_drv_read_sectors(struct ata_device* dev, uint64_t start, size_t count,
    void* buffer)
40009445:	68 54 a6 00 40       	push   $0x4000a654
4000944a:	ff 75 0c             	pushl  0xc(%ebp)
4000944d:	ff 75 08             	pushl  0x8(%ebp)
40009450:	e8 0f ff ff ff       	call   40009364 <__strtok_r>
40009455:	83 c4 0c             	add    $0xc,%esp
{
40009458:	c9                   	leave  
40009459:	c3                   	ret    
4000945a:	90                   	nop    
4000945b:	90                   	nop    

4000945c <__udivdi3>:
4000945c:	55                   	push   %ebp
4000945d:	89 e5                	mov    %esp,%ebp
4000945f:	57                   	push   %edi
40009460:	56                   	push   %esi
40009461:	83 ec 20             	sub    $0x20,%esp
40009464:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
4000946b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
40009472:	8b 45 10             	mov    0x10(%ebp),%eax
40009475:	8b 55 14             	mov    0x14(%ebp),%edx
40009478:	89 45 f4             	mov    %eax,-0xc(%ebp)
4000947b:	89 c1                	mov    %eax,%ecx
4000947d:	89 d7                	mov    %edx,%edi
4000947f:	8b 45 08             	mov    0x8(%ebp),%eax
40009482:	89 45 ec             	mov    %eax,-0x14(%ebp)
40009485:	8b 75 0c             	mov    0xc(%ebp),%esi
40009488:	85 d2                	test   %edx,%edx
4000948a:	75 20                	jne    400094ac <__udivdi3+0x50>
4000948c:	39 f1                	cmp    %esi,%ecx
4000948e:	76 48                	jbe    400094d8 <__udivdi3+0x7c>
40009490:	89 f2                	mov    %esi,%edx
40009492:	f7 f1                	div    %ecx
40009494:	89 c1                	mov    %eax,%ecx
40009496:	31 c0                	xor    %eax,%eax
40009498:	89 4d e0             	mov    %ecx,-0x20(%ebp)
4000949b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000949e:	8b 45 e0             	mov    -0x20(%ebp),%eax
400094a1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
400094a4:	83 c4 20             	add    $0x20,%esp
400094a7:	5e                   	pop    %esi
400094a8:	5f                   	pop    %edi
400094a9:	c9                   	leave  
400094aa:	c3                   	ret    
400094ab:	90                   	nop    
400094ac:	39 f2                	cmp    %esi,%edx
400094ae:	0f 87 ac 00 00 00    	ja     40009560 <__udivdi3+0x104>
400094b4:	0f bd c2             	bsr    %edx,%eax
400094b7:	83 f0 1f             	xor    $0x1f,%eax
400094ba:	89 45 e8             	mov    %eax,-0x18(%ebp)
400094bd:	75 41                	jne    40009500 <__udivdi3+0xa4>
400094bf:	39 f2                	cmp    %esi,%edx
400094c1:	72 0c                	jb     400094cf <__udivdi3+0x73>
400094c3:	8b 55 ec             	mov    -0x14(%ebp),%edx
400094c6:	39 55 f4             	cmp    %edx,-0xc(%ebp)
400094c9:	0f 87 91 00 00 00    	ja     40009560 <__udivdi3+0x104>
400094cf:	b9 01 00 00 00       	mov    $0x1,%ecx
400094d4:	31 c0                	xor    %eax,%eax
400094d6:	eb c0                	jmp    40009498 <__udivdi3+0x3c>
400094d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
400094db:	85 c0                	test   %eax,%eax
400094dd:	75 0c                	jne    400094eb <__udivdi3+0x8f>
400094df:	b8 01 00 00 00       	mov    $0x1,%eax
400094e4:	31 d2                	xor    %edx,%edx
400094e6:	f7 75 f4             	divl   -0xc(%ebp)
400094e9:	89 c1                	mov    %eax,%ecx
400094eb:	89 f0                	mov    %esi,%eax
400094ed:	89 fa                	mov    %edi,%edx
400094ef:	f7 f1                	div    %ecx
400094f1:	89 c6                	mov    %eax,%esi
400094f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
400094f6:	f7 f1                	div    %ecx
400094f8:	89 c1                	mov    %eax,%ecx
400094fa:	89 f0                	mov    %esi,%eax
400094fc:	eb 9a                	jmp    40009498 <__udivdi3+0x3c>
400094fe:	89 f6                	mov    %esi,%esi
40009500:	b8 20 00 00 00       	mov    $0x20,%eax
40009505:	2b 45 e8             	sub    -0x18(%ebp),%eax
40009508:	89 45 f0             	mov    %eax,-0x10(%ebp)
4000950b:	8b 55 f4             	mov    -0xc(%ebp),%edx
4000950e:	8a 4d f0             	mov    -0x10(%ebp),%cl
40009511:	d3 ea                	shr    %cl,%edx
40009513:	89 f8                	mov    %edi,%eax
40009515:	8a 4d e8             	mov    -0x18(%ebp),%cl
40009518:	d3 e0                	shl    %cl,%eax
4000951a:	09 c2                	or     %eax,%edx
4000951c:	89 55 dc             	mov    %edx,-0x24(%ebp)
4000951f:	8b 7d f4             	mov    -0xc(%ebp),%edi
40009522:	d3 e7                	shl    %cl,%edi
40009524:	8b 45 ec             	mov    -0x14(%ebp),%eax
40009527:	8a 4d f0             	mov    -0x10(%ebp),%cl
4000952a:	d3 e8                	shr    %cl,%eax
4000952c:	89 f2                	mov    %esi,%edx
4000952e:	8a 4d e8             	mov    -0x18(%ebp),%cl
40009531:	d3 e2                	shl    %cl,%edx
40009533:	09 d0                	or     %edx,%eax
40009535:	8a 4d f0             	mov    -0x10(%ebp),%cl
40009538:	d3 ee                	shr    %cl,%esi
4000953a:	89 75 d8             	mov    %esi,-0x28(%ebp)
4000953d:	89 f2                	mov    %esi,%edx
4000953f:	f7 75 dc             	divl   -0x24(%ebp)
40009542:	89 d1                	mov    %edx,%ecx
40009544:	89 45 d8             	mov    %eax,-0x28(%ebp)
40009547:	f7 e7                	mul    %edi
40009549:	89 c6                	mov    %eax,%esi
4000954b:	39 d1                	cmp    %edx,%ecx
4000954d:	72 29                	jb     40009578 <__udivdi3+0x11c>
4000954f:	39 ca                	cmp    %ecx,%edx
40009551:	74 16                	je     40009569 <__udivdi3+0x10d>
40009553:	8b 4d d8             	mov    -0x28(%ebp),%ecx
40009556:	31 c0                	xor    %eax,%eax
40009558:	e9 3b ff ff ff       	jmp    40009498 <__udivdi3+0x3c>
4000955d:	8d 76 00             	lea    0x0(%esi),%esi
40009560:	31 c9                	xor    %ecx,%ecx
40009562:	31 c0                	xor    %eax,%eax
40009564:	e9 2f ff ff ff       	jmp    40009498 <__udivdi3+0x3c>
40009569:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000956c:	8a 4d e8             	mov    -0x18(%ebp),%cl
4000956f:	d3 e0                	shl    %cl,%eax
40009571:	39 f0                	cmp    %esi,%eax
40009573:	73 de                	jae    40009553 <__udivdi3+0xf7>
40009575:	8d 76 00             	lea    0x0(%esi),%esi
40009578:	8b 4d d8             	mov    -0x28(%ebp),%ecx
4000957b:	49                   	dec    %ecx
4000957c:	31 c0                	xor    %eax,%eax
4000957e:	e9 15 ff ff ff       	jmp    40009498 <__udivdi3+0x3c>
40009583:	90                   	nop    

40009584 <__umoddi3>:
40009584:	55                   	push   %ebp
40009585:	89 e5                	mov    %esp,%ebp
40009587:	57                   	push   %edi
40009588:	56                   	push   %esi
40009589:	83 ec 30             	sub    $0x30,%esp
4000958c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
40009593:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
4000959a:	8b 75 08             	mov    0x8(%ebp),%esi
4000959d:	8b 7d 0c             	mov    0xc(%ebp),%edi
400095a0:	8b 45 10             	mov    0x10(%ebp),%eax
400095a3:	8b 55 14             	mov    0x14(%ebp),%edx
400095a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
400095a9:	89 c1                	mov    %eax,%ecx
400095ab:	89 55 e8             	mov    %edx,-0x18(%ebp)
400095ae:	89 75 e4             	mov    %esi,-0x1c(%ebp)
400095b1:	89 75 f0             	mov    %esi,-0x10(%ebp)
400095b4:	89 7d e0             	mov    %edi,-0x20(%ebp)
400095b7:	89 fa                	mov    %edi,%edx
400095b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
400095bc:	85 c0                	test   %eax,%eax
400095be:	75 14                	jne    400095d4 <__umoddi3+0x50>
400095c0:	39 f9                	cmp    %edi,%ecx
400095c2:	76 68                	jbe    4000962c <__umoddi3+0xa8>
400095c4:	89 f0                	mov    %esi,%eax
400095c6:	f7 f1                	div    %ecx
400095c8:	89 55 d0             	mov    %edx,-0x30(%ebp)
400095cb:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
400095d2:	eb 10                	jmp    400095e4 <__umoddi3+0x60>
400095d4:	8b 4d e0             	mov    -0x20(%ebp),%ecx
400095d7:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
400095da:	76 18                	jbe    400095f4 <__umoddi3+0x70>
400095dc:	89 75 d0             	mov    %esi,-0x30(%ebp)
400095df:	89 7d d4             	mov    %edi,-0x2c(%ebp)
400095e2:	89 f6                	mov    %esi,%esi
400095e4:	8b 45 d0             	mov    -0x30(%ebp),%eax
400095e7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
400095ea:	83 c4 30             	add    $0x30,%esp
400095ed:	5e                   	pop    %esi
400095ee:	5f                   	pop    %edi
400095ef:	c9                   	leave  
400095f0:	c3                   	ret    
400095f1:	8d 76 00             	lea    0x0(%esi),%esi
400095f4:	0f bd 45 e8          	bsr    -0x18(%ebp),%eax
400095f8:	83 f0 1f             	xor    $0x1f,%eax
400095fb:	89 45 d8             	mov    %eax,-0x28(%ebp)
400095fe:	75 54                	jne    40009654 <__umoddi3+0xd0>
40009600:	8b 45 e0             	mov    -0x20(%ebp),%eax
40009603:	39 45 e8             	cmp    %eax,-0x18(%ebp)
40009606:	72 08                	jb     40009610 <__umoddi3+0x8c>
40009608:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
4000960b:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
4000960e:	77 0f                	ja     4000961f <__umoddi3+0x9b>
40009610:	8b 55 e0             	mov    -0x20(%ebp),%edx
40009613:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40009616:	2b 45 ec             	sub    -0x14(%ebp),%eax
40009619:	1b 55 e8             	sbb    -0x18(%ebp),%edx
4000961c:	89 45 f0             	mov    %eax,-0x10(%ebp)
4000961f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40009622:	89 4d d0             	mov    %ecx,-0x30(%ebp)
40009625:	89 55 d4             	mov    %edx,-0x2c(%ebp)
40009628:	eb ba                	jmp    400095e4 <__umoddi3+0x60>
4000962a:	89 f6                	mov    %esi,%esi
4000962c:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000962f:	85 c0                	test   %eax,%eax
40009631:	75 0c                	jne    4000963f <__umoddi3+0xbb>
40009633:	b8 01 00 00 00       	mov    $0x1,%eax
40009638:	31 d2                	xor    %edx,%edx
4000963a:	f7 75 ec             	divl   -0x14(%ebp)
4000963d:	89 c1                	mov    %eax,%ecx
4000963f:	8b 45 e0             	mov    -0x20(%ebp),%eax
40009642:	8b 55 e8             	mov    -0x18(%ebp),%edx
40009645:	f7 f1                	div    %ecx
40009647:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000964a:	f7 f1                	div    %ecx
4000964c:	e9 77 ff ff ff       	jmp    400095c8 <__umoddi3+0x44>
40009651:	8d 76 00             	lea    0x0(%esi),%esi
40009654:	b8 20 00 00 00       	mov    $0x20,%eax
40009659:	2b 45 d8             	sub    -0x28(%ebp),%eax
4000965c:	89 45 dc             	mov    %eax,-0x24(%ebp)
4000965f:	8b 55 ec             	mov    -0x14(%ebp),%edx
40009662:	8a 4d dc             	mov    -0x24(%ebp),%cl
40009665:	d3 ea                	shr    %cl,%edx
40009667:	8b 45 e8             	mov    -0x18(%ebp),%eax
4000966a:	8a 4d d8             	mov    -0x28(%ebp),%cl
4000966d:	d3 e0                	shl    %cl,%eax
4000966f:	09 c2                	or     %eax,%edx
40009671:	89 55 f4             	mov    %edx,-0xc(%ebp)
40009674:	8b 7d ec             	mov    -0x14(%ebp),%edi
40009677:	d3 e7                	shl    %cl,%edi
40009679:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000967c:	8a 4d dc             	mov    -0x24(%ebp),%cl
4000967f:	d3 e8                	shr    %cl,%eax
40009681:	8b 55 e0             	mov    -0x20(%ebp),%edx
40009684:	8a 4d d8             	mov    -0x28(%ebp),%cl
40009687:	d3 e2                	shl    %cl,%edx
40009689:	09 d0                	or     %edx,%eax
4000968b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
4000968e:	d3 e6                	shl    %cl,%esi
40009690:	8b 55 e0             	mov    -0x20(%ebp),%edx
40009693:	8a 4d dc             	mov    -0x24(%ebp),%cl
40009696:	d3 ea                	shr    %cl,%edx
40009698:	f7 75 f4             	divl   -0xc(%ebp)
4000969b:	89 55 cc             	mov    %edx,-0x34(%ebp)
4000969e:	f7 e7                	mul    %edi
400096a0:	39 55 cc             	cmp    %edx,-0x34(%ebp)
400096a3:	72 37                	jb     400096dc <__umoddi3+0x158>
400096a5:	3b 55 cc             	cmp    -0x34(%ebp),%edx
400096a8:	74 2e                	je     400096d8 <__umoddi3+0x154>
400096aa:	8b 4d cc             	mov    -0x34(%ebp),%ecx
400096ad:	29 c6                	sub    %eax,%esi
400096af:	19 d1                	sbb    %edx,%ecx
400096b1:	89 4d cc             	mov    %ecx,-0x34(%ebp)
400096b4:	89 f2                	mov    %esi,%edx
400096b6:	8a 4d d8             	mov    -0x28(%ebp),%cl
400096b9:	d3 ea                	shr    %cl,%edx
400096bb:	8b 45 cc             	mov    -0x34(%ebp),%eax
400096be:	8a 4d dc             	mov    -0x24(%ebp),%cl
400096c1:	d3 e0                	shl    %cl,%eax
400096c3:	09 c2                	or     %eax,%edx
400096c5:	89 55 d0             	mov    %edx,-0x30(%ebp)
400096c8:	8b 45 cc             	mov    -0x34(%ebp),%eax
400096cb:	8a 4d d8             	mov    -0x28(%ebp),%cl
400096ce:	d3 e8                	shr    %cl,%eax
400096d0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
400096d3:	e9 0c ff ff ff       	jmp    400095e4 <__umoddi3+0x60>
400096d8:	39 c6                	cmp    %eax,%esi
400096da:	73 ce                	jae    400096aa <__umoddi3+0x126>
400096dc:	29 f8                	sub    %edi,%eax
400096de:	1b 55 f4             	sbb    -0xc(%ebp),%edx
400096e1:	eb c7                	jmp    400096aa <__umoddi3+0x126>
