
hw:     file format elf32-i386

Disassembly of section .init:

40000074 <.init>:
40000074:	e8 87 00 00 00       	call   40000100 <frame_dummy>
40000079:	e8 22 bb 00 00       	call   4000bba0 <__do_global_ctors_aux>
Disassembly of section .text:

40000080 <_start>:
40000080:	e8 1b 07 00 00       	call   400007a0 <__init>
40000085:	e8 d6 00 00 00       	call   40000160 <main>
4000008a:	50                   	push   %eax
4000008b:	e8 40 07 00 00       	call   400007d0 <__deinit>

40000090 <.wait>:
40000090:	eb fe                	jmp    40000090 <.wait>
40000092:	90                   	nop    
40000093:	90                   	nop    
40000094:	90                   	nop    
40000095:	90                   	nop    
40000096:	90                   	nop    
40000097:	90                   	nop    
40000098:	90                   	nop    
40000099:	90                   	nop    
4000009a:	90                   	nop    
4000009b:	90                   	nop    
4000009c:	90                   	nop    
4000009d:	90                   	nop    
4000009e:	90                   	nop    
4000009f:	90                   	nop    

400000a0 <__do_global_dtors_aux>:
400000a0:	55                   	push   %ebp
400000a1:	89 e5                	mov    %esp,%ebp
400000a3:	53                   	push   %ebx
400000a4:	83 ec 04             	sub    $0x4,%esp
400000a7:	e8 00 00 00 00       	call   400000ac <__do_global_dtors_aux+0xc>
400000ac:	5b                   	pop    %ebx
400000ad:	81 c3 78 cf 00 00    	add    $0xcf78,%ebx
400000b3:	80 bb bc 08 00 00 00 	cmpb   $0x0,0x8bc(%ebx)
400000ba:	74 0f                	je     400000cb <__do_global_dtors_aux+0x2b>
400000bc:	eb 3c                	jmp    400000fa <__do_global_dtors_aux+0x5a>
400000be:	66 90                	xchg   %ax,%ax
400000c0:	83 c0 04             	add    $0x4,%eax
400000c3:	89 83 20 00 00 00    	mov    %eax,0x20(%ebx)
400000c9:	ff d2                	call   *%edx
400000cb:	8b 83 20 00 00 00    	mov    0x20(%ebx),%eax
400000d1:	8b 10                	mov    (%eax),%edx
400000d3:	85 d2                	test   %edx,%edx
400000d5:	75 e9                	jne    400000c0 <__do_global_dtors_aux+0x20>
400000d7:	8b 83 f4 ff ff ff    	mov    -0xc(%ebx),%eax
400000dd:	85 c0                	test   %eax,%eax
400000df:	74 12                	je     400000f3 <__do_global_dtors_aux+0x53>
400000e1:	83 ec 0c             	sub    $0xc,%esp
400000e4:	8d 83 dc ff ff ff    	lea    -0x24(%ebx),%eax
400000ea:	50                   	push   %eax
400000eb:	e8 10 ff ff bf       	call   0 <_start-0x40000080>
400000f0:	83 c4 10             	add    $0x10,%esp
400000f3:	c6 83 bc 08 00 00 01 	movb   $0x1,0x8bc(%ebx)
400000fa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400000fd:	c9                   	leave  
400000fe:	c3                   	ret    
400000ff:	90                   	nop    

40000100 <frame_dummy>:
40000100:	55                   	push   %ebp
40000101:	89 e5                	mov    %esp,%ebp
40000103:	53                   	push   %ebx
40000104:	83 ec 04             	sub    $0x4,%esp
40000107:	e8 00 00 00 00       	call   4000010c <frame_dummy+0xc>
4000010c:	5b                   	pop    %ebx
4000010d:	81 c3 18 cf 00 00    	add    $0xcf18,%ebx
40000113:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
40000119:	85 c0                	test   %eax,%eax
4000011b:	74 18                	je     40000135 <frame_dummy+0x35>
4000011d:	8d 83 c0 08 00 00    	lea    0x8c0(%ebx),%eax
40000123:	51                   	push   %ecx
40000124:	51                   	push   %ecx
40000125:	50                   	push   %eax
40000126:	8d 83 dc ff ff ff    	lea    -0x24(%ebx),%eax
4000012c:	50                   	push   %eax
4000012d:	e8 ce fe ff bf       	call   0 <_start-0x40000080>
40000132:	83 c4 10             	add    $0x10,%esp
40000135:	8b 93 f0 ff ff ff    	mov    -0x10(%ebx),%edx
4000013b:	85 d2                	test   %edx,%edx
4000013d:	74 19                	je     40000158 <frame_dummy+0x58>
4000013f:	8b 93 f8 ff ff ff    	mov    -0x8(%ebx),%edx
40000145:	85 d2                	test   %edx,%edx
40000147:	74 0f                	je     40000158 <frame_dummy+0x58>
40000149:	83 ec 0c             	sub    $0xc,%esp
4000014c:	8d 83 f0 ff ff ff    	lea    -0x10(%ebx),%eax
40000152:	50                   	push   %eax
40000153:	ff d2                	call   *%edx
40000155:	83 c4 10             	add    $0x10,%esp
40000158:	8b 5d fc             	mov    -0x4(%ebp),%ebx
4000015b:	c9                   	leave  
4000015c:	c3                   	ret    
4000015d:	90                   	nop    
4000015e:	90                   	nop    
4000015f:	90                   	nop    

40000160 <main>:
40000160:	8d 4c 24 04          	lea    0x4(%esp),%ecx
40000164:	83 e4 f0             	and    $0xfffffff0,%esp
40000167:	ff 71 fc             	pushl  -0x4(%ecx)
4000016a:	55                   	push   %ebp
4000016b:	89 e5                	mov    %esp,%ebp
4000016d:	51                   	push   %ecx
4000016e:	83 ec 24             	sub    $0x24,%esp
40000171:	83 ec 0c             	sub    $0xc,%esp
40000174:	68 00 bc 00 40       	push   $0x4000bc00
40000179:	e8 82 0f 00 00       	call   40001100 <puts>
4000017e:	83 c4 10             	add    $0x10,%esp
40000181:	83 ec 0c             	sub    $0xc,%esp
40000184:	68 0d bc 00 40       	push   $0x4000bc0d
40000189:	e8 c2 0e 00 00       	call   40001050 <printf>
4000018e:	83 c4 10             	add    $0x10,%esp
40000191:	83 ec 08             	sub    $0x8,%esp
40000194:	8d 45 e8             	lea    -0x18(%ebp),%eax
40000197:	50                   	push   %eax
40000198:	68 20 bc 00 40       	push   $0x4000bc20
4000019d:	e8 ee 0f 00 00       	call   40001190 <scanf>
400001a2:	83 c4 10             	add    $0x10,%esp
400001a5:	83 ec 08             	sub    $0x8,%esp
400001a8:	8d 45 e8             	lea    -0x18(%ebp),%eax
400001ab:	50                   	push   %eax
400001ac:	68 23 bc 00 40       	push   $0x4000bc23
400001b1:	e8 9a 0e 00 00       	call   40001050 <printf>
400001b6:	83 c4 10             	add    $0x10,%esp
400001b9:	a1 60 d0 00 40       	mov    0x4000d060,%eax
400001be:	8b 40 08             	mov    0x8(%eax),%eax
400001c1:	83 ec 0c             	sub    $0xc,%esp
400001c4:	50                   	push   %eax
400001c5:	e8 26 00 00 00       	call   400001f0 <fflush>
400001ca:	83 c4 10             	add    $0x10,%esp
400001cd:	b8 00 00 00 00       	mov    $0x0,%eax
400001d2:	8b 4d fc             	mov    -0x4(%ebp),%ecx
400001d5:	c9                   	leave  
400001d6:	8d 61 fc             	lea    -0x4(%ecx),%esp
400001d9:	c3                   	ret    

400001da <_write>:
400001da:	55                   	push   %ebp
400001db:	89 e5                	mov    %esp,%ebp
400001dd:	b8 00 00 00 00       	mov    $0x0,%eax
400001e2:	5d                   	pop    %ebp
400001e3:	c3                   	ret    
400001e4:	90                   	nop    
400001e5:	90                   	nop    
400001e6:	90                   	nop    
400001e7:	90                   	nop    
400001e8:	90                   	nop    
400001e9:	90                   	nop    
400001ea:	90                   	nop    
400001eb:	90                   	nop    
400001ec:	90                   	nop    
400001ed:	90                   	nop    
400001ee:	90                   	nop    
400001ef:	90                   	nop    

400001f0 <fflush>:
/* Flush a single file, or (if fp is NULL) all files.  */

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
400001f0:	55                   	push   %ebp
400001f1:	89 e5                	mov    %esp,%ebp
400001f3:	57                   	push   %edi
400001f4:	56                   	push   %esi
400001f5:	53                   	push   %ebx
400001f6:	83 ec 0c             	sub    $0xc,%esp
400001f9:	8b 7d 08             	mov    0x8(%ebp),%edi
  register unsigned char *p;
  register int n, t;

  if (fp == NULL)
400001fc:	85 ff                	test   %edi,%edi
400001fe:	0f 84 3c 01 00 00    	je     40000340 <fflush+0x150>
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);
40000204:	a1 60 d0 00 40       	mov    0x4000d060,%eax
40000209:	85 c0                	test   %eax,%eax
4000020b:	74 0b                	je     40000218 <fflush+0x28>
4000020d:	8b 58 38             	mov    0x38(%eax),%ebx
40000210:	85 db                	test   %ebx,%ebx
40000212:	0f 84 f2 00 00 00    	je     4000030a <fflush+0x11a>

  _flockfile (fp);

  t = fp->_flags;
40000218:	8b 47 0c             	mov    0xc(%edi),%eax
4000021b:	0f bf d0             	movswl %ax,%edx
  if ((t & __SWR) == 0)
4000021e:	f6 c2 08             	test   $0x8,%dl
40000221:	74 5d                	je     40000280 <fflush+0x90>
            }
        } 
      _funlockfile (fp);
      return 0;
    }
  if ((p = fp->_bf._base) == NULL)
40000223:	8b 77 10             	mov    0x10(%edi),%esi
40000226:	85 f6                	test   %esi,%esi
40000228:	0f 84 d2 00 00 00    	je     40000300 <fflush+0x110>
    {
      /* Nothing to flush.  */
      _funlockfile (fp);
      return 0;
    }
  n = fp->_p - p;		/* write this much */
4000022e:	8b 1f                	mov    (%edi),%ebx
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
40000230:	31 c0                	xor    %eax,%eax
    {
      /* Nothing to flush.  */
      _funlockfile (fp);
      return 0;
    }
  n = fp->_p - p;		/* write this much */
40000232:	29 f3                	sub    %esi,%ebx
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
40000234:	83 e2 03             	and    $0x3,%edx
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
40000237:	89 37                	mov    %esi,(%edi)
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
40000239:	75 03                	jne    4000023e <fflush+0x4e>
4000023b:	8b 47 14             	mov    0x14(%edi),%eax
4000023e:	89 47 08             	mov    %eax,0x8(%edi)

  while (n > 0)
40000241:	85 db                	test   %ebx,%ebx
40000243:	7f 17                	jg     4000025c <fflush+0x6c>
40000245:	e9 b6 00 00 00       	jmp    40000300 <fflush+0x110>
4000024a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
	}
      p += t;
      n -= t;
40000250:	29 c3                	sub    %eax,%ebx
   * write function.
   */
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
40000252:	85 db                	test   %ebx,%ebx
40000254:	0f 8e a6 00 00 00    	jle    40000300 <fflush+0x110>
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
	}
      p += t;
4000025a:	01 c6                	add    %eax,%esi
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
    {
      t = (*fp->_write) (fp->_cookie, (char *) p, n);
4000025c:	52                   	push   %edx
4000025d:	53                   	push   %ebx
4000025e:	56                   	push   %esi
4000025f:	8b 47 1c             	mov    0x1c(%edi),%eax
40000262:	50                   	push   %eax
40000263:	ff 57 24             	call   *0x24(%edi)
      if (t <= 0)
40000266:	83 c4 10             	add    $0x10,%esp
40000269:	85 c0                	test   %eax,%eax
4000026b:	7f e3                	jg     40000250 <fflush+0x60>
	{
          fp->_flags |= __SERR;
4000026d:	66 83 4f 0c 40       	orw    $0x40,0xc(%edi)
40000272:	83 c8 ff             	or     $0xffffffff,%eax
      p += t;
      n -= t;
    }
  _funlockfile (fp);
  return 0;
}
40000275:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000278:	5b                   	pop    %ebx
40000279:	5e                   	pop    %esi
4000027a:	5f                   	pop    %edi
4000027b:	5d                   	pop    %ebp
4000027c:	c3                   	ret    
4000027d:	8d 76 00             	lea    0x0(%esi),%esi
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
40000280:	80 cc 08             	or     $0x8,%ah
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
40000283:	8b 4f 04             	mov    0x4(%edi),%ecx
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
40000286:	66 89 47 0c          	mov    %ax,0xc(%edi)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
4000028a:	85 c9                	test   %ecx,%ecx
4000028c:	0f 8e 9f 00 00 00    	jle    40000331 <fflush+0x141>
40000292:	8b 77 28             	mov    0x28(%edi),%esi
40000295:	85 f6                	test   %esi,%esi
40000297:	74 67                	je     40000300 <fflush+0x110>
        {
          _fpos_t curoff;

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
40000299:	f6 c4 10             	test   $0x10,%ah
4000029c:	74 3e                	je     400002dc <fflush+0xec>
            curoff = fp->_offset;
4000029e:	8b 5f 50             	mov    0x50(%edi),%ebx
                {
                  _funlockfile (fp);
                  return 0;
                }
            }
          if (fp->_flags & __SRD)
400002a1:	f6 47 0c 04          	testb  $0x4,0xc(%edi)
400002a5:	75 74                	jne    4000031b <fflush+0x12b>
              curoff -= fp->_r;
              if (HASUB (fp))
                curoff -= fp->_ur;
            }
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
400002a7:	50                   	push   %eax
400002a8:	6a 00                	push   $0x0
400002aa:	53                   	push   %ebx
400002ab:	8b 4f 1c             	mov    0x1c(%edi),%ecx
400002ae:	51                   	push   %ecx
400002af:	ff d6                	call   *%esi
400002b1:	83 c4 10             	add    $0x10,%esp
400002b4:	40                   	inc    %eax
400002b5:	74 49                	je     40000300 <fflush+0x110>
            {
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
400002b7:	66 81 67 0c ff f7    	andw   $0xf7ff,0xc(%edi)
              fp->_r = 0;
              fp->_p = fp->_bf._base;
400002bd:	8b 47 10             	mov    0x10(%edi),%eax
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
400002c0:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
              fp->_p = fp->_bf._base;
400002c7:	89 07                	mov    %eax,(%edi)
              if (fp->_flags & __SOFF)
400002c9:	f6 47 0d 10          	testb  $0x10,0xd(%edi)
400002cd:	74 31                	je     40000300 <fflush+0x110>
                fp->_offset = curoff;
400002cf:	89 5f 50             	mov    %ebx,0x50(%edi)
400002d2:	31 c0                	xor    %eax,%eax
      p += t;
      n -= t;
    }
  _funlockfile (fp);
  return 0;
}
400002d4:	8d 65 f4             	lea    -0xc(%ebp),%esp
400002d7:	5b                   	pop    %ebx
400002d8:	5e                   	pop    %esi
400002d9:	5f                   	pop    %edi
400002da:	5d                   	pop    %ebp
400002db:	c3                   	ret    
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
            {
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
400002dc:	50                   	push   %eax
400002dd:	6a 01                	push   $0x1
400002df:	6a 00                	push   $0x0
400002e1:	8b 47 1c             	mov    0x1c(%edi),%eax
400002e4:	50                   	push   %eax
400002e5:	ff d6                	call   *%esi
              if (curoff == -1L)
400002e7:	83 c4 10             	add    $0x10,%esp
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
            {
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
400002ea:	89 c3                	mov    %eax,%ebx
              if (curoff == -1L)
400002ec:	83 f8 ff             	cmp    $0xffffffff,%eax
400002ef:	75 b0                	jne    400002a1 <fflush+0xb1>
400002f1:	eb 0d                	jmp    40000300 <fflush+0x110>
400002f3:	90                   	nop    
400002f4:	90                   	nop    
400002f5:	90                   	nop    
400002f6:	90                   	nop    
400002f7:	90                   	nop    
400002f8:	90                   	nop    
400002f9:	90                   	nop    
400002fa:	90                   	nop    
400002fb:	90                   	nop    
400002fc:	90                   	nop    
400002fd:	90                   	nop    
400002fe:	90                   	nop    
400002ff:	90                   	nop    
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
	}
      p += t;
40000300:	31 c0                	xor    %eax,%eax
      n -= t;
    }
  _funlockfile (fp);
  return 0;
}
40000302:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000305:	5b                   	pop    %ebx
40000306:	5e                   	pop    %esi
40000307:	5f                   	pop    %edi
40000308:	5d                   	pop    %ebp
40000309:	c3                   	ret    
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);
4000030a:	83 ec 0c             	sub    $0xc,%esp
4000030d:	50                   	push   %eax
4000030e:	e8 ed 00 00 00       	call   40000400 <__sinit>
40000313:	83 c4 10             	add    $0x10,%esp
40000316:	e9 fd fe ff ff       	jmp    40000218 <fflush+0x28>
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
4000031b:	8b 47 04             	mov    0x4(%edi),%eax
4000031e:	29 c3                	sub    %eax,%ebx
              if (HASUB (fp))
40000320:	8b 47 30             	mov    0x30(%edi),%eax
40000323:	85 c0                	test   %eax,%eax
40000325:	74 80                	je     400002a7 <fflush+0xb7>
                curoff -= fp->_ur;
40000327:	8b 47 3c             	mov    0x3c(%edi),%eax
4000032a:	29 c3                	sub    %eax,%ebx
4000032c:	e9 76 ff ff ff       	jmp    400002a7 <fflush+0xb7>
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
40000331:	8b 57 3c             	mov    0x3c(%edi),%edx
40000334:	85 d2                	test   %edx,%edx
40000336:	0f 8f 56 ff ff ff    	jg     40000292 <fflush+0xa2>
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
	}
      p += t;
4000033c:	31 c0                	xor    %eax,%eax
4000033e:	eb c2                	jmp    40000302 <fflush+0x112>
{
  register unsigned char *p;
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);
40000340:	8b 35 34 bc 00 40    	mov    0x4000bc34,%esi
40000346:	57                   	push   %edi
40000347:	57                   	push   %edi
40000348:	68 f0 01 00 40       	push   $0x400001f0
4000034d:	56                   	push   %esi
4000034e:	e8 ad 03 00 00       	call   40000700 <_fwalk>
40000353:	83 c4 10             	add    $0x10,%esp
40000356:	e9 79 ff ff ff       	jmp    400002d4 <fflush+0xe4>
4000035b:	90                   	nop    
4000035c:	90                   	nop    
4000035d:	90                   	nop    
4000035e:	90                   	nop    
4000035f:	90                   	nop    

40000360 <std>:
or stream identified by <[fp]>) to the host system.

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
open files.

RETURNS
40000360:	55                   	push   %ebp
<<fflush>> returns <<0>> unless it encounters a write error; in that
40000361:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
or stream identified by <[fp]>) to the host system.

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
open files.

RETURNS
40000367:	89 e5                	mov    %esp,%ebp
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.
40000369:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

40000370:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
PORTABILITY
40000377:	66 89 50 0c          	mov    %dx,0xc(%eax)
ANSI C requires <<fflush>>.
4000037b:	66 89 48 0e          	mov    %cx,0xe(%eax)

4000037f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
No supporting OS subroutines are required.
40000386:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
*/
4000038d:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)

40000394:	89 40 1c             	mov    %eax,0x1c(%eax)
#include <_ansi.h>
40000397:	c7 40 20 80 12 00 40 	movl   $0x40001280,0x20(%eax)
#include <stdio.h>
4000039e:	c7 40 24 30 12 00 40 	movl   $0x40001230,0x24(%eax)
#include "local.h"
400003a5:	c7 40 28 e0 11 00 40 	movl   $0x400011e0,0x28(%eax)

400003ac:	c7 40 2c c0 11 00 40 	movl   $0x400011c0,0x2c(%eax)
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);
400003b3:	5d                   	pop    %ebp
400003b4:	c3                   	ret    
400003b5:	8d 74 26 00          	lea    0x0(%esi),%esi
400003b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

400003c0 <__sfp_lock_acquire>:
400003c0:	55                   	push   %ebp
400003c1:	89 e5                	mov    %esp,%ebp
400003c3:	5d                   	pop    %ebp
400003c4:	c3                   	ret    
400003c5:	8d 74 26 00          	lea    0x0(%esi),%esi
400003c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

400003d0 <__sfp_lock_release>:
400003d0:	55                   	push   %ebp
400003d1:	89 e5                	mov    %esp,%ebp
400003d3:	5d                   	pop    %ebp
400003d4:	c3                   	ret    
400003d5:	8d 74 26 00          	lea    0x0(%esi),%esi
400003d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

400003e0 <__sinit_lock_acquire>:
400003e0:	55                   	push   %ebp
400003e1:	89 e5                	mov    %esp,%ebp
400003e3:	5d                   	pop    %ebp
400003e4:	c3                   	ret    
400003e5:	8d 74 26 00          	lea    0x0(%esi),%esi
400003e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

400003f0 <__sinit_lock_release>:
400003f0:	55                   	push   %ebp
400003f1:	89 e5                	mov    %esp,%ebp
400003f3:	5d                   	pop    %ebp
400003f4:	c3                   	ret    
400003f5:	8d 74 26 00          	lea    0x0(%esi),%esi
400003f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40000400 <__sinit>:
40000400:	55                   	push   %ebp
40000401:	89 e5                	mov    %esp,%ebp
40000403:	53                   	push   %ebx
40000404:	8b 5d 08             	mov    0x8(%ebp),%ebx
40000407:	8b 4b 38             	mov    0x38(%ebx),%ecx
4000040a:	85 c9                	test   %ecx,%ecx
4000040c:	74 12                	je     40000420 <__sinit+0x20>
4000040e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40000411:	c9                   	leave  
40000412:	c3                   	ret    
40000413:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40000419:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40000420:	8d 83 ec 02 00 00    	lea    0x2ec(%ebx),%eax
40000426:	c7 43 3c f0 04 00 40 	movl   $0x400004f0,0x3c(%ebx)
4000042d:	89 83 e8 02 00 00    	mov    %eax,0x2e8(%ebx)
40000433:	c7 43 38 01 00 00 00 	movl   $0x1,0x38(%ebx)
4000043a:	8b 43 04             	mov    0x4(%ebx),%eax
4000043d:	c7 83 e0 02 00 00 00 	movl   $0x0,0x2e0(%ebx)
40000444:	00 00 00 
40000447:	c7 83 e4 02 00 00 03 	movl   $0x3,0x2e4(%ebx)
4000044e:	00 00 00 
40000451:	31 c9                	xor    %ecx,%ecx
40000453:	ba 04 00 00 00       	mov    $0x4,%edx
40000458:	53                   	push   %ebx
40000459:	e8 02 ff ff ff       	call   40000360 <std>
4000045e:	8b 43 08             	mov    0x8(%ebx),%eax
40000461:	b9 01 00 00 00       	mov    $0x1,%ecx
40000466:	ba 09 00 00 00       	mov    $0x9,%edx
4000046b:	53                   	push   %ebx
4000046c:	e8 ef fe ff ff       	call   40000360 <std>
40000471:	58                   	pop    %eax
40000472:	b9 02 00 00 00       	mov    $0x2,%ecx
40000477:	5a                   	pop    %edx
40000478:	8b 43 0c             	mov    0xc(%ebx),%eax
4000047b:	ba 0a 00 00 00       	mov    $0xa,%edx
40000480:	89 5d 08             	mov    %ebx,0x8(%ebp)
40000483:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40000486:	c9                   	leave  
40000487:	e9 d4 fe ff ff       	jmp    40000360 <std>
4000048c:	8d 74 26 00          	lea    0x0(%esi),%esi

40000490 <__fp_lock>:
40000490:	55                   	push   %ebp
40000491:	31 c0                	xor    %eax,%eax
40000493:	89 e5                	mov    %esp,%ebp
40000495:	5d                   	pop    %ebp
40000496:	c3                   	ret    
40000497:	89 f6                	mov    %esi,%esi
40000499:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

400004a0 <__fp_unlock>:
400004a0:	55                   	push   %ebp
400004a1:	31 c0                	xor    %eax,%eax
400004a3:	89 e5                	mov    %esp,%ebp
400004a5:	5d                   	pop    %ebp
400004a6:	c3                   	ret    
400004a7:	89 f6                	mov    %esi,%esi
400004a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

400004b0 <__fp_unlock_all>:
400004b0:	55                   	push   %ebp
400004b1:	89 e5                	mov    %esp,%ebp
400004b3:	83 ec 10             	sub    $0x10,%esp
400004b6:	a1 60 d0 00 40       	mov    0x4000d060,%eax
400004bb:	68 a0 04 00 40       	push   $0x400004a0
400004c0:	50                   	push   %eax
400004c1:	e8 3a 02 00 00       	call   40000700 <_fwalk>
400004c6:	83 c4 10             	add    $0x10,%esp
400004c9:	c9                   	leave  
400004ca:	c3                   	ret    
400004cb:	90                   	nop    
400004cc:	8d 74 26 00          	lea    0x0(%esi),%esi

400004d0 <__fp_lock_all>:
400004d0:	55                   	push   %ebp
400004d1:	89 e5                	mov    %esp,%ebp
400004d3:	83 ec 10             	sub    $0x10,%esp
400004d6:	a1 60 d0 00 40       	mov    0x4000d060,%eax
400004db:	68 90 04 00 40       	push   $0x40000490
400004e0:	50                   	push   %eax
400004e1:	e8 1a 02 00 00       	call   40000700 <_fwalk>
400004e6:	83 c4 10             	add    $0x10,%esp
400004e9:	c9                   	leave  
400004ea:	c3                   	ret    
400004eb:	90                   	nop    
400004ec:	8d 74 26 00          	lea    0x0(%esi),%esi

400004f0 <_cleanup_r>:
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
	}
400004f0:	55                   	push   %ebp
400004f1:	89 e5                	mov    %esp,%ebp
400004f3:	83 ec 10             	sub    $0x10,%esp
      p += t;
400004f6:	8b 45 08             	mov    0x8(%ebp),%eax
400004f9:	68 00 6c 00 40       	push   $0x40006c00
400004fe:	50                   	push   %eax
400004ff:	e8 fc 01 00 00       	call   40000700 <_fwalk>
40000504:	83 c4 10             	add    $0x10,%esp
      n -= t;
    }
40000507:	c9                   	leave  
40000508:	c3                   	ret    
40000509:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

40000510 <_cleanup>:
  _funlockfile (fp);
  return 0;
}
40000510:	55                   	push   %ebp
40000511:	89 e5                	mov    %esp,%ebp
40000513:	83 ec 14             	sub    $0x14,%esp
40000516:	a1 34 bc 00 40       	mov    0x4000bc34,%eax
4000051b:	50                   	push   %eax
4000051c:	e8 cf ff ff ff       	call   400004f0 <_cleanup_r>
40000521:	83 c4 10             	add    $0x10,%esp
40000524:	c9                   	leave  
40000525:	c3                   	ret    
40000526:	8d 76 00             	lea    0x0(%esi),%esi
40000529:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40000530 <__sfmoreglue>:

  _flockfile (fp);

  t = fp->_flags;
  if ((t & __SWR) == 0)
    {
40000530:	55                   	push   %ebp
40000531:	89 e5                	mov    %esp,%ebp
40000533:	57                   	push   %edi
40000534:	56                   	push   %esi
40000535:	53                   	push   %ebx
40000536:	83 ec 14             	sub    $0x14,%esp
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
40000539:	31 db                	xor    %ebx,%ebx

  _flockfile (fp);

  t = fp->_flags;
  if ((t & __SWR) == 0)
    {
4000053b:	8b 75 0c             	mov    0xc(%ebp),%esi
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
4000053e:	8b 4d 08             	mov    0x8(%ebp),%ecx
40000541:	8d 04 76             	lea    (%esi,%esi,2),%eax
40000544:	c1 e0 03             	shl    $0x3,%eax
40000547:	29 f0                	sub    %esi,%eax
40000549:	8d 3c 85 00 00 00 00 	lea    0x0(,%eax,4),%edi
40000550:	8d 47 0c             	lea    0xc(%edi),%eax
40000553:	50                   	push   %eax
40000554:	51                   	push   %ecx
40000555:	e8 86 02 00 00       	call   400007e0 <_malloc_r>
         to the POSIX and SUSv3 standards.  */
4000055a:	83 c4 10             	add    $0x10,%esp
4000055d:	85 c0                	test   %eax,%eax
4000055f:	74 1e                	je     4000057f <__sfmoreglue+0x4f>
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
40000561:	89 c3                	mov    %eax,%ebx
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;

40000563:	8d 40 0c             	lea    0xc(%eax),%eax
      /* For a seekable stream with buffered read characters, we will attempt
40000566:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
         a seek to the current position now.  A subsequent read will then get
4000056c:	89 73 04             	mov    %esi,0x4(%ebx)
         the next byte from the file rather than the buffer.  This conforms
4000056f:	89 43 08             	mov    %eax,0x8(%ebx)
         to the POSIX and SUSv3 standards.  Note that the standards allow
40000572:	52                   	push   %edx
40000573:	57                   	push   %edi
40000574:	6a 00                	push   $0x0
40000576:	50                   	push   %eax
40000577:	e8 6c 0a 00 00       	call   40000fe8 <memset>
4000057c:	83 c4 10             	add    $0x10,%esp
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
4000057f:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000582:	89 d8                	mov    %ebx,%eax
40000584:	5b                   	pop    %ebx
40000585:	5e                   	pop    %esi
40000586:	5f                   	pop    %edi
40000587:	5d                   	pop    %ebp
40000588:	c3                   	ret    
40000589:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

40000590 <__sfp>:
          _fpos_t curoff;

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
40000590:	55                   	push   %ebp
40000591:	89 e5                	mov    %esp,%ebp
40000593:	53                   	push   %ebx
40000594:	83 ec 04             	sub    $0x4,%esp
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
                  _funlockfile (fp);
                  return 0;
40000597:	a1 34 bc 00 40       	mov    0x4000bc34,%eax
4000059c:	8b 50 38             	mov    0x38(%eax),%edx
4000059f:	85 d2                	test   %edx,%edx
400005a1:	0f 84 89 00 00 00    	je     40000630 <__sfp+0xa0>
                }
            }
400005a7:	8b 1d 34 bc 00 40    	mov    0x4000bc34,%ebx
400005ad:	81 c3 e0 02 00 00    	add    $0x2e0,%ebx
          if (fp->_flags & __SRD)
            {
400005b3:	8b 53 04             	mov    0x4(%ebx),%edx
400005b6:	8b 43 08             	mov    0x8(%ebx),%eax
400005b9:	4a                   	dec    %edx
400005ba:	79 0d                	jns    400005c9 <__sfp+0x39>
400005bc:	eb 68                	jmp    40000626 <__sfp+0x96>
400005be:	66 90                	xchg   %ax,%ax
400005c0:	4a                   	dec    %edx
400005c1:	83 fa ff             	cmp    $0xffffffff,%edx
400005c4:	74 60                	je     40000626 <__sfp+0x96>
400005c6:	83 c0 5c             	add    $0x5c,%eax
              /* Current offset is at end of buffer.  Compensate for
400005c9:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
400005ce:	75 f0                	jne    400005c0 <__sfp+0x30>
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
400005d0:	66 c7 40 0e ff ff    	movw   $0xffff,0xe(%eax)
              fp->_p = fp->_bf._base;
400005d6:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
              if (fp->_flags & __SOFF)
                fp->_offset = curoff;
            }
        } 
      _funlockfile (fp);
      return 0;
400005dc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
400005e2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  if ((p = fp->_bf._base) == NULL)
400005e9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    {
400005f0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
      /* Nothing to flush.  */
400005f7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
      _funlockfile (fp);
400005fe:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
      return 0;
    }
40000605:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
  n = fp->_p - p;		/* write this much */
4000060c:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)

40000613:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  /*
4000061a:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
40000621:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40000624:	c9                   	leave  
40000625:	c3                   	ret    
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
40000626:	8b 03                	mov    (%ebx),%eax
40000628:	85 c0                	test   %eax,%eax
4000062a:	74 10                	je     4000063c <__sfp+0xac>
              if (HASUB (fp))
                curoff -= fp->_ur;
4000062c:	89 c3                	mov    %eax,%ebx
4000062e:	eb 83                	jmp    400005b3 <__sfp+0x23>
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
                  _funlockfile (fp);
                  return 0;
                }
40000630:	50                   	push   %eax
40000631:	e8 ca fd ff ff       	call   40000400 <__sinit>
40000636:	58                   	pop    %eax
40000637:	e9 6b ff ff ff       	jmp    400005a7 <__sfp+0x17>
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
4000063c:	50                   	push   %eax
4000063d:	50                   	push   %eax
4000063e:	8b 45 08             	mov    0x8(%ebp),%eax
40000641:	6a 04                	push   $0x4
40000643:	50                   	push   %eax
40000644:	e8 e7 fe ff ff       	call   40000530 <__sfmoreglue>
40000649:	83 c4 10             	add    $0x10,%esp
4000064c:	89 03                	mov    %eax,(%ebx)
4000064e:	85 c0                	test   %eax,%eax
40000650:	75 da                	jne    4000062c <__sfp+0x9c>
              if (HASUB (fp))
                curoff -= fp->_ur;
            }
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
40000652:	8b 45 08             	mov    0x8(%ebp),%eax
40000655:	c7 00 0c 00 00 00    	movl   $0xc,(%eax)
4000065b:	31 c0                	xor    %eax,%eax
4000065d:	eb c2                	jmp    40000621 <__sfp+0x91>
4000065f:	90                   	nop    

40000660 <_fwalk_reent>:
          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
            {
              /* We don't know current physical offset, so ask for it.  */
40000660:	55                   	push   %ebp
40000661:	89 e5                	mov    %esp,%ebp
40000663:	57                   	push   %edi
40000664:	56                   	push   %esi
40000665:	53                   	push   %ebx
40000666:	83 ec 0c             	sub    $0xc,%esp
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
40000669:	e8 52 fd ff ff       	call   400003c0 <__sfp_lock_acquire>
/* Flush a single file, or (if fp is NULL) all files.  */

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
4000066e:	8b 45 08             	mov    0x8(%ebp),%eax
40000671:	05 e0 02 00 00       	add    $0x2e0,%eax
40000676:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000067d:	89 45 ec             	mov    %eax,-0x14(%ebp)
40000680:	74 5f                	je     400006e1 <_fwalk_reent+0x81>
  register unsigned char *p;
40000682:	8b 45 ec             	mov    -0x14(%ebp),%eax
40000685:	8b 78 04             	mov    0x4(%eax),%edi
40000688:	8b 58 08             	mov    0x8(%eax),%ebx
4000068b:	89 f8                	mov    %edi,%eax
4000068d:	48                   	dec    %eax
4000068e:	78 45                	js     400006d5 <_fwalk_reent+0x75>
40000690:	31 f6                	xor    %esi,%esi
40000692:	eb 0f                	jmp    400006a3 <_fwalk_reent+0x43>
40000694:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000069a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
400006a0:	83 c3 5c             	add    $0x5c,%ebx
  register int n, t;
400006a3:	66 83 7b 0c 00       	cmpw   $0x0,0xc(%ebx)
400006a8:	74 26                	je     400006d0 <_fwalk_reent+0x70>

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);
400006aa:	66 83 7b 0e ff       	cmpw   $0xffffffff,0xe(%ebx)
400006af:	74 1f                	je     400006d0 <_fwalk_reent+0x70>

400006b1:	8b 4d 08             	mov    0x8(%ebp),%ecx
400006b4:	50                   	push   %eax
400006b5:	50                   	push   %eax
400006b6:	53                   	push   %ebx
400006b7:	51                   	push   %ecx
400006b8:	ff 55 0c             	call   *0xc(%ebp)
400006bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
400006be:	83 c4 10             	add    $0x10,%esp
400006c1:	09 c2                	or     %eax,%edx
400006c3:	89 55 f0             	mov    %edx,-0x10(%ebp)
400006c6:	8d 76 00             	lea    0x0(%esi),%esi
400006c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
400006d0:	46                   	inc    %esi

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  register unsigned char *p;
400006d1:	39 fe                	cmp    %edi,%esi
400006d3:	75 cb                	jne    400006a0 <_fwalk_reent+0x40>
/* Flush a single file, or (if fp is NULL) all files.  */

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
400006d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
400006d8:	8b 00                	mov    (%eax),%eax
400006da:	89 45 ec             	mov    %eax,-0x14(%ebp)
400006dd:	85 c0                	test   %eax,%eax
400006df:	75 a1                	jne    40000682 <_fwalk_reent+0x22>
                  _funlockfile (fp);
                  return 0;
                }
            }
          if (fp->_flags & __SRD)
            {
400006e1:	e8 ea fc ff ff       	call   400003d0 <__sfp_lock_release>
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
400006e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
400006e9:	8d 65 f4             	lea    -0xc(%ebp),%esp
400006ec:	5b                   	pop    %ebx
400006ed:	5e                   	pop    %esi
400006ee:	5f                   	pop    %edi
400006ef:	5d                   	pop    %ebp
400006f0:	c3                   	ret    
400006f1:	eb 0d                	jmp    40000700 <_fwalk>
400006f3:	90                   	nop    
400006f4:	90                   	nop    
400006f5:	90                   	nop    
400006f6:	90                   	nop    
400006f7:	90                   	nop    
400006f8:	90                   	nop    
400006f9:	90                   	nop    
400006fa:	90                   	nop    
400006fb:	90                   	nop    
400006fc:	90                   	nop    
400006fd:	90                   	nop    
400006fe:	90                   	nop    
400006ff:	90                   	nop    

40000700 <_fwalk>:
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
40000700:	55                   	push   %ebp
40000701:	89 e5                	mov    %esp,%ebp
40000703:	57                   	push   %edi
40000704:	56                   	push   %esi
40000705:	53                   	push   %ebx
40000706:	83 ec 0c             	sub    $0xc,%esp
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;

40000709:	e8 b2 fc ff ff       	call   400003c0 <__sfp_lock_acquire>
DESCRIPTION
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

Use <<fflush>> to deliver any such pending output (for the file
or stream identified by <[fp]>) to the host system.
4000070e:	8b 45 08             	mov    0x8(%ebp),%eax
40000711:	05 e0 02 00 00       	add    $0x2e0,%eax
40000716:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000071d:	89 45 ec             	mov    %eax,-0x14(%ebp)
40000720:	74 5f                	je     40000781 <_fwalk+0x81>

40000722:	8b 45 ec             	mov    -0x14(%ebp),%eax
40000725:	8b 78 04             	mov    0x4(%eax),%edi
40000728:	8b 58 08             	mov    0x8(%eax),%ebx
4000072b:	89 f8                	mov    %edi,%eax
4000072d:	48                   	dec    %eax
4000072e:	78 45                	js     40000775 <_fwalk+0x75>
40000730:	31 f6                	xor    %esi,%esi
40000732:	eb 0f                	jmp    40000743 <_fwalk+0x43>
40000734:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000073a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
40000740:	83 c3 5c             	add    $0x5c,%ebx
If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
40000743:	66 83 7b 0c 00       	cmpw   $0x0,0xc(%ebx)
40000748:	74 26                	je     40000770 <_fwalk+0x70>
open files.

RETURNS
4000074a:	66 83 7b 0e ff       	cmpw   $0xffffffff,0xe(%ebx)
4000074f:	74 1f                	je     40000770 <_fwalk+0x70>
<<fflush>> returns <<0>> unless it encounters a write error; in that
40000751:	83 ec 0c             	sub    $0xc,%esp
40000754:	53                   	push   %ebx
40000755:	ff 55 0c             	call   *0xc(%ebp)
40000758:	8b 55 f0             	mov    -0x10(%ebp),%edx
4000075b:	83 c4 10             	add    $0x10,%esp
4000075e:	09 c2                	or     %eax,%edx
40000760:	89 55 f0             	mov    %edx,-0x10(%ebp)
40000763:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40000769:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40000770:	46                   	inc    %esi
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

Use <<fflush>> to deliver any such pending output (for the file
or stream identified by <[fp]>) to the host system.

40000771:	39 fe                	cmp    %edi,%esi
40000773:	75 cb                	jne    40000740 <_fwalk+0x40>
DESCRIPTION
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

Use <<fflush>> to deliver any such pending output (for the file
or stream identified by <[fp]>) to the host system.
40000775:	8b 45 ec             	mov    -0x14(%ebp),%eax
40000778:	8b 00                	mov    (%eax),%eax
4000077a:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000077d:	85 c0                	test   %eax,%eax
4000077f:	75 a1                	jne    40000722 <_fwalk+0x22>
      /* For a seekable stream with buffered read characters, we will attempt
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
40000781:	e8 4a fc ff ff       	call   400003d0 <__sfp_lock_release>
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
40000786:	8b 45 f0             	mov    -0x10(%ebp),%eax
40000789:	8d 65 f4             	lea    -0xc(%ebp),%esp
4000078c:	5b                   	pop    %ebx
4000078d:	5e                   	pop    %esi
4000078e:	5f                   	pop    %edi
4000078f:	5d                   	pop    %ebp
40000790:	c3                   	ret    
40000791:	90                   	nop    
40000792:	90                   	nop    
40000793:	90                   	nop    
40000794:	90                   	nop    
40000795:	90                   	nop    
40000796:	90                   	nop    
40000797:	90                   	nop    
40000798:	90                   	nop    
40000799:	90                   	nop    
4000079a:	90                   	nop    
4000079b:	90                   	nop    
4000079c:	90                   	nop    
4000079d:	90                   	nop    
4000079e:	90                   	nop    
4000079f:	90                   	nop    

400007a0 <__init>:
400007a0:	55                   	push   %ebp
400007a1:	b8 18 00 00 00       	mov    $0x18,%eax
400007a6:	89 e5                	mov    %esp,%ebp
400007a8:	53                   	push   %ebx
400007a9:	31 db                	xor    %ebx,%ebx
400007ab:	83 ec 10             	sub    $0x10,%esp
400007ae:	89 d9                	mov    %ebx,%ecx
400007b0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
400007b7:	89 da                	mov    %ebx,%edx
400007b9:	cd 30                	int    $0x30
400007bb:	89 45 f8             	mov    %eax,-0x8(%ebp)
400007be:	8b 45 f8             	mov    -0x8(%ebp),%eax
400007c1:	83 c4 10             	add    $0x10,%esp
400007c4:	5b                   	pop    %ebx
400007c5:	5d                   	pop    %ebp
400007c6:	c3                   	ret    
400007c7:	89 f6                	mov    %esi,%esi
400007c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

400007d0 <__deinit>:
400007d0:	55                   	push   %ebp
400007d1:	89 e5                	mov    %esp,%ebp
400007d3:	5d                   	pop    %ebp
400007d4:	e9 b7 62 00 00       	jmp    40006a90 <exit>
400007d9:	90                   	nop    
400007da:	90                   	nop    
400007db:	90                   	nop    
400007dc:	90                   	nop    
400007dd:	90                   	nop    
400007de:	90                   	nop    
400007df:	90                   	nop    

400007e0 <_malloc_r>:
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
400007e0:	55                   	push   %ebp
400007e1:	89 e5                	mov    %esp,%ebp
400007e3:	57                   	push   %edi
400007e4:	56                   	push   %esi
400007e5:	53                   	push   %ebx
400007e6:	83 ec 2c             	sub    $0x2c,%esp
400007e9:	8b 55 0c             	mov    0xc(%ebp),%edx
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
400007ec:	8d 42 0b             	lea    0xb(%edx),%eax
400007ef:	83 f8 16             	cmp    $0x16,%eax
400007f2:	0f 87 98 00 00 00    	ja     40000890 <_malloc_r+0xb0>
400007f8:	bf 10 00 00 00       	mov    $0x10,%edi
400007fd:	31 c0                	xor    %eax,%eax

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
400007ff:	39 d7                	cmp    %edx,%edi
40000801:	73 1d                	jae    40000820 <_malloc_r+0x40>
  {
    RERRNO = ENOMEM;
40000803:	8b 45 08             	mov    0x8(%ebp),%eax
40000806:	c7 00 0c 00 00 00    	movl   $0xc,(%eax)
4000080c:	31 c0                	xor    %eax,%eax
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
  return chunk2mem(victim);

#endif /* MALLOC_PROVIDED */
}
4000080e:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000811:	5b                   	pop    %ebx
40000812:	5e                   	pop    %esi
40000813:	5f                   	pop    %edi
40000814:	5d                   	pop    %ebp
40000815:	c3                   	ret    
40000816:	8d 76 00             	lea    0x0(%esi),%esi
40000819:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
40000820:	84 c0                	test   %al,%al
40000822:	75 df                	jne    40000803 <_malloc_r+0x23>
  {
    RERRNO = ENOMEM;
    return 0;
  }

  MALLOC_LOCK;
40000824:	83 ec 0c             	sub    $0xc,%esp
40000827:	8b 45 08             	mov    0x8(%ebp),%eax
4000082a:	50                   	push   %eax
4000082b:	e8 00 08 00 00       	call   40001030 <__malloc_lock>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
40000830:	83 c4 10             	add    $0x10,%esp
40000833:	81 ff f7 01 00 00    	cmp    $0x1f7,%edi
40000839:	77 64                	ja     4000089f <_malloc_r+0xbf>
  {
    idx = smallbin_index(nb); 
4000083b:	89 fa                	mov    %edi,%edx
4000083d:	c1 ea 03             	shr    $0x3,%edx

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
40000840:	8d 04 d5 80 d4 00 40 	lea    0x4000d480(,%edx,8),%eax
    victim = last(q);
40000847:	8b 58 0c             	mov    0xc(%eax),%ebx

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
4000084a:	39 c3                	cmp    %eax,%ebx
4000084c:	0f 84 12 01 00 00    	je     40000964 <_malloc_r+0x184>
      victim = last(q);
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
40000852:	8b 4b 04             	mov    0x4(%ebx),%ecx
40000855:	83 e1 fc             	and    $0xfffffffc,%ecx
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
40000858:	8b 43 08             	mov    0x8(%ebx),%eax
4000085b:	8b 53 0c             	mov    0xc(%ebx),%edx
4000085e:	89 50 0c             	mov    %edx,0xc(%eax)
40000861:	89 42 08             	mov    %eax,0x8(%edx)
        set_inuse_bit_at_offset(victim, victim_size);
40000864:	8b 44 19 04          	mov    0x4(%ecx,%ebx,1),%eax
40000868:	83 c8 01             	or     $0x1,%eax
4000086b:	89 44 19 04          	mov    %eax,0x4(%ecx,%ebx,1)
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
4000086f:	83 ec 0c             	sub    $0xc,%esp
40000872:	8b 45 08             	mov    0x8(%ebp),%eax
40000875:	50                   	push   %eax
40000876:	e8 c5 07 00 00       	call   40001040 <__malloc_unlock>
      return chunk2mem(victim);
4000087b:	8d 43 08             	lea    0x8(%ebx),%eax
4000087e:	83 c4 10             	add    $0x10,%esp
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
  return chunk2mem(victim);

#endif /* MALLOC_PROVIDED */
}
40000881:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000884:	5b                   	pop    %ebx
40000885:	5e                   	pop    %esi
40000886:	5f                   	pop    %edi
40000887:	5d                   	pop    %ebp
40000888:	c3                   	ret    
40000889:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
40000890:	89 c7                	mov    %eax,%edi
40000892:	83 e7 f8             	and    $0xfffffff8,%edi
40000895:	89 f8                	mov    %edi,%eax
40000897:	c1 e8 1f             	shr    $0x1f,%eax
4000089a:	e9 60 ff ff ff       	jmp    400007ff <_malloc_r+0x1f>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
4000089f:	89 f8                	mov    %edi,%eax
400008a1:	c1 e8 09             	shr    $0x9,%eax
400008a4:	0f 84 a5 00 00 00    	je     4000094f <_malloc_r+0x16f>
400008aa:	83 f8 04             	cmp    $0x4,%eax
400008ad:	0f 87 ee 01 00 00    	ja     40000aa1 <_malloc_r+0x2c1>
400008b3:	89 f8                	mov    %edi,%eax
400008b5:	c1 e8 06             	shr    $0x6,%eax
400008b8:	8d 70 38             	lea    0x38(%eax),%esi
400008bb:	83 c0 39             	add    $0x39,%eax
400008be:	89 45 f0             	mov    %eax,-0x10(%ebp)
400008c1:	c1 e0 03             	shl    $0x3,%eax
    bin = bin_at(idx);
400008c4:	8d 90 78 d4 00 40    	lea    0x4000d478(%eax),%edx

    for (victim = last(bin); victim != bin; victim = victim->bk)
400008ca:	8b 5a 0c             	mov    0xc(%edx),%ebx
400008cd:	39 da                	cmp    %ebx,%edx
400008cf:	75 1e                	jne    400008ef <_malloc_r+0x10f>
400008d1:	eb 2e                	jmp    40000901 <_malloc_r+0x121>
400008d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
400008d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
      {
        --idx; /* adjust to rescan below after checking last remainder */
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
400008e0:	85 c0                	test   %eax,%eax
400008e2:	0f 89 70 ff ff ff    	jns    40000858 <_malloc_r+0x78>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
400008e8:	8b 5b 0c             	mov    0xc(%ebx),%ebx
400008eb:	39 da                	cmp    %ebx,%edx
400008ed:	74 12                	je     40000901 <_malloc_r+0x121>
    {
      victim_size = chunksize(victim);
400008ef:	8b 4b 04             	mov    0x4(%ebx),%ecx
400008f2:	83 e1 fc             	and    $0xfffffffc,%ecx
      remainder_size = long_sub_size_t(victim_size, nb);
400008f5:	89 c8                	mov    %ecx,%eax
400008f7:	29 f8                	sub    %edi,%eax
      
      if (remainder_size >= (long)MINSIZE) /* too big */
400008f9:	83 f8 0f             	cmp    $0xf,%eax
400008fc:	7e e2                	jle    400008e0 <_malloc_r+0x100>
      {
        --idx; /* adjust to rescan below after checking last remainder */
400008fe:	89 75 f0             	mov    %esi,-0x10(%ebp)

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
40000901:	8b 1d 90 d4 00 40    	mov    0x4000d490,%ebx
40000907:	b9 88 d4 00 40       	mov    $0x4000d488,%ecx
4000090c:	39 d9                	cmp    %ebx,%ecx
4000090e:	0f 84 cf 00 00 00    	je     400009e3 <_malloc_r+0x203>
  {
    victim_size = chunksize(victim);
40000914:	8b 53 04             	mov    0x4(%ebx),%edx
40000917:	83 e2 fc             	and    $0xfffffffc,%edx
    remainder_size = long_sub_size_t(victim_size, nb);
4000091a:	89 d1                	mov    %edx,%ecx
4000091c:	29 f9                	sub    %edi,%ecx

    if (remainder_size >= (long)MINSIZE) /* re-split */
4000091e:	83 f9 0f             	cmp    $0xf,%ecx
40000921:	0f 8f 94 01 00 00    	jg     40000abb <_malloc_r+0x2db>
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    clear_last_remainder;
40000927:	c7 05 94 d4 00 40 88 	movl   $0x4000d488,0x4000d494
4000092e:	d4 00 40 
40000931:	c7 05 90 d4 00 40 88 	movl   $0x4000d488,0x4000d490
40000938:	d4 00 40 

    if (remainder_size >= 0)  /* exhaust */
4000093b:	85 c9                	test   %ecx,%ecx
4000093d:	78 3b                	js     4000097a <_malloc_r+0x19a>
    {
      set_inuse_bit_at_offset(victim, victim_size);
4000093f:	8b 7c 1a 04          	mov    0x4(%edx,%ebx,1),%edi
40000943:	83 cf 01             	or     $0x1,%edi
40000946:	89 7c 1a 04          	mov    %edi,0x4(%edx,%ebx,1)
4000094a:	e9 20 ff ff ff       	jmp    4000086f <_malloc_r+0x8f>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
4000094f:	89 fe                	mov    %edi,%esi
40000951:	c1 ee 03             	shr    $0x3,%esi
40000954:	8d 56 01             	lea    0x1(%esi),%edx
40000957:	89 d0                	mov    %edx,%eax
40000959:	89 55 f0             	mov    %edx,-0x10(%ebp)
4000095c:	c1 e0 03             	shl    $0x3,%eax
4000095f:	e9 60 ff ff ff       	jmp    400008c4 <_malloc_r+0xe4>

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
    {
      q = next_bin(q);
40000964:	8d 43 08             	lea    0x8(%ebx),%eax
      victim = last(q);
40000967:	8b 58 0c             	mov    0xc(%eax),%ebx
    }
#endif
    if (victim != q)
4000096a:	39 d8                	cmp    %ebx,%eax
4000096c:	0f 85 e0 fe ff ff    	jne    40000852 <_malloc_r+0x72>
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
40000972:	83 c2 02             	add    $0x2,%edx
40000975:	89 55 f0             	mov    %edx,-0x10(%ebp)
40000978:	eb 87                	jmp    40000901 <_malloc_r+0x121>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
4000097a:	81 fa ff 01 00 00    	cmp    $0x1ff,%edx
40000980:	0f 86 34 02 00 00    	jbe    40000bba <_malloc_r+0x3da>
40000986:	89 d0                	mov    %edx,%eax
40000988:	c1 e8 09             	shr    $0x9,%eax
4000098b:	0f 85 f5 03 00 00    	jne    40000d86 <_malloc_r+0x5a6>
40000991:	89 d0                	mov    %edx,%eax
40000993:	c1 e8 03             	shr    $0x3,%eax
40000996:	89 45 dc             	mov    %eax,-0x24(%ebp)
40000999:	8d 04 c5 08 00 00 00 	lea    0x8(,%eax,8),%eax
400009a0:	8d b0 78 d4 00 40    	lea    0x4000d478(%eax),%esi
400009a6:	8b 46 08             	mov    0x8(%esi),%eax
400009a9:	89 45 d0             	mov    %eax,-0x30(%ebp)
400009ac:	39 f0                	cmp    %esi,%eax
400009ae:	0f 84 b4 04 00 00    	je     40000e68 <_malloc_r+0x688>
400009b4:	8b 4d d0             	mov    -0x30(%ebp),%ecx
400009b7:	8b 41 04             	mov    0x4(%ecx),%eax
400009ba:	83 e0 fc             	and    $0xfffffffc,%eax
400009bd:	39 c2                	cmp    %eax,%edx
400009bf:	73 0d                	jae    400009ce <_malloc_r+0x1ee>
400009c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
400009c4:	8b 40 08             	mov    0x8(%eax),%eax
400009c7:	89 45 d0             	mov    %eax,-0x30(%ebp)
400009ca:	39 c6                	cmp    %eax,%esi
400009cc:	75 e6                	jne    400009b4 <_malloc_r+0x1d4>
400009ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
400009d1:	8b 42 0c             	mov    0xc(%edx),%eax
400009d4:	8b 4d d0             	mov    -0x30(%ebp),%ecx
400009d7:	89 43 0c             	mov    %eax,0xc(%ebx)
400009da:	89 4b 08             	mov    %ecx,0x8(%ebx)
400009dd:	89 58 08             	mov    %ebx,0x8(%eax)
400009e0:	89 59 0c             	mov    %ebx,0xc(%ecx)
  /* 
     If there are any possibly nonempty big-enough blocks, 
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)  
400009e3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
400009e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
400009e9:	c1 f9 1f             	sar    $0x1f,%ecx
400009ec:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
400009f3:	c1 e9 1e             	shr    $0x1e,%ecx
400009f6:	01 c1                	add    %eax,%ecx
400009f8:	a1 84 d4 00 40       	mov    0x4000d484,%eax
400009fd:	c1 f9 02             	sar    $0x2,%ecx
40000a00:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40000a03:	d3 65 e0             	shll   %cl,-0x20(%ebp)
40000a06:	39 45 e0             	cmp    %eax,-0x20(%ebp)
40000a09:	0f 87 df 00 00 00    	ja     40000aee <_malloc_r+0x30e>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
40000a0f:	85 45 e0             	test   %eax,-0x20(%ebp)
40000a12:	0f 84 13 02 00 00    	je     40000c2b <_malloc_r+0x44b>
      
    /* For each possibly nonempty block ... */
    for (;;)  
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);
40000a18:	8b 55 f0             	mov    -0x10(%ebp),%edx
40000a1b:	89 55 ec             	mov    %edx,-0x14(%ebp)
40000a1e:	8d 04 d5 80 d4 00 40 	lea    0x4000d480(,%edx,8),%eax
40000a25:	89 c1                	mov    %eax,%ecx
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
40000a27:	8b 71 0c             	mov    0xc(%ecx),%esi
40000a2a:	39 f1                	cmp    %esi,%ecx
40000a2c:	75 25                	jne    40000a53 <_malloc_r+0x273>
40000a2e:	e9 4c 02 00 00       	jmp    40000c7f <_malloc_r+0x49f>
40000a33:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40000a39:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
40000a40:	85 db                	test   %ebx,%ebx
40000a42:	0f 89 50 02 00 00    	jns    40000c98 <_malloc_r+0x4b8>
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
40000a48:	8b 76 0c             	mov    0xc(%esi),%esi
40000a4b:	39 f1                	cmp    %esi,%ecx
40000a4d:	0f 84 2c 02 00 00    	je     40000c7f <_malloc_r+0x49f>
        {
          victim_size = chunksize(victim);
40000a53:	8b 56 04             	mov    0x4(%esi),%edx
40000a56:	83 e2 fc             	and    $0xfffffffc,%edx
          remainder_size = long_sub_size_t(victim_size, nb);
40000a59:	89 d3                	mov    %edx,%ebx
40000a5b:	29 fb                	sub    %edi,%ebx

          if (remainder_size >= (long)MINSIZE) /* split */
40000a5d:	83 fb 0f             	cmp    $0xf,%ebx
40000a60:	7e de                	jle    40000a40 <_malloc_r+0x260>
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
40000a62:	8b 46 08             	mov    0x8(%esi),%eax
40000a65:	8b 4e 0c             	mov    0xc(%esi),%ecx
          victim_size = chunksize(victim);
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
40000a68:	8d 14 3e             	lea    (%esi,%edi,1),%edx
            set_head(victim, nb | PREV_INUSE);
40000a6b:	83 cf 01             	or     $0x1,%edi
            unlink(victim, bck, fwd);
40000a6e:	89 48 0c             	mov    %ecx,0xc(%eax)
40000a71:	89 41 08             	mov    %eax,0x8(%ecx)
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
40000a74:	89 d8                	mov    %ebx,%eax
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
40000a76:	89 7e 04             	mov    %edi,0x4(%esi)
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
40000a79:	83 c8 01             	or     $0x1,%eax
          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
40000a7c:	89 15 94 d4 00 40    	mov    %edx,0x4000d494
40000a82:	89 15 90 d4 00 40    	mov    %edx,0x4000d490
40000a88:	c7 42 0c 88 d4 00 40 	movl   $0x4000d488,0xc(%edx)
40000a8f:	c7 42 08 88 d4 00 40 	movl   $0x4000d488,0x8(%edx)
            set_head(remainder, remainder_size | PREV_INUSE);
40000a96:	89 42 04             	mov    %eax,0x4(%edx)
            set_foot(remainder, remainder_size);
40000a99:	89 1c 1a             	mov    %ebx,(%edx,%ebx,1)
40000a9c:	e9 70 01 00 00       	jmp    40000c11 <_malloc_r+0x431>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
40000aa1:	83 f8 14             	cmp    $0x14,%eax
40000aa4:	0f 87 e6 00 00 00    	ja     40000b90 <_malloc_r+0x3b0>
40000aaa:	8d 70 5b             	lea    0x5b(%eax),%esi
40000aad:	83 c0 5c             	add    $0x5c,%eax
40000ab0:	89 45 f0             	mov    %eax,-0x10(%ebp)
40000ab3:	c1 e0 03             	shl    $0x3,%eax
40000ab6:	e9 09 fe ff ff       	jmp    400008c4 <_malloc_r+0xe4>
    victim_size = chunksize(victim);
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
40000abb:	8d 14 3b             	lea    (%ebx,%edi,1),%edx
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
40000abe:	89 c8                	mov    %ecx,%eax
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
40000ac0:	83 cf 01             	or     $0x1,%edi
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
40000ac3:	83 c8 01             	or     $0x1,%eax
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
40000ac6:	89 7b 04             	mov    %edi,0x4(%ebx)
      link_last_remainder(remainder);
40000ac9:	89 15 94 d4 00 40    	mov    %edx,0x4000d494
40000acf:	89 15 90 d4 00 40    	mov    %edx,0x4000d490
40000ad5:	c7 42 0c 88 d4 00 40 	movl   $0x4000d488,0xc(%edx)
40000adc:	c7 42 08 88 d4 00 40 	movl   $0x4000d488,0x8(%edx)
      set_head(remainder, remainder_size | PREV_INUSE);
40000ae3:	89 42 04             	mov    %eax,0x4(%edx)
      set_foot(remainder, remainder_size);
40000ae6:	89 0c 0a             	mov    %ecx,(%edx,%ecx,1)
40000ae9:	e9 81 fd ff ff       	jmp    4000086f <_malloc_r+0x8f>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
40000aee:	8b 35 88 d4 00 40    	mov    0x4000d488,%esi
40000af4:	8b 46 04             	mov    0x4(%esi),%eax
40000af7:	83 e0 fc             	and    $0xfffffffc,%eax
40000afa:	89 c2                	mov    %eax,%edx
40000afc:	89 45 d8             	mov    %eax,-0x28(%ebp)
40000aff:	29 fa                	sub    %edi,%edx
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
40000b01:	39 c7                	cmp    %eax,%edi
40000b03:	0f 86 e9 00 00 00    	jbe    40000bf2 <_malloc_r+0x412>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
40000b09:	a1 00 d9 00 40       	mov    0x4000d900,%eax
40000b0e:	83 c0 10             	add    $0x10,%eax

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
40000b11:	83 3d 8c d8 00 40 ff 	cmpl   $0xffffffff,0x4000d88c
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
40000b18:	8d 1c 38             	lea    (%eax,%edi,1),%ebx

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
40000b1b:	74 0c                	je     40000b29 <_malloc_r+0x349>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
40000b1d:	81 c3 ff 0f 00 00    	add    $0xfff,%ebx
40000b23:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

  brk = (char*)(MORECORE (sbrk_size));
40000b29:	50                   	push   %eax
40000b2a:	50                   	push   %eax
40000b2b:	53                   	push   %ebx
40000b2c:	8b 45 08             	mov    0x8(%ebp),%eax
40000b2f:	50                   	push   %eax
40000b30:	e8 eb 05 00 00       	call   40001120 <_sbrk_r>

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
40000b35:	83 c4 10             	add    $0x10,%esp
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
40000b38:	89 c2                	mov    %eax,%edx

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
40000b3a:	83 f8 ff             	cmp    $0xffffffff,%eax
40000b3d:	74 1d                	je     40000b5c <_malloc_r+0x37c>
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
40000b3f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
40000b42:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
40000b45:	8d 04 0e             	lea    (%esi,%ecx,1),%eax
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
40000b48:	39 d0                	cmp    %edx,%eax
40000b4a:	0f 86 72 01 00 00    	jbe    40000cc2 <_malloc_r+0x4e2>
40000b50:	81 fe 80 d4 00 40    	cmp    $0x4000d480,%esi
40000b56:	0f 84 de 03 00 00    	je     40000f3a <_malloc_r+0x75a>
40000b5c:	8b 35 88 d4 00 40    	mov    0x4000d488,%esi
    }
#endif

    /* Try to extend */
    malloc_extend_top(RCALL nb);
    remainder_size = long_sub_size_t(chunksize(top), nb);
40000b62:	8b 46 04             	mov    0x4(%esi),%eax
40000b65:	83 e0 fc             	and    $0xfffffffc,%eax
40000b68:	89 c2                	mov    %eax,%edx
40000b6a:	29 fa                	sub    %edi,%edx
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
40000b6c:	39 c7                	cmp    %eax,%edi
40000b6e:	0f 86 40 01 00 00    	jbe    40000cb4 <_malloc_r+0x4d4>
    {
      MALLOC_UNLOCK;
40000b74:	83 ec 0c             	sub    $0xc,%esp
40000b77:	8b 55 08             	mov    0x8(%ebp),%edx
40000b7a:	52                   	push   %edx
40000b7b:	e8 c0 04 00 00       	call   40001040 <__malloc_unlock>
40000b80:	31 c0                	xor    %eax,%eax
      return 0; /* propagate failure */
40000b82:	83 c4 10             	add    $0x10,%esp
40000b85:	e9 84 fc ff ff       	jmp    4000080e <_malloc_r+0x2e>
40000b8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
40000b90:	83 f8 54             	cmp    $0x54,%eax
40000b93:	0f 86 d0 00 00 00    	jbe    40000c69 <_malloc_r+0x489>
40000b99:	3d 54 01 00 00       	cmp    $0x154,%eax
40000b9e:	0f 87 fe 01 00 00    	ja     40000da2 <_malloc_r+0x5c2>
40000ba4:	89 f8                	mov    %edi,%eax
40000ba6:	c1 e8 0f             	shr    $0xf,%eax
40000ba9:	8d 70 77             	lea    0x77(%eax),%esi
40000bac:	83 c0 78             	add    $0x78,%eax
40000baf:	89 45 f0             	mov    %eax,-0x10(%ebp)
40000bb2:	c1 e0 03             	shl    $0x3,%eax
40000bb5:	e9 0a fd ff ff       	jmp    400008c4 <_malloc_r+0xe4>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
40000bba:	c1 ea 03             	shr    $0x3,%edx
40000bbd:	b8 01 00 00 00       	mov    $0x1,%eax
40000bc2:	89 d1                	mov    %edx,%ecx
40000bc4:	8b 35 84 d4 00 40    	mov    0x4000d484,%esi
40000bca:	c1 e9 02             	shr    $0x2,%ecx
40000bcd:	8d 14 d5 80 d4 00 40 	lea    0x4000d480(,%edx,8),%edx
40000bd4:	d3 e0                	shl    %cl,%eax
40000bd6:	09 c6                	or     %eax,%esi
40000bd8:	8b 42 08             	mov    0x8(%edx),%eax
40000bdb:	89 53 0c             	mov    %edx,0xc(%ebx)
40000bde:	89 43 08             	mov    %eax,0x8(%ebx)
40000be1:	89 35 84 d4 00 40    	mov    %esi,0x4000d484
40000be7:	89 5a 08             	mov    %ebx,0x8(%edx)
40000bea:	89 58 0c             	mov    %ebx,0xc(%eax)
40000bed:	e9 f1 fd ff ff       	jmp    400009e3 <_malloc_r+0x203>

  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
40000bf2:	83 fa 0f             	cmp    $0xf,%edx
40000bf5:	0f 8e 0e ff ff ff    	jle    40000b09 <_malloc_r+0x329>
      return 0; /* propagate failure */
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
40000bfb:	89 f8                	mov    %edi,%eax
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
40000bfd:	83 ca 01             	or     $0x1,%edx
      return 0; /* propagate failure */
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
40000c00:	83 c8 01             	or     $0x1,%eax
40000c03:	89 46 04             	mov    %eax,0x4(%esi)
  top = chunk_at_offset(victim, nb);
40000c06:	8d 04 3e             	lea    (%esi,%edi,1),%eax
40000c09:	a3 88 d4 00 40       	mov    %eax,0x4000d488
  set_head(top, remainder_size | PREV_INUSE);
40000c0e:	89 50 04             	mov    %edx,0x4(%eax)
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
40000c11:	83 ec 0c             	sub    $0xc,%esp
40000c14:	8b 45 08             	mov    0x8(%ebp),%eax
40000c17:	50                   	push   %eax
40000c18:	e8 23 04 00 00       	call   40001040 <__malloc_unlock>
  return chunk2mem(victim);
40000c1d:	8d 46 08             	lea    0x8(%esi),%eax
40000c20:	83 c4 10             	add    $0x10,%esp

#endif /* MALLOC_PROVIDED */
}
40000c23:	8d 65 f4             	lea    -0xc(%ebp),%esp
40000c26:	5b                   	pop    %ebx
40000c27:	5e                   	pop    %esi
40000c28:	5f                   	pop    %edi
40000c29:	5d                   	pop    %ebp
40000c2a:	c3                   	ret    
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
40000c2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
      block <<= 1;
      while ((block & binblocks) == 0)
40000c2e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
40000c31:	83 e0 fc             	and    $0xfffffffc,%eax
40000c34:	83 c0 04             	add    $0x4,%eax
40000c37:	89 45 f0             	mov    %eax,-0x10(%ebp)
      block <<= 1;
40000c3a:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000c3d:	01 c0                	add    %eax,%eax
40000c3f:	89 45 e0             	mov    %eax,-0x20(%ebp)
      while ((block & binblocks) == 0)
40000c42:	85 55 e0             	test   %edx,-0x20(%ebp)
40000c45:	0f 85 cd fd ff ff    	jne    40000a18 <_malloc_r+0x238>
      {
        idx += BINBLOCKWIDTH;
40000c4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
40000c4e:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
      {
        idx += BINBLOCKWIDTH;
40000c51:	83 c0 04             	add    $0x4,%eax
40000c54:	89 45 f0             	mov    %eax,-0x10(%ebp)
        block <<= 1;
40000c57:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000c5a:	01 c0                	add    %eax,%eax
40000c5c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
40000c5f:	85 4d e0             	test   %ecx,-0x20(%ebp)
40000c62:	74 e7                	je     40000c4b <_malloc_r+0x46b>
40000c64:	e9 af fd ff ff       	jmp    40000a18 <_malloc_r+0x238>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
40000c69:	89 f8                	mov    %edi,%eax
40000c6b:	c1 e8 0c             	shr    $0xc,%eax
40000c6e:	8d 70 6e             	lea    0x6e(%eax),%esi
40000c71:	83 c0 6f             	add    $0x6f,%eax
40000c74:	89 45 f0             	mov    %eax,-0x10(%ebp)
40000c77:	c1 e0 03             	shl    $0x3,%eax
40000c7a:	e9 45 fc ff ff       	jmp    400008c4 <_malloc_r+0xe4>
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
40000c7f:	8b 75 ec             	mov    -0x14(%ebp),%esi
40000c82:	46                   	inc    %esi
40000c83:	89 75 ec             	mov    %esi,-0x14(%ebp)
40000c86:	f6 45 ec 03          	testb  $0x3,-0x14(%ebp)
40000c8a:	0f 84 38 02 00 00    	je     40000ec8 <_malloc_r+0x6e8>
40000c90:	83 c1 08             	add    $0x8,%ecx
40000c93:	e9 8f fd ff ff       	jmp    40000a27 <_malloc_r+0x247>
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
40000c98:	8b 7c 32 04          	mov    0x4(%edx,%esi,1),%edi
            unlink(victim, bck, fwd);
40000c9c:	8b 46 08             	mov    0x8(%esi),%eax
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
40000c9f:	83 cf 01             	or     $0x1,%edi
40000ca2:	89 7c 32 04          	mov    %edi,0x4(%edx,%esi,1)
            unlink(victim, bck, fwd);
40000ca6:	8b 56 0c             	mov    0xc(%esi),%edx
40000ca9:	89 50 0c             	mov    %edx,0xc(%eax)
40000cac:	89 42 08             	mov    %eax,0x8(%edx)
40000caf:	e9 5d ff ff ff       	jmp    40000c11 <_malloc_r+0x431>
#endif

    /* Try to extend */
    malloc_extend_top(RCALL nb);
    remainder_size = long_sub_size_t(chunksize(top), nb);
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
40000cb4:	83 fa 0f             	cmp    $0xf,%edx
40000cb7:	0f 8f 3e ff ff ff    	jg     40000bfb <_malloc_r+0x41b>
40000cbd:	e9 b2 fe ff ff       	jmp    40000b74 <_malloc_r+0x394>
  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
40000cc2:	8b 0d 20 d9 00 40    	mov    0x4000d920,%ecx
40000cc8:	01 d9                	add    %ebx,%ecx

  if (brk == old_end /* can just add bytes to current top, unless
40000cca:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
40000ccd:	89 4d d0             	mov    %ecx,-0x30(%ebp)
40000cd0:	89 0d 20 d9 00 40    	mov    %ecx,0x4000d920

  if (brk == old_end /* can just add bytes to current top, unless
40000cd6:	0f 84 3a 02 00 00    	je     40000f16 <_malloc_r+0x736>
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
40000cdc:	83 3d 8c d8 00 40 ff 	cmpl   $0xffffffff,0x4000d88c
40000ce3:	0f 84 d4 01 00 00    	je     40000ebd <_malloc_r+0x6dd>
      sbrk_base = brk;
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
40000ce9:	89 d1                	mov    %edx,%ecx
40000ceb:	29 c1                	sub    %eax,%ecx
40000ced:	89 c8                	mov    %ecx,%eax
40000cef:	8b 4d d0             	mov    -0x30(%ebp),%ecx
40000cf2:	01 c8                	add    %ecx,%eax
40000cf4:	a3 20 d9 00 40       	mov    %eax,0x4000d920

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
    if (front_misalign > 0) 
40000cf9:	89 d1                	mov    %edx,%ecx
40000cfb:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
40000d02:	83 e1 07             	and    $0x7,%ecx
40000d05:	74 14                	je     40000d1b <_malloc_r+0x53b>
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
40000d07:	b8 08 00 00 00       	mov    $0x8,%eax
40000d0c:	29 c8                	sub    %ecx,%eax
      brk += correction;
40000d0e:	01 c2                	add    %eax,%edx
40000d10:	05 00 10 00 00       	add    $0x1000,%eax
40000d15:	89 55 e4             	mov    %edx,-0x1c(%ebp)
40000d18:	89 45 e8             	mov    %eax,-0x18(%ebp)
    }
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
40000d1b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40000d1e:	01 d8                	add    %ebx,%eax
40000d20:	8b 5d e8             	mov    -0x18(%ebp),%ebx
40000d23:	25 ff 0f 00 00       	and    $0xfff,%eax
40000d28:	29 c3                	sub    %eax,%ebx

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
40000d2a:	50                   	push   %eax
40000d2b:	50                   	push   %eax
40000d2c:	53                   	push   %ebx
40000d2d:	8b 45 08             	mov    0x8(%ebp),%eax
40000d30:	50                   	push   %eax
40000d31:	e8 ea 03 00 00       	call   40001120 <_sbrk_r>
    if (new_brk == (char*)(MORECORE_FAILURE))
40000d36:	83 c4 10             	add    $0x10,%esp
40000d39:	83 f8 ff             	cmp    $0xffffffff,%eax
40000d3c:	0f 84 6f 01 00 00    	je     40000eb1 <_malloc_r+0x6d1>
40000d42:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40000d45:	29 c8                	sub    %ecx,%eax
40000d47:	01 d8                	add    %ebx,%eax
40000d49:	83 c8 01             	or     $0x1,%eax
	correction = 0;
	correction_failed = 1;
	new_brk = brk;
      }

    sbrked_mem += correction;
40000d4c:	8b 15 20 d9 00 40    	mov    0x4000d920,%edx
40000d52:	01 da                	add    %ebx,%edx

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
40000d54:	81 fe 80 d4 00 40    	cmp    $0x4000d480,%esi
	correction = 0;
	correction_failed = 1;
	new_brk = brk;
      }

    sbrked_mem += correction;
40000d5a:	89 15 20 d9 00 40    	mov    %edx,0x4000d920

    top = (mchunkptr)brk;
40000d60:	8b 55 e4             	mov    -0x1c(%ebp),%edx
40000d63:	89 15 88 d4 00 40    	mov    %edx,0x4000d488
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
40000d69:	89 42 04             	mov    %eax,0x4(%edx)

    if (old_top != initial_top)
40000d6c:	74 55                	je     40000dc3 <_malloc_r+0x5e3>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
40000d6e:	83 7d d8 0f          	cmpl   $0xf,-0x28(%ebp)
40000d72:	0f 87 94 00 00 00    	ja     40000e0c <_malloc_r+0x62c>
40000d78:	89 d6                	mov    %edx,%esi
      {
        set_head(top, PREV_INUSE); /* will force null return from malloc */
40000d7a:	c7 42 04 01 00 00 00 	movl   $0x1,0x4(%edx)
40000d81:	e9 dc fd ff ff       	jmp    40000b62 <_malloc_r+0x382>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
40000d86:	83 f8 04             	cmp    $0x4,%eax
40000d89:	77 66                	ja     40000df1 <_malloc_r+0x611>
40000d8b:	89 d0                	mov    %edx,%eax
40000d8d:	c1 e8 06             	shr    $0x6,%eax
40000d90:	8d 48 38             	lea    0x38(%eax),%ecx
40000d93:	8d 04 c5 c8 01 00 00 	lea    0x1c8(,%eax,8),%eax
40000d9a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
40000d9d:	e9 fe fb ff ff       	jmp    400009a0 <_malloc_r+0x1c0>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
40000da2:	3d 54 05 00 00       	cmp    $0x554,%eax
40000da7:	0f 86 a5 00 00 00    	jbe    40000e52 <_malloc_r+0x672>
40000dad:	be 7e 00 00 00       	mov    $0x7e,%esi
40000db2:	b8 f8 03 00 00       	mov    $0x3f8,%eax
40000db7:	c7 45 f0 7f 00 00 00 	movl   $0x7f,-0x10(%ebp)
40000dbe:	e9 01 fb ff ff       	jmp    400008c4 <_malloc_r+0xe4>
40000dc3:	8b 35 88 d4 00 40    	mov    0x4000d488,%esi
      if (old_top_size >= MINSIZE) 
        fREe(RCALL chunk2mem(old_top));
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
40000dc9:	a1 20 d9 00 40       	mov    0x4000d920,%eax
40000dce:	3b 05 04 d9 00 40    	cmp    0x4000d904,%eax
40000dd4:	76 05                	jbe    40000ddb <_malloc_r+0x5fb>
    max_sbrked_mem = sbrked_mem;
40000dd6:	a3 04 d9 00 40       	mov    %eax,0x4000d904
#if HAVE_MMAP
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem) 
    max_total_mem = mmapped_mem + sbrked_mem;
#else
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
40000ddb:	3b 05 08 d9 00 40    	cmp    0x4000d908,%eax
40000de1:	0f 86 7b fd ff ff    	jbe    40000b62 <_malloc_r+0x382>
    max_total_mem = sbrked_mem;
40000de7:	a3 08 d9 00 40       	mov    %eax,0x4000d908
40000dec:	e9 71 fd ff ff       	jmp    40000b62 <_malloc_r+0x382>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
40000df1:	83 f8 14             	cmp    $0x14,%eax
40000df4:	0f 87 97 00 00 00    	ja     40000e91 <_malloc_r+0x6b1>
40000dfa:	8d 48 5b             	lea    0x5b(%eax),%ecx
40000dfd:	8d 04 c5 e0 02 00 00 	lea    0x2e0(,%eax,8),%eax
40000e04:	89 4d dc             	mov    %ecx,-0x24(%ebp)
40000e07:	e9 94 fb ff ff       	jmp    400009a0 <_malloc_r+0x1c0>
        set_head(top, PREV_INUSE); /* will force null return from malloc */
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
40000e0c:	8b 55 d8             	mov    -0x28(%ebp),%edx
40000e0f:	83 ea 0c             	sub    $0xc,%edx
40000e12:	83 e2 f8             	and    $0xfffffff8,%edx
      chunk_at_offset(old_top, old_top_size          )->size =
40000e15:	c7 44 16 04 05 00 00 	movl   $0x5,0x4(%esi,%edx,1)
40000e1c:	00 
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
40000e1d:	c7 44 32 08 05 00 00 	movl   $0x5,0x8(%edx,%esi,1)
40000e24:	00 
        SIZE_SZ|PREV_INUSE;
      set_head_size(old_top, old_top_size);
40000e25:	8b 46 04             	mov    0x4(%esi),%eax
40000e28:	83 e0 01             	and    $0x1,%eax
40000e2b:	09 d0                	or     %edx,%eax
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
40000e2d:	83 fa 0f             	cmp    $0xf,%edx
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      chunk_at_offset(old_top, old_top_size          )->size =
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
        SIZE_SZ|PREV_INUSE;
      set_head_size(old_top, old_top_size);
40000e30:	89 46 04             	mov    %eax,0x4(%esi)
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
40000e33:	76 8e                	jbe    40000dc3 <_malloc_r+0x5e3>
        fREe(RCALL chunk2mem(old_top));
40000e35:	8d 46 08             	lea    0x8(%esi),%eax
40000e38:	53                   	push   %ebx
40000e39:	53                   	push   %ebx
40000e3a:	50                   	push   %eax
40000e3b:	8b 4d 08             	mov    0x8(%ebp),%ecx
40000e3e:	51                   	push   %ecx
40000e3f:	e8 1c 61 00 00       	call   40006f60 <_free_r>
40000e44:	83 c4 10             	add    $0x10,%esp
40000e47:	8b 35 88 d4 00 40    	mov    0x4000d488,%esi
40000e4d:	e9 77 ff ff ff       	jmp    40000dc9 <_malloc_r+0x5e9>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
40000e52:	89 f8                	mov    %edi,%eax
40000e54:	c1 e8 12             	shr    $0x12,%eax
40000e57:	8d 70 7c             	lea    0x7c(%eax),%esi
40000e5a:	83 c0 7d             	add    $0x7d,%eax
40000e5d:	89 45 f0             	mov    %eax,-0x10(%ebp)
40000e60:	c1 e0 03             	shl    $0x3,%eax
40000e63:	e9 5c fa ff ff       	jmp    400008c4 <_malloc_r+0xe4>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
40000e68:	8b 4d dc             	mov    -0x24(%ebp),%ecx
40000e6b:	b8 01 00 00 00       	mov    $0x1,%eax
40000e70:	c1 e9 02             	shr    $0x2,%ecx
40000e73:	8b 15 84 d4 00 40    	mov    0x4000d484,%edx
40000e79:	89 4d dc             	mov    %ecx,-0x24(%ebp)
40000e7c:	8a 4d dc             	mov    -0x24(%ebp),%cl
40000e7f:	d3 e0                	shl    %cl,%eax
40000e81:	09 c2                	or     %eax,%edx
40000e83:	8b 45 d0             	mov    -0x30(%ebp),%eax
40000e86:	89 15 84 d4 00 40    	mov    %edx,0x4000d484
40000e8c:	e9 43 fb ff ff       	jmp    400009d4 <_malloc_r+0x1f4>
40000e91:	83 f8 54             	cmp    $0x54,%eax
40000e94:	0f 87 b6 00 00 00    	ja     40000f50 <_malloc_r+0x770>
40000e9a:	89 d0                	mov    %edx,%eax
40000e9c:	c1 e8 0c             	shr    $0xc,%eax
40000e9f:	8d 48 6e             	lea    0x6e(%eax),%ecx
40000ea2:	8d 04 c5 78 03 00 00 	lea    0x378(,%eax,8),%eax
40000ea9:	89 4d dc             	mov    %ecx,-0x24(%ebp)
40000eac:	e9 ef fa ff ff       	jmp    400009a0 <_malloc_r+0x1c0>
    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE))
40000eb1:	31 db                	xor    %ebx,%ebx
40000eb3:	b8 01 00 00 00       	mov    $0x1,%eax
40000eb8:	e9 8f fe ff ff       	jmp    40000d4c <_malloc_r+0x56c>
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
      sbrk_base = brk;
40000ebd:	89 15 8c d8 00 40    	mov    %edx,0x4000d88c
40000ec3:	e9 31 fe ff ff       	jmp    40000cf9 <_malloc_r+0x519>
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
40000ec8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40000ecb:	89 c2                	mov    %eax,%edx
40000ecd:	eb 01                	jmp    40000ed0 <_malloc_r+0x6f0>
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
40000ecf:	49                   	dec    %ecx

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
40000ed0:	f6 c1 03             	test   $0x3,%cl
40000ed3:	0f 84 95 00 00 00    	je     40000f6e <_malloc_r+0x78e>
        {
          binblocks &= ~block;
          break;
40000ed9:	8d 42 f8             	lea    -0x8(%edx),%eax
        }
        --startidx;
       q = prev_bin(q);
      } while (first(q) == q);
40000edc:	8b 50 08             	mov    0x8(%eax),%edx
40000edf:	39 c2                	cmp    %eax,%edx
40000ee1:	74 ec                	je     40000ecf <_malloc_r+0x6ef>

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
40000ee3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
40000ee6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
40000ee9:	01 c9                	add    %ecx,%ecx
40000eeb:	89 4d e0             	mov    %ecx,-0x20(%ebp)
40000eee:	39 45 e0             	cmp    %eax,-0x20(%ebp)
40000ef1:	0f 87 f7 fb ff ff    	ja     40000aee <_malloc_r+0x30e>
40000ef7:	8b 55 e0             	mov    -0x20(%ebp),%edx
40000efa:	85 d2                	test   %edx,%edx
40000efc:	0f 84 ec fb ff ff    	je     40000aee <_malloc_r+0x30e>
      {
        while ((block & binblocks) == 0)
40000f02:	85 45 e0             	test   %eax,-0x20(%ebp)
40000f05:	0f 84 9d 00 00 00    	je     40000fa8 <_malloc_r+0x7c8>
40000f0b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40000f0e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40000f11:	e9 02 fb ff ff       	jmp    40000a18 <_malloc_r+0x238>
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;

  if (brk == old_end /* can just add bytes to current top, unless
40000f16:	f7 45 e4 ff 0f 00 00 	testl  $0xfff,-0x1c(%ebp)
40000f1d:	0f 85 b9 fd ff ff    	jne    40000cdc <_malloc_r+0x4fc>
			previous correction failed */
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
  {
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
40000f23:	8b 55 d8             	mov    -0x28(%ebp),%edx
40000f26:	8b 35 88 d4 00 40    	mov    0x4000d488,%esi
40000f2c:	8d 04 13             	lea    (%ebx,%edx,1),%eax
40000f2f:	83 c8 01             	or     $0x1,%eax
40000f32:	89 46 04             	mov    %eax,0x4(%esi)
40000f35:	e9 8f fe ff ff       	jmp    40000dc9 <_malloc_r+0x5e9>
  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
40000f3a:	8b 0d 20 d9 00 40    	mov    0x4000d920,%ecx
40000f40:	01 d9                	add    %ebx,%ecx
40000f42:	89 4d d0             	mov    %ecx,-0x30(%ebp)
40000f45:	89 0d 20 d9 00 40    	mov    %ecx,0x4000d920
40000f4b:	e9 8c fd ff ff       	jmp    40000cdc <_malloc_r+0x4fc>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
40000f50:	3d 54 01 00 00       	cmp    $0x154,%eax
40000f55:	77 39                	ja     40000f90 <_malloc_r+0x7b0>
40000f57:	89 d0                	mov    %edx,%eax
40000f59:	c1 e8 0f             	shr    $0xf,%eax
40000f5c:	8d 48 77             	lea    0x77(%eax),%ecx
40000f5f:	8d 04 c5 c0 03 00 00 	lea    0x3c0(,%eax,8),%eax
40000f66:	89 4d dc             	mov    %ecx,-0x24(%ebp)
40000f69:	e9 32 fa ff ff       	jmp    400009a0 <_malloc_r+0x1c0>

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
        {
          binblocks &= ~block;
40000f6e:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000f71:	8b 1d 84 d4 00 40    	mov    0x4000d484,%ebx
40000f77:	83 f0 ff             	xor    $0xffffffff,%eax
40000f7a:	21 c3                	and    %eax,%ebx
40000f7c:	89 1d 84 d4 00 40    	mov    %ebx,0x4000d484
40000f82:	8b 0d 84 d4 00 40    	mov    0x4000d484,%ecx
40000f88:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
40000f8b:	e9 53 ff ff ff       	jmp    40000ee3 <_malloc_r+0x703>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
40000f90:	3d 54 05 00 00       	cmp    $0x554,%eax
40000f95:	76 39                	jbe    40000fd0 <_malloc_r+0x7f0>
40000f97:	b8 f8 03 00 00       	mov    $0x3f8,%eax
40000f9c:	c7 45 dc 7e 00 00 00 	movl   $0x7e,-0x24(%ebp)
40000fa3:	e9 f8 f9 ff ff       	jmp    400009a0 <_malloc_r+0x1c0>

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
        {
          idx += BINBLOCKWIDTH;
40000fa8:	8b 45 ec             	mov    -0x14(%ebp),%eax

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
40000fab:	8b 55 d4             	mov    -0x2c(%ebp),%edx
        {
          idx += BINBLOCKWIDTH;
40000fae:	83 c0 04             	add    $0x4,%eax
40000fb1:	89 45 ec             	mov    %eax,-0x14(%ebp)
          block <<= 1;
40000fb4:	8b 45 e0             	mov    -0x20(%ebp),%eax
40000fb7:	01 c0                	add    %eax,%eax
40000fb9:	89 45 e0             	mov    %eax,-0x20(%ebp)

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
40000fbc:	85 55 e0             	test   %edx,-0x20(%ebp)
40000fbf:	0f 85 46 ff ff ff    	jne    40000f0b <_malloc_r+0x72b>
40000fc5:	eb e1                	jmp    40000fa8 <_malloc_r+0x7c8>
40000fc7:	89 f6                	mov    %esi,%esi
40000fc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
40000fd0:	89 d0                	mov    %edx,%eax
40000fd2:	c1 e8 12             	shr    $0x12,%eax
40000fd5:	8d 48 7c             	lea    0x7c(%eax),%ecx
40000fd8:	8d 04 c5 e8 03 00 00 	lea    0x3e8(,%eax,8),%eax
40000fdf:	89 4d dc             	mov    %ecx,-0x24(%ebp)
40000fe2:	e9 b9 f9 ff ff       	jmp    400009a0 <_malloc_r+0x1c0>
40000fe7:	90                   	nop    

40000fe8 <memset>:
40000fe8:	55                   	push   %ebp
40000fe9:	89 e5                	mov    %esp,%ebp
40000feb:	57                   	push   %edi
40000fec:	53                   	push   %ebx
40000fed:	8b 7d 08             	mov    0x8(%ebp),%edi
40000ff0:	8b 45 0c             	mov    0xc(%ebp),%eax
40000ff3:	8b 4d 10             	mov    0x10(%ebp),%ecx
40000ff6:	fc                   	cld    
40000ff7:	25 ff 00 00 00       	and    $0xff,%eax
40000ffc:	89 cb                	mov    %ecx,%ebx
40000ffe:	f7 c7 03 00 00 00    	test   $0x3,%edi
40001004:	75 1d                	jne    40001023 <memset+0x3b>
40001006:	83 f9 10             	cmp    $0x10,%ecx
40001009:	76 18                	jbe    40001023 <memset+0x3b>
4000100b:	89 c2                	mov    %eax,%edx
4000100d:	c1 e0 08             	shl    $0x8,%eax
40001010:	09 d0                	or     %edx,%eax
40001012:	89 c2                	mov    %eax,%edx
40001014:	c1 e2 10             	shl    $0x10,%edx
40001017:	09 d0                	or     %edx,%eax
40001019:	c1 e9 02             	shr    $0x2,%ecx
4000101c:	83 e3 03             	and    $0x3,%ebx
4000101f:	f3 ab                	rep stos %eax,%es:(%edi)
40001021:	89 d9                	mov    %ebx,%ecx
40001023:	f3 aa                	rep stos %al,%es:(%edi)
40001025:	8b 45 08             	mov    0x8(%ebp),%eax
40001028:	8d 65 f8             	lea    -0x8(%ebp),%esp
4000102b:	5b                   	pop    %ebx
4000102c:	5f                   	pop    %edi
4000102d:	c9                   	leave  
4000102e:	c3                   	ret    
4000102f:	90                   	nop    

40001030 <__malloc_lock>:
RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.

PORTABILITY
ANSI C requires <<fflush>>.
40001030:	55                   	push   %ebp
40001031:	89 e5                	mov    %esp,%ebp

No supporting OS subroutines are required.
*/

40001033:	5d                   	pop    %ebp
40001034:	c3                   	ret    
40001035:	8d 74 26 00          	lea    0x0(%esi),%esi
40001039:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40001040 <__malloc_unlock>:
#include <_ansi.h>
#include <stdio.h>
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */
40001040:	55                   	push   %ebp
40001041:	89 e5                	mov    %esp,%ebp

int
_DEFUN(fflush, (fp),
       register FILE * fp)
40001043:	5d                   	pop    %ebp
40001044:	c3                   	ret    
40001045:	90                   	nop    
40001046:	90                   	nop    
40001047:	90                   	nop    
40001048:	90                   	nop    
40001049:	90                   	nop    
4000104a:	90                   	nop    
4000104b:	90                   	nop    
4000104c:	90                   	nop    
4000104d:	90                   	nop    
4000104e:	90                   	nop    
4000104f:	90                   	nop    

40001050 <printf>:
{
  register unsigned char *p;
40001050:	55                   	push   %ebp
40001051:	89 e5                	mov    %esp,%ebp
40001053:	83 ec 1c             	sub    $0x1c,%esp
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);
40001056:	8d 45 0c             	lea    0xc(%ebp),%eax

  _flockfile (fp);

  t = fp->_flags;
40001059:	8b 55 08             	mov    0x8(%ebp),%edx
4000105c:	50                   	push   %eax
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);
4000105d:	89 45 fc             	mov    %eax,-0x4(%ebp)

  _flockfile (fp);

  t = fp->_flags;
40001060:	a1 60 d0 00 40       	mov    0x4000d060,%eax
40001065:	52                   	push   %edx
40001066:	8b 40 08             	mov    0x8(%eax),%eax
40001069:	50                   	push   %eax
4000106a:	e8 c1 26 00 00       	call   40003730 <vfprintf>
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));
4000106f:	c9                   	leave  
40001070:	c3                   	ret    
40001071:	eb 0d                	jmp    40001080 <_printf_r>
40001073:	90                   	nop    
40001074:	90                   	nop    
40001075:	90                   	nop    
40001076:	90                   	nop    
40001077:	90                   	nop    
40001078:	90                   	nop    
40001079:	90                   	nop    
4000107a:	90                   	nop    
4000107b:	90                   	nop    
4000107c:	90                   	nop    
4000107d:	90                   	nop    
4000107e:	90                   	nop    
4000107f:	90                   	nop    

40001080 <_printf_r>:

DESCRIPTION
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

Use <<fflush>> to deliver any such pending output (for the file
40001080:	55                   	push   %ebp
40001081:	89 e5                	mov    %esp,%ebp
40001083:	83 ec 18             	sub    $0x18,%esp
or stream identified by <[fp]>) to the host system.

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
open files.

RETURNS
40001086:	8d 45 10             	lea    0x10(%ebp),%eax

DESCRIPTION
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

Use <<fflush>> to deliver any such pending output (for the file
40001089:	8b 55 08             	mov    0x8(%ebp),%edx

RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.

PORTABILITY
4000108c:	50                   	push   %eax
or stream identified by <[fp]>) to the host system.

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
open files.

RETURNS
4000108d:	89 45 fc             	mov    %eax,-0x4(%ebp)
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.

PORTABILITY
40001090:	8b 45 0c             	mov    0xc(%ebp),%eax
40001093:	50                   	push   %eax
40001094:	8b 4a 08             	mov    0x8(%edx),%ecx
40001097:	51                   	push   %ecx
40001098:	52                   	push   %edx
40001099:	e8 22 05 00 00       	call   400015c0 <_vfprintf_r>
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
4000109e:	c9                   	leave  
4000109f:	c3                   	ret    

400010a0 <_puts_r>:
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
400010a0:	55                   	push   %ebp
400010a1:	89 e5                	mov    %esp,%ebp
400010a3:	56                   	push   %esi
400010a4:	53                   	push   %ebx
400010a5:	83 ec 2c             	sub    $0x2c,%esp
400010a8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
400010ab:	8b 75 08             	mov    0x8(%ebp),%esi
         to the POSIX and SUSv3 standards.  */
400010ae:	53                   	push   %ebx
400010af:	e8 18 02 00 00       	call   400012cc <strlen>
      fp->_flags |= __SNPT;

      /* For a seekable stream with buffered read characters, we will attempt
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
400010b4:	89 45 e0             	mov    %eax,-0x20(%ebp)
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
400010b7:	40                   	inc    %eax
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;

400010b8:	83 c4 0c             	add    $0xc,%esp
      /* For a seekable stream with buffered read characters, we will attempt
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
400010bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
         to miss a code scenario.  */
400010be:	8d 45 dc             	lea    -0x24(%ebp),%eax
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;

      /* For a seekable stream with buffered read characters, we will attempt
         a seek to the current position now.  A subsequent read will then get
400010c1:	89 5d dc             	mov    %ebx,-0x24(%ebp)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
400010c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;

400010c7:	8d 45 ec             	lea    -0x14(%ebp),%eax
400010ca:	50                   	push   %eax
      fp->_flags |= __SNPT;

      /* For a seekable stream with buffered read characters, we will attempt
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
400010cb:	c7 45 e4 3a bc 00 40 	movl   $0x4000bc3a,-0x1c(%ebp)
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;

400010d2:	8b 46 08             	mov    0x8(%esi),%eax

      /* For a seekable stream with buffered read characters, we will attempt
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
400010d5:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;

400010dc:	50                   	push   %eax
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
400010dd:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
        {
          _fpos_t curoff;

400010e4:	56                   	push   %esi
400010e5:	e8 56 61 00 00       	call   40007240 <__sfvwrite_r>
400010ea:	83 c4 10             	add    $0x10,%esp
400010ed:	83 f8 01             	cmp    $0x1,%eax
400010f0:	19 c0                	sbb    %eax,%eax
          /* Get the physical position we are at in the file.  */
400010f2:	8d 65 f8             	lea    -0x8(%ebp),%esp
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;

400010f5:	83 e0 0b             	and    $0xb,%eax
          /* Get the physical position we are at in the file.  */
400010f8:	5b                   	pop    %ebx
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;

400010f9:	48                   	dec    %eax
          /* Get the physical position we are at in the file.  */
400010fa:	5e                   	pop    %esi
400010fb:	5d                   	pop    %ebp
400010fc:	c3                   	ret    
400010fd:	8d 76 00             	lea    0x0(%esi),%esi

40001100 <puts>:
            curoff = fp->_offset;
          else
            {
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
40001100:	55                   	push   %ebp
40001101:	89 e5                	mov    %esp,%ebp
40001103:	83 ec 10             	sub    $0x10,%esp
                {
40001106:	8b 15 60 d0 00 40    	mov    0x4000d060,%edx
4000110c:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000110f:	51                   	push   %ecx
40001110:	52                   	push   %edx
40001111:	e8 8a ff ff ff       	call   400010a0 <_puts_r>
                  _funlockfile (fp);
40001116:	c9                   	leave  
40001117:	c3                   	ret    
40001118:	90                   	nop    
40001119:	90                   	nop    
4000111a:	90                   	nop    
4000111b:	90                   	nop    
4000111c:	90                   	nop    
4000111d:	90                   	nop    
4000111e:	90                   	nop    
4000111f:	90                   	nop    

40001120 <_sbrk_r>:

No supporting OS subroutines are required.
*/

#include <_ansi.h>
#include <stdio.h>
40001120:	55                   	push   %ebp
40001121:	89 e5                	mov    %esp,%ebp
40001123:	83 ec 14             	sub    $0x14,%esp
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */

40001126:	c7 05 60 d9 00 40 00 	movl   $0x0,0x4000d960
4000112d:	00 00 00 
int
40001130:	8b 45 0c             	mov    0xc(%ebp),%eax
40001133:	50                   	push   %eax
40001134:	e8 27 03 00 00       	call   40001460 <sbrk>
40001139:	83 c4 10             	add    $0x10,%esp
4000113c:	83 f8 ff             	cmp    $0xffffffff,%eax
4000113f:	74 0f                	je     40001150 <_sbrk_r+0x30>
_DEFUN(fflush, (fp),
       register FILE * fp)
{
40001141:	c9                   	leave  
40001142:	c3                   	ret    
40001143:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40001149:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
#include <stdio.h>
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */

int
40001150:	8b 15 60 d9 00 40    	mov    0x4000d960,%edx
40001156:	85 d2                	test   %edx,%edx
40001158:	74 e7                	je     40001141 <_sbrk_r+0x21>
_DEFUN(fflush, (fp),
4000115a:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000115d:	89 11                	mov    %edx,(%ecx)
       register FILE * fp)
{
4000115f:	c9                   	leave  
40001160:	c3                   	ret    
40001161:	90                   	nop    
40001162:	90                   	nop    
40001163:	90                   	nop    
40001164:	90                   	nop    
40001165:	90                   	nop    
40001166:	90                   	nop    
40001167:	90                   	nop    
40001168:	90                   	nop    
40001169:	90                   	nop    
4000116a:	90                   	nop    
4000116b:	90                   	nop    
4000116c:	90                   	nop    
4000116d:	90                   	nop    
4000116e:	90                   	nop    
4000116f:	90                   	nop    

40001170 <_scanf_r>:
  register unsigned char *p;
40001170:	55                   	push   %ebp
40001171:	89 e5                	mov    %esp,%ebp
40001173:	83 ec 18             	sub    $0x18,%esp
40001176:	8b 55 08             	mov    0x8(%ebp),%edx
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);
40001179:	8d 45 10             	lea    0x10(%ebp),%eax

  _flockfile (fp);

  t = fp->_flags;
4000117c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
4000117f:	50                   	push   %eax
40001180:	51                   	push   %ecx
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);
40001181:	89 45 fc             	mov    %eax,-0x4(%ebp)

  _flockfile (fp);

  t = fp->_flags;
40001184:	8b 42 04             	mov    0x4(%edx),%eax
40001187:	50                   	push   %eax
40001188:	52                   	push   %edx
40001189:	e8 c2 25 00 00       	call   40003750 <__svfscanf_r>
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));
4000118e:	c9                   	leave  
4000118f:	c3                   	ret    

40001190 <scanf>:

DESCRIPTION
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

Use <<fflush>> to deliver any such pending output (for the file
40001190:	55                   	push   %ebp
40001191:	89 e5                	mov    %esp,%ebp
40001193:	83 ec 18             	sub    $0x18,%esp

RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.

PORTABILITY
40001196:	8b 15 60 d0 00 40    	mov    0x4000d060,%edx
or stream identified by <[fp]>) to the host system.

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
open files.

RETURNS
4000119c:	8d 45 0c             	lea    0xc(%ebp),%eax
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.

PORTABILITY
4000119f:	50                   	push   %eax
or stream identified by <[fp]>) to the host system.

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
open files.

RETURNS
400011a0:	89 45 fc             	mov    %eax,-0x4(%ebp)
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.

PORTABILITY
400011a3:	8b 45 08             	mov    0x8(%ebp),%eax
400011a6:	50                   	push   %eax
400011a7:	8b 42 04             	mov    0x4(%edx),%eax
400011aa:	50                   	push   %eax
400011ab:	52                   	push   %edx
400011ac:	e8 9f 25 00 00       	call   40003750 <__svfscanf_r>
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
400011b1:	c9                   	leave  
400011b2:	c3                   	ret    
400011b3:	90                   	nop    
400011b4:	90                   	nop    
400011b5:	90                   	nop    
400011b6:	90                   	nop    
400011b7:	90                   	nop    
400011b8:	90                   	nop    
400011b9:	90                   	nop    
400011ba:	90                   	nop    
400011bb:	90                   	nop    
400011bc:	90                   	nop    
400011bd:	90                   	nop    
400011be:	90                   	nop    
400011bf:	90                   	nop    

400011c0 <__sclose>:
              curoff -= fp->_r;
              if (HASUB (fp))
                curoff -= fp->_ur;
            }
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
400011c0:	55                   	push   %ebp
400011c1:	89 e5                	mov    %esp,%ebp
400011c3:	83 ec 10             	sub    $0x10,%esp
            {
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
400011c6:	8b 45 08             	mov    0x8(%ebp),%eax
400011c9:	0f bf 40 0e          	movswl 0xe(%eax),%eax
400011cd:	50                   	push   %eax
400011ce:	a1 60 d0 00 40       	mov    0x4000d060,%eax
400011d3:	50                   	push   %eax
400011d4:	e8 17 43 00 00       	call   400054f0 <_close_r>
              fp->_r = 0;
400011d9:	c9                   	leave  
400011da:	c3                   	ret    
400011db:	90                   	nop    
400011dc:	8d 74 26 00          	lea    0x0(%esi),%esi

400011e0 <__sseek>:

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
            {
400011e0:	55                   	push   %ebp
400011e1:	89 e5                	mov    %esp,%ebp
400011e3:	53                   	push   %ebx
400011e4:	83 ec 04             	sub    $0x4,%esp
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
400011e7:	8b 45 10             	mov    0x10(%ebp),%eax

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
            {
400011ea:	8b 5d 08             	mov    0x8(%ebp),%ebx
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
400011ed:	50                   	push   %eax
400011ee:	8b 4d 0c             	mov    0xc(%ebp),%ecx
400011f1:	51                   	push   %ecx
400011f2:	0f bf 43 0e          	movswl 0xe(%ebx),%eax
400011f6:	50                   	push   %eax
400011f7:	8b 15 60 d0 00 40    	mov    0x4000d060,%edx
400011fd:	52                   	push   %edx
400011fe:	e8 cd 65 00 00       	call   400077d0 <_lseek_r>
                  _funlockfile (fp);
40001203:	83 c4 10             	add    $0x10,%esp
40001206:	83 f8 ff             	cmp    $0xffffffff,%eax
40001209:	74 15                	je     40001220 <__sseek+0x40>
                  return 0;
                }
            }
          if (fp->_flags & __SRD)
4000120b:	66 81 4b 0c 00 10    	orw    $0x1000,0xc(%ebx)
            {
40001211:	89 43 50             	mov    %eax,0x50(%ebx)
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
40001214:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40001217:	c9                   	leave  
40001218:	c3                   	ret    
40001219:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
                  _funlockfile (fp);
                  return 0;
40001220:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
40001226:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40001229:	c9                   	leave  
4000122a:	c3                   	ret    
4000122b:	90                   	nop    
4000122c:	8d 74 26 00          	lea    0x0(%esi),%esi

40001230 <__swrite>:
{
  register unsigned char *p;
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);
40001230:	55                   	push   %ebp
40001231:	89 e5                	mov    %esp,%ebp
40001233:	53                   	push   %ebx
40001234:	83 ec 04             	sub    $0x4,%esp
40001237:	8b 5d 08             	mov    0x8(%ebp),%ebx
  CHECK_INIT (_REENT, fp);

  _flockfile (fp);

  t = fp->_flags;
  if ((t & __SWR) == 0)
4000123a:	f6 43 0d 01          	testb  $0x1,0xd(%ebx)
4000123e:	74 17                	je     40001257 <__swrite+0x27>
    {
40001240:	6a 02                	push   $0x2
40001242:	6a 00                	push   $0x0
40001244:	0f bf 43 0e          	movswl 0xe(%ebx),%eax
40001248:	50                   	push   %eax
40001249:	a1 60 d0 00 40       	mov    0x4000d060,%eax
4000124e:	50                   	push   %eax
4000124f:	e8 7c 65 00 00       	call   400077d0 <_lseek_r>
40001254:	83 c4 10             	add    $0x10,%esp
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;

      /* For a seekable stream with buffered read characters, we will attempt
40001257:	8b 45 10             	mov    0x10(%ebp),%eax
  _flockfile (fp);

  t = fp->_flags;
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));
4000125a:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;

      /* For a seekable stream with buffered read characters, we will attempt
40001260:	50                   	push   %eax
40001261:	8b 45 0c             	mov    0xc(%ebp),%eax
40001264:	50                   	push   %eax
40001265:	0f bf 43 0e          	movswl 0xe(%ebx),%eax
40001269:	50                   	push   %eax
4000126a:	a1 60 d0 00 40       	mov    0x4000d060,%eax
4000126f:	50                   	push   %eax
40001270:	e8 2b 41 00 00       	call   400053a0 <_write_r>
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
40001275:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40001278:	c9                   	leave  
40001279:	c3                   	ret    
4000127a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

40001280 <__sread>:
	FILE *<[fp]>;

DESCRIPTION
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

40001280:	55                   	push   %ebp
40001281:	89 e5                	mov    %esp,%ebp
40001283:	53                   	push   %ebx
40001284:	83 ec 04             	sub    $0x4,%esp
open files.

RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.

40001287:	8b 45 10             	mov    0x10(%ebp),%eax
	FILE *<[fp]>;

DESCRIPTION
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

4000128a:	8b 5d 08             	mov    0x8(%ebp),%ebx
open files.

RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.

4000128d:	50                   	push   %eax
4000128e:	8b 45 0c             	mov    0xc(%ebp),%eax
40001291:	50                   	push   %eax
40001292:	0f bf 43 0e          	movswl 0xe(%ebx),%eax
40001296:	50                   	push   %eax
40001297:	8b 0d 60 d0 00 40    	mov    0x4000d060,%ecx
4000129d:	51                   	push   %ecx
4000129e:	e8 7d 76 00 00       	call   40008920 <_read_r>
No supporting OS subroutines are required.
*/

#include <_ansi.h>
#include <stdio.h>
#include "local.h"
400012a3:	83 c4 10             	add    $0x10,%esp
400012a6:	85 c0                	test   %eax,%eax
400012a8:	78 16                	js     400012c0 <__sread+0x40>

400012aa:	8b 53 50             	mov    0x50(%ebx),%edx
400012ad:	01 c2                	add    %eax,%edx
400012af:	89 53 50             	mov    %edx,0x50(%ebx)
/* Flush a single file, or (if fp is NULL) all files.  */

int
_DEFUN(fflush, (fp),
400012b2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400012b5:	c9                   	leave  
400012b6:	c3                   	ret    
400012b7:	89 f6                	mov    %esi,%esi
400012b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
#include <_ansi.h>
#include <stdio.h>
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */

400012c0:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
int
_DEFUN(fflush, (fp),
400012c6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400012c9:	c9                   	leave  
400012ca:	c3                   	ret    
400012cb:	90                   	nop    

400012cc <strlen>:
400012cc:	55                   	push   %ebp
400012cd:	89 e5                	mov    %esp,%ebp
400012cf:	57                   	push   %edi
400012d0:	8b 55 08             	mov    0x8(%ebp),%edx
400012d3:	fc                   	cld    
400012d4:	89 d7                	mov    %edx,%edi
400012d6:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
400012db:	31 c0                	xor    %eax,%eax
400012dd:	f2 ae                	repnz scas %es:(%edi),%al
400012df:	29 d7                	sub    %edx,%edi
400012e1:	8d 47 ff             	lea    -0x1(%edi),%eax
400012e4:	8d 65 fc             	lea    -0x4(%ebp),%esp
400012e7:	5f                   	pop    %edi
400012e8:	c9                   	leave  
400012e9:	c3                   	ret    
400012ea:	90                   	nop    
400012eb:	90                   	nop    
400012ec:	90                   	nop    
400012ed:	90                   	nop    
400012ee:	90                   	nop    
400012ef:	90                   	nop    

400012f0 <do_syscall>:
     http://g.oswego.edu/dl/html/malloc.html

* Synopsis of public routines

  (Much fuller descriptions are contained in the program documentation below.)

400012f0:	55                   	push   %ebp
400012f1:	89 e5                	mov    %esp,%ebp
400012f3:	53                   	push   %ebx
400012f4:	83 ec 10             	sub    $0x10,%esp
400012f7:	89 d3                	mov    %edx,%ebx
  malloc(size_t n);
400012f9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
     http://g.oswego.edu/dl/html/malloc.html

* Synopsis of public routines

  (Much fuller descriptions are contained in the program documentation below.)

40001300:	8b 55 08             	mov    0x8(%ebp),%edx
  malloc(size_t n);
     Return a pointer to a newly allocated chunk of at least n bytes, or null
     if no space is available.
40001303:	cd 30                	int    $0x30
40001305:	89 45 f8             	mov    %eax,-0x8(%ebp)
  free(Void_t* p);
     Release the chunk of memory pointed to by p, or no effect if p is null.
  realloc(Void_t* p, size_t n);
     Return a pointer to a chunk of size n that contains the same data
     as does chunk p up to the minimum of (n, p's size) bytes, or null
     if no space is available. The returned pointer may or may not be
40001308:	8b 45 f8             	mov    -0x8(%ebp),%eax
     the same as p. If p is null, equivalent to malloc.  Unless the
4000130b:	83 c4 10             	add    $0x10,%esp
4000130e:	5b                   	pop    %ebx
4000130f:	5d                   	pop    %ebp
40001310:	c3                   	ret    
40001311:	eb 0d                	jmp    40001320 <_exit>
40001313:	90                   	nop    
40001314:	90                   	nop    
40001315:	90                   	nop    
40001316:	90                   	nop    
40001317:	90                   	nop    
40001318:	90                   	nop    
40001319:	90                   	nop    
4000131a:	90                   	nop    
4000131b:	90                   	nop    
4000131c:	90                   	nop    
4000131d:	90                   	nop    
4000131e:	90                   	nop    
4000131f:	90                   	nop    

40001320 <_exit>:
     set to zero.
  cfree(Void_t* p);
     Equivalent to free(p).
  malloc_trim(size_t pad);
     Release all but pad bytes of freed top-most memory back 
     to the system. Return 1 if successful, else 0.
40001320:	55                   	push   %ebp
  malloc_usable_size(Void_t* p);
40001321:	31 c9                	xor    %ecx,%ecx
     set to zero.
  cfree(Void_t* p);
     Equivalent to free(p).
  malloc_trim(size_t pad);
     Release all but pad bytes of freed top-most memory back 
     to the system. Return 1 if successful, else 0.
40001323:	89 e5                	mov    %esp,%ebp
  malloc_usable_size(Void_t* p);
40001325:	b8 01 00 00 00       	mov    $0x1,%eax
4000132a:	6a 00                	push   $0x0
4000132c:	8b 55 08             	mov    0x8(%ebp),%edx
4000132f:	e8 bc ff ff ff       	call   400012f0 <do_syscall>
40001334:	58                   	pop    %eax
40001335:	eb fe                	jmp    40001335 <_exit+0x15>
40001337:	89 f6                	mov    %esi,%esi
40001339:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40001340 <close>:
     Report the number usable allocated bytes associated with allocated
     chunk p. This may or may not report more bytes than were requested,
     due to alignment and minimum size constraints.
  malloc_stats();
     Prints brief summary statistics on stderr.
40001340:	55                   	push   %ebp
  mallinfo()
40001341:	31 c9                	xor    %ecx,%ecx
  malloc_usable_size(Void_t* p);
     Report the number usable allocated bytes associated with allocated
     chunk p. This may or may not report more bytes than were requested,
     due to alignment and minimum size constraints.
  malloc_stats();
     Prints brief summary statistics on stderr.
40001343:	89 e5                	mov    %esp,%ebp
  mallinfo()
40001345:	b8 08 00 00 00       	mov    $0x8,%eax
  malloc_usable_size(Void_t* p);
     Report the number usable allocated bytes associated with allocated
     chunk p. This may or may not report more bytes than were requested,
     due to alignment and minimum size constraints.
  malloc_stats();
     Prints brief summary statistics on stderr.
4000134a:	8b 55 08             	mov    0x8(%ebp),%edx
  mallinfo()
4000134d:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
     Returns (by copy) a struct containing various summary statistics.
40001354:	5d                   	pop    %ebp
     Report the number usable allocated bytes associated with allocated
     chunk p. This may or may not report more bytes than were requested,
     due to alignment and minimum size constraints.
  malloc_stats();
     Prints brief summary statistics on stderr.
  mallinfo()
40001355:	eb 99                	jmp    400012f0 <do_syscall>
40001357:	89 f6                	mov    %esi,%esi
40001359:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40001360 <execve>:
     Returns (by copy) a struct containing various summary statistics.
  mallopt(int parameter_number, int parameter_value)
     Changes one of the tunable parameters described below. Returns
     1 if successful in changing the parameter, else 0.
40001360:	55                   	push   %ebp

* Vital statistics:

40001361:	83 c8 ff             	or     $0xffffffff,%eax
     Prints brief summary statistics on stderr.
  mallinfo()
     Returns (by copy) a struct containing various summary statistics.
  mallopt(int parameter_number, int parameter_value)
     Changes one of the tunable parameters described below. Returns
     1 if successful in changing the parameter, else 0.
40001364:	89 e5                	mov    %esp,%ebp

40001366:	c7 05 60 d9 00 40 0c 	movl   $0xc,0x4000d960
4000136d:	00 00 00 
* Vital statistics:

40001370:	5d                   	pop    %ebp
40001371:	c3                   	ret    
40001372:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40001379:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40001380 <fork>:
  Alignment:                            8-byte
       8 byte alignment is currently hardwired into the design.  This
       seems to suffice for all current machines and C compilers.
40001380:	55                   	push   %ebp

  Assumed pointer representation:       4 or 8 bytes
       Code for 8-byte pointers is untested by me but has worked
40001381:	83 c8 ff             	or     $0xffffffff,%eax

* Vital statistics:

  Alignment:                            8-byte
       8 byte alignment is currently hardwired into the design.  This
       seems to suffice for all current machines and C compilers.
40001384:	89 e5                	mov    %esp,%ebp

40001386:	c7 05 60 d9 00 40 0b 	movl   $0xb,0x4000d960
4000138d:	00 00 00 
  Assumed pointer representation:       4 or 8 bytes
       Code for 8-byte pointers is untested by me but has worked
40001390:	5d                   	pop    %ebp
40001391:	c3                   	ret    
40001392:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40001399:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

400013a0 <fstat>:
       reliably by Wolfram Gloger, who contributed most of the
       changes supporting this.

400013a0:	55                   	push   %ebp
400013a1:	89 e5                	mov    %esp,%ebp
  Assumed size_t  representation:       4 or 8 bytes
400013a3:	8b 45 0c             	mov    0xc(%ebp),%eax
400013a6:	c7 40 04 00 20 00 00 	movl   $0x2000,0x4(%eax)
       Note that size_t is allowed to be 4 bytes even if pointers are 8.        

400013ad:	31 c0                	xor    %eax,%eax
400013af:	5d                   	pop    %ebp
400013b0:	c3                   	ret    
400013b1:	eb 0d                	jmp    400013c0 <getpid>
400013b3:	90                   	nop    
400013b4:	90                   	nop    
400013b5:	90                   	nop    
400013b6:	90                   	nop    
400013b7:	90                   	nop    
400013b8:	90                   	nop    
400013b9:	90                   	nop    
400013ba:	90                   	nop    
400013bb:	90                   	nop    
400013bc:	90                   	nop    
400013bd:	90                   	nop    
400013be:	90                   	nop    
400013bf:	90                   	nop    

400013c0 <getpid>:
  Minimum overhead per allocated chunk: 4 or 8 bytes
       Each malloced chunk has a hidden overhead of 4 bytes holding size
       and status information.  
400013c0:	55                   	push   %ebp

400013c1:	31 c9                	xor    %ecx,%ecx
  Assumed size_t  representation:       4 or 8 bytes
       Note that size_t is allowed to be 4 bytes even if pointers are 8.        

  Minimum overhead per allocated chunk: 4 or 8 bytes
       Each malloced chunk has a hidden overhead of 4 bytes holding size
       and status information.  
400013c3:	89 e5                	mov    %esp,%ebp

400013c5:	31 d2                	xor    %edx,%edx
400013c7:	b8 06 00 00 00       	mov    $0x6,%eax
400013cc:	6a 00                	push   $0x0
400013ce:	e8 1d ff ff ff       	call   400012f0 <do_syscall>
  Minimum allocated size: 4-byte ptrs:  16 bytes    (including 4 overhead)
400013d3:	c9                   	leave  
400013d4:	c3                   	ret    
400013d5:	8d 74 26 00          	lea    0x0(%esi),%esi
400013d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

400013e0 <isatty>:
                          8-byte ptrs:  24/32 bytes (including, 4/8 overhead)
                                     
       When a chunk is freed, 12 (for 4byte ptrs) or 20 (for 8 byte
400013e0:	55                   	push   %ebp
       ptrs but 4 byte size) or 24 (for 8/8) additional bytes are 
       needed; 4 (8) for a trailing size field
400013e1:	b8 01 00 00 00       	mov    $0x1,%eax
       and status information.  

  Minimum allocated size: 4-byte ptrs:  16 bytes    (including 4 overhead)
                          8-byte ptrs:  24/32 bytes (including, 4/8 overhead)
                                     
       When a chunk is freed, 12 (for 4byte ptrs) or 20 (for 8 byte
400013e6:	89 e5                	mov    %esp,%ebp
       ptrs but 4 byte size) or 24 (for 8/8) additional bytes are 
       needed; 4 (8) for a trailing size field
400013e8:	5d                   	pop    %ebp
400013e9:	c3                   	ret    
400013ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

400013f0 <kill>:
       and 8 (16) bytes for free list pointers. Thus, the minimum
       allocatable size is 16/24/32 bytes.

400013f0:	55                   	push   %ebp
       Even a request for zero bytes (i.e., malloc(0)) returns a
       pointer to something of the minimum allocatable size.

400013f1:	83 c8 ff             	or     $0xffffffff,%eax
       When a chunk is freed, 12 (for 4byte ptrs) or 20 (for 8 byte
       ptrs but 4 byte size) or 24 (for 8/8) additional bytes are 
       needed; 4 (8) for a trailing size field
       and 8 (16) bytes for free list pointers. Thus, the minimum
       allocatable size is 16/24/32 bytes.

400013f4:	89 e5                	mov    %esp,%ebp
       Even a request for zero bytes (i.e., malloc(0)) returns a
400013f6:	c7 05 60 d9 00 40 16 	movl   $0x16,0x4000d960
400013fd:	00 00 00 
       pointer to something of the minimum allocatable size.

40001400:	5d                   	pop    %ebp
40001401:	c3                   	ret    
40001402:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40001409:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40001410 <link>:
  Maximum allocated size: 4-byte size_t: 2^31 -  8 bytes
                          8-byte size_t: 2^63 - 16 bytes

40001410:	55                   	push   %ebp
       It is assumed that (possibly signed) size_t bit values suffice to
       represent chunk sizes. `Possibly signed' is due to the fact
       that `size_t' may be defined on a system as either a signed or
40001411:	83 c8 ff             	or     $0xffffffff,%eax
       Even a request for zero bytes (i.e., malloc(0)) returns a
       pointer to something of the minimum allocatable size.

  Maximum allocated size: 4-byte size_t: 2^31 -  8 bytes
                          8-byte size_t: 2^63 - 16 bytes

40001414:	89 e5                	mov    %esp,%ebp
       It is assumed that (possibly signed) size_t bit values suffice to
40001416:	c7 05 60 d9 00 40 1f 	movl   $0x1f,0x4000d960
4000141d:	00 00 00 
       represent chunk sizes. `Possibly signed' is due to the fact
       that `size_t' may be defined on a system as either a signed or
40001420:	5d                   	pop    %ebp
40001421:	c3                   	ret    
40001422:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40001429:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40001430 <lseek>:
       an unsigned type. To be conservative, values that would appear
       as negative numbers are avoided.  
       Requests for sizes with a negative sign bit will return a
40001430:	55                   	push   %ebp
       minimum-sized chunk.

40001431:	31 c0                	xor    %eax,%eax
       It is assumed that (possibly signed) size_t bit values suffice to
       represent chunk sizes. `Possibly signed' is due to the fact
       that `size_t' may be defined on a system as either a signed or
       an unsigned type. To be conservative, values that would appear
       as negative numbers are avoided.  
       Requests for sizes with a negative sign bit will return a
40001433:	89 e5                	mov    %esp,%ebp
       minimum-sized chunk.

40001435:	5d                   	pop    %ebp
40001436:	c3                   	ret    
40001437:	89 f6                	mov    %esi,%esi
40001439:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40001440 <read>:
    versions of Unix, sometimes by tweaking some of the defines
    below. It has been tested most extensively on Solaris and
    Linux. It is also reported to work on WIN32 platforms.
    People have also reported adapting this malloc for use in
    stand-alone embedded systems.

40001440:	55                   	push   %ebp
40001441:	89 e5                	mov    %esp,%ebp
    The implementation is in straight, hand-tuned ANSI C.  Among other
40001443:	8b 45 10             	mov    0x10(%ebp),%eax
    versions of Unix, sometimes by tweaking some of the defines
    below. It has been tested most extensively on Solaris and
    Linux. It is also reported to work on WIN32 platforms.
    People have also reported adapting this malloc for use in
    stand-alone embedded systems.

40001446:	8b 55 08             	mov    0x8(%ebp),%edx
40001449:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    The implementation is in straight, hand-tuned ANSI C.  Among other
4000144c:	89 45 08             	mov    %eax,0x8(%ebp)
4000144f:	b8 09 00 00 00       	mov    $0x9,%eax
    consequences, it uses a lot of macros.  Because of this, to be at
40001454:	5d                   	pop    %ebp
    below. It has been tested most extensively on Solaris and
    Linux. It is also reported to work on WIN32 platforms.
    People have also reported adapting this malloc for use in
    stand-alone embedded systems.

    The implementation is in straight, hand-tuned ANSI C.  Among other
40001455:	e9 96 fe ff ff       	jmp    400012f0 <do_syscall>
4000145a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

40001460 <sbrk>:
    consequences, it uses a lot of macros.  Because of this, to be at
    all usable, this code should be compiled using an optimizing compiler
    (for example gcc -O2) that can simplify expressions and control
    paths.
40001460:	55                   	push   %ebp

40001461:	31 c9                	xor    %ecx,%ecx

    The implementation is in straight, hand-tuned ANSI C.  Among other
    consequences, it uses a lot of macros.  Because of this, to be at
    all usable, this code should be compiled using an optimizing compiler
    (for example gcc -O2) that can simplify expressions and control
    paths.
40001463:	89 e5                	mov    %esp,%ebp

40001465:	b8 16 00 00 00       	mov    $0x16,%eax

    The implementation is in straight, hand-tuned ANSI C.  Among other
    consequences, it uses a lot of macros.  Because of this, to be at
    all usable, this code should be compiled using an optimizing compiler
    (for example gcc -O2) that can simplify expressions and control
    paths.
4000146a:	8b 55 08             	mov    0x8(%ebp),%edx

4000146d:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  __STD_C                  (default: derived from C compiler defines)
40001474:	5d                   	pop    %ebp
    The implementation is in straight, hand-tuned ANSI C.  Among other
    consequences, it uses a lot of macros.  Because of this, to be at
    all usable, this code should be compiled using an optimizing compiler
    (for example gcc -O2) that can simplify expressions and control
    paths.

40001475:	e9 76 fe ff ff       	jmp    400012f0 <do_syscall>
4000147a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

40001480 <stat>:
  __STD_C                  (default: derived from C compiler defines)
     Nonzero if using ANSI-standard C compiler, a C++ compiler, or
     a C compiler sufficiently close to ANSI to get away with it.
  DEBUG                    (default: NOT defined)
40001480:	55                   	push   %ebp
40001481:	89 e5                	mov    %esp,%ebp
     Define to enable debugging. Adds fairly extensive assertion-based 
40001483:	8b 45 0c             	mov    0xc(%ebp),%eax
40001486:	c7 40 04 00 20 00 00 	movl   $0x2000,0x4(%eax)
     checking to help track down memory errors, but noticeably slows down
     execution.
4000148d:	31 c0                	xor    %eax,%eax
4000148f:	5d                   	pop    %ebp
40001490:	c3                   	ret    
40001491:	eb 0d                	jmp    400014a0 <times>
40001493:	90                   	nop    
40001494:	90                   	nop    
40001495:	90                   	nop    
40001496:	90                   	nop    
40001497:	90                   	nop    
40001498:	90                   	nop    
40001499:	90                   	nop    
4000149a:	90                   	nop    
4000149b:	90                   	nop    
4000149c:	90                   	nop    
4000149d:	90                   	nop    
4000149e:	90                   	nop    
4000149f:	90                   	nop    

400014a0 <times>:
  SEPARATE_OBJECTS	   (default: NOT defined)
     Define this to compile into separate .o files.  You must then
     compile malloc.c several times, defining a DEFINE_* macro each
400014a0:	55                   	push   %ebp
     time.  The list of DEFINE_* macros appears below.
  MALLOC_LOCK		   (default: NOT defined)
400014a1:	31 c0                	xor    %eax,%eax
     Define to enable debugging. Adds fairly extensive assertion-based 
     checking to help track down memory errors, but noticeably slows down
     execution.
  SEPARATE_OBJECTS	   (default: NOT defined)
     Define this to compile into separate .o files.  You must then
     compile malloc.c several times, defining a DEFINE_* macro each
400014a3:	89 e5                	mov    %esp,%ebp
     time.  The list of DEFINE_* macros appears below.
  MALLOC_LOCK		   (default: NOT defined)
400014a5:	5d                   	pop    %ebp
400014a6:	c3                   	ret    
400014a7:	89 f6                	mov    %esi,%esi
400014a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

400014b0 <unlink>:
  MALLOC_UNLOCK		   (default: NOT defined)
     Define these to C expressions which are run to lock and unlock
     the malloc data structures.  Calls may be nested; that is,
400014b0:	55                   	push   %ebp
     MALLOC_LOCK may be called more than once before the corresponding
     MALLOC_UNLOCK calls.  MALLOC_LOCK must avoid waiting for a lock
     that it already holds.
400014b1:	83 c8 ff             	or     $0xffffffff,%eax
     compile malloc.c several times, defining a DEFINE_* macro each
     time.  The list of DEFINE_* macros appears below.
  MALLOC_LOCK		   (default: NOT defined)
  MALLOC_UNLOCK		   (default: NOT defined)
     Define these to C expressions which are run to lock and unlock
     the malloc data structures.  Calls may be nested; that is,
400014b4:	89 e5                	mov    %esp,%ebp
     MALLOC_LOCK may be called more than once before the corresponding
400014b6:	c7 05 60 d9 00 40 02 	movl   $0x2,0x4000d960
400014bd:	00 00 00 
     MALLOC_UNLOCK calls.  MALLOC_LOCK must avoid waiting for a lock
     that it already holds.
400014c0:	5d                   	pop    %ebp
400014c1:	c3                   	ret    
400014c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
400014c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

400014d0 <wait>:
  MALLOC_ALIGNMENT          (default: NOT defined)
     Define this to 16 if you need 16 byte alignment instead of 8 byte alignment
     which is the normal default.
400014d0:	55                   	push   %ebp
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
     Define this if you think that realloc(p, 0) should be equivalent
     to free(p). Otherwise, since malloc returns a unique pointer for
400014d1:	83 c8 ff             	or     $0xffffffff,%eax
     MALLOC_LOCK may be called more than once before the corresponding
     MALLOC_UNLOCK calls.  MALLOC_LOCK must avoid waiting for a lock
     that it already holds.
  MALLOC_ALIGNMENT          (default: NOT defined)
     Define this to 16 if you need 16 byte alignment instead of 8 byte alignment
     which is the normal default.
400014d4:	89 e5                	mov    %esp,%ebp
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
400014d6:	c7 05 60 d9 00 40 0a 	movl   $0xa,0x4000d960
400014dd:	00 00 00 
     Define this if you think that realloc(p, 0) should be equivalent
     to free(p). Otherwise, since malloc returns a unique pointer for
400014e0:	5d                   	pop    %ebp
400014e1:	c3                   	ret    
400014e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
400014e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

400014f0 <write>:
     malloc(0), so does realloc(p, 0).
  HAVE_MEMCPY               (default: defined)
     Define if you are not otherwise using ANSI STD C, but still 
400014f0:	55                   	push   %ebp
400014f1:	89 e5                	mov    %esp,%ebp
     have memcpy and memset in your C library and want to use them.
400014f3:	8b 45 10             	mov    0x10(%ebp),%eax
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
     Define this if you think that realloc(p, 0) should be equivalent
     to free(p). Otherwise, since malloc returns a unique pointer for
     malloc(0), so does realloc(p, 0).
  HAVE_MEMCPY               (default: defined)
     Define if you are not otherwise using ANSI STD C, but still 
400014f6:	8b 55 08             	mov    0x8(%ebp),%edx
400014f9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
     have memcpy and memset in your C library and want to use them.
400014fc:	89 45 08             	mov    %eax,0x8(%ebp)
400014ff:	b8 0a 00 00 00       	mov    $0xa,%eax
     Otherwise, simple internal versions are supplied.
40001504:	5d                   	pop    %ebp
     Define this if you think that realloc(p, 0) should be equivalent
     to free(p). Otherwise, since malloc returns a unique pointer for
     malloc(0), so does realloc(p, 0).
  HAVE_MEMCPY               (default: defined)
     Define if you are not otherwise using ANSI STD C, but still 
     have memcpy and memset in your C library and want to use them.
40001505:	e9 e6 fd ff ff       	jmp    400012f0 <do_syscall>
4000150a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

40001510 <gettimeofday>:
     Otherwise, simple internal versions are supplied.
  USE_MEMCPY               (default: 1 if HAVE_MEMCPY is defined, 0 otherwise)
     Define as 1 if you want the C library versions of memset and
     memcpy called in realloc and calloc (otherwise macro versions are used). 
40001510:	55                   	push   %ebp
     At least on some platforms, the simple macro versions usually
     outperform libc versions.
40001511:	83 c8 ff             	or     $0xffffffff,%eax
     Define if you are not otherwise using ANSI STD C, but still 
     have memcpy and memset in your C library and want to use them.
     Otherwise, simple internal versions are supplied.
  USE_MEMCPY               (default: 1 if HAVE_MEMCPY is defined, 0 otherwise)
     Define as 1 if you want the C library versions of memset and
     memcpy called in realloc and calloc (otherwise macro versions are used). 
40001514:	89 e5                	mov    %esp,%ebp
     At least on some platforms, the simple macro versions usually
     outperform libc versions.
40001516:	5d                   	pop    %ebp
40001517:	c3                   	ret    
40001518:	90                   	nop    
40001519:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

40001520 <open>:
       Requests for sizes with a negative sign bit will return a
       minimum-sized chunk.

  Maximum overhead wastage per allocated chunk: normally 15 bytes

       Alignnment demands, plus the minimum allocatable size restriction
40001520:	55                   	push   %ebp
40001521:	89 e5                	mov    %esp,%ebp
40001523:	56                   	push   %esi
40001524:	53                   	push   %ebx
       make the normal worst-case wastage 15 bytes (i.e., up to 15
       more bytes will be allocated than were requested in malloc), with 
       two exceptions:
40001525:	31 f6                	xor    %esi,%esi
       Requests for sizes with a negative sign bit will return a
       minimum-sized chunk.

  Maximum overhead wastage per allocated chunk: normally 15 bytes

       Alignnment demands, plus the minimum allocatable size restriction
40001527:	83 ec 10             	sub    $0x10,%esp
4000152a:	8b 5d 08             	mov    0x8(%ebp),%ebx
       make the normal worst-case wastage 15 bytes (i.e., up to 15
       more bytes will be allocated than were requested in malloc), with 
       two exceptions:
4000152d:	f7 45 0c 00 02 00 00 	testl  $0x200,0xc(%ebp)
40001534:	75 3a                	jne    40001570 <open+0x50>

    Here are some features that are NOT currently supported

    * No user-definable hooks for callbacks and the like.
    * No automated mechanism for fully checking that all accesses
      to malloced memory stay within their bounds.
40001536:	83 ec 0c             	sub    $0xc,%esp
40001539:	53                   	push   %ebx
4000153a:	e8 8d fd ff ff       	call   400012cc <strlen>
    * No support for compaction.

4000153f:	83 c4 10             	add    $0x10,%esp

    Here are some features that are NOT currently supported

    * No user-definable hooks for callbacks and the like.
    * No automated mechanism for fully checking that all accesses
      to malloced memory stay within their bounds.
40001542:	a3 48 d9 00 40       	mov    %eax,0x4000d948

* Synopsis of compile-time options:

    People have reported using previous versions of this malloc on all
    versions of Unix, sometimes by tweaking some of the defines
    below. It has been tested most extensively on Solaris and
40001547:	8b 4d 0c             	mov    0xc(%ebp),%ecx
4000154a:	ba 48 d9 00 40       	mov    $0x4000d948,%edx
4000154f:	b8 07 00 00 00       	mov    $0x7,%eax
40001554:	56                   	push   %esi

    Here are some features that are NOT currently supported

    * No user-definable hooks for callbacks and the like.
    * No automated mechanism for fully checking that all accesses
      to malloced memory stay within their bounds.
40001555:	89 1d 4c d9 00 40    	mov    %ebx,0x4000d94c

* Synopsis of compile-time options:

    People have reported using previous versions of this malloc on all
    versions of Unix, sometimes by tweaking some of the defines
    below. It has been tested most extensively on Solaris and
4000155b:	e8 90 fd ff ff       	call   400012f0 <do_syscall>
40001560:	5a                   	pop    %edx
    Linux. It is also reported to work on WIN32 platforms.
40001561:	8d 65 f8             	lea    -0x8(%ebp),%esp
40001564:	5b                   	pop    %ebx
40001565:	5e                   	pop    %esi
40001566:	5d                   	pop    %ebp
40001567:	c3                   	ret    
40001568:	90                   	nop    
40001569:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
       more bytes will be allocated than were requested in malloc), with 
       two exceptions:
         1. Because requests for zero bytes allocate non-zero space,
            the worst case wastage for a request of zero bytes is 24 bytes.
         2. For requests >= mmap_threshold that are serviced via
            mmap(), the worst case wastage is 8 bytes plus the remainder
40001570:	8d 45 14             	lea    0x14(%ebp),%eax
40001573:	8b 75 10             	mov    0x10(%ebp),%esi
40001576:	89 45 f4             	mov    %eax,-0xc(%ebp)
40001579:	eb bb                	jmp    40001536 <open+0x16>
4000157b:	90                   	nop    
4000157c:	90                   	nop    
4000157d:	90                   	nop    
4000157e:	90                   	nop    
4000157f:	90                   	nop    

40001580 <__sprint_r>:
40001580:	55                   	push   %ebp
40001581:	89 e5                	mov    %esp,%ebp
40001583:	53                   	push   %ebx
40001584:	83 ec 04             	sub    $0x4,%esp
40001587:	89 cb                	mov    %ecx,%ebx
40001589:	8b 49 08             	mov    0x8(%ecx),%ecx
4000158c:	85 c9                	test   %ecx,%ecx
4000158e:	75 10                	jne    400015a0 <__sprint_r+0x20>
40001590:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
40001597:	31 c0                	xor    %eax,%eax
40001599:	8b 5d fc             	mov    -0x4(%ebp),%ebx
4000159c:	c9                   	leave  
4000159d:	c3                   	ret    
4000159e:	66 90                	xchg   %ax,%ax
400015a0:	51                   	push   %ecx
400015a1:	53                   	push   %ebx
400015a2:	52                   	push   %edx
400015a3:	50                   	push   %eax
400015a4:	e8 97 5c 00 00       	call   40007240 <__sfvwrite_r>
400015a9:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
400015b0:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
400015b7:	83 c4 10             	add    $0x10,%esp
400015ba:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400015bd:	c9                   	leave  
400015be:	c3                   	ret    
400015bf:	90                   	nop    

400015c0 <_vfprintf_r>:
400015c0:	55                   	push   %ebp
400015c1:	89 e5                	mov    %esp,%ebp
400015c3:	57                   	push   %edi
400015c4:	56                   	push   %esi
400015c5:	53                   	push   %ebx
400015c6:	81 ec 0c 07 00 00    	sub    $0x70c,%esp
400015cc:	e8 5f 61 00 00       	call   40007730 <localeconv>
400015d1:	8b 75 08             	mov    0x8(%ebp),%esi
400015d4:	85 f6                	test   %esi,%esi
400015d6:	8b 00                	mov    (%eax),%eax
400015d8:	89 85 48 f9 ff ff    	mov    %eax,-0x6b8(%ebp)
400015de:	74 0e                	je     400015ee <_vfprintf_r+0x2e>
400015e0:	8b 45 08             	mov    0x8(%ebp),%eax
400015e3:	8b 58 38             	mov    0x38(%eax),%ebx
400015e6:	85 db                	test   %ebx,%ebx
400015e8:	0f 84 4b 06 00 00    	je     40001c39 <_vfprintf_r+0x679>
400015ee:	8b 4d 0c             	mov    0xc(%ebp),%ecx
400015f1:	8b 51 0c             	mov    0xc(%ecx),%edx
400015f4:	0f bf c2             	movswl %dx,%eax
400015f7:	a8 08                	test   $0x8,%al
400015f9:	0f 84 4b 06 00 00    	je     40001c4a <_vfprintf_r+0x68a>
400015ff:	8b 49 10             	mov    0x10(%ecx),%ecx
40001602:	85 c9                	test   %ecx,%ecx
40001604:	0f 84 40 06 00 00    	je     40001c4a <_vfprintf_r+0x68a>
4000160a:	83 e0 1a             	and    $0x1a,%eax
4000160d:	83 f8 0a             	cmp    $0xa,%eax
40001610:	0f 84 5a 05 00 00    	je     40001b70 <_vfprintf_r+0x5b0>
40001616:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
4000161c:	31 d2                	xor    %edx,%edx
4000161e:	8b 5d 10             	mov    0x10(%ebp),%ebx
40001621:	89 45 b0             	mov    %eax,-0x50(%ebp)
40001624:	89 95 74 f9 ff ff    	mov    %edx,-0x68c(%ebp)
4000162a:	31 c0                	xor    %eax,%eax
4000162c:	8d 55 b0             	lea    -0x50(%ebp),%edx
4000162f:	8d 8d ec fe ff ff    	lea    -0x114(%ebp),%ecx
40001635:	89 9d 34 f9 ff ff    	mov    %ebx,-0x6cc(%ebp)
4000163b:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
40001642:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
40001649:	89 85 70 f9 ff ff    	mov    %eax,-0x690(%ebp)
4000164f:	c7 85 40 f9 ff ff 00 	movl   $0x0,-0x6c0(%ebp)
40001656:	00 00 00 
40001659:	c7 85 64 f9 ff ff 00 	movl   $0x0,-0x69c(%ebp)
40001660:	00 00 00 
40001663:	8d bd 48 ff ff ff    	lea    -0xb8(%ebp),%edi
40001669:	c7 85 50 f9 ff ff 00 	movl   $0x0,-0x6b0(%ebp)
40001670:	00 00 00 
40001673:	c7 85 54 f9 ff ff 00 	movl   $0x0,-0x6ac(%ebp)
4000167a:	00 00 00 
4000167d:	89 95 14 f9 ff ff    	mov    %edx,-0x6ec(%ebp)
40001683:	89 8d 10 f9 ff ff    	mov    %ecx,-0x6f0(%ebp)
40001689:	8b 95 34 f9 ff ff    	mov    -0x6cc(%ebp),%edx
4000168f:	8a 02                	mov    (%edx),%al
40001691:	84 c0                	test   %al,%al
40001693:	0f 85 ce 00 00 00    	jne    40001767 <_vfprintf_r+0x1a7>
40001699:	8b 9d 34 f9 ff ff    	mov    -0x6cc(%ebp),%ebx
4000169f:	80 3b 00             	cmpb   $0x0,(%ebx)
400016a2:	0f 84 9b 17 00 00    	je     40002e43 <_vfprintf_r+0x1883>
400016a8:	8d 43 01             	lea    0x1(%ebx),%eax
400016ab:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
400016af:	89 85 34 f9 ff ff    	mov    %eax,-0x6cc(%ebp)
400016b5:	8a 43 01             	mov    0x1(%ebx),%al
400016b8:	c7 85 44 f9 ff ff 00 	movl   $0x0,-0x6bc(%ebp)
400016bf:	00 00 00 
400016c2:	c7 85 78 f9 ff ff ff 	movl   $0xffffffff,-0x688(%ebp)
400016c9:	ff ff ff 
400016cc:	c7 85 3c f9 ff ff 00 	movl   $0x0,-0x6c4(%ebp)
400016d3:	00 00 00 
400016d6:	0f be f0             	movsbl %al,%esi
400016d9:	8b 85 34 f9 ff ff    	mov    -0x6cc(%ebp),%eax
400016df:	40                   	inc    %eax
400016e0:	89 85 34 f9 ff ff    	mov    %eax,-0x6cc(%ebp)
400016e6:	8d 46 e0             	lea    -0x20(%esi),%eax
400016e9:	83 f8 5a             	cmp    $0x5a,%eax
400016ec:	76 72                	jbe    40001760 <_vfprintf_r+0x1a0>
400016ee:	85 f6                	test   %esi,%esi
400016f0:	0f 84 4d 17 00 00    	je     40002e43 <_vfprintf_r+0x1883>
400016f6:	89 f0                	mov    %esi,%eax
400016f8:	8b 55 14             	mov    0x14(%ebp),%edx
400016fb:	8d 8d 90 fd ff ff    	lea    -0x270(%ebp),%ecx
40001701:	88 85 90 fd ff ff    	mov    %al,-0x270(%ebp)
40001707:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
4000170b:	89 95 7c f9 ff ff    	mov    %edx,-0x684(%ebp)
40001711:	c7 85 60 f9 ff ff 01 	movl   $0x1,-0x6a0(%ebp)
40001718:	00 00 00 
4000171b:	89 8d 38 f9 ff ff    	mov    %ecx,-0x6c8(%ebp)
40001721:	c7 85 5c f9 ff ff 01 	movl   $0x1,-0x6a4(%ebp)
40001728:	00 00 00 
4000172b:	c7 85 58 f9 ff ff 00 	movl   $0x0,-0x6a8(%ebp)
40001732:	00 00 00 
40001735:	c7 85 68 f9 ff ff 00 	movl   $0x0,-0x698(%ebp)
4000173c:	00 00 00 
4000173f:	f6 85 3c f9 ff ff 02 	testb  $0x2,-0x6c4(%ebp)
40001746:	0f 84 74 02 00 00    	je     400019c0 <_vfprintf_r+0x400>
4000174c:	8b 85 5c f9 ff ff    	mov    -0x6a4(%ebp),%eax
40001752:	83 c0 02             	add    $0x2,%eax
40001755:	89 85 5c f9 ff ff    	mov    %eax,-0x6a4(%ebp)
4000175b:	e9 60 02 00 00       	jmp    400019c0 <_vfprintf_r+0x400>
40001760:	ff 24 85 94 bc 00 40 	jmp    *0x4000bc94(,%eax,4)
40001767:	89 d3                	mov    %edx,%ebx
40001769:	3c 25                	cmp    $0x25,%al
4000176b:	0f 84 28 ff ff ff    	je     40001699 <_vfprintf_r+0xd9>
40001771:	eb 0d                	jmp    40001780 <_vfprintf_r+0x1c0>
40001773:	90                   	nop    
40001774:	90                   	nop    
40001775:	90                   	nop    
40001776:	90                   	nop    
40001777:	90                   	nop    
40001778:	90                   	nop    
40001779:	90                   	nop    
4000177a:	90                   	nop    
4000177b:	90                   	nop    
4000177c:	90                   	nop    
4000177d:	90                   	nop    
4000177e:	90                   	nop    
4000177f:	90                   	nop    
40001780:	43                   	inc    %ebx
40001781:	8a 03                	mov    (%ebx),%al
40001783:	84 c0                	test   %al,%al
40001785:	75 49                	jne    400017d0 <_vfprintf_r+0x210>
40001787:	89 de                	mov    %ebx,%esi
40001789:	2b b5 34 f9 ff ff    	sub    -0x6cc(%ebp),%esi
4000178f:	0f 84 0a ff ff ff    	je     4000169f <_vfprintf_r+0xdf>
40001795:	8b 8d 34 f9 ff ff    	mov    -0x6cc(%ebp),%ecx
4000179b:	8b 55 b8             	mov    -0x48(%ebp),%edx
4000179e:	89 0f                	mov    %ecx,(%edi)
400017a0:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
400017a3:	01 f2                	add    %esi,%edx
400017a5:	41                   	inc    %ecx
400017a6:	89 77 04             	mov    %esi,0x4(%edi)
400017a9:	89 55 b8             	mov    %edx,-0x48(%ebp)
400017ac:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
400017af:	83 f9 07             	cmp    $0x7,%ecx
400017b2:	0f 8f 53 03 00 00    	jg     40001b0b <_vfprintf_r+0x54b>
400017b8:	83 c7 08             	add    $0x8,%edi
400017bb:	8b 85 40 f9 ff ff    	mov    -0x6c0(%ebp),%eax
400017c1:	01 f0                	add    %esi,%eax
400017c3:	89 85 40 f9 ff ff    	mov    %eax,-0x6c0(%ebp)
400017c9:	e9 d1 fe ff ff       	jmp    4000169f <_vfprintf_r+0xdf>
400017ce:	66 90                	xchg   %ax,%ax
400017d0:	3c 25                	cmp    $0x25,%al
400017d2:	75 ac                	jne    40001780 <_vfprintf_r+0x1c0>
400017d4:	eb b1                	jmp    40001787 <_vfprintf_r+0x1c7>
400017d6:	8b 85 3c f9 ff ff    	mov    -0x6c4(%ebp),%eax
400017dc:	83 c8 10             	or     $0x10,%eax
400017df:	89 85 3c f9 ff ff    	mov    %eax,-0x6c4(%ebp)
400017e5:	f6 85 3c f9 ff ff 10 	testb  $0x10,-0x6c4(%ebp)
400017ec:	0f 85 9d 04 00 00    	jne    40001c8f <_vfprintf_r+0x6cf>
400017f2:	f6 85 3c f9 ff ff 40 	testb  $0x40,-0x6c4(%ebp)
400017f9:	0f 84 e3 12 00 00    	je     40002ae2 <_vfprintf_r+0x1522>
400017ff:	8b 4d 14             	mov    0x14(%ebp),%ecx
40001802:	8b 55 14             	mov    0x14(%ebp),%edx
40001805:	83 c2 04             	add    $0x4,%edx
40001808:	8b 01                	mov    (%ecx),%eax
4000180a:	89 95 7c f9 ff ff    	mov    %edx,-0x684(%ebp)
40001810:	89 c1                	mov    %eax,%ecx
40001812:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
40001818:	b0 01                	mov    $0x1,%al
4000181a:	8b 95 78 f9 ff ff    	mov    -0x688(%ebp),%edx
40001820:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
40001824:	85 d2                	test   %edx,%edx
40001826:	0f 89 10 01 00 00    	jns    4000193c <_vfprintf_r+0x37c>
4000182c:	3c 01                	cmp    $0x1,%al
4000182e:	0f 84 ae 0e 00 00    	je     400026e2 <_vfprintf_r+0x1122>
40001834:	0f 83 2f 0e 00 00    	jae    40002669 <_vfprintf_r+0x10a9>
4000183a:	8d 9d ec fe ff ff    	lea    -0x114(%ebp),%ebx
40001840:	89 9d 38 f9 ff ff    	mov    %ebx,-0x6c8(%ebp)
40001846:	8b 85 38 f9 ff ff    	mov    -0x6c8(%ebp),%eax
4000184c:	48                   	dec    %eax
4000184d:	89 85 38 f9 ff ff    	mov    %eax,-0x6c8(%ebp)
40001853:	88 c8                	mov    %cl,%al
40001855:	83 e0 07             	and    $0x7,%eax
40001858:	8b 95 38 f9 ff ff    	mov    -0x6c8(%ebp),%edx
4000185e:	83 c0 30             	add    $0x30,%eax
40001861:	c1 e9 03             	shr    $0x3,%ecx
40001864:	88 02                	mov    %al,(%edx)
40001866:	75 de                	jne    40001846 <_vfprintf_r+0x286>
40001868:	f6 85 3c f9 ff ff 01 	testb  $0x1,-0x6c4(%ebp)
4000186f:	0f 84 9a 10 00 00    	je     4000290f <_vfprintf_r+0x134f>
40001875:	3c 30                	cmp    $0x30,%al
40001877:	0f 84 92 10 00 00    	je     4000290f <_vfprintf_r+0x134f>
4000187d:	8b 9d 38 f9 ff ff    	mov    -0x6c8(%ebp),%ebx
40001883:	4b                   	dec    %ebx
40001884:	89 9d 38 f9 ff ff    	mov    %ebx,-0x6c8(%ebp)
4000188a:	8b 8d 38 f9 ff ff    	mov    -0x6c8(%ebp),%ecx
40001890:	c6 01 30             	movb   $0x30,(%ecx)
40001893:	8b 95 10 f9 ff ff    	mov    -0x6f0(%ebp),%edx
40001899:	29 ca                	sub    %ecx,%edx
4000189b:	e9 d7 00 00 00       	jmp    40001977 <_vfprintf_r+0x3b7>
400018a0:	8b 85 3c f9 ff ff    	mov    -0x6c4(%ebp),%eax
400018a6:	83 c8 10             	or     $0x10,%eax
400018a9:	89 85 3c f9 ff ff    	mov    %eax,-0x6c4(%ebp)
400018af:	f6 85 3c f9 ff ff 10 	testb  $0x10,-0x6c4(%ebp)
400018b6:	0f 85 e9 03 00 00    	jne    40001ca5 <_vfprintf_r+0x6e5>
400018bc:	f6 85 3c f9 ff ff 40 	testb  $0x40,-0x6c4(%ebp)
400018c3:	0f 84 ef 11 00 00    	je     40002ab8 <_vfprintf_r+0x14f8>
400018c9:	8b 4d 14             	mov    0x14(%ebp),%ecx
400018cc:	8b 55 14             	mov    0x14(%ebp),%edx
400018cf:	83 c2 04             	add    $0x4,%edx
400018d2:	8b 01                	mov    (%ecx),%eax
400018d4:	89 95 7c f9 ff ff    	mov    %edx,-0x684(%ebp)
400018da:	89 c1                	mov    %eax,%ecx
400018dc:	31 c0                	xor    %eax,%eax
400018de:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
400018e4:	e9 31 ff ff ff       	jmp    4000181a <_vfprintf_r+0x25a>
400018e9:	8b 85 3c f9 ff ff    	mov    -0x6c4(%ebp),%eax
400018ef:	83 c8 10             	or     $0x10,%eax
400018f2:	89 85 3c f9 ff ff    	mov    %eax,-0x6c4(%ebp)
400018f8:	f6 85 3c f9 ff ff 10 	testb  $0x10,-0x6c4(%ebp)
400018ff:	0f 85 74 03 00 00    	jne    40001c79 <_vfprintf_r+0x6b9>
40001905:	f6 85 3c f9 ff ff 40 	testb  $0x40,-0x6c4(%ebp)
4000190c:	0f 84 f8 11 00 00    	je     40002b0a <_vfprintf_r+0x154a>
40001912:	8b 55 14             	mov    0x14(%ebp),%edx
40001915:	8b 45 14             	mov    0x14(%ebp),%eax
40001918:	83 c0 04             	add    $0x4,%eax
4000191b:	0f bf 0a             	movswl (%edx),%ecx
4000191e:	89 85 7c f9 ff ff    	mov    %eax,-0x684(%ebp)
40001924:	b0 01                	mov    $0x1,%al
40001926:	85 c9                	test   %ecx,%ecx
40001928:	0f 88 c1 12 00 00    	js     40002bef <_vfprintf_r+0x162f>
4000192e:	8b 95 78 f9 ff ff    	mov    -0x688(%ebp),%edx
40001934:	85 d2                	test   %edx,%edx
40001936:	0f 88 f0 fe ff ff    	js     4000182c <_vfprintf_r+0x26c>
4000193c:	8b 9d 3c f9 ff ff    	mov    -0x6c4(%ebp),%ebx
40001942:	80 e3 7f             	and    $0x7f,%bl
40001945:	85 c9                	test   %ecx,%ecx
40001947:	89 9d 3c f9 ff ff    	mov    %ebx,-0x6c4(%ebp)
4000194d:	0f 85 d9 fe ff ff    	jne    4000182c <_vfprintf_r+0x26c>
40001953:	8b 95 78 f9 ff ff    	mov    -0x688(%ebp),%edx
40001959:	85 d2                	test   %edx,%edx
4000195b:	0f 85 cb fe ff ff    	jne    4000182c <_vfprintf_r+0x26c>
40001961:	84 c0                	test   %al,%al
40001963:	0f 84 59 0d 00 00    	je     400026c2 <_vfprintf_r+0x1102>
40001969:	8d 9d ec fe ff ff    	lea    -0x114(%ebp),%ebx
4000196f:	31 d2                	xor    %edx,%edx
40001971:	89 9d 38 f9 ff ff    	mov    %ebx,-0x6c8(%ebp)
40001977:	8b 8d 78 f9 ff ff    	mov    -0x688(%ebp),%ecx
4000197d:	89 95 5c f9 ff ff    	mov    %edx,-0x6a4(%ebp)
40001983:	39 ca                	cmp    %ecx,%edx
40001985:	7d 06                	jge    4000198d <_vfprintf_r+0x3cd>
40001987:	89 8d 5c f9 ff ff    	mov    %ecx,-0x6a4(%ebp)
4000198d:	8b 9d 78 f9 ff ff    	mov    -0x688(%ebp),%ebx
40001993:	89 95 60 f9 ff ff    	mov    %edx,-0x6a0(%ebp)
40001999:	89 9d 58 f9 ff ff    	mov    %ebx,-0x6a8(%ebp)
4000199f:	c7 85 68 f9 ff ff 00 	movl   $0x0,-0x698(%ebp)
400019a6:	00 00 00 
400019a9:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
400019ad:	0f 84 8c fd ff ff    	je     4000173f <_vfprintf_r+0x17f>
400019b3:	8b 85 5c f9 ff ff    	mov    -0x6a4(%ebp),%eax
400019b9:	40                   	inc    %eax
400019ba:	89 85 5c f9 ff ff    	mov    %eax,-0x6a4(%ebp)
400019c0:	8b 9d 3c f9 ff ff    	mov    -0x6c4(%ebp),%ebx
400019c6:	81 e3 84 00 00 00    	and    $0x84,%ebx
400019cc:	89 9d 30 f9 ff ff    	mov    %ebx,-0x6d0(%ebp)
400019d2:	0f 85 b4 0a 00 00    	jne    4000248c <_vfprintf_r+0xecc>
400019d8:	8b 9d 44 f9 ff ff    	mov    -0x6bc(%ebp),%ebx
400019de:	8b 85 5c f9 ff ff    	mov    -0x6a4(%ebp),%eax
400019e4:	29 c3                	sub    %eax,%ebx
400019e6:	85 db                	test   %ebx,%ebx
400019e8:	0f 8e 9e 0a 00 00    	jle    4000248c <_vfprintf_r+0xecc>
400019ee:	83 fb 10             	cmp    $0x10,%ebx
400019f1:	0f 8e 5c 15 00 00    	jle    40002f53 <_vfprintf_r+0x1993>
400019f7:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
400019fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40001a00:	8b 45 b8             	mov    -0x48(%ebp),%eax
40001a03:	41                   	inc    %ecx
40001a04:	83 c0 10             	add    $0x10,%eax
40001a07:	c7 07 10 be 00 40    	movl   $0x4000be10,(%edi)
40001a0d:	c7 47 04 10 00 00 00 	movl   $0x10,0x4(%edi)
40001a14:	89 45 b8             	mov    %eax,-0x48(%ebp)
40001a17:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40001a1a:	83 f9 07             	cmp    $0x7,%ecx
40001a1d:	0f 8f 9d 07 00 00    	jg     400021c0 <_vfprintf_r+0xc00>
40001a23:	83 eb 10             	sub    $0x10,%ebx
40001a26:	83 c7 08             	add    $0x8,%edi
40001a29:	83 fb 10             	cmp    $0x10,%ebx
40001a2c:	7f d2                	jg     40001a00 <_vfprintf_r+0x440>
40001a2e:	8b 45 b8             	mov    -0x48(%ebp),%eax
40001a31:	41                   	inc    %ecx
40001a32:	01 d8                	add    %ebx,%eax
40001a34:	c7 07 10 be 00 40    	movl   $0x4000be10,(%edi)
40001a3a:	89 5f 04             	mov    %ebx,0x4(%edi)
40001a3d:	89 45 b8             	mov    %eax,-0x48(%ebp)
40001a40:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40001a43:	83 f9 07             	cmp    $0x7,%ecx
40001a46:	0f 8f 24 0a 00 00    	jg     40002470 <_vfprintf_r+0xeb0>
40001a4c:	83 c7 08             	add    $0x8,%edi
40001a4f:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
40001a53:	0f 85 40 0a 00 00    	jne    40002499 <_vfprintf_r+0xed9>
40001a59:	f6 85 3c f9 ff ff 02 	testb  $0x2,-0x6c4(%ebp)
40001a60:	74 2e                	je     40001a90 <_vfprintf_r+0x4d0>
40001a62:	89 f0                	mov    %esi,%eax
40001a64:	8b 55 b8             	mov    -0x48(%ebp),%edx
40001a67:	88 45 e6             	mov    %al,-0x1a(%ebp)
40001a6a:	83 c2 02             	add    $0x2,%edx
40001a6d:	41                   	inc    %ecx
40001a6e:	8d 45 e5             	lea    -0x1b(%ebp),%eax
40001a71:	c6 45 e5 30          	movb   $0x30,-0x1b(%ebp)
40001a75:	89 55 b8             	mov    %edx,-0x48(%ebp)
40001a78:	89 07                	mov    %eax,(%edi)
40001a7a:	c7 47 04 02 00 00 00 	movl   $0x2,0x4(%edi)
40001a81:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40001a84:	83 f9 07             	cmp    $0x7,%ecx
40001a87:	0f 8f 2c 0a 00 00    	jg     400024b9 <_vfprintf_r+0xef9>
40001a8d:	83 c7 08             	add    $0x8,%edi
40001a90:	81 bd 30 f9 ff ff 80 	cmpl   $0x80,-0x6d0(%ebp)
40001a97:	00 00 00 
40001a9a:	0f 84 48 0a 00 00    	je     400024e8 <_vfprintf_r+0xf28>
40001aa0:	8b 9d 58 f9 ff ff    	mov    -0x6a8(%ebp),%ebx
40001aa6:	8b 85 60 f9 ff ff    	mov    -0x6a0(%ebp),%eax
40001aac:	29 c3                	sub    %eax,%ebx
40001aae:	85 db                	test   %ebx,%ebx
40001ab0:	7f 14                	jg     40001ac6 <_vfprintf_r+0x506>
40001ab2:	e9 5a 07 00 00       	jmp    40002211 <_vfprintf_r+0xc51>
40001ab7:	89 f6                	mov    %esi,%esi
40001ab9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40001ac0:	83 c7 08             	add    $0x8,%edi
40001ac3:	83 eb 10             	sub    $0x10,%ebx
40001ac6:	83 fb 10             	cmp    $0x10,%ebx
40001ac9:	0f 8e 21 07 00 00    	jle    400021f0 <_vfprintf_r+0xc30>
40001acf:	8b 45 b8             	mov    -0x48(%ebp),%eax
40001ad2:	41                   	inc    %ecx
40001ad3:	83 c0 10             	add    $0x10,%eax
40001ad6:	c7 07 00 be 00 40    	movl   $0x4000be00,(%edi)
40001adc:	c7 47 04 10 00 00 00 	movl   $0x10,0x4(%edi)
40001ae3:	89 45 b8             	mov    %eax,-0x48(%ebp)
40001ae6:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40001ae9:	83 f9 07             	cmp    $0x7,%ecx
40001aec:	7e d2                	jle    40001ac0 <_vfprintf_r+0x500>
40001aee:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40001af1:	8b 55 0c             	mov    0xc(%ebp),%edx
40001af4:	8b 45 08             	mov    0x8(%ebp),%eax
40001af7:	e8 84 fa ff ff       	call   40001580 <__sprint_r>
40001afc:	85 c0                	test   %eax,%eax
40001afe:	75 30                	jne    40001b30 <_vfprintf_r+0x570>
40001b00:	8d bd 48 ff ff ff    	lea    -0xb8(%ebp),%edi
40001b06:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
40001b09:	eb b8                	jmp    40001ac3 <_vfprintf_r+0x503>
40001b0b:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40001b0e:	8b 55 0c             	mov    0xc(%ebp),%edx
40001b11:	8b 45 08             	mov    0x8(%ebp),%eax
40001b14:	e8 67 fa ff ff       	call   40001580 <__sprint_r>
40001b19:	85 c0                	test   %eax,%eax
40001b1b:	75 32                	jne    40001b4f <_vfprintf_r+0x58f>
40001b1d:	8d bd 48 ff ff ff    	lea    -0xb8(%ebp),%edi
40001b23:	e9 93 fc ff ff       	jmp    400017bb <_vfprintf_r+0x1fb>
40001b28:	8b 55 0c             	mov    0xc(%ebp),%edx
40001b2b:	66 83 4a 0c 40       	orw    $0x40,0xc(%edx)
40001b30:	8b 85 68 f9 ff ff    	mov    -0x698(%ebp),%eax
40001b36:	85 c0                	test   %eax,%eax
40001b38:	74 15                	je     40001b4f <_vfprintf_r+0x58f>
40001b3a:	57                   	push   %edi
40001b3b:	57                   	push   %edi
40001b3c:	8b b5 68 f9 ff ff    	mov    -0x698(%ebp),%esi
40001b42:	56                   	push   %esi
40001b43:	8b 5d 08             	mov    0x8(%ebp),%ebx
40001b46:	53                   	push   %ebx
40001b47:	e8 14 54 00 00       	call   40006f60 <_free_r>
40001b4c:	83 c4 10             	add    $0x10,%esp
40001b4f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40001b52:	f6 41 0c 40          	testb  $0x40,0xc(%ecx)
40001b56:	74 0a                	je     40001b62 <_vfprintf_r+0x5a2>
40001b58:	c7 85 40 f9 ff ff ff 	movl   $0xffffffff,-0x6c0(%ebp)
40001b5f:	ff ff ff 
40001b62:	8b 85 40 f9 ff ff    	mov    -0x6c0(%ebp),%eax
40001b68:	8d 65 f4             	lea    -0xc(%ebp),%esp
40001b6b:	5b                   	pop    %ebx
40001b6c:	5e                   	pop    %esi
40001b6d:	5f                   	pop    %edi
40001b6e:	5d                   	pop    %ebp
40001b6f:	c3                   	ret    
40001b70:	8b 45 0c             	mov    0xc(%ebp),%eax
40001b73:	66 83 78 0e 00       	cmpw   $0x0,0xe(%eax)
40001b78:	0f 88 98 fa ff ff    	js     40001616 <_vfprintf_r+0x56>
40001b7e:	83 e2 fd             	and    $0xfffffffd,%edx
40001b81:	8b 75 14             	mov    0x14(%ebp),%esi
40001b84:	66 89 95 f8 fe ff ff 	mov    %dx,-0x108(%ebp)
40001b8b:	89 c2                	mov    %eax,%edx
40001b8d:	66 8b 40 0e          	mov    0xe(%eax),%ax
40001b91:	c7 85 f4 fe ff ff 00 	movl   $0x400,-0x10c(%ebp)
40001b98:	04 00 00 
40001b9b:	66 89 85 fa fe ff ff 	mov    %ax,-0x106(%ebp)
40001ba2:	8b 42 1c             	mov    0x1c(%edx),%eax
40001ba5:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%ebp)
40001bab:	8b 42 24             	mov    0x24(%edx),%eax
40001bae:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%ebp)
40001bb4:	8d 85 90 f9 ff ff    	lea    -0x670(%ebp),%eax
40001bba:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
40001bc0:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
40001bc6:	c7 85 00 ff ff ff 00 	movl   $0x400,-0x100(%ebp)
40001bcd:	04 00 00 
40001bd0:	c7 85 04 ff ff ff 00 	movl   $0x0,-0xfc(%ebp)
40001bd7:	00 00 00 
40001bda:	56                   	push   %esi
40001bdb:	8b 5d 10             	mov    0x10(%ebp),%ebx
40001bde:	53                   	push   %ebx
40001bdf:	8d 9d ec fe ff ff    	lea    -0x114(%ebp),%ebx
40001be5:	53                   	push   %ebx
40001be6:	8b 4d 08             	mov    0x8(%ebp),%ecx
40001be9:	51                   	push   %ecx
40001bea:	e8 d1 f9 ff ff       	call   400015c0 <_vfprintf_r>
40001bef:	83 c4 10             	add    $0x10,%esp
40001bf2:	89 85 40 f9 ff ff    	mov    %eax,-0x6c0(%ebp)
40001bf8:	85 c0                	test   %eax,%eax
40001bfa:	78 1a                	js     40001c16 <_vfprintf_r+0x656>
40001bfc:	83 ec 0c             	sub    $0xc,%esp
40001bff:	53                   	push   %ebx
40001c00:	e8 eb e5 ff ff       	call   400001f0 <fflush>
40001c05:	83 c4 10             	add    $0x10,%esp
40001c08:	85 c0                	test   %eax,%eax
40001c0a:	74 0a                	je     40001c16 <_vfprintf_r+0x656>
40001c0c:	c7 85 40 f9 ff ff ff 	movl   $0xffffffff,-0x6c0(%ebp)
40001c13:	ff ff ff 
40001c16:	f6 85 f8 fe ff ff 40 	testb  $0x40,-0x108(%ebp)
40001c1d:	0f 84 3f ff ff ff    	je     40001b62 <_vfprintf_r+0x5a2>
40001c23:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40001c26:	8b 85 40 f9 ff ff    	mov    -0x6c0(%ebp),%eax
40001c2c:	66 83 49 0c 40       	orw    $0x40,0xc(%ecx)
40001c31:	8d 65 f4             	lea    -0xc(%ebp),%esp
40001c34:	5b                   	pop    %ebx
40001c35:	5e                   	pop    %esi
40001c36:	5f                   	pop    %edi
40001c37:	5d                   	pop    %ebp
40001c38:	c3                   	ret    
40001c39:	83 ec 0c             	sub    $0xc,%esp
40001c3c:	50                   	push   %eax
40001c3d:	e8 be e7 ff ff       	call   40000400 <__sinit>
40001c42:	83 c4 10             	add    $0x10,%esp
40001c45:	e9 a4 f9 ff ff       	jmp    400015ee <_vfprintf_r+0x2e>
40001c4a:	83 ec 0c             	sub    $0xc,%esp
40001c4d:	8b 7d 0c             	mov    0xc(%ebp),%edi
40001c50:	57                   	push   %edi
40001c51:	e8 9a 37 00 00       	call   400053f0 <__swsetup>
40001c56:	83 c4 10             	add    $0x10,%esp
40001c59:	c7 85 40 f9 ff ff ff 	movl   $0xffffffff,-0x6c0(%ebp)
40001c60:	ff ff ff 
40001c63:	85 c0                	test   %eax,%eax
40001c65:	0f 85 f7 fe ff ff    	jne    40001b62 <_vfprintf_r+0x5a2>
40001c6b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
40001c6e:	8b 53 0c             	mov    0xc(%ebx),%edx
40001c71:	0f bf c2             	movswl %dx,%eax
40001c74:	e9 91 f9 ff ff       	jmp    4000160a <_vfprintf_r+0x4a>
40001c79:	8b 5d 14             	mov    0x14(%ebp),%ebx
40001c7c:	8b 55 14             	mov    0x14(%ebp),%edx
40001c7f:	83 c2 04             	add    $0x4,%edx
40001c82:	8b 0b                	mov    (%ebx),%ecx
40001c84:	89 95 7c f9 ff ff    	mov    %edx,-0x684(%ebp)
40001c8a:	e9 95 fc ff ff       	jmp    40001924 <_vfprintf_r+0x364>
40001c8f:	8b 45 14             	mov    0x14(%ebp),%eax
40001c92:	8b 5d 14             	mov    0x14(%ebp),%ebx
40001c95:	83 c3 04             	add    $0x4,%ebx
40001c98:	8b 08                	mov    (%eax),%ecx
40001c9a:	89 9d 7c f9 ff ff    	mov    %ebx,-0x684(%ebp)
40001ca0:	e9 73 fb ff ff       	jmp    40001818 <_vfprintf_r+0x258>
40001ca5:	8b 45 14             	mov    0x14(%ebp),%eax
40001ca8:	8b 5d 14             	mov    0x14(%ebp),%ebx
40001cab:	83 c3 04             	add    $0x4,%ebx
40001cae:	8b 08                	mov    (%eax),%ecx
40001cb0:	31 c0                	xor    %eax,%eax
40001cb2:	89 9d 7c f9 ff ff    	mov    %ebx,-0x684(%ebp)
40001cb8:	e9 5d fb ff ff       	jmp    4000181a <_vfprintf_r+0x25a>
40001cbd:	f7 9d 44 f9 ff ff    	negl   -0x6bc(%ebp)
40001cc3:	89 55 14             	mov    %edx,0x14(%ebp)
40001cc6:	8b 85 3c f9 ff ff    	mov    -0x6c4(%ebp),%eax
40001ccc:	8b 95 34 f9 ff ff    	mov    -0x6cc(%ebp),%edx
40001cd2:	83 c8 04             	or     $0x4,%eax
40001cd5:	89 85 3c f9 ff ff    	mov    %eax,-0x6c4(%ebp)
40001cdb:	8a 02                	mov    (%edx),%al
40001cdd:	e9 f4 f9 ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
40001ce2:	c7 85 64 f9 ff ff 3c 	movl   $0x4000bc3c,-0x69c(%ebp)
40001ce9:	bc 00 40 
40001cec:	f6 85 3c f9 ff ff 10 	testb  $0x10,-0x6c4(%ebp)
40001cf3:	0f 84 c1 03 00 00    	je     400020ba <_vfprintf_r+0xafa>
40001cf9:	8b 45 14             	mov    0x14(%ebp),%eax
40001cfc:	8b 55 14             	mov    0x14(%ebp),%edx
40001cff:	83 c0 04             	add    $0x4,%eax
40001d02:	89 85 7c f9 ff ff    	mov    %eax,-0x684(%ebp)
40001d08:	8b 0a                	mov    (%edx),%ecx
40001d0a:	f6 85 3c f9 ff ff 01 	testb  $0x1,-0x6c4(%ebp)
40001d11:	74 13                	je     40001d26 <_vfprintf_r+0x766>
40001d13:	85 c9                	test   %ecx,%ecx
40001d15:	74 0f                	je     40001d26 <_vfprintf_r+0x766>
40001d17:	8b 9d 3c f9 ff ff    	mov    -0x6c4(%ebp),%ebx
40001d1d:	83 cb 02             	or     $0x2,%ebx
40001d20:	89 9d 3c f9 ff ff    	mov    %ebx,-0x6c4(%ebp)
40001d26:	b0 02                	mov    $0x2,%al
40001d28:	e9 ed fa ff ff       	jmp    4000181a <_vfprintf_r+0x25a>
40001d2d:	8b 85 3c f9 ff ff    	mov    -0x6c4(%ebp),%eax
40001d33:	83 c8 10             	or     $0x10,%eax
40001d36:	89 85 3c f9 ff ff    	mov    %eax,-0x6c4(%ebp)
40001d3c:	8b 8d 34 f9 ff ff    	mov    -0x6cc(%ebp),%ecx
40001d42:	8a 01                	mov    (%ecx),%al
40001d44:	e9 8d f9 ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
40001d49:	8b 9d 34 f9 ff ff    	mov    -0x6cc(%ebp),%ebx
40001d4f:	8a 03                	mov    (%ebx),%al
40001d51:	3c 6c                	cmp    $0x6c,%al
40001d53:	0f 84 85 11 00 00    	je     40002ede <_vfprintf_r+0x191e>
40001d59:	8b 95 3c f9 ff ff    	mov    -0x6c4(%ebp),%edx
40001d5f:	83 ca 10             	or     $0x10,%edx
40001d62:	89 95 3c f9 ff ff    	mov    %edx,-0x6c4(%ebp)
40001d68:	e9 69 f9 ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
40001d6d:	8b 45 14             	mov    0x14(%ebp),%eax
40001d70:	8b 55 14             	mov    0x14(%ebp),%edx
40001d73:	83 c0 04             	add    $0x4,%eax
40001d76:	be 78 00 00 00       	mov    $0x78,%esi
40001d7b:	89 85 7c f9 ff ff    	mov    %eax,-0x684(%ebp)
40001d81:	8b 85 3c f9 ff ff    	mov    -0x6c4(%ebp),%eax
40001d87:	83 c8 02             	or     $0x2,%eax
40001d8a:	8b 0a                	mov    (%edx),%ecx
40001d8c:	89 85 3c f9 ff ff    	mov    %eax,-0x6c4(%ebp)
40001d92:	b0 02                	mov    $0x2,%al
40001d94:	c7 85 64 f9 ff ff 3c 	movl   $0x4000bc3c,-0x69c(%ebp)
40001d9b:	bc 00 40 
40001d9e:	e9 77 fa ff ff       	jmp    4000181a <_vfprintf_r+0x25a>
40001da3:	8b 85 3c f9 ff ff    	mov    -0x6c4(%ebp),%eax
40001da9:	8b 95 34 f9 ff ff    	mov    -0x6cc(%ebp),%edx
40001daf:	83 c8 10             	or     $0x10,%eax
40001db2:	89 85 3c f9 ff ff    	mov    %eax,-0x6c4(%ebp)
40001db8:	8a 02                	mov    (%edx),%al
40001dba:	e9 17 f9 ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
40001dbf:	f6 85 3c f9 ff ff 10 	testb  $0x10,-0x6c4(%ebp)
40001dc6:	0f 84 b1 0c 00 00    	je     40002a7d <_vfprintf_r+0x14bd>
40001dcc:	8b 45 14             	mov    0x14(%ebp),%eax
40001dcf:	8b 55 14             	mov    0x14(%ebp),%edx
40001dd2:	83 c0 04             	add    $0x4,%eax
40001dd5:	8b 8d 40 f9 ff ff    	mov    -0x6c0(%ebp),%ecx
40001ddb:	89 85 7c f9 ff ff    	mov    %eax,-0x684(%ebp)
40001de1:	8b 02                	mov    (%edx),%eax
40001de3:	89 08                	mov    %ecx,(%eax)
40001de5:	8b 9d 7c f9 ff ff    	mov    -0x684(%ebp),%ebx
40001deb:	89 5d 14             	mov    %ebx,0x14(%ebp)
40001dee:	e9 96 f8 ff ff       	jmp    40001689 <_vfprintf_r+0xc9>
40001df3:	8b 95 34 f9 ff ff    	mov    -0x6cc(%ebp),%edx
40001df9:	8a 02                	mov    (%edx),%al
40001dfb:	e9 d6 f8 ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
40001e00:	83 fe 43             	cmp    $0x43,%esi
40001e03:	0f 84 c1 0b 00 00    	je     400029ca <_vfprintf_r+0x140a>
40001e09:	f6 85 3c f9 ff ff 10 	testb  $0x10,-0x6c4(%ebp)
40001e10:	0f 85 b4 0b 00 00    	jne    400029ca <_vfprintf_r+0x140a>
40001e16:	8b 5d 14             	mov    0x14(%ebp),%ebx
40001e19:	8b 4d 14             	mov    0x14(%ebp),%ecx
40001e1c:	83 c1 04             	add    $0x4,%ecx
40001e1f:	c7 85 60 f9 ff ff 01 	movl   $0x1,-0x6a0(%ebp)
40001e26:	00 00 00 
40001e29:	8b 03                	mov    (%ebx),%eax
40001e2b:	89 8d 7c f9 ff ff    	mov    %ecx,-0x684(%ebp)
40001e31:	88 85 90 fd ff ff    	mov    %al,-0x270(%ebp)
40001e37:	8d 9d 90 fd ff ff    	lea    -0x270(%ebp),%ebx
40001e3d:	8b 85 60 f9 ff ff    	mov    -0x6a0(%ebp),%eax
40001e43:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
40001e47:	89 85 5c f9 ff ff    	mov    %eax,-0x6a4(%ebp)
40001e4d:	83 f0 ff             	xor    $0xffffffff,%eax
40001e50:	8b 95 5c f9 ff ff    	mov    -0x6a4(%ebp),%edx
40001e56:	89 9d 38 f9 ff ff    	mov    %ebx,-0x6c8(%ebp)
40001e5c:	c1 f8 1f             	sar    $0x1f,%eax
40001e5f:	21 c2                	and    %eax,%edx
40001e61:	89 95 5c f9 ff ff    	mov    %edx,-0x6a4(%ebp)
40001e67:	e9 bf f8 ff ff       	jmp    4000172b <_vfprintf_r+0x16b>
40001e6c:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
40001e70:	0f 85 c6 fe ff ff    	jne    40001d3c <_vfprintf_r+0x77c>
40001e76:	8b 9d 34 f9 ff ff    	mov    -0x6cc(%ebp),%ebx
40001e7c:	c6 45 e7 20          	movb   $0x20,-0x19(%ebp)
40001e80:	8a 03                	mov    (%ebx),%al
40001e82:	e9 4f f8 ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
40001e87:	8b 85 3c f9 ff ff    	mov    -0x6c4(%ebp),%eax
40001e8d:	8b 95 34 f9 ff ff    	mov    -0x6cc(%ebp),%edx
40001e93:	83 c8 01             	or     $0x1,%eax
40001e96:	89 85 3c f9 ff ff    	mov    %eax,-0x6c4(%ebp)
40001e9c:	8a 02                	mov    (%edx),%al
40001e9e:	e9 33 f8 ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
40001ea3:	8b 4d 14             	mov    0x14(%ebp),%ecx
40001ea6:	8b 55 14             	mov    0x14(%ebp),%edx
40001ea9:	83 c2 04             	add    $0x4,%edx
40001eac:	8b 09                	mov    (%ecx),%ecx
40001eae:	89 8d 44 f9 ff ff    	mov    %ecx,-0x6bc(%ebp)
40001eb4:	85 c9                	test   %ecx,%ecx
40001eb6:	0f 88 01 fe ff ff    	js     40001cbd <_vfprintf_r+0x6fd>
40001ebc:	8b 9d 34 f9 ff ff    	mov    -0x6cc(%ebp),%ebx
40001ec2:	8a 03                	mov    (%ebx),%al
40001ec4:	89 55 14             	mov    %edx,0x14(%ebp)
40001ec7:	e9 0a f8 ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
40001ecc:	c6 45 e7 2b          	movb   $0x2b,-0x19(%ebp)
40001ed0:	e9 67 fe ff ff       	jmp    40001d3c <_vfprintf_r+0x77c>
40001ed5:	8b 85 3c f9 ff ff    	mov    -0x6c4(%ebp),%eax
40001edb:	8b 8d 34 f9 ff ff    	mov    -0x6cc(%ebp),%ecx
40001ee1:	0c 80                	or     $0x80,%al
40001ee3:	89 85 3c f9 ff ff    	mov    %eax,-0x6c4(%ebp)
40001ee9:	8a 01                	mov    (%ecx),%al
40001eeb:	e9 e6 f7 ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
40001ef0:	31 c0                	xor    %eax,%eax
40001ef2:	8d 56 d0             	lea    -0x30(%esi),%edx
40001ef5:	8b 9d 34 f9 ff ff    	mov    -0x6cc(%ebp),%ebx
40001efb:	8d 04 80             	lea    (%eax,%eax,4),%eax
40001efe:	0f be 33             	movsbl (%ebx),%esi
40001f01:	8d 04 42             	lea    (%edx,%eax,2),%eax
40001f04:	43                   	inc    %ebx
40001f05:	8d 56 d0             	lea    -0x30(%esi),%edx
40001f08:	89 9d 34 f9 ff ff    	mov    %ebx,-0x6cc(%ebp)
40001f0e:	83 fa 09             	cmp    $0x9,%edx
40001f11:	76 e2                	jbe    40001ef5 <_vfprintf_r+0x935>
40001f13:	89 85 44 f9 ff ff    	mov    %eax,-0x6bc(%ebp)
40001f19:	e9 c8 f7 ff ff       	jmp    400016e6 <_vfprintf_r+0x126>
40001f1e:	8b 9d 34 f9 ff ff    	mov    -0x6cc(%ebp),%ebx
40001f24:	8a 03                	mov    (%ebx),%al
40001f26:	43                   	inc    %ebx
40001f27:	89 9d 34 f9 ff ff    	mov    %ebx,-0x6cc(%ebp)
40001f2d:	3c 2a                	cmp    $0x2a,%al
40001f2f:	0f 84 a3 16 00 00    	je     400035d8 <_vfprintf_r+0x2018>
40001f35:	0f be f0             	movsbl %al,%esi
40001f38:	c7 85 78 f9 ff ff 00 	movl   $0x0,-0x688(%ebp)
40001f3f:	00 00 00 
40001f42:	8d 56 d0             	lea    -0x30(%esi),%edx
40001f45:	83 fa 09             	cmp    $0x9,%edx
40001f48:	0f 87 98 f7 ff ff    	ja     400016e6 <_vfprintf_r+0x126>
40001f4e:	31 c0                	xor    %eax,%eax
40001f50:	8d 04 80             	lea    (%eax,%eax,4),%eax
40001f53:	8d 04 42             	lea    (%edx,%eax,2),%eax
40001f56:	8b 95 34 f9 ff ff    	mov    -0x6cc(%ebp),%edx
40001f5c:	0f be 32             	movsbl (%edx),%esi
40001f5f:	42                   	inc    %edx
40001f60:	89 95 34 f9 ff ff    	mov    %edx,-0x6cc(%ebp)
40001f66:	8d 56 d0             	lea    -0x30(%esi),%edx
40001f69:	83 fa 09             	cmp    $0x9,%edx
40001f6c:	76 e2                	jbe    40001f50 <_vfprintf_r+0x990>
40001f6e:	89 85 78 f9 ff ff    	mov    %eax,-0x688(%ebp)
40001f74:	85 c0                	test   %eax,%eax
40001f76:	0f 89 6a f7 ff ff    	jns    400016e6 <_vfprintf_r+0x126>
40001f7c:	c7 85 78 f9 ff ff ff 	movl   $0xffffffff,-0x688(%ebp)
40001f83:	ff ff ff 
40001f86:	e9 5b f7 ff ff       	jmp    400016e6 <_vfprintf_r+0x126>
40001f8b:	8b 8d 34 f9 ff ff    	mov    -0x6cc(%ebp),%ecx
40001f91:	8a 01                	mov    (%ecx),%al
40001f93:	3c 68                	cmp    $0x68,%al
40001f95:	0f 84 60 0f 00 00    	je     40002efb <_vfprintf_r+0x193b>
40001f9b:	8b 9d 3c f9 ff ff    	mov    -0x6c4(%ebp),%ebx
40001fa1:	83 cb 40             	or     $0x40,%ebx
40001fa4:	89 9d 3c f9 ff ff    	mov    %ebx,-0x6c4(%ebp)
40001faa:	e9 27 f7 ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
40001faf:	8b 5d 14             	mov    0x14(%ebp),%ebx
40001fb2:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
40001fb6:	8b 4d 14             	mov    0x14(%ebp),%ecx
40001fb9:	83 c1 04             	add    $0x4,%ecx
40001fbc:	8b 1b                	mov    (%ebx),%ebx
40001fbe:	89 8d 7c f9 ff ff    	mov    %ecx,-0x684(%ebp)
40001fc4:	89 9d 38 f9 ff ff    	mov    %ebx,-0x6c8(%ebp)
40001fca:	85 db                	test   %ebx,%ebx
40001fcc:	0f 84 6d 10 00 00    	je     4000303f <_vfprintf_r+0x1a7f>
40001fd2:	83 fe 53             	cmp    $0x53,%esi
40001fd5:	74 0d                	je     40001fe4 <_vfprintf_r+0xa24>
40001fd7:	f6 85 3c f9 ff ff 10 	testb  $0x10,-0x6c4(%ebp)
40001fde:	0f 84 6a 0c 00 00    	je     40002c4e <_vfprintf_r+0x168e>
40001fe4:	8b 85 38 f9 ff ff    	mov    -0x6c8(%ebp),%eax
40001fea:	8d 55 bc             	lea    -0x44(%ebp),%edx
40001fed:	89 45 dc             	mov    %eax,-0x24(%ebp)
40001ff0:	50                   	push   %eax
40001ff1:	6a 08                	push   $0x8
40001ff3:	6a 00                	push   $0x0
40001ff5:	52                   	push   %edx
40001ff6:	e8 ed ef ff ff       	call   40000fe8 <memset>
40001ffb:	8b 9d 78 f9 ff ff    	mov    -0x688(%ebp),%ebx
40002001:	83 c4 10             	add    $0x10,%esp
40002004:	85 db                	test   %ebx,%ebx
40002006:	0f 88 94 14 00 00    	js     400034a0 <_vfprintf_r+0x1ee0>
4000200c:	31 db                	xor    %ebx,%ebx
4000200e:	c7 85 60 f9 ff ff 00 	movl   $0x0,-0x6a0(%ebp)
40002015:	00 00 00 
40002018:	eb 06                	jmp    40002020 <_vfprintf_r+0xa60>
4000201a:	89 85 60 f9 ff ff    	mov    %eax,-0x6a0(%ebp)
40002020:	8b 45 dc             	mov    -0x24(%ebp),%eax
40002023:	8b 04 18             	mov    (%eax,%ebx,1),%eax
40002026:	85 c0                	test   %eax,%eax
40002028:	74 48                	je     40002072 <_vfprintf_r+0xab2>
4000202a:	8d 4d bc             	lea    -0x44(%ebp),%ecx
4000202d:	51                   	push   %ecx
4000202e:	50                   	push   %eax
4000202f:	8d 85 90 fd ff ff    	lea    -0x270(%ebp),%eax
40002035:	50                   	push   %eax
40002036:	8b 4d 08             	mov    0x8(%ebp),%ecx
40002039:	51                   	push   %ecx
4000203a:	e8 b1 2d 00 00       	call   40004df0 <_wcrtomb_r>
4000203f:	83 c4 10             	add    $0x10,%esp
40002042:	83 f8 ff             	cmp    $0xffffffff,%eax
40002045:	0f 84 d9 12 00 00    	je     40003324 <_vfprintf_r+0x1d64>
4000204b:	8b 95 60 f9 ff ff    	mov    -0x6a0(%ebp),%edx
40002051:	01 d0                	add    %edx,%eax
40002053:	3b 85 78 f9 ff ff    	cmp    -0x688(%ebp),%eax
40002059:	7f 17                	jg     40002072 <_vfprintf_r+0xab2>
4000205b:	83 c3 04             	add    $0x4,%ebx
4000205e:	39 85 78 f9 ff ff    	cmp    %eax,-0x688(%ebp)
40002064:	75 b4                	jne    4000201a <_vfprintf_r+0xa5a>
40002066:	8b 8d 78 f9 ff ff    	mov    -0x688(%ebp),%ecx
4000206c:	89 8d 60 f9 ff ff    	mov    %ecx,-0x6a0(%ebp)
40002072:	8b 85 60 f9 ff ff    	mov    -0x6a0(%ebp),%eax
40002078:	85 c0                	test   %eax,%eax
4000207a:	0f 85 2f 0d 00 00    	jne    40002daf <_vfprintf_r+0x17ef>
40002080:	c7 85 58 f9 ff ff 00 	movl   $0x0,-0x6a8(%ebp)
40002087:	00 00 00 
4000208a:	c7 85 68 f9 ff ff 00 	movl   $0x0,-0x698(%ebp)
40002091:	00 00 00 
40002094:	c7 85 5c f9 ff ff 00 	movl   $0x0,-0x6a4(%ebp)
4000209b:	00 00 00 
4000209e:	e9 06 f9 ff ff       	jmp    400019a9 <_vfprintf_r+0x3e9>
400020a3:	c7 85 64 f9 ff ff 59 	movl   $0x4000bc59,-0x69c(%ebp)
400020aa:	bc 00 40 
400020ad:	f6 85 3c f9 ff ff 10 	testb  $0x10,-0x6c4(%ebp)
400020b4:	0f 85 3f fc ff ff    	jne    40001cf9 <_vfprintf_r+0x739>
400020ba:	f6 85 3c f9 ff ff 40 	testb  $0x40,-0x6c4(%ebp)
400020c1:	0f 84 72 09 00 00    	je     40002a39 <_vfprintf_r+0x1479>
400020c7:	8b 5d 14             	mov    0x14(%ebp),%ebx
400020ca:	8b 4d 14             	mov    0x14(%ebp),%ecx
400020cd:	83 c1 04             	add    $0x4,%ecx
400020d0:	8b 03                	mov    (%ebx),%eax
400020d2:	89 8d 7c f9 ff ff    	mov    %ecx,-0x684(%ebp)
400020d8:	89 c1                	mov    %eax,%ecx
400020da:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
400020e0:	e9 25 fc ff ff       	jmp    40001d0a <_vfprintf_r+0x74a>
400020e5:	83 bd 78 f9 ff ff ff 	cmpl   $0xffffffff,-0x688(%ebp)
400020ec:	0f 84 29 0e 00 00    	je     40002f1b <_vfprintf_r+0x195b>
400020f2:	83 fe 67             	cmp    $0x67,%esi
400020f5:	0f 84 36 0b 00 00    	je     40002c31 <_vfprintf_r+0x1671>
400020fb:	83 fe 47             	cmp    $0x47,%esi
400020fe:	0f 84 2d 0b 00 00    	je     40002c31 <_vfprintf_r+0x1671>
40002104:	f6 85 3c f9 ff ff 08 	testb  $0x8,-0x6c4(%ebp)
4000210b:	0f 84 50 09 00 00    	je     40002a61 <_vfprintf_r+0x14a1>
40002111:	8b 5d 14             	mov    0x14(%ebp),%ebx
40002114:	8b 4d 14             	mov    0x14(%ebp),%ecx
40002117:	83 c1 0c             	add    $0xc,%ecx
4000211a:	db 2b                	fldt   (%ebx)
4000211c:	89 8d 7c f9 ff ff    	mov    %ecx,-0x684(%ebp)
40002122:	dd 9d 70 f9 ff ff    	fstpl  -0x690(%ebp)
40002128:	51                   	push   %ecx
40002129:	51                   	push   %ecx
4000212a:	8b 95 74 f9 ff ff    	mov    -0x68c(%ebp),%edx
40002130:	52                   	push   %edx
40002131:	8b 85 70 f9 ff ff    	mov    -0x690(%ebp),%eax
40002137:	50                   	push   %eax
40002138:	e8 93 71 00 00       	call   400092d0 <__isinfd>
4000213d:	83 c4 10             	add    $0x10,%esp
40002140:	85 c0                	test   %eax,%eax
40002142:	0f 84 33 0d 00 00    	je     40002e7b <_vfprintf_r+0x18bb>
40002148:	d9 ee                	fldz   
4000214a:	dd 85 70 f9 ff ff    	fldl   -0x690(%ebp)
40002150:	d9 c9                	fxch   %st(1)
40002152:	da e9                	fucompp 
40002154:	df e0                	fnstsw %ax
40002156:	f6 c4 45             	test   $0x45,%ah
40002159:	0f 84 de 10 00 00    	je     4000323d <_vfprintf_r+0x1c7d>
4000215f:	8d 46 bb             	lea    -0x45(%esi),%eax
40002162:	83 f8 02             	cmp    $0x2,%eax
40002165:	0f 87 8f 0a 00 00    	ja     40002bfa <_vfprintf_r+0x163a>
4000216b:	c7 85 58 f9 ff ff 00 	movl   $0x0,-0x6a8(%ebp)
40002172:	00 00 00 
40002175:	c7 85 60 f9 ff ff 03 	movl   $0x3,-0x6a0(%ebp)
4000217c:	00 00 00 
4000217f:	c7 85 68 f9 ff ff 00 	movl   $0x0,-0x698(%ebp)
40002186:	00 00 00 
40002189:	c7 85 38 f9 ff ff 4d 	movl   $0x4000bc4d,-0x6c8(%ebp)
40002190:	bc 00 40 
40002193:	c7 85 5c f9 ff ff 03 	movl   $0x3,-0x6a4(%ebp)
4000219a:	00 00 00 
4000219d:	e9 07 f8 ff ff       	jmp    400019a9 <_vfprintf_r+0x3e9>
400021a2:	8b 85 3c f9 ff ff    	mov    -0x6c4(%ebp),%eax
400021a8:	8b 95 34 f9 ff ff    	mov    -0x6cc(%ebp),%edx
400021ae:	83 c8 08             	or     $0x8,%eax
400021b1:	89 85 3c f9 ff ff    	mov    %eax,-0x6c4(%ebp)
400021b7:	8a 02                	mov    (%edx),%al
400021b9:	e9 18 f5 ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
400021be:	66 90                	xchg   %ax,%ax
400021c0:	8d 4d b0             	lea    -0x50(%ebp),%ecx
400021c3:	8b 55 0c             	mov    0xc(%ebp),%edx
400021c6:	8b 45 08             	mov    0x8(%ebp),%eax
400021c9:	e8 b2 f3 ff ff       	call   40001580 <__sprint_r>
400021ce:	85 c0                	test   %eax,%eax
400021d0:	0f 85 5a f9 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
400021d6:	83 eb 10             	sub    $0x10,%ebx
400021d9:	8d bd 48 ff ff ff    	lea    -0xb8(%ebp),%edi
400021df:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
400021e2:	83 fb 10             	cmp    $0x10,%ebx
400021e5:	0f 8f 15 f8 ff ff    	jg     40001a00 <_vfprintf_r+0x440>
400021eb:	e9 3e f8 ff ff       	jmp    40001a2e <_vfprintf_r+0x46e>
400021f0:	8b 45 b8             	mov    -0x48(%ebp),%eax
400021f3:	41                   	inc    %ecx
400021f4:	01 d8                	add    %ebx,%eax
400021f6:	c7 07 00 be 00 40    	movl   $0x4000be00,(%edi)
400021fc:	89 5f 04             	mov    %ebx,0x4(%edi)
400021ff:	89 45 b8             	mov    %eax,-0x48(%ebp)
40002202:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40002205:	83 f9 07             	cmp    $0x7,%ecx
40002208:	0f 8f 37 04 00 00    	jg     40002645 <_vfprintf_r+0x1085>
4000220e:	83 c7 08             	add    $0x8,%edi
40002211:	f7 85 3c f9 ff ff 00 	testl  $0x100,-0x6c4(%ebp)
40002218:	01 00 00 
4000221b:	0f 84 fe 00 00 00    	je     4000231f <_vfprintf_r+0xd5f>
40002221:	83 fe 65             	cmp    $0x65,%esi
40002224:	0f 8e 46 03 00 00    	jle    40002570 <_vfprintf_r+0xfb0>
4000222a:	d9 ee                	fldz   
4000222c:	dd 85 70 f9 ff ff    	fldl   -0x690(%ebp)
40002232:	da e9                	fucompp 
40002234:	df e0                	fnstsw %ax
40002236:	80 e4 45             	and    $0x45,%ah
40002239:	80 f4 40             	xor    $0x40,%ah
4000223c:	0f 85 3b 05 00 00    	jne    4000277d <_vfprintf_r+0x11bd>
40002242:	8b 5d b8             	mov    -0x48(%ebp),%ebx
40002245:	41                   	inc    %ecx
40002246:	43                   	inc    %ebx
40002247:	c7 07 88 bc 00 40    	movl   $0x4000bc88,(%edi)
4000224d:	c7 47 04 01 00 00 00 	movl   $0x1,0x4(%edi)
40002254:	89 5d b8             	mov    %ebx,-0x48(%ebp)
40002257:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
4000225a:	8d 47 08             	lea    0x8(%edi),%eax
4000225d:	83 f9 07             	cmp    $0x7,%ecx
40002260:	0f 8f f4 0b 00 00    	jg     40002e5a <_vfprintf_r+0x189a>
40002266:	8b 95 54 f9 ff ff    	mov    -0x6ac(%ebp),%edx
4000226c:	39 55 e0             	cmp    %edx,-0x20(%ebp)
4000226f:	7c 0d                	jl     4000227e <_vfprintf_r+0xcbe>
40002271:	f6 85 3c f9 ff ff 01 	testb  $0x1,-0x6c4(%ebp)
40002278:	0f 84 e2 00 00 00    	je     40002360 <_vfprintf_r+0xda0>
4000227e:	8b 8d 48 f9 ff ff    	mov    -0x6b8(%ebp),%ecx
40002284:	8b 55 b8             	mov    -0x48(%ebp),%edx
40002287:	89 08                	mov    %ecx,(%eax)
40002289:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
4000228c:	42                   	inc    %edx
4000228d:	41                   	inc    %ecx
4000228e:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
40002295:	89 55 b8             	mov    %edx,-0x48(%ebp)
40002298:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
4000229b:	83 f9 07             	cmp    $0x7,%ecx
4000229e:	0f 8f b7 0c 00 00    	jg     40002f5b <_vfprintf_r+0x199b>
400022a4:	83 c0 08             	add    $0x8,%eax
400022a7:	8b 9d 54 f9 ff ff    	mov    -0x6ac(%ebp),%ebx
400022ad:	4b                   	dec    %ebx
400022ae:	85 db                	test   %ebx,%ebx
400022b0:	0f 8e aa 00 00 00    	jle    40002360 <_vfprintf_r+0xda0>
400022b6:	83 fb 10             	cmp    $0x10,%ebx
400022b9:	0f 8e 51 07 00 00    	jle    40002a10 <_vfprintf_r+0x1450>
400022bf:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
400022c2:	eb 1b                	jmp    400022df <_vfprintf_r+0xd1f>
400022c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
400022ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
400022d0:	83 c0 08             	add    $0x8,%eax
400022d3:	83 eb 10             	sub    $0x10,%ebx
400022d6:	83 fb 10             	cmp    $0x10,%ebx
400022d9:	0f 8e 34 07 00 00    	jle    40002a13 <_vfprintf_r+0x1453>
400022df:	8b 7d b8             	mov    -0x48(%ebp),%edi
400022e2:	41                   	inc    %ecx
400022e3:	83 c7 10             	add    $0x10,%edi
400022e6:	c7 00 00 be 00 40    	movl   $0x4000be00,(%eax)
400022ec:	c7 40 04 10 00 00 00 	movl   $0x10,0x4(%eax)
400022f3:	89 7d b8             	mov    %edi,-0x48(%ebp)
400022f6:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
400022f9:	83 f9 07             	cmp    $0x7,%ecx
400022fc:	7e d2                	jle    400022d0 <_vfprintf_r+0xd10>
400022fe:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002301:	8b 55 0c             	mov    0xc(%ebp),%edx
40002304:	8b 45 08             	mov    0x8(%ebp),%eax
40002307:	e8 74 f2 ff ff       	call   40001580 <__sprint_r>
4000230c:	85 c0                	test   %eax,%eax
4000230e:	0f 85 1c f8 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40002314:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
4000231a:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
4000231d:	eb b4                	jmp    400022d3 <_vfprintf_r+0xd13>
4000231f:	8b 9d 60 f9 ff ff    	mov    -0x6a0(%ebp),%ebx
40002325:	8b 75 b8             	mov    -0x48(%ebp),%esi
40002328:	01 de                	add    %ebx,%esi
4000232a:	41                   	inc    %ecx
4000232b:	8b 95 38 f9 ff ff    	mov    -0x6c8(%ebp),%edx
40002331:	89 5f 04             	mov    %ebx,0x4(%edi)
40002334:	89 17                	mov    %edx,(%edi)
40002336:	89 75 b8             	mov    %esi,-0x48(%ebp)
40002339:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
4000233c:	8d 47 08             	lea    0x8(%edi),%eax
4000233f:	83 f9 07             	cmp    $0x7,%ecx
40002342:	7e 1c                	jle    40002360 <_vfprintf_r+0xda0>
40002344:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002347:	8b 55 0c             	mov    0xc(%ebp),%edx
4000234a:	8b 45 08             	mov    0x8(%ebp),%eax
4000234d:	e8 2e f2 ff ff       	call   40001580 <__sprint_r>
40002352:	85 c0                	test   %eax,%eax
40002354:	0f 85 d6 f7 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
4000235a:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
40002360:	f6 85 3c f9 ff ff 04 	testb  $0x4,-0x6c4(%ebp)
40002367:	74 73                	je     400023dc <_vfprintf_r+0xe1c>
40002369:	8b 9d 44 f9 ff ff    	mov    -0x6bc(%ebp),%ebx
4000236f:	8b 95 5c f9 ff ff    	mov    -0x6a4(%ebp),%edx
40002375:	29 d3                	sub    %edx,%ebx
40002377:	85 db                	test   %ebx,%ebx
40002379:	7e 61                	jle    400023dc <_vfprintf_r+0xe1c>
4000237b:	83 fb 10             	cmp    $0x10,%ebx
4000237e:	0f 8e 29 0d 00 00    	jle    400030ad <_vfprintf_r+0x1aed>
40002384:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
40002387:	89 f6                	mov    %esi,%esi
40002389:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40002390:	8b 7d b8             	mov    -0x48(%ebp),%edi
40002393:	41                   	inc    %ecx
40002394:	83 c7 10             	add    $0x10,%edi
40002397:	c7 00 10 be 00 40    	movl   $0x4000be10,(%eax)
4000239d:	c7 40 04 10 00 00 00 	movl   $0x10,0x4(%eax)
400023a4:	89 7d b8             	mov    %edi,-0x48(%ebp)
400023a7:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
400023aa:	83 f9 07             	cmp    $0x7,%ecx
400023ad:	0f 8f 8d 00 00 00    	jg     40002440 <_vfprintf_r+0xe80>
400023b3:	83 eb 10             	sub    $0x10,%ebx
400023b6:	83 c0 08             	add    $0x8,%eax
400023b9:	83 fb 10             	cmp    $0x10,%ebx
400023bc:	7f d2                	jg     40002390 <_vfprintf_r+0xdd0>
400023be:	8b 75 b8             	mov    -0x48(%ebp),%esi
400023c1:	41                   	inc    %ecx
400023c2:	01 de                	add    %ebx,%esi
400023c4:	c7 00 10 be 00 40    	movl   $0x4000be10,(%eax)
400023ca:	89 58 04             	mov    %ebx,0x4(%eax)
400023cd:	89 75 b8             	mov    %esi,-0x48(%ebp)
400023d0:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
400023d3:	83 f9 07             	cmp    $0x7,%ecx
400023d6:	0f 8f 46 05 00 00    	jg     40002922 <_vfprintf_r+0x1362>
400023dc:	8b 85 44 f9 ff ff    	mov    -0x6bc(%ebp),%eax
400023e2:	3b 85 5c f9 ff ff    	cmp    -0x6a4(%ebp),%eax
400023e8:	7d 06                	jge    400023f0 <_vfprintf_r+0xe30>
400023ea:	8b 85 5c f9 ff ff    	mov    -0x6a4(%ebp),%eax
400023f0:	8b 8d 40 f9 ff ff    	mov    -0x6c0(%ebp),%ecx
400023f6:	8b 55 b8             	mov    -0x48(%ebp),%edx
400023f9:	01 c1                	add    %eax,%ecx
400023fb:	85 d2                	test   %edx,%edx
400023fd:	89 8d 40 f9 ff ff    	mov    %ecx,-0x6c0(%ebp)
40002403:	0f 85 46 01 00 00    	jne    4000254f <_vfprintf_r+0xf8f>
40002409:	8b 85 68 f9 ff ff    	mov    -0x698(%ebp),%eax
4000240f:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
40002416:	8d bd 48 ff ff ff    	lea    -0xb8(%ebp),%edi
4000241c:	85 c0                	test   %eax,%eax
4000241e:	0f 84 c1 f9 ff ff    	je     40001de5 <_vfprintf_r+0x825>
40002424:	50                   	push   %eax
40002425:	50                   	push   %eax
40002426:	8b 85 68 f9 ff ff    	mov    -0x698(%ebp),%eax
4000242c:	50                   	push   %eax
4000242d:	8b 45 08             	mov    0x8(%ebp),%eax
40002430:	50                   	push   %eax
40002431:	e8 2a 4b 00 00       	call   40006f60 <_free_r>
40002436:	83 c4 10             	add    $0x10,%esp
40002439:	e9 a7 f9 ff ff       	jmp    40001de5 <_vfprintf_r+0x825>
4000243e:	66 90                	xchg   %ax,%ax
40002440:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002443:	8b 55 0c             	mov    0xc(%ebp),%edx
40002446:	8b 45 08             	mov    0x8(%ebp),%eax
40002449:	e8 32 f1 ff ff       	call   40001580 <__sprint_r>
4000244e:	85 c0                	test   %eax,%eax
40002450:	0f 85 da f6 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40002456:	83 eb 10             	sub    $0x10,%ebx
40002459:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
4000245f:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
40002462:	83 fb 10             	cmp    $0x10,%ebx
40002465:	0f 8f 25 ff ff ff    	jg     40002390 <_vfprintf_r+0xdd0>
4000246b:	e9 4e ff ff ff       	jmp    400023be <_vfprintf_r+0xdfe>
40002470:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002473:	8b 55 0c             	mov    0xc(%ebp),%edx
40002476:	8b 45 08             	mov    0x8(%ebp),%eax
40002479:	e8 02 f1 ff ff       	call   40001580 <__sprint_r>
4000247e:	85 c0                	test   %eax,%eax
40002480:	0f 85 aa f6 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40002486:	8d bd 48 ff ff ff    	lea    -0xb8(%ebp),%edi
4000248c:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
4000248f:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
40002493:	0f 84 c0 f5 ff ff    	je     40001a59 <_vfprintf_r+0x499>
40002499:	8b 5d b8             	mov    -0x48(%ebp),%ebx
4000249c:	41                   	inc    %ecx
4000249d:	43                   	inc    %ebx
4000249e:	8d 45 e7             	lea    -0x19(%ebp),%eax
400024a1:	89 07                	mov    %eax,(%edi)
400024a3:	c7 47 04 01 00 00 00 	movl   $0x1,0x4(%edi)
400024aa:	89 5d b8             	mov    %ebx,-0x48(%ebp)
400024ad:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
400024b0:	83 f9 07             	cmp    $0x7,%ecx
400024b3:	0f 8e d4 f5 ff ff    	jle    40001a8d <_vfprintf_r+0x4cd>
400024b9:	8d 4d b0             	lea    -0x50(%ebp),%ecx
400024bc:	8b 55 0c             	mov    0xc(%ebp),%edx
400024bf:	8b 45 08             	mov    0x8(%ebp),%eax
400024c2:	e8 b9 f0 ff ff       	call   40001580 <__sprint_r>
400024c7:	85 c0                	test   %eax,%eax
400024c9:	0f 85 61 f6 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
400024cf:	8d bd 48 ff ff ff    	lea    -0xb8(%ebp),%edi
400024d5:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
400024d8:	81 bd 30 f9 ff ff 80 	cmpl   $0x80,-0x6d0(%ebp)
400024df:	00 00 00 
400024e2:	0f 85 b8 f5 ff ff    	jne    40001aa0 <_vfprintf_r+0x4e0>
400024e8:	8b 9d 44 f9 ff ff    	mov    -0x6bc(%ebp),%ebx
400024ee:	8b 85 5c f9 ff ff    	mov    -0x6a4(%ebp),%eax
400024f4:	29 c3                	sub    %eax,%ebx
400024f6:	85 db                	test   %ebx,%ebx
400024f8:	7f 0c                	jg     40002506 <_vfprintf_r+0xf46>
400024fa:	e9 a1 f5 ff ff       	jmp    40001aa0 <_vfprintf_r+0x4e0>
400024ff:	90                   	nop    
40002500:	83 c7 08             	add    $0x8,%edi
40002503:	83 eb 10             	sub    $0x10,%ebx
40002506:	83 fb 10             	cmp    $0x10,%ebx
40002509:	0f 8e 10 01 00 00    	jle    4000261f <_vfprintf_r+0x105f>
4000250f:	8b 45 b8             	mov    -0x48(%ebp),%eax
40002512:	41                   	inc    %ecx
40002513:	83 c0 10             	add    $0x10,%eax
40002516:	c7 07 00 be 00 40    	movl   $0x4000be00,(%edi)
4000251c:	c7 47 04 10 00 00 00 	movl   $0x10,0x4(%edi)
40002523:	89 45 b8             	mov    %eax,-0x48(%ebp)
40002526:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40002529:	83 f9 07             	cmp    $0x7,%ecx
4000252c:	7e d2                	jle    40002500 <_vfprintf_r+0xf40>
4000252e:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002531:	8b 55 0c             	mov    0xc(%ebp),%edx
40002534:	8b 45 08             	mov    0x8(%ebp),%eax
40002537:	e8 44 f0 ff ff       	call   40001580 <__sprint_r>
4000253c:	85 c0                	test   %eax,%eax
4000253e:	0f 85 ec f5 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40002544:	8d bd 48 ff ff ff    	lea    -0xb8(%ebp),%edi
4000254a:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
4000254d:	eb b4                	jmp    40002503 <_vfprintf_r+0xf43>
4000254f:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002552:	8b 55 0c             	mov    0xc(%ebp),%edx
40002555:	8b 45 08             	mov    0x8(%ebp),%eax
40002558:	e8 23 f0 ff ff       	call   40001580 <__sprint_r>
4000255d:	85 c0                	test   %eax,%eax
4000255f:	0f 84 a4 fe ff ff    	je     40002409 <_vfprintf_r+0xe49>
40002565:	e9 c6 f5 ff ff       	jmp    40001b30 <_vfprintf_r+0x570>
4000256a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40002570:	83 bd 54 f9 ff ff 01 	cmpl   $0x1,-0x6ac(%ebp)
40002577:	0f 8e b4 05 00 00    	jle    40002b31 <_vfprintf_r+0x1571>
4000257d:	8b 95 38 f9 ff ff    	mov    -0x6c8(%ebp),%edx
40002583:	8b 5d b8             	mov    -0x48(%ebp),%ebx
40002586:	83 c3 02             	add    $0x2,%ebx
40002589:	41                   	inc    %ecx
4000258a:	8a 02                	mov    (%edx),%al
4000258c:	8d 77 08             	lea    0x8(%edi),%esi
4000258f:	88 45 e5             	mov    %al,-0x1b(%ebp)
40002592:	8d 45 e5             	lea    -0x1b(%ebp),%eax
40002595:	c6 45 e6 2e          	movb   $0x2e,-0x1a(%ebp)
40002599:	89 5d b8             	mov    %ebx,-0x48(%ebp)
4000259c:	89 07                	mov    %eax,(%edi)
4000259e:	c7 47 04 02 00 00 00 	movl   $0x2,0x4(%edi)
400025a5:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
400025a8:	83 f9 07             	cmp    $0x7,%ecx
400025ab:	0f 8f f5 03 00 00    	jg     400029a6 <_vfprintf_r+0x13e6>
400025b1:	d9 ee                	fldz   
400025b3:	dd 85 70 f9 ff ff    	fldl   -0x690(%ebp)
400025b9:	da e9                	fucompp 
400025bb:	df e0                	fnstsw %ax
400025bd:	80 e4 45             	and    $0x45,%ah
400025c0:	80 fc 40             	cmp    $0x40,%ah
400025c3:	0f 84 c7 02 00 00    	je     40002890 <_vfprintf_r+0x12d0>
400025c9:	8b 85 38 f9 ff ff    	mov    -0x6c8(%ebp),%eax
400025cf:	8b 55 b8             	mov    -0x48(%ebp),%edx
400025d2:	40                   	inc    %eax
400025d3:	41                   	inc    %ecx
400025d4:	89 06                	mov    %eax,(%esi)
400025d6:	8b 85 54 f9 ff ff    	mov    -0x6ac(%ebp),%eax
400025dc:	48                   	dec    %eax
400025dd:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
400025e0:	01 c2                	add    %eax,%edx
400025e2:	89 46 04             	mov    %eax,0x4(%esi)
400025e5:	89 55 b8             	mov    %edx,-0x48(%ebp)
400025e8:	83 f9 07             	cmp    $0x7,%ecx
400025eb:	0f 8f 91 03 00 00    	jg     40002982 <_vfprintf_r+0x13c2>
400025f1:	83 c6 08             	add    $0x8,%esi
400025f4:	8b 95 50 f9 ff ff    	mov    -0x6b0(%ebp),%edx
400025fa:	8b 5d b8             	mov    -0x48(%ebp),%ebx
400025fd:	8d 45 cd             	lea    -0x33(%ebp),%eax
40002600:	01 d3                	add    %edx,%ebx
40002602:	41                   	inc    %ecx
40002603:	89 06                	mov    %eax,(%esi)
40002605:	89 56 04             	mov    %edx,0x4(%esi)
40002608:	89 5d b8             	mov    %ebx,-0x48(%ebp)
4000260b:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
4000260e:	8d 46 08             	lea    0x8(%esi),%eax
40002611:	83 f9 07             	cmp    $0x7,%ecx
40002614:	0f 8e 46 fd ff ff    	jle    40002360 <_vfprintf_r+0xda0>
4000261a:	e9 25 fd ff ff       	jmp    40002344 <_vfprintf_r+0xd84>
4000261f:	8b 45 b8             	mov    -0x48(%ebp),%eax
40002622:	41                   	inc    %ecx
40002623:	01 d8                	add    %ebx,%eax
40002625:	c7 07 00 be 00 40    	movl   $0x4000be00,(%edi)
4000262b:	89 5f 04             	mov    %ebx,0x4(%edi)
4000262e:	89 45 b8             	mov    %eax,-0x48(%ebp)
40002631:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40002634:	83 f9 07             	cmp    $0x7,%ecx
40002637:	0f 8f 03 03 00 00    	jg     40002940 <_vfprintf_r+0x1380>
4000263d:	83 c7 08             	add    $0x8,%edi
40002640:	e9 5b f4 ff ff       	jmp    40001aa0 <_vfprintf_r+0x4e0>
40002645:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002648:	8b 55 0c             	mov    0xc(%ebp),%edx
4000264b:	8b 45 08             	mov    0x8(%ebp),%eax
4000264e:	e8 2d ef ff ff       	call   40001580 <__sprint_r>
40002653:	85 c0                	test   %eax,%eax
40002655:	0f 85 d5 f4 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
4000265b:	8d bd 48 ff ff ff    	lea    -0xb8(%ebp),%edi
40002661:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
40002664:	e9 a8 fb ff ff       	jmp    40002211 <_vfprintf_r+0xc51>
40002669:	3c 02                	cmp    $0x2,%al
4000266b:	0f 84 cb 00 00 00    	je     4000273c <_vfprintf_r+0x117c>
40002671:	83 ec 0c             	sub    $0xc,%esp
40002674:	68 6a bc 00 40       	push   $0x4000bc6a
40002679:	e8 4e ec ff ff       	call   400012cc <strlen>
4000267e:	8b 95 78 f9 ff ff    	mov    -0x688(%ebp),%edx
40002684:	83 c4 10             	add    $0x10,%esp
40002687:	89 85 60 f9 ff ff    	mov    %eax,-0x6a0(%ebp)
4000268d:	89 85 5c f9 ff ff    	mov    %eax,-0x6a4(%ebp)
40002693:	39 d0                	cmp    %edx,%eax
40002695:	7d 06                	jge    4000269d <_vfprintf_r+0x10dd>
40002697:	89 95 5c f9 ff ff    	mov    %edx,-0x6a4(%ebp)
4000269d:	8b 8d 78 f9 ff ff    	mov    -0x688(%ebp),%ecx
400026a3:	c7 85 68 f9 ff ff 00 	movl   $0x0,-0x698(%ebp)
400026aa:	00 00 00 
400026ad:	89 8d 58 f9 ff ff    	mov    %ecx,-0x6a8(%ebp)
400026b3:	c7 85 38 f9 ff ff 6a 	movl   $0x4000bc6a,-0x6c8(%ebp)
400026ba:	bc 00 40 
400026bd:	e9 e7 f2 ff ff       	jmp    400019a9 <_vfprintf_r+0x3e9>
400026c2:	f6 85 3c f9 ff ff 01 	testb  $0x1,-0x6c4(%ebp)
400026c9:	0f 85 20 02 00 00    	jne    400028ef <_vfprintf_r+0x132f>
400026cf:	8d 85 ec fe ff ff    	lea    -0x114(%ebp),%eax
400026d5:	31 d2                	xor    %edx,%edx
400026d7:	89 85 38 f9 ff ff    	mov    %eax,-0x6c8(%ebp)
400026dd:	e9 95 f2 ff ff       	jmp    40001977 <_vfprintf_r+0x3b7>
400026e2:	83 f9 09             	cmp    $0x9,%ecx
400026e5:	0f 86 5b 0b 00 00    	jbe    40003246 <_vfprintf_r+0x1c86>
400026eb:	8d 9d ec fe ff ff    	lea    -0x114(%ebp),%ebx
400026f1:	89 9d 2c f9 ff ff    	mov    %ebx,-0x6d4(%ebp)
400026f7:	89 c8                	mov    %ecx,%eax
400026f9:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
400026fe:	f7 e2                	mul    %edx
40002700:	c1 ea 03             	shr    $0x3,%edx
40002703:	4b                   	dec    %ebx
40002704:	8d 04 92             	lea    (%edx,%edx,4),%eax
40002707:	01 c0                	add    %eax,%eax
40002709:	29 c1                	sub    %eax,%ecx
4000270b:	83 fa 09             	cmp    $0x9,%edx
4000270e:	8d 41 30             	lea    0x30(%ecx),%eax
40002711:	89 d1                	mov    %edx,%ecx
40002713:	88 03                	mov    %al,(%ebx)
40002715:	77 e0                	ja     400026f7 <_vfprintf_r+0x1137>
40002717:	4b                   	dec    %ebx
40002718:	89 9d 38 f9 ff ff    	mov    %ebx,-0x6c8(%ebp)
4000271e:	8b 95 38 f9 ff ff    	mov    -0x6c8(%ebp),%edx
40002724:	8d 41 30             	lea    0x30(%ecx),%eax
40002727:	88 02                	mov    %al,(%edx)
40002729:	8b 95 2c f9 ff ff    	mov    -0x6d4(%ebp),%edx
4000272f:	8b 8d 38 f9 ff ff    	mov    -0x6c8(%ebp),%ecx
40002735:	29 ca                	sub    %ecx,%edx
40002737:	e9 3b f2 ff ff       	jmp    40001977 <_vfprintf_r+0x3b7>
4000273c:	8d 9d ec fe ff ff    	lea    -0x114(%ebp),%ebx
40002742:	89 9d 38 f9 ff ff    	mov    %ebx,-0x6c8(%ebp)
40002748:	8b 85 38 f9 ff ff    	mov    -0x6c8(%ebp),%eax
4000274e:	8b 95 64 f9 ff ff    	mov    -0x69c(%ebp),%edx
40002754:	48                   	dec    %eax
40002755:	89 85 38 f9 ff ff    	mov    %eax,-0x6c8(%ebp)
4000275b:	89 c8                	mov    %ecx,%eax
4000275d:	83 e0 0f             	and    $0xf,%eax
40002760:	8b 9d 38 f9 ff ff    	mov    -0x6c8(%ebp),%ebx
40002766:	c1 e9 04             	shr    $0x4,%ecx
40002769:	8a 04 10             	mov    (%eax,%edx,1),%al
4000276c:	88 03                	mov    %al,(%ebx)
4000276e:	75 d8                	jne    40002748 <_vfprintf_r+0x1188>
40002770:	8b 95 10 f9 ff ff    	mov    -0x6f0(%ebp),%edx
40002776:	29 da                	sub    %ebx,%edx
40002778:	e9 fa f1 ff ff       	jmp    40001977 <_vfprintf_r+0x3b7>
4000277d:	8b 5d e0             	mov    -0x20(%ebp),%ebx
40002780:	85 db                	test   %ebx,%ebx
40002782:	0f 8e f4 07 00 00    	jle    40002f7c <_vfprintf_r+0x19bc>
40002788:	3b 9d 54 f9 ff ff    	cmp    -0x6ac(%ebp),%ebx
4000278e:	0f 8c d5 03 00 00    	jl     40002b69 <_vfprintf_r+0x15a9>
40002794:	8b 85 38 f9 ff ff    	mov    -0x6c8(%ebp),%eax
4000279a:	8b 95 54 f9 ff ff    	mov    -0x6ac(%ebp),%edx
400027a0:	89 07                	mov    %eax,(%edi)
400027a2:	8b 45 b8             	mov    -0x48(%ebp),%eax
400027a5:	01 d0                	add    %edx,%eax
400027a7:	41                   	inc    %ecx
400027a8:	89 45 b8             	mov    %eax,-0x48(%ebp)
400027ab:	89 57 04             	mov    %edx,0x4(%edi)
400027ae:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
400027b1:	8d 47 08             	lea    0x8(%edi),%eax
400027b4:	83 f9 07             	cmp    $0x7,%ecx
400027b7:	0f 8f ce 05 00 00    	jg     40002d8b <_vfprintf_r+0x17cb>
400027bd:	8b bd 54 f9 ff ff    	mov    -0x6ac(%ebp),%edi
400027c3:	29 fb                	sub    %edi,%ebx
400027c5:	85 db                	test   %ebx,%ebx
400027c7:	0f 8e 7e 00 00 00    	jle    4000284b <_vfprintf_r+0x128b>
400027cd:	83 fb 10             	cmp    $0x10,%ebx
400027d0:	0f 8e 54 07 00 00    	jle    40002f2a <_vfprintf_r+0x196a>
400027d6:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
400027d9:	eb 14                	jmp    400027ef <_vfprintf_r+0x122f>
400027db:	90                   	nop    
400027dc:	8d 74 26 00          	lea    0x0(%esi),%esi
400027e0:	83 c0 08             	add    $0x8,%eax
400027e3:	83 eb 10             	sub    $0x10,%ebx
400027e6:	83 fb 10             	cmp    $0x10,%ebx
400027e9:	0f 8e 3e 07 00 00    	jle    40002f2d <_vfprintf_r+0x196d>
400027ef:	8b 75 b8             	mov    -0x48(%ebp),%esi
400027f2:	41                   	inc    %ecx
400027f3:	83 c6 10             	add    $0x10,%esi
400027f6:	c7 00 00 be 00 40    	movl   $0x4000be00,(%eax)
400027fc:	c7 40 04 10 00 00 00 	movl   $0x10,0x4(%eax)
40002803:	89 75 b8             	mov    %esi,-0x48(%ebp)
40002806:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40002809:	83 f9 07             	cmp    $0x7,%ecx
4000280c:	7e d2                	jle    400027e0 <_vfprintf_r+0x1220>
4000280e:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002811:	8b 55 0c             	mov    0xc(%ebp),%edx
40002814:	8b 45 08             	mov    0x8(%ebp),%eax
40002817:	e8 64 ed ff ff       	call   40001580 <__sprint_r>
4000281c:	85 c0                	test   %eax,%eax
4000281e:	0f 85 0c f3 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40002824:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
4000282a:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
4000282d:	eb b4                	jmp    400027e3 <_vfprintf_r+0x1223>
4000282f:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002832:	8b 55 0c             	mov    0xc(%ebp),%edx
40002835:	8b 45 08             	mov    0x8(%ebp),%eax
40002838:	e8 43 ed ff ff       	call   40001580 <__sprint_r>
4000283d:	85 c0                	test   %eax,%eax
4000283f:	0f 85 eb f2 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40002845:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
4000284b:	f6 85 3c f9 ff ff 01 	testb  $0x1,-0x6c4(%ebp)
40002852:	0f 84 08 fb ff ff    	je     40002360 <_vfprintf_r+0xda0>
40002858:	8b 7d b8             	mov    -0x48(%ebp),%edi
4000285b:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
4000285e:	47                   	inc    %edi
4000285f:	41                   	inc    %ecx
40002860:	c7 00 8a bc 00 40    	movl   $0x4000bc8a,(%eax)
40002866:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
4000286d:	89 7d b8             	mov    %edi,-0x48(%ebp)
40002870:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40002873:	83 f9 07             	cmp    $0x7,%ecx
40002876:	0f 8e b5 01 00 00    	jle    40002a31 <_vfprintf_r+0x1471>
4000287c:	e9 c3 fa ff ff       	jmp    40002344 <_vfprintf_r+0xd84>
40002881:	eb 0d                	jmp    40002890 <_vfprintf_r+0x12d0>
40002883:	90                   	nop    
40002884:	90                   	nop    
40002885:	90                   	nop    
40002886:	90                   	nop    
40002887:	90                   	nop    
40002888:	90                   	nop    
40002889:	90                   	nop    
4000288a:	90                   	nop    
4000288b:	90                   	nop    
4000288c:	90                   	nop    
4000288d:	90                   	nop    
4000288e:	90                   	nop    
4000288f:	90                   	nop    
40002890:	8b 9d 54 f9 ff ff    	mov    -0x6ac(%ebp),%ebx
40002896:	4b                   	dec    %ebx
40002897:	85 db                	test   %ebx,%ebx
40002899:	7f 0b                	jg     400028a6 <_vfprintf_r+0x12e6>
4000289b:	e9 54 fd ff ff       	jmp    400025f4 <_vfprintf_r+0x1034>
400028a0:	83 c6 08             	add    $0x8,%esi
400028a3:	83 eb 10             	sub    $0x10,%ebx
400028a6:	83 fb 10             	cmp    $0x10,%ebx
400028a9:	0f 8e b5 00 00 00    	jle    40002964 <_vfprintf_r+0x13a4>
400028af:	8b 45 b8             	mov    -0x48(%ebp),%eax
400028b2:	41                   	inc    %ecx
400028b3:	83 c0 10             	add    $0x10,%eax
400028b6:	c7 06 00 be 00 40    	movl   $0x4000be00,(%esi)
400028bc:	c7 46 04 10 00 00 00 	movl   $0x10,0x4(%esi)
400028c3:	89 45 b8             	mov    %eax,-0x48(%ebp)
400028c6:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
400028c9:	83 f9 07             	cmp    $0x7,%ecx
400028cc:	7e d2                	jle    400028a0 <_vfprintf_r+0x12e0>
400028ce:	8d 4d b0             	lea    -0x50(%ebp),%ecx
400028d1:	8b 55 0c             	mov    0xc(%ebp),%edx
400028d4:	8b 45 08             	mov    0x8(%ebp),%eax
400028d7:	e8 a4 ec ff ff       	call   40001580 <__sprint_r>
400028dc:	85 c0                	test   %eax,%eax
400028de:	0f 85 4c f2 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
400028e4:	8d b5 48 ff ff ff    	lea    -0xb8(%ebp),%esi
400028ea:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
400028ed:	eb b4                	jmp    400028a3 <_vfprintf_r+0x12e3>
400028ef:	8d 85 eb fe ff ff    	lea    -0x115(%ebp),%eax
400028f5:	8b 95 10 f9 ff ff    	mov    -0x6f0(%ebp),%edx
400028fb:	29 c2                	sub    %eax,%edx
400028fd:	c6 85 eb fe ff ff 30 	movb   $0x30,-0x115(%ebp)
40002904:	89 85 38 f9 ff ff    	mov    %eax,-0x6c8(%ebp)
4000290a:	e9 68 f0 ff ff       	jmp    40001977 <_vfprintf_r+0x3b7>
4000290f:	8b 95 10 f9 ff ff    	mov    -0x6f0(%ebp),%edx
40002915:	8b 85 38 f9 ff ff    	mov    -0x6c8(%ebp),%eax
4000291b:	29 c2                	sub    %eax,%edx
4000291d:	e9 55 f0 ff ff       	jmp    40001977 <_vfprintf_r+0x3b7>
40002922:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002925:	8b 55 0c             	mov    0xc(%ebp),%edx
40002928:	8b 45 08             	mov    0x8(%ebp),%eax
4000292b:	e8 50 ec ff ff       	call   40001580 <__sprint_r>
40002930:	85 c0                	test   %eax,%eax
40002932:	0f 84 a4 fa ff ff    	je     400023dc <_vfprintf_r+0xe1c>
40002938:	e9 f3 f1 ff ff       	jmp    40001b30 <_vfprintf_r+0x570>
4000293d:	8d 76 00             	lea    0x0(%esi),%esi
40002940:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002943:	8b 55 0c             	mov    0xc(%ebp),%edx
40002946:	8b 45 08             	mov    0x8(%ebp),%eax
40002949:	e8 32 ec ff ff       	call   40001580 <__sprint_r>
4000294e:	85 c0                	test   %eax,%eax
40002950:	0f 85 da f1 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40002956:	8d bd 48 ff ff ff    	lea    -0xb8(%ebp),%edi
4000295c:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
4000295f:	e9 3c f1 ff ff       	jmp    40001aa0 <_vfprintf_r+0x4e0>
40002964:	8b 7d b8             	mov    -0x48(%ebp),%edi
40002967:	41                   	inc    %ecx
40002968:	01 df                	add    %ebx,%edi
4000296a:	c7 06 00 be 00 40    	movl   $0x4000be00,(%esi)
40002970:	89 5e 04             	mov    %ebx,0x4(%esi)
40002973:	89 7d b8             	mov    %edi,-0x48(%ebp)
40002976:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40002979:	83 f9 07             	cmp    $0x7,%ecx
4000297c:	0f 8e 6f fc ff ff    	jle    400025f1 <_vfprintf_r+0x1031>
40002982:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002985:	8b 55 0c             	mov    0xc(%ebp),%edx
40002988:	8b 45 08             	mov    0x8(%ebp),%eax
4000298b:	e8 f0 eb ff ff       	call   40001580 <__sprint_r>
40002990:	85 c0                	test   %eax,%eax
40002992:	0f 85 98 f1 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40002998:	8d b5 48 ff ff ff    	lea    -0xb8(%ebp),%esi
4000299e:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
400029a1:	e9 4e fc ff ff       	jmp    400025f4 <_vfprintf_r+0x1034>
400029a6:	8d 4d b0             	lea    -0x50(%ebp),%ecx
400029a9:	8b 55 0c             	mov    0xc(%ebp),%edx
400029ac:	8b 45 08             	mov    0x8(%ebp),%eax
400029af:	e8 cc eb ff ff       	call   40001580 <__sprint_r>
400029b4:	85 c0                	test   %eax,%eax
400029b6:	0f 85 74 f1 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
400029bc:	8d b5 48 ff ff ff    	lea    -0xb8(%ebp),%esi
400029c2:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
400029c5:	e9 e7 fb ff ff       	jmp    400025b1 <_vfprintf_r+0xff1>
400029ca:	8d 5d c4             	lea    -0x3c(%ebp),%ebx
400029cd:	50                   	push   %eax
400029ce:	6a 08                	push   $0x8
400029d0:	6a 00                	push   $0x0
400029d2:	53                   	push   %ebx
400029d3:	e8 10 e6 ff ff       	call   40000fe8 <memset>
400029d8:	53                   	push   %ebx
400029d9:	8b 5d 14             	mov    0x14(%ebp),%ebx
400029dc:	8b 1b                	mov    (%ebx),%ebx
400029de:	53                   	push   %ebx
400029df:	8d 9d 90 fd ff ff    	lea    -0x270(%ebp),%ebx
400029e5:	53                   	push   %ebx
400029e6:	8b 4d 08             	mov    0x8(%ebp),%ecx
400029e9:	51                   	push   %ecx
400029ea:	e8 01 24 00 00       	call   40004df0 <_wcrtomb_r>
400029ef:	83 c4 20             	add    $0x20,%esp
400029f2:	89 85 60 f9 ff ff    	mov    %eax,-0x6a0(%ebp)
400029f8:	40                   	inc    %eax
400029f9:	0f 84 25 09 00 00    	je     40003324 <_vfprintf_r+0x1d64>
400029ff:	8b 45 14             	mov    0x14(%ebp),%eax
40002a02:	83 c0 04             	add    $0x4,%eax
40002a05:	89 85 7c f9 ff ff    	mov    %eax,-0x684(%ebp)
40002a0b:	e9 2d f4 ff ff       	jmp    40001e3d <_vfprintf_r+0x87d>
40002a10:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
40002a13:	c7 00 00 be 00 40    	movl   $0x4000be00,(%eax)
40002a19:	8b 55 b8             	mov    -0x48(%ebp),%edx
40002a1c:	41                   	inc    %ecx
40002a1d:	01 da                	add    %ebx,%edx
40002a1f:	89 58 04             	mov    %ebx,0x4(%eax)
40002a22:	89 55 b8             	mov    %edx,-0x48(%ebp)
40002a25:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40002a28:	83 f9 07             	cmp    $0x7,%ecx
40002a2b:	0f 8f 13 f9 ff ff    	jg     40002344 <_vfprintf_r+0xd84>
40002a31:	83 c0 08             	add    $0x8,%eax
40002a34:	e9 27 f9 ff ff       	jmp    40002360 <_vfprintf_r+0xda0>
40002a39:	f7 85 3c f9 ff ff 00 	testl  $0x200,-0x6c4(%ebp)
40002a40:	02 00 00 
40002a43:	0f 84 b2 02 00 00    	je     40002cfb <_vfprintf_r+0x173b>
40002a49:	8b 55 14             	mov    0x14(%ebp),%edx
40002a4c:	8b 45 14             	mov    0x14(%ebp),%eax
40002a4f:	31 c9                	xor    %ecx,%ecx
40002a51:	83 c0 04             	add    $0x4,%eax
40002a54:	8a 0a                	mov    (%edx),%cl
40002a56:	89 85 7c f9 ff ff    	mov    %eax,-0x684(%ebp)
40002a5c:	e9 a9 f2 ff ff       	jmp    40001d0a <_vfprintf_r+0x74a>
40002a61:	8b 55 14             	mov    0x14(%ebp),%edx
40002a64:	8b 45 14             	mov    0x14(%ebp),%eax
40002a67:	83 c0 08             	add    $0x8,%eax
40002a6a:	dd 02                	fldl   (%edx)
40002a6c:	89 85 7c f9 ff ff    	mov    %eax,-0x684(%ebp)
40002a72:	dd 9d 70 f9 ff ff    	fstpl  -0x690(%ebp)
40002a78:	e9 ab f6 ff ff       	jmp    40002128 <_vfprintf_r+0xb68>
40002a7d:	f6 85 3c f9 ff ff 40 	testb  $0x40,-0x6c4(%ebp)
40002a84:	0f 85 52 02 00 00    	jne    40002cdc <_vfprintf_r+0x171c>
40002a8a:	f7 85 3c f9 ff ff 00 	testl  $0x200,-0x6c4(%ebp)
40002a91:	02 00 00 
40002a94:	0f 84 fb 07 00 00    	je     40003295 <_vfprintf_r+0x1cd5>
40002a9a:	8b 55 14             	mov    0x14(%ebp),%edx
40002a9d:	8b 5d 14             	mov    0x14(%ebp),%ebx
40002aa0:	83 c3 04             	add    $0x4,%ebx
40002aa3:	8a 8d 40 f9 ff ff    	mov    -0x6c0(%ebp),%cl
40002aa9:	8b 02                	mov    (%edx),%eax
40002aab:	89 9d 7c f9 ff ff    	mov    %ebx,-0x684(%ebp)
40002ab1:	88 08                	mov    %cl,(%eax)
40002ab3:	e9 2d f3 ff ff       	jmp    40001de5 <_vfprintf_r+0x825>
40002ab8:	f7 85 3c f9 ff ff 00 	testl  $0x200,-0x6c4(%ebp)
40002abf:	02 00 00 
40002ac2:	0f 84 fc 01 00 00    	je     40002cc4 <_vfprintf_r+0x1704>
40002ac8:	8b 45 14             	mov    0x14(%ebp),%eax
40002acb:	8b 5d 14             	mov    0x14(%ebp),%ebx
40002ace:	31 c9                	xor    %ecx,%ecx
40002ad0:	83 c3 04             	add    $0x4,%ebx
40002ad3:	8a 08                	mov    (%eax),%cl
40002ad5:	31 c0                	xor    %eax,%eax
40002ad7:	89 9d 7c f9 ff ff    	mov    %ebx,-0x684(%ebp)
40002add:	e9 38 ed ff ff       	jmp    4000181a <_vfprintf_r+0x25a>
40002ae2:	f7 85 3c f9 ff ff 00 	testl  $0x200,-0x6c4(%ebp)
40002ae9:	02 00 00 
40002aec:	0f 84 35 02 00 00    	je     40002d27 <_vfprintf_r+0x1767>
40002af2:	8b 45 14             	mov    0x14(%ebp),%eax
40002af5:	8b 5d 14             	mov    0x14(%ebp),%ebx
40002af8:	31 c9                	xor    %ecx,%ecx
40002afa:	83 c3 04             	add    $0x4,%ebx
40002afd:	8a 08                	mov    (%eax),%cl
40002aff:	89 9d 7c f9 ff ff    	mov    %ebx,-0x684(%ebp)
40002b05:	e9 0e ed ff ff       	jmp    40001818 <_vfprintf_r+0x258>
40002b0a:	f7 85 3c f9 ff ff 00 	testl  $0x200,-0x6c4(%ebp)
40002b11:	02 00 00 
40002b14:	0f 84 f7 01 00 00    	je     40002d11 <_vfprintf_r+0x1751>
40002b1a:	8b 4d 14             	mov    0x14(%ebp),%ecx
40002b1d:	8b 5d 14             	mov    0x14(%ebp),%ebx
40002b20:	83 c1 04             	add    $0x4,%ecx
40002b23:	89 8d 7c f9 ff ff    	mov    %ecx,-0x684(%ebp)
40002b29:	0f be 0b             	movsbl (%ebx),%ecx
40002b2c:	e9 f3 ed ff ff       	jmp    40001924 <_vfprintf_r+0x364>
40002b31:	f6 85 3c f9 ff ff 01 	testb  $0x1,-0x6c4(%ebp)
40002b38:	0f 85 3f fa ff ff    	jne    4000257d <_vfprintf_r+0xfbd>
40002b3e:	8b 75 b8             	mov    -0x48(%ebp),%esi
40002b41:	41                   	inc    %ecx
40002b42:	46                   	inc    %esi
40002b43:	8b 85 38 f9 ff ff    	mov    -0x6c8(%ebp),%eax
40002b49:	89 75 b8             	mov    %esi,-0x48(%ebp)
40002b4c:	89 07                	mov    %eax,(%edi)
40002b4e:	c7 47 04 01 00 00 00 	movl   $0x1,0x4(%edi)
40002b55:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40002b58:	8d 77 08             	lea    0x8(%edi),%esi
40002b5b:	83 f9 07             	cmp    $0x7,%ecx
40002b5e:	0f 8e 90 fa ff ff    	jle    400025f4 <_vfprintf_r+0x1034>
40002b64:	e9 19 fe ff ff       	jmp    40002982 <_vfprintf_r+0x13c2>
40002b69:	8b 75 b8             	mov    -0x48(%ebp),%esi
40002b6c:	8b 85 38 f9 ff ff    	mov    -0x6c8(%ebp),%eax
40002b72:	01 de                	add    %ebx,%esi
40002b74:	41                   	inc    %ecx
40002b75:	89 07                	mov    %eax,(%edi)
40002b77:	89 5f 04             	mov    %ebx,0x4(%edi)
40002b7a:	89 75 b8             	mov    %esi,-0x48(%ebp)
40002b7d:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40002b80:	8d 47 08             	lea    0x8(%edi),%eax
40002b83:	83 f9 07             	cmp    $0x7,%ecx
40002b86:	0f 8f d8 01 00 00    	jg     40002d64 <_vfprintf_r+0x17a4>
40002b8c:	8b 55 b8             	mov    -0x48(%ebp),%edx
40002b8f:	41                   	inc    %ecx
40002b90:	42                   	inc    %edx
40002b91:	89 de                	mov    %ebx,%esi
40002b93:	89 55 b8             	mov    %edx,-0x48(%ebp)
40002b96:	c7 00 8a bc 00 40    	movl   $0x4000bc8a,(%eax)
40002b9c:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
40002ba3:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40002ba6:	8d 50 08             	lea    0x8(%eax),%edx
40002ba9:	83 f9 07             	cmp    $0x7,%ecx
40002bac:	0f 8f 8b 01 00 00    	jg     40002d3d <_vfprintf_r+0x177d>
40002bb2:	8b 85 38 f9 ff ff    	mov    -0x6c8(%ebp),%eax
40002bb8:	8b 7d e0             	mov    -0x20(%ebp),%edi
40002bbb:	01 f0                	add    %esi,%eax
40002bbd:	8b 75 b8             	mov    -0x48(%ebp),%esi
40002bc0:	89 02                	mov    %eax,(%edx)
40002bc2:	8b 85 54 f9 ff ff    	mov    -0x6ac(%ebp),%eax
40002bc8:	29 f8                	sub    %edi,%eax
40002bca:	41                   	inc    %ecx
40002bcb:	89 42 04             	mov    %eax,0x4(%edx)
40002bce:	8b 85 54 f9 ff ff    	mov    -0x6ac(%ebp),%eax
40002bd4:	01 f0                	add    %esi,%eax
40002bd6:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40002bd9:	29 d8                	sub    %ebx,%eax
40002bdb:	83 f9 07             	cmp    $0x7,%ecx
40002bde:	89 45 b8             	mov    %eax,-0x48(%ebp)
40002be1:	8d 42 08             	lea    0x8(%edx),%eax
40002be4:	0f 8e 76 f7 ff ff    	jle    40002360 <_vfprintf_r+0xda0>
40002bea:	e9 55 f7 ff ff       	jmp    40002344 <_vfprintf_r+0xd84>
40002bef:	f7 d9                	neg    %ecx
40002bf1:	c6 45 e7 2d          	movb   $0x2d,-0x19(%ebp)
40002bf5:	e9 34 ed ff ff       	jmp    4000192e <_vfprintf_r+0x36e>
40002bfa:	c7 85 58 f9 ff ff 00 	movl   $0x0,-0x6a8(%ebp)
40002c01:	00 00 00 
40002c04:	c7 85 60 f9 ff ff 03 	movl   $0x3,-0x6a0(%ebp)
40002c0b:	00 00 00 
40002c0e:	c7 85 68 f9 ff ff 00 	movl   $0x0,-0x698(%ebp)
40002c15:	00 00 00 
40002c18:	c7 85 38 f9 ff ff 84 	movl   $0x4000bc84,-0x6c8(%ebp)
40002c1f:	bc 00 40 
40002c22:	c7 85 5c f9 ff ff 03 	movl   $0x3,-0x6a4(%ebp)
40002c29:	00 00 00 
40002c2c:	e9 78 ed ff ff       	jmp    400019a9 <_vfprintf_r+0x3e9>
40002c31:	8b 9d 78 f9 ff ff    	mov    -0x688(%ebp),%ebx
40002c37:	85 db                	test   %ebx,%ebx
40002c39:	0f 85 c5 f4 ff ff    	jne    40002104 <_vfprintf_r+0xb44>
40002c3f:	c7 85 78 f9 ff ff 01 	movl   $0x1,-0x688(%ebp)
40002c46:	00 00 00 
40002c49:	e9 b6 f4 ff ff       	jmp    40002104 <_vfprintf_r+0xb44>
40002c4e:	8b 85 78 f9 ff ff    	mov    -0x688(%ebp),%eax
40002c54:	85 c0                	test   %eax,%eax
40002c56:	0f 88 06 04 00 00    	js     40003062 <_vfprintf_r+0x1aa2>
40002c5c:	50                   	push   %eax
40002c5d:	8b 85 78 f9 ff ff    	mov    -0x688(%ebp),%eax
40002c63:	50                   	push   %eax
40002c64:	6a 00                	push   $0x0
40002c66:	8b 85 38 f9 ff ff    	mov    -0x6c8(%ebp),%eax
40002c6c:	50                   	push   %eax
40002c6d:	e8 b6 4d 00 00       	call   40007a28 <memchr>
40002c72:	83 c4 10             	add    $0x10,%esp
40002c75:	85 c0                	test   %eax,%eax
40002c77:	0f 84 b8 07 00 00    	je     40003435 <_vfprintf_r+0x1e75>
40002c7d:	8b 9d 38 f9 ff ff    	mov    -0x6c8(%ebp),%ebx
40002c83:	8b 95 78 f9 ff ff    	mov    -0x688(%ebp),%edx
40002c89:	29 d8                	sub    %ebx,%eax
40002c8b:	89 85 60 f9 ff ff    	mov    %eax,-0x6a0(%ebp)
40002c91:	39 d0                	cmp    %edx,%eax
40002c93:	0f 8e e1 03 00 00    	jle    4000307a <_vfprintf_r+0x1aba>
40002c99:	8b 8d 78 f9 ff ff    	mov    -0x688(%ebp),%ecx
40002c9f:	c7 85 58 f9 ff ff 00 	movl   $0x0,-0x6a8(%ebp)
40002ca6:	00 00 00 
40002ca9:	89 8d 5c f9 ff ff    	mov    %ecx,-0x6a4(%ebp)
40002caf:	89 8d 60 f9 ff ff    	mov    %ecx,-0x6a0(%ebp)
40002cb5:	c7 85 68 f9 ff ff 00 	movl   $0x0,-0x698(%ebp)
40002cbc:	00 00 00 
40002cbf:	e9 e5 ec ff ff       	jmp    400019a9 <_vfprintf_r+0x3e9>
40002cc4:	8b 5d 14             	mov    0x14(%ebp),%ebx
40002cc7:	8b 55 14             	mov    0x14(%ebp),%edx
40002cca:	83 c2 04             	add    $0x4,%edx
40002ccd:	31 c0                	xor    %eax,%eax
40002ccf:	8b 0b                	mov    (%ebx),%ecx
40002cd1:	89 95 7c f9 ff ff    	mov    %edx,-0x684(%ebp)
40002cd7:	e9 3e eb ff ff       	jmp    4000181a <_vfprintf_r+0x25a>
40002cdc:	8b 55 14             	mov    0x14(%ebp),%edx
40002cdf:	8b 5d 14             	mov    0x14(%ebp),%ebx
40002ce2:	83 c3 04             	add    $0x4,%ebx
40002ce5:	8b 8d 40 f9 ff ff    	mov    -0x6c0(%ebp),%ecx
40002ceb:	8b 02                	mov    (%edx),%eax
40002ced:	89 9d 7c f9 ff ff    	mov    %ebx,-0x684(%ebp)
40002cf3:	66 89 08             	mov    %cx,(%eax)
40002cf6:	e9 ea f0 ff ff       	jmp    40001de5 <_vfprintf_r+0x825>
40002cfb:	8b 4d 14             	mov    0x14(%ebp),%ecx
40002cfe:	8b 5d 14             	mov    0x14(%ebp),%ebx
40002d01:	83 c1 04             	add    $0x4,%ecx
40002d04:	89 8d 7c f9 ff ff    	mov    %ecx,-0x684(%ebp)
40002d0a:	8b 0b                	mov    (%ebx),%ecx
40002d0c:	e9 f9 ef ff ff       	jmp    40001d0a <_vfprintf_r+0x74a>
40002d11:	8b 55 14             	mov    0x14(%ebp),%edx
40002d14:	8b 45 14             	mov    0x14(%ebp),%eax
40002d17:	83 c0 04             	add    $0x4,%eax
40002d1a:	8b 0a                	mov    (%edx),%ecx
40002d1c:	89 85 7c f9 ff ff    	mov    %eax,-0x684(%ebp)
40002d22:	e9 fd eb ff ff       	jmp    40001924 <_vfprintf_r+0x364>
40002d27:	8b 5d 14             	mov    0x14(%ebp),%ebx
40002d2a:	8b 55 14             	mov    0x14(%ebp),%edx
40002d2d:	83 c2 04             	add    $0x4,%edx
40002d30:	8b 0b                	mov    (%ebx),%ecx
40002d32:	89 95 7c f9 ff ff    	mov    %edx,-0x684(%ebp)
40002d38:	e9 db ea ff ff       	jmp    40001818 <_vfprintf_r+0x258>
40002d3d:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002d40:	8b 55 0c             	mov    0xc(%ebp),%edx
40002d43:	8b 45 08             	mov    0x8(%ebp),%eax
40002d46:	e8 35 e8 ff ff       	call   40001580 <__sprint_r>
40002d4b:	85 c0                	test   %eax,%eax
40002d4d:	0f 85 dd ed ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40002d53:	8d 95 48 ff ff ff    	lea    -0xb8(%ebp),%edx
40002d59:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
40002d5c:	8b 5d e0             	mov    -0x20(%ebp),%ebx
40002d5f:	e9 4e fe ff ff       	jmp    40002bb2 <_vfprintf_r+0x15f2>
40002d64:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002d67:	8b 55 0c             	mov    0xc(%ebp),%edx
40002d6a:	8b 45 08             	mov    0x8(%ebp),%eax
40002d6d:	e8 0e e8 ff ff       	call   40001580 <__sprint_r>
40002d72:	85 c0                	test   %eax,%eax
40002d74:	0f 85 b6 ed ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40002d7a:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
40002d80:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
40002d83:	8b 5d e0             	mov    -0x20(%ebp),%ebx
40002d86:	e9 01 fe ff ff       	jmp    40002b8c <_vfprintf_r+0x15cc>
40002d8b:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002d8e:	8b 55 0c             	mov    0xc(%ebp),%edx
40002d91:	8b 45 08             	mov    0x8(%ebp),%eax
40002d94:	e8 e7 e7 ff ff       	call   40001580 <__sprint_r>
40002d99:	85 c0                	test   %eax,%eax
40002d9b:	0f 85 8f ed ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40002da1:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
40002da7:	8b 5d e0             	mov    -0x20(%ebp),%ebx
40002daa:	e9 0e fa ff ff       	jmp    400027bd <_vfprintf_r+0x11fd>
40002daf:	50                   	push   %eax
40002db0:	50                   	push   %eax
40002db1:	8b 85 60 f9 ff ff    	mov    -0x6a0(%ebp),%eax
40002db7:	40                   	inc    %eax
40002db8:	50                   	push   %eax
40002db9:	8b 5d 08             	mov    0x8(%ebp),%ebx
40002dbc:	53                   	push   %ebx
40002dbd:	e8 1e da ff ff       	call   400007e0 <_malloc_r>
40002dc2:	83 c4 10             	add    $0x10,%esp
40002dc5:	89 85 68 f9 ff ff    	mov    %eax,-0x698(%ebp)
40002dcb:	85 c0                	test   %eax,%eax
40002dcd:	0f 84 1d 09 00 00    	je     400036f0 <_vfprintf_r+0x2130>
40002dd3:	8d 5d bc             	lea    -0x44(%ebp),%ebx
40002dd6:	51                   	push   %ecx
40002dd7:	6a 08                	push   $0x8
40002dd9:	6a 00                	push   $0x0
40002ddb:	53                   	push   %ebx
40002ddc:	e8 07 e2 ff ff       	call   40000fe8 <memset>
40002de1:	89 1c 24             	mov    %ebx,(%esp)
40002de4:	8d 45 dc             	lea    -0x24(%ebp),%eax
40002de7:	8b 95 60 f9 ff ff    	mov    -0x6a0(%ebp),%edx
40002ded:	52                   	push   %edx
40002dee:	50                   	push   %eax
40002def:	8b 85 68 f9 ff ff    	mov    -0x698(%ebp),%eax
40002df5:	50                   	push   %eax
40002df6:	8b 45 08             	mov    0x8(%ebp),%eax
40002df9:	50                   	push   %eax
40002dfa:	e8 71 20 00 00       	call   40004e70 <_wcsrtombs_r>
40002dff:	83 c4 20             	add    $0x20,%esp
40002e02:	39 85 60 f9 ff ff    	cmp    %eax,-0x6a0(%ebp)
40002e08:	0f 85 1a ed ff ff    	jne    40001b28 <_vfprintf_r+0x568>
40002e0e:	8b 9d 60 f9 ff ff    	mov    -0x6a0(%ebp),%ebx
40002e14:	8b 8d 68 f9 ff ff    	mov    -0x698(%ebp),%ecx
40002e1a:	89 d8                	mov    %ebx,%eax
40002e1c:	83 f0 ff             	xor    $0xffffffff,%eax
40002e1f:	c6 04 19 00          	movb   $0x0,(%ecx,%ebx,1)
40002e23:	c1 f8 1f             	sar    $0x1f,%eax
40002e26:	89 8d 38 f9 ff ff    	mov    %ecx,-0x6c8(%ebp)
40002e2c:	21 c3                	and    %eax,%ebx
40002e2e:	c7 85 58 f9 ff ff 00 	movl   $0x0,-0x6a8(%ebp)
40002e35:	00 00 00 
40002e38:	89 9d 5c f9 ff ff    	mov    %ebx,-0x6a4(%ebp)
40002e3e:	e9 66 eb ff ff       	jmp    400019a9 <_vfprintf_r+0x3e9>
40002e43:	8b 45 b8             	mov    -0x48(%ebp),%eax
40002e46:	85 c0                	test   %eax,%eax
40002e48:	0f 85 84 04 00 00    	jne    400032d2 <_vfprintf_r+0x1d12>
40002e4e:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
40002e55:	e9 f5 ec ff ff       	jmp    40001b4f <_vfprintf_r+0x58f>
40002e5a:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002e5d:	8b 55 0c             	mov    0xc(%ebp),%edx
40002e60:	8b 45 08             	mov    0x8(%ebp),%eax
40002e63:	e8 18 e7 ff ff       	call   40001580 <__sprint_r>
40002e68:	85 c0                	test   %eax,%eax
40002e6a:	0f 85 c0 ec ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40002e70:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
40002e76:	e9 eb f3 ff ff       	jmp    40002266 <_vfprintf_r+0xca6>
40002e7b:	50                   	push   %eax
40002e7c:	50                   	push   %eax
40002e7d:	8b 85 74 f9 ff ff    	mov    -0x68c(%ebp),%eax
40002e83:	50                   	push   %eax
40002e84:	8b 85 70 f9 ff ff    	mov    -0x690(%ebp),%eax
40002e8a:	50                   	push   %eax
40002e8b:	e8 80 64 00 00       	call   40009310 <__isnand>
40002e90:	83 c4 10             	add    $0x10,%esp
40002e93:	85 c0                	test   %eax,%eax
40002e95:	0f 84 1a 02 00 00    	je     400030b5 <_vfprintf_r+0x1af5>
40002e9b:	8d 46 bb             	lea    -0x45(%esi),%eax
40002e9e:	83 f8 02             	cmp    $0x2,%eax
40002ea1:	0f 87 46 04 00 00    	ja     400032ed <_vfprintf_r+0x1d2d>
40002ea7:	c7 85 58 f9 ff ff 00 	movl   $0x0,-0x6a8(%ebp)
40002eae:	00 00 00 
40002eb1:	c7 85 60 f9 ff ff 03 	movl   $0x3,-0x6a0(%ebp)
40002eb8:	00 00 00 
40002ebb:	c7 85 68 f9 ff ff 00 	movl   $0x0,-0x698(%ebp)
40002ec2:	00 00 00 
40002ec5:	c7 85 38 f9 ff ff 51 	movl   $0x4000bc51,-0x6c8(%ebp)
40002ecc:	bc 00 40 
40002ecf:	c7 85 5c f9 ff ff 03 	movl   $0x3,-0x6a4(%ebp)
40002ed6:	00 00 00 
40002ed9:	e9 cb ea ff ff       	jmp    400019a9 <_vfprintf_r+0x3e9>
40002ede:	8b 8d 3c f9 ff ff    	mov    -0x6c4(%ebp),%ecx
40002ee4:	43                   	inc    %ebx
40002ee5:	83 c9 10             	or     $0x10,%ecx
40002ee8:	89 9d 34 f9 ff ff    	mov    %ebx,-0x6cc(%ebp)
40002eee:	89 8d 3c f9 ff ff    	mov    %ecx,-0x6c4(%ebp)
40002ef4:	8a 03                	mov    (%ebx),%al
40002ef6:	e9 db e7 ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
40002efb:	8b b5 3c f9 ff ff    	mov    -0x6c4(%ebp),%esi
40002f01:	41                   	inc    %ecx
40002f02:	81 ce 00 02 00 00    	or     $0x200,%esi
40002f08:	89 8d 34 f9 ff ff    	mov    %ecx,-0x6cc(%ebp)
40002f0e:	89 b5 3c f9 ff ff    	mov    %esi,-0x6c4(%ebp)
40002f14:	8a 01                	mov    (%ecx),%al
40002f16:	e9 bb e7 ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
40002f1b:	c7 85 78 f9 ff ff 06 	movl   $0x6,-0x688(%ebp)
40002f22:	00 00 00 
40002f25:	e9 da f1 ff ff       	jmp    40002104 <_vfprintf_r+0xb44>
40002f2a:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
40002f2d:	8b 55 b8             	mov    -0x48(%ebp),%edx
40002f30:	41                   	inc    %ecx
40002f31:	01 da                	add    %ebx,%edx
40002f33:	c7 00 00 be 00 40    	movl   $0x4000be00,(%eax)
40002f39:	89 58 04             	mov    %ebx,0x4(%eax)
40002f3c:	89 55 b8             	mov    %edx,-0x48(%ebp)
40002f3f:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40002f42:	83 f9 07             	cmp    $0x7,%ecx
40002f45:	0f 8f e4 f8 ff ff    	jg     4000282f <_vfprintf_r+0x126f>
40002f4b:	83 c0 08             	add    $0x8,%eax
40002f4e:	e9 f8 f8 ff ff       	jmp    4000284b <_vfprintf_r+0x128b>
40002f53:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
40002f56:	e9 d3 ea ff ff       	jmp    40001a2e <_vfprintf_r+0x46e>
40002f5b:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40002f5e:	8b 55 0c             	mov    0xc(%ebp),%edx
40002f61:	8b 45 08             	mov    0x8(%ebp),%eax
40002f64:	e8 17 e6 ff ff       	call   40001580 <__sprint_r>
40002f69:	85 c0                	test   %eax,%eax
40002f6b:	0f 85 bf eb ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40002f71:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
40002f77:	e9 2b f3 ff ff       	jmp    400022a7 <_vfprintf_r+0xce7>
40002f7c:	8b 75 b8             	mov    -0x48(%ebp),%esi
40002f7f:	41                   	inc    %ecx
40002f80:	46                   	inc    %esi
40002f81:	c7 07 88 bc 00 40    	movl   $0x4000bc88,(%edi)
40002f87:	c7 47 04 01 00 00 00 	movl   $0x1,0x4(%edi)
40002f8e:	89 75 b8             	mov    %esi,-0x48(%ebp)
40002f91:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40002f94:	8d 47 08             	lea    0x8(%edi),%eax
40002f97:	83 f9 07             	cmp    $0x7,%ecx
40002f9a:	0f 8f 91 03 00 00    	jg     40003331 <_vfprintf_r+0x1d71>
40002fa0:	8b 5d e0             	mov    -0x20(%ebp),%ebx
40002fa3:	85 db                	test   %ebx,%ebx
40002fa5:	75 0e                	jne    40002fb5 <_vfprintf_r+0x19f5>
40002fa7:	8b 8d 54 f9 ff ff    	mov    -0x6ac(%ebp),%ecx
40002fad:	85 c9                	test   %ecx,%ecx
40002faf:	0f 84 ab f3 ff ff    	je     40002360 <_vfprintf_r+0xda0>
40002fb5:	8b 55 b8             	mov    -0x48(%ebp),%edx
40002fb8:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
40002fbb:	42                   	inc    %edx
40002fbc:	41                   	inc    %ecx
40002fbd:	8b 9d 48 f9 ff ff    	mov    -0x6b8(%ebp),%ebx
40002fc3:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
40002fca:	89 18                	mov    %ebx,(%eax)
40002fcc:	89 55 b8             	mov    %edx,-0x48(%ebp)
40002fcf:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40002fd2:	83 f9 07             	cmp    $0x7,%ecx
40002fd5:	0f 8f 36 04 00 00    	jg     40003411 <_vfprintf_r+0x1e51>
40002fdb:	83 c0 08             	add    $0x8,%eax
40002fde:	8b 5d e0             	mov    -0x20(%ebp),%ebx
40002fe1:	f7 db                	neg    %ebx
40002fe3:	85 db                	test   %ebx,%ebx
40002fe5:	7f 0f                	jg     40002ff6 <_vfprintf_r+0x1a36>
40002fe7:	e9 96 02 00 00       	jmp    40003282 <_vfprintf_r+0x1cc2>
40002fec:	8d 74 26 00          	lea    0x0(%esi),%esi
40002ff0:	83 c0 08             	add    $0x8,%eax
40002ff3:	83 eb 10             	sub    $0x10,%ebx
40002ff6:	83 fb 10             	cmp    $0x10,%ebx
40002ff9:	0f 8e b4 02 00 00    	jle    400032b3 <_vfprintf_r+0x1cf3>
40002fff:	8b 7d b8             	mov    -0x48(%ebp),%edi
40003002:	41                   	inc    %ecx
40003003:	83 c7 10             	add    $0x10,%edi
40003006:	c7 00 00 be 00 40    	movl   $0x4000be00,(%eax)
4000300c:	c7 40 04 10 00 00 00 	movl   $0x10,0x4(%eax)
40003013:	89 7d b8             	mov    %edi,-0x48(%ebp)
40003016:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
40003019:	83 f9 07             	cmp    $0x7,%ecx
4000301c:	7e d2                	jle    40002ff0 <_vfprintf_r+0x1a30>
4000301e:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40003021:	8b 55 0c             	mov    0xc(%ebp),%edx
40003024:	8b 45 08             	mov    0x8(%ebp),%eax
40003027:	e8 54 e5 ff ff       	call   40001580 <__sprint_r>
4000302c:	85 c0                	test   %eax,%eax
4000302e:	0f 85 fc ea ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40003034:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
4000303a:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
4000303d:	eb b4                	jmp    40002ff3 <_vfprintf_r+0x1a33>
4000303f:	c7 85 60 f9 ff ff 06 	movl   $0x6,-0x6a0(%ebp)
40003046:	00 00 00 
40003049:	c7 85 38 f9 ff ff 8c 	movl   $0x4000bc8c,-0x6c8(%ebp)
40003050:	bc 00 40 
40003053:	c7 85 5c f9 ff ff 06 	movl   $0x6,-0x6a4(%ebp)
4000305a:	00 00 00 
4000305d:	e9 c9 e6 ff ff       	jmp    4000172b <_vfprintf_r+0x16b>
40003062:	83 ec 0c             	sub    $0xc,%esp
40003065:	8b 8d 38 f9 ff ff    	mov    -0x6c8(%ebp),%ecx
4000306b:	51                   	push   %ecx
4000306c:	e8 5b e2 ff ff       	call   400012cc <strlen>
40003071:	83 c4 10             	add    $0x10,%esp
40003074:	89 85 60 f9 ff ff    	mov    %eax,-0x6a0(%ebp)
4000307a:	89 85 5c f9 ff ff    	mov    %eax,-0x6a4(%ebp)
40003080:	83 f0 ff             	xor    $0xffffffff,%eax
40003083:	8b 95 5c f9 ff ff    	mov    -0x6a4(%ebp),%edx
40003089:	c7 85 58 f9 ff ff 00 	movl   $0x0,-0x6a8(%ebp)
40003090:	00 00 00 
40003093:	c1 f8 1f             	sar    $0x1f,%eax
40003096:	c7 85 68 f9 ff ff 00 	movl   $0x0,-0x698(%ebp)
4000309d:	00 00 00 
400030a0:	21 c2                	and    %eax,%edx
400030a2:	89 95 5c f9 ff ff    	mov    %edx,-0x6a4(%ebp)
400030a8:	e9 fc e8 ff ff       	jmp    400019a9 <_vfprintf_r+0x3e9>
400030ad:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
400030b0:	e9 09 f3 ff ff       	jmp    400023be <_vfprintf_r+0xdfe>
400030b5:	8b 85 3c f9 ff ff    	mov    -0x6c4(%ebp),%eax
400030bb:	80 cc 01             	or     $0x1,%ah
400030be:	83 fe 66             	cmp    $0x66,%esi
400030c1:	89 85 3c f9 ff ff    	mov    %eax,-0x6c4(%ebp)
400030c7:	0f 84 c3 03 00 00    	je     40003490 <_vfprintf_r+0x1ed0>
400030cd:	83 fe 65             	cmp    $0x65,%esi
400030d0:	0f 84 8a 03 00 00    	je     40003460 <_vfprintf_r+0x1ea0>
400030d6:	83 fe 45             	cmp    $0x45,%esi
400030d9:	0f 84 81 03 00 00    	je     40003460 <_vfprintf_r+0x1ea0>
400030df:	8b 9d 78 f9 ff ff    	mov    -0x688(%ebp),%ebx
400030e5:	b9 02 00 00 00       	mov    $0x2,%ecx
400030ea:	8b 95 74 f9 ff ff    	mov    -0x68c(%ebp),%edx
400030f0:	85 d2                	test   %edx,%edx
400030f2:	0f 88 8c 04 00 00    	js     40003584 <_vfprintf_r+0x1fc4>
400030f8:	dd 85 70 f9 ff ff    	fldl   -0x690(%ebp)
400030fe:	c6 85 4f f9 ff ff 00 	movb   $0x0,-0x6b1(%ebp)
40003105:	8d 45 d4             	lea    -0x2c(%ebp),%eax
40003108:	50                   	push   %eax
40003109:	8d 45 d8             	lea    -0x28(%ebp),%eax
4000310c:	50                   	push   %eax
4000310d:	8d 45 e0             	lea    -0x20(%ebp),%eax
40003110:	50                   	push   %eax
40003111:	53                   	push   %ebx
40003112:	51                   	push   %ecx
40003113:	83 ec 08             	sub    $0x8,%esp
40003116:	dd 14 24             	fstl   (%esp)
40003119:	8b 45 08             	mov    0x8(%ebp),%eax
4000311c:	50                   	push   %eax
4000311d:	dd 9d 18 f9 ff ff    	fstpl  -0x6e8(%ebp)
40003123:	e8 28 26 00 00       	call   40005750 <_dtoa_r>
40003128:	83 c4 20             	add    $0x20,%esp
4000312b:	89 85 38 f9 ff ff    	mov    %eax,-0x6c8(%ebp)
40003131:	83 fe 67             	cmp    $0x67,%esi
40003134:	dd 85 18 f9 ff ff    	fldl   -0x6e8(%ebp)
4000313a:	0f 84 ba 02 00 00    	je     400033fa <_vfprintf_r+0x1e3a>
40003140:	83 fe 47             	cmp    $0x47,%esi
40003143:	0f 84 b1 02 00 00    	je     400033fa <_vfprintf_r+0x1e3a>
40003149:	8b 8d 38 f9 ff ff    	mov    -0x6c8(%ebp),%ecx
4000314f:	01 d9                	add    %ebx,%ecx
40003151:	83 fe 66             	cmp    $0x66,%esi
40003154:	0f 84 11 04 00 00    	je     4000356b <_vfprintf_r+0x1fab>
4000315a:	d9 ee                	fldz   
4000315c:	d9 c9                	fxch   %st(1)
4000315e:	da e9                	fucompp 
40003160:	df e0                	fnstsw %ax
40003162:	80 e4 45             	and    $0x45,%ah
40003165:	80 f4 40             	xor    $0x40,%ah
40003168:	0f 85 03 03 00 00    	jne    40003471 <_vfprintf_r+0x1eb1>
4000316e:	89 c8                	mov    %ecx,%eax
40003170:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
40003173:	8b 95 38 f9 ff ff    	mov    -0x6c8(%ebp),%edx
40003179:	29 d0                	sub    %edx,%eax
4000317b:	83 fe 67             	cmp    $0x67,%esi
4000317e:	89 85 6c f9 ff ff    	mov    %eax,-0x694(%ebp)
40003184:	0f 94 c0             	sete   %al
40003187:	0f 84 49 02 00 00    	je     400033d6 <_vfprintf_r+0x1e16>
4000318d:	83 fe 47             	cmp    $0x47,%esi
40003190:	0f 84 40 02 00 00    	je     400033d6 <_vfprintf_r+0x1e16>
40003196:	83 fe 65             	cmp    $0x65,%esi
40003199:	0f 8f dc 01 00 00    	jg     4000337b <_vfprintf_r+0x1dbb>
4000319f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
400031a2:	89 f2                	mov    %esi,%edx
400031a4:	49                   	dec    %ecx
400031a5:	88 55 cd             	mov    %dl,-0x33(%ebp)
400031a8:	89 4d e0             	mov    %ecx,-0x20(%ebp)
400031ab:	85 c9                	test   %ecx,%ecx
400031ad:	0f 88 4e 04 00 00    	js     40003601 <_vfprintf_r+0x2041>
400031b3:	c6 45 ce 2b          	movb   $0x2b,-0x32(%ebp)
400031b7:	83 f9 09             	cmp    $0x9,%ecx
400031ba:	0f 8f 16 03 00 00    	jg     400034d6 <_vfprintf_r+0x1f16>
400031c0:	8d 41 30             	lea    0x30(%ecx),%eax
400031c3:	c6 45 cf 30          	movb   $0x30,-0x31(%ebp)
400031c7:	88 45 d0             	mov    %al,-0x30(%ebp)
400031ca:	8d 4d d1             	lea    -0x2f(%ebp),%ecx
400031cd:	8d 45 cd             	lea    -0x33(%ebp),%eax
400031d0:	8b 9d 6c f9 ff ff    	mov    -0x694(%ebp),%ebx
400031d6:	29 c1                	sub    %eax,%ecx
400031d8:	89 8d 50 f9 ff ff    	mov    %ecx,-0x6b0(%ebp)
400031de:	01 d9                	add    %ebx,%ecx
400031e0:	89 8d 60 f9 ff ff    	mov    %ecx,-0x6a0(%ebp)
400031e6:	83 bd 6c f9 ff ff 01 	cmpl   $0x1,-0x694(%ebp)
400031ed:	0f 8e 6d 04 00 00    	jle    40003660 <_vfprintf_r+0x20a0>
400031f3:	8b 8d 60 f9 ff ff    	mov    -0x6a0(%ebp),%ecx
400031f9:	41                   	inc    %ecx
400031fa:	89 8d 60 f9 ff ff    	mov    %ecx,-0x6a0(%ebp)
40003200:	8b 9d 60 f9 ff ff    	mov    -0x6a0(%ebp),%ebx
40003206:	89 9d 5c f9 ff ff    	mov    %ebx,-0x6a4(%ebp)
4000320c:	85 db                	test   %ebx,%ebx
4000320e:	0f 88 b3 01 00 00    	js     400033c7 <_vfprintf_r+0x1e07>
40003214:	80 bd 4f f9 ff ff 00 	cmpb   $0x0,-0x6b1(%ebp)
4000321b:	0f 85 31 01 00 00    	jne    40003352 <_vfprintf_r+0x1d92>
40003221:	8b 95 60 f9 ff ff    	mov    -0x6a0(%ebp),%edx
40003227:	8b 8d 6c f9 ff ff    	mov    -0x694(%ebp),%ecx
4000322d:	89 d0                	mov    %edx,%eax
4000322f:	89 8d 54 f9 ff ff    	mov    %ecx,-0x6ac(%ebp)
40003235:	83 f0 ff             	xor    $0xffffffff,%eax
40003238:	e9 4c fe ff ff       	jmp    40003089 <_vfprintf_r+0x1ac9>
4000323d:	c6 45 e7 2d          	movb   $0x2d,-0x19(%ebp)
40003241:	e9 19 ef ff ff       	jmp    4000215f <_vfprintf_r+0xb9f>
40003246:	8d 85 eb fe ff ff    	lea    -0x115(%ebp),%eax
4000324c:	8d 95 ec fe ff ff    	lea    -0x114(%ebp),%edx
40003252:	89 85 38 f9 ff ff    	mov    %eax,-0x6c8(%ebp)
40003258:	89 95 2c f9 ff ff    	mov    %edx,-0x6d4(%ebp)
4000325e:	e9 bb f4 ff ff       	jmp    4000271e <_vfprintf_r+0x115e>
40003263:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40003266:	8b 55 0c             	mov    0xc(%ebp),%edx
40003269:	8b 45 08             	mov    0x8(%ebp),%eax
4000326c:	e8 0f e3 ff ff       	call   40001580 <__sprint_r>
40003271:	85 c0                	test   %eax,%eax
40003273:	0f 85 b7 e8 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40003279:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
4000327f:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
40003282:	8b 95 38 f9 ff ff    	mov    -0x6c8(%ebp),%edx
40003288:	8b 9d 54 f9 ff ff    	mov    -0x6ac(%ebp),%ebx
4000328e:	89 10                	mov    %edx,(%eax)
40003290:	e9 84 f7 ff ff       	jmp    40002a19 <_vfprintf_r+0x1459>
40003295:	8b 5d 14             	mov    0x14(%ebp),%ebx
40003298:	8b 55 14             	mov    0x14(%ebp),%edx
4000329b:	83 c3 04             	add    $0x4,%ebx
4000329e:	8b 8d 40 f9 ff ff    	mov    -0x6c0(%ebp),%ecx
400032a4:	89 9d 7c f9 ff ff    	mov    %ebx,-0x684(%ebp)
400032aa:	8b 02                	mov    (%edx),%eax
400032ac:	89 08                	mov    %ecx,(%eax)
400032ae:	e9 32 eb ff ff       	jmp    40001de5 <_vfprintf_r+0x825>
400032b3:	8b 75 b8             	mov    -0x48(%ebp),%esi
400032b6:	41                   	inc    %ecx
400032b7:	01 de                	add    %ebx,%esi
400032b9:	c7 00 00 be 00 40    	movl   $0x4000be00,(%eax)
400032bf:	89 58 04             	mov    %ebx,0x4(%eax)
400032c2:	89 75 b8             	mov    %esi,-0x48(%ebp)
400032c5:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
400032c8:	83 f9 07             	cmp    $0x7,%ecx
400032cb:	7f 96                	jg     40003263 <_vfprintf_r+0x1ca3>
400032cd:	83 c0 08             	add    $0x8,%eax
400032d0:	eb b0                	jmp    40003282 <_vfprintf_r+0x1cc2>
400032d2:	8d 4d b0             	lea    -0x50(%ebp),%ecx
400032d5:	8b 55 0c             	mov    0xc(%ebp),%edx
400032d8:	8b 45 08             	mov    0x8(%ebp),%eax
400032db:	e8 a0 e2 ff ff       	call   40001580 <__sprint_r>
400032e0:	85 c0                	test   %eax,%eax
400032e2:	0f 85 67 e8 ff ff    	jne    40001b4f <_vfprintf_r+0x58f>
400032e8:	e9 61 fb ff ff       	jmp    40002e4e <_vfprintf_r+0x188e>
400032ed:	c7 85 58 f9 ff ff 00 	movl   $0x0,-0x6a8(%ebp)
400032f4:	00 00 00 
400032f7:	c7 85 60 f9 ff ff 03 	movl   $0x3,-0x6a0(%ebp)
400032fe:	00 00 00 
40003301:	c7 85 68 f9 ff ff 00 	movl   $0x0,-0x698(%ebp)
40003308:	00 00 00 
4000330b:	c7 85 38 f9 ff ff 55 	movl   $0x4000bc55,-0x6c8(%ebp)
40003312:	bc 00 40 
40003315:	c7 85 5c f9 ff ff 03 	movl   $0x3,-0x6a4(%ebp)
4000331c:	00 00 00 
4000331f:	e9 85 e6 ff ff       	jmp    400019a9 <_vfprintf_r+0x3e9>
40003324:	8b 55 0c             	mov    0xc(%ebp),%edx
40003327:	66 83 4a 0c 40       	orw    $0x40,0xc(%edx)
4000332c:	e9 1e e8 ff ff       	jmp    40001b4f <_vfprintf_r+0x58f>
40003331:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40003334:	8b 55 0c             	mov    0xc(%ebp),%edx
40003337:	8b 45 08             	mov    0x8(%ebp),%eax
4000333a:	e8 41 e2 ff ff       	call   40001580 <__sprint_r>
4000333f:	85 c0                	test   %eax,%eax
40003341:	0f 85 e9 e7 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40003347:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
4000334d:	e9 4e fc ff ff       	jmp    40002fa0 <_vfprintf_r+0x19e0>
40003352:	8b 9d 6c f9 ff ff    	mov    -0x694(%ebp),%ebx
40003358:	c6 45 e7 2d          	movb   $0x2d,-0x19(%ebp)
4000335c:	89 9d 54 f9 ff ff    	mov    %ebx,-0x6ac(%ebp)
40003362:	c7 85 58 f9 ff ff 00 	movl   $0x0,-0x6a8(%ebp)
40003369:	00 00 00 
4000336c:	c7 85 68 f9 ff ff 00 	movl   $0x0,-0x698(%ebp)
40003373:	00 00 00 
40003376:	e9 38 e6 ff ff       	jmp    400019b3 <_vfprintf_r+0x3f3>
4000337b:	83 fe 66             	cmp    $0x66,%esi
4000337e:	0f 84 88 02 00 00    	je     4000360c <_vfprintf_r+0x204c>
40003384:	8b 5d e0             	mov    -0x20(%ebp),%ebx
40003387:	89 9d 60 f9 ff ff    	mov    %ebx,-0x6a0(%ebp)
4000338d:	39 9d 6c f9 ff ff    	cmp    %ebx,-0x694(%ebp)
40003393:	0f 8f ff 01 00 00    	jg     40003598 <_vfprintf_r+0x1fd8>
40003399:	f6 85 3c f9 ff ff 01 	testb  $0x1,-0x6c4(%ebp)
400033a0:	0f 84 60 fe ff ff    	je     40003206 <_vfprintf_r+0x1c46>
400033a6:	8b 8d 60 f9 ff ff    	mov    -0x6a0(%ebp),%ecx
400033ac:	41                   	inc    %ecx
400033ad:	89 8d 60 f9 ff ff    	mov    %ecx,-0x6a0(%ebp)
400033b3:	8b 85 60 f9 ff ff    	mov    -0x6a0(%ebp),%eax
400033b9:	89 85 5c f9 ff ff    	mov    %eax,-0x6a4(%ebp)
400033bf:	85 c0                	test   %eax,%eax
400033c1:	0f 89 4d fe ff ff    	jns    40003214 <_vfprintf_r+0x1c54>
400033c7:	c7 85 5c f9 ff ff 00 	movl   $0x0,-0x6a4(%ebp)
400033ce:	00 00 00 
400033d1:	e9 3e fe ff ff       	jmp    40003214 <_vfprintf_r+0x1c54>
400033d6:	8b 5d e0             	mov    -0x20(%ebp),%ebx
400033d9:	83 fb fc             	cmp    $0xfffffffc,%ebx
400033dc:	7e 0d                	jle    400033eb <_vfprintf_r+0x1e2b>
400033de:	be 67 00 00 00       	mov    $0x67,%esi
400033e3:	39 9d 78 f9 ff ff    	cmp    %ebx,-0x688(%ebp)
400033e9:	7d 9c                	jge    40003387 <_vfprintf_r+0x1dc7>
400033eb:	3c 01                	cmp    $0x1,%al
400033ed:	19 f6                	sbb    %esi,%esi
400033ef:	83 e6 e0             	and    $0xffffffe0,%esi
400033f2:	83 c6 65             	add    $0x65,%esi
400033f5:	e9 a5 fd ff ff       	jmp    4000319f <_vfprintf_r+0x1bdf>
400033fa:	f6 85 3c f9 ff ff 01 	testb  $0x1,-0x6c4(%ebp)
40003401:	0f 85 42 fd ff ff    	jne    40003149 <_vfprintf_r+0x1b89>
40003407:	dd d8                	fstp   %st(0)
40003409:	8b 45 d4             	mov    -0x2c(%ebp),%eax
4000340c:	e9 62 fd ff ff       	jmp    40003173 <_vfprintf_r+0x1bb3>
40003411:	8d 4d b0             	lea    -0x50(%ebp),%ecx
40003414:	8b 55 0c             	mov    0xc(%ebp),%edx
40003417:	8b 45 08             	mov    0x8(%ebp),%eax
4000341a:	e8 61 e1 ff ff       	call   40001580 <__sprint_r>
4000341f:	85 c0                	test   %eax,%eax
40003421:	0f 85 09 e7 ff ff    	jne    40001b30 <_vfprintf_r+0x570>
40003427:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
4000342d:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
40003430:	e9 a9 fb ff ff       	jmp    40002fde <_vfprintf_r+0x1a1e>
40003435:	8b 85 78 f9 ff ff    	mov    -0x688(%ebp),%eax
4000343b:	c7 85 58 f9 ff ff 00 	movl   $0x0,-0x6a8(%ebp)
40003442:	00 00 00 
40003445:	89 85 5c f9 ff ff    	mov    %eax,-0x6a4(%ebp)
4000344b:	89 85 60 f9 ff ff    	mov    %eax,-0x6a0(%ebp)
40003451:	c7 85 68 f9 ff ff 00 	movl   $0x0,-0x698(%ebp)
40003458:	00 00 00 
4000345b:	e9 49 e5 ff ff       	jmp    400019a9 <_vfprintf_r+0x3e9>
40003460:	8b 9d 78 f9 ff ff    	mov    -0x688(%ebp),%ebx
40003466:	b9 02 00 00 00       	mov    $0x2,%ecx
4000346b:	43                   	inc    %ebx
4000346c:	e9 79 fc ff ff       	jmp    400030ea <_vfprintf_r+0x1b2a>
40003471:	8b 45 d4             	mov    -0x2c(%ebp),%eax
40003474:	89 c2                	mov    %eax,%edx
40003476:	39 c1                	cmp    %eax,%ecx
40003478:	0f 86 f5 fc ff ff    	jbe    40003173 <_vfprintf_r+0x1bb3>
4000347e:	c6 02 30             	movb   $0x30,(%edx)
40003481:	42                   	inc    %edx
40003482:	89 d0                	mov    %edx,%eax
40003484:	89 55 d4             	mov    %edx,-0x2c(%ebp)
40003487:	39 ca                	cmp    %ecx,%edx
40003489:	75 f3                	jne    4000347e <_vfprintf_r+0x1ebe>
4000348b:	e9 e3 fc ff ff       	jmp    40003173 <_vfprintf_r+0x1bb3>
40003490:	8b 9d 78 f9 ff ff    	mov    -0x688(%ebp),%ebx
40003496:	b9 03 00 00 00       	mov    $0x3,%ecx
4000349b:	e9 4a fc ff ff       	jmp    400030ea <_vfprintf_r+0x1b2a>
400034a0:	83 ec 0c             	sub    $0xc,%esp
400034a3:	8d 45 dc             	lea    -0x24(%ebp),%eax
400034a6:	8d 5d bc             	lea    -0x44(%ebp),%ebx
400034a9:	53                   	push   %ebx
400034aa:	6a 00                	push   $0x0
400034ac:	50                   	push   %eax
400034ad:	6a 00                	push   $0x0
400034af:	8b 45 08             	mov    0x8(%ebp),%eax
400034b2:	50                   	push   %eax
400034b3:	e8 b8 19 00 00       	call   40004e70 <_wcsrtombs_r>
400034b8:	83 c4 20             	add    $0x20,%esp
400034bb:	89 85 60 f9 ff ff    	mov    %eax,-0x6a0(%ebp)
400034c1:	40                   	inc    %eax
400034c2:	0f 84 35 02 00 00    	je     400036fd <_vfprintf_r+0x213d>
400034c8:	8b 95 38 f9 ff ff    	mov    -0x6c8(%ebp),%edx
400034ce:	89 55 dc             	mov    %edx,-0x24(%ebp)
400034d1:	e9 9c eb ff ff       	jmp    40002072 <_vfprintf_r+0xab2>
400034d6:	8d 5d b0             	lea    -0x50(%ebp),%ebx
400034d9:	89 9d f4 f8 ff ff    	mov    %ebx,-0x70c(%ebp)
400034df:	8b 85 f4 f8 ff ff    	mov    -0x70c(%ebp),%eax
400034e5:	89 ca                	mov    %ecx,%edx
400034e7:	48                   	dec    %eax
400034e8:	bb 0a 00 00 00       	mov    $0xa,%ebx
400034ed:	c1 fa 1f             	sar    $0x1f,%edx
400034f0:	89 85 f4 f8 ff ff    	mov    %eax,-0x70c(%ebp)
400034f6:	89 c8                	mov    %ecx,%eax
400034f8:	f7 fb                	idiv   %ebx
400034fa:	89 95 04 f9 ff ff    	mov    %edx,-0x6fc(%ebp)
40003500:	8b 85 f4 f8 ff ff    	mov    -0x70c(%ebp),%eax
40003506:	8a 95 04 f9 ff ff    	mov    -0x6fc(%ebp),%dl
4000350c:	83 c2 30             	add    $0x30,%edx
4000350f:	88 10                	mov    %dl,(%eax)
40003511:	89 c8                	mov    %ecx,%eax
40003513:	ba 67 66 66 66       	mov    $0x66666667,%edx
40003518:	f7 ea                	imul   %edx
4000351a:	c1 fa 02             	sar    $0x2,%edx
4000351d:	89 c8                	mov    %ecx,%eax
4000351f:	c1 f8 1f             	sar    $0x1f,%eax
40003522:	89 d1                	mov    %edx,%ecx
40003524:	29 c1                	sub    %eax,%ecx
40003526:	83 f9 09             	cmp    $0x9,%ecx
40003529:	7f b4                	jg     400034df <_vfprintf_r+0x1f1f>
4000352b:	8d 51 30             	lea    0x30(%ecx),%edx
4000352e:	8b 8d f4 f8 ff ff    	mov    -0x70c(%ebp),%ecx
40003534:	8b 85 f4 f8 ff ff    	mov    -0x70c(%ebp),%eax
4000353a:	48                   	dec    %eax
4000353b:	88 51 ff             	mov    %dl,-0x1(%ecx)
4000353e:	39 85 14 f9 ff ff    	cmp    %eax,-0x6ec(%ebp)
40003544:	8d 4d cf             	lea    -0x31(%ebp),%ecx
40003547:	0f 86 80 fc ff ff    	jbe    400031cd <_vfprintf_r+0x1c0d>
4000354d:	8b 85 f4 f8 ff ff    	mov    -0x70c(%ebp),%eax
40003553:	8d 4d cf             	lea    -0x31(%ebp),%ecx
40003556:	eb 03                	jmp    4000355b <_vfprintf_r+0x1f9b>
40003558:	8a 10                	mov    (%eax),%dl
4000355a:	40                   	inc    %eax
4000355b:	88 11                	mov    %dl,(%ecx)
4000355d:	41                   	inc    %ecx
4000355e:	39 85 14 f9 ff ff    	cmp    %eax,-0x6ec(%ebp)
40003564:	77 f2                	ja     40003558 <_vfprintf_r+0x1f98>
40003566:	e9 62 fc ff ff       	jmp    400031cd <_vfprintf_r+0x1c0d>
4000356b:	8b 85 38 f9 ff ff    	mov    -0x6c8(%ebp),%eax
40003571:	80 38 30             	cmpb   $0x30,(%eax)
40003574:	0f 84 f4 00 00 00    	je     4000366e <_vfprintf_r+0x20ae>
4000357a:	8b 5d e0             	mov    -0x20(%ebp),%ebx
4000357d:	01 d9                	add    %ebx,%ecx
4000357f:	e9 d6 fb ff ff       	jmp    4000315a <_vfprintf_r+0x1b9a>
40003584:	dd 85 70 f9 ff ff    	fldl   -0x690(%ebp)
4000358a:	d9 e0                	fchs   
4000358c:	c6 85 4f f9 ff ff 2d 	movb   $0x2d,-0x6b1(%ebp)
40003593:	e9 6d fb ff ff       	jmp    40003105 <_vfprintf_r+0x1b45>
40003598:	8b 95 60 f9 ff ff    	mov    -0x6a0(%ebp),%edx
4000359e:	b8 01 00 00 00       	mov    $0x1,%eax
400035a3:	85 d2                	test   %edx,%edx
400035a5:	0f 8e 14 01 00 00    	jle    400036bf <_vfprintf_r+0x20ff>
400035ab:	8b 8d 6c f9 ff ff    	mov    -0x694(%ebp),%ecx
400035b1:	01 c8                	add    %ecx,%eax
400035b3:	89 85 5c f9 ff ff    	mov    %eax,-0x6a4(%ebp)
400035b9:	89 85 60 f9 ff ff    	mov    %eax,-0x6a0(%ebp)
400035bf:	83 f0 ff             	xor    $0xffffffff,%eax
400035c2:	8b 95 5c f9 ff ff    	mov    -0x6a4(%ebp),%edx
400035c8:	c1 f8 1f             	sar    $0x1f,%eax
400035cb:	21 c2                	and    %eax,%edx
400035cd:	89 95 5c f9 ff ff    	mov    %edx,-0x6a4(%ebp)
400035d3:	e9 3c fc ff ff       	jmp    40003214 <_vfprintf_r+0x1c54>
400035d8:	8b 45 14             	mov    0x14(%ebp),%eax
400035db:	8b 55 14             	mov    0x14(%ebp),%edx
400035de:	83 c2 04             	add    $0x4,%edx
400035e1:	8b 00                	mov    (%eax),%eax
400035e3:	89 85 78 f9 ff ff    	mov    %eax,-0x688(%ebp)
400035e9:	85 c0                	test   %eax,%eax
400035eb:	0f 88 19 01 00 00    	js     4000370a <_vfprintf_r+0x214a>
400035f1:	8b 8d 34 f9 ff ff    	mov    -0x6cc(%ebp),%ecx
400035f7:	8a 01                	mov    (%ecx),%al
400035f9:	89 55 14             	mov    %edx,0x14(%ebp)
400035fc:	e9 d5 e0 ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
40003601:	f7 d9                	neg    %ecx
40003603:	c6 45 ce 2d          	movb   $0x2d,-0x32(%ebp)
40003607:	e9 ab fb ff ff       	jmp    400031b7 <_vfprintf_r+0x1bf7>
4000360c:	8b 45 e0             	mov    -0x20(%ebp),%eax
4000360f:	89 85 60 f9 ff ff    	mov    %eax,-0x6a0(%ebp)
40003615:	85 c0                	test   %eax,%eax
40003617:	7e 7a                	jle    40003693 <_vfprintf_r+0x20d3>
40003619:	8b 95 78 f9 ff ff    	mov    -0x688(%ebp),%edx
4000361f:	85 d2                	test   %edx,%edx
40003621:	75 13                	jne    40003636 <_vfprintf_r+0x2076>
40003623:	89 85 5c f9 ff ff    	mov    %eax,-0x6a4(%ebp)
40003629:	f6 85 3c f9 ff ff 01 	testb  $0x1,-0x6c4(%ebp)
40003630:	0f 84 de fb ff ff    	je     40003214 <_vfprintf_r+0x1c54>
40003636:	8b 8d 60 f9 ff ff    	mov    -0x6a0(%ebp),%ecx
4000363c:	8b 95 78 f9 ff ff    	mov    -0x688(%ebp),%edx
40003642:	8d 4c 0a 01          	lea    0x1(%edx,%ecx,1),%ecx
40003646:	89 8d 60 f9 ff ff    	mov    %ecx,-0x6a0(%ebp)
4000364c:	89 8d 5c f9 ff ff    	mov    %ecx,-0x6a4(%ebp)
40003652:	85 c9                	test   %ecx,%ecx
40003654:	0f 89 ba fb ff ff    	jns    40003214 <_vfprintf_r+0x1c54>
4000365a:	e9 68 fd ff ff       	jmp    400033c7 <_vfprintf_r+0x1e07>
4000365f:	90                   	nop    
40003660:	f6 85 3c f9 ff ff 01 	testb  $0x1,-0x6c4(%ebp)
40003667:	74 e3                	je     4000364c <_vfprintf_r+0x208c>
40003669:	e9 85 fb ff ff       	jmp    400031f3 <_vfprintf_r+0x1c33>
4000366e:	d9 ee                	fldz   
40003670:	d9 c9                	fxch   %st(1)
40003672:	dd e1                	fucom  %st(1)
40003674:	df e0                	fnstsw %ax
40003676:	dd d9                	fstp   %st(1)
40003678:	80 e4 45             	and    $0x45,%ah
4000367b:	80 fc 40             	cmp    $0x40,%ah
4000367e:	0f 84 f6 fe ff ff    	je     4000357a <_vfprintf_r+0x1fba>
40003684:	b8 01 00 00 00       	mov    $0x1,%eax
40003689:	29 d8                	sub    %ebx,%eax
4000368b:	89 45 e0             	mov    %eax,-0x20(%ebp)
4000368e:	e9 e7 fe ff ff       	jmp    4000357a <_vfprintf_r+0x1fba>
40003693:	8b 9d 78 f9 ff ff    	mov    -0x688(%ebp),%ebx
40003699:	85 db                	test   %ebx,%ebx
4000369b:	75 31                	jne    400036ce <_vfprintf_r+0x210e>
4000369d:	f6 85 3c f9 ff ff 01 	testb  $0x1,-0x6c4(%ebp)
400036a4:	75 28                	jne    400036ce <_vfprintf_r+0x210e>
400036a6:	c7 85 60 f9 ff ff 01 	movl   $0x1,-0x6a0(%ebp)
400036ad:	00 00 00 
400036b0:	c7 85 5c f9 ff ff 01 	movl   $0x1,-0x6a4(%ebp)
400036b7:	00 00 00 
400036ba:	e9 55 fb ff ff       	jmp    40003214 <_vfprintf_r+0x1c54>
400036bf:	b0 02                	mov    $0x2,%al
400036c1:	8b 9d 60 f9 ff ff    	mov    -0x6a0(%ebp),%ebx
400036c7:	29 d8                	sub    %ebx,%eax
400036c9:	e9 dd fe ff ff       	jmp    400035ab <_vfprintf_r+0x1feb>
400036ce:	8b 9d 78 f9 ff ff    	mov    -0x688(%ebp),%ebx
400036d4:	83 c3 02             	add    $0x2,%ebx
400036d7:	89 9d 60 f9 ff ff    	mov    %ebx,-0x6a0(%ebp)
400036dd:	89 9d 5c f9 ff ff    	mov    %ebx,-0x6a4(%ebp)
400036e3:	85 db                	test   %ebx,%ebx
400036e5:	0f 89 29 fb ff ff    	jns    40003214 <_vfprintf_r+0x1c54>
400036eb:	e9 d7 fc ff ff       	jmp    400033c7 <_vfprintf_r+0x1e07>
400036f0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
400036f3:	66 83 49 0c 40       	orw    $0x40,0xc(%ecx)
400036f8:	e9 52 e4 ff ff       	jmp    40001b4f <_vfprintf_r+0x58f>
400036fd:	8b 45 0c             	mov    0xc(%ebp),%eax
40003700:	66 83 48 0c 40       	orw    $0x40,0xc(%eax)
40003705:	e9 45 e4 ff ff       	jmp    40001b4f <_vfprintf_r+0x58f>
4000370a:	8b 9d 34 f9 ff ff    	mov    -0x6cc(%ebp),%ebx
40003710:	8a 03                	mov    (%ebx),%al
40003712:	89 55 14             	mov    %edx,0x14(%ebp)
40003715:	c7 85 78 f9 ff ff ff 	movl   $0xffffffff,-0x688(%ebp)
4000371c:	ff ff ff 
4000371f:	e9 b2 df ff ff       	jmp    400016d6 <_vfprintf_r+0x116>
40003724:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000372a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

40003730 <vfprintf>:
40003730:	55                   	push   %ebp
40003731:	89 e5                	mov    %esp,%ebp
40003733:	83 ec 08             	sub    $0x8,%esp
40003736:	8b 45 10             	mov    0x10(%ebp),%eax
40003739:	50                   	push   %eax
4000373a:	8b 45 0c             	mov    0xc(%ebp),%eax
4000373d:	50                   	push   %eax
4000373e:	8b 45 08             	mov    0x8(%ebp),%eax
40003741:	50                   	push   %eax
40003742:	a1 60 d0 00 40       	mov    0x4000d060,%eax
40003747:	50                   	push   %eax
40003748:	e8 73 de ff ff       	call   400015c0 <_vfprintf_r>
4000374d:	c9                   	leave  
4000374e:	c3                   	ret    
4000374f:	90                   	nop    

40003750 <__svfscanf_r>:
40003750:	55                   	push   %ebp
40003751:	89 e5                	mov    %esp,%ebp
40003753:	57                   	push   %edi
40003754:	56                   	push   %esi
40003755:	53                   	push   %ebx
40003756:	81 ec 2c 03 00 00    	sub    $0x32c,%esp
4000375c:	8d 85 d1 fe ff ff    	lea    -0x12f(%ebp),%eax
40003762:	8b 5d 0c             	mov    0xc(%ebp),%ebx
40003765:	8b 7d 10             	mov    0x10(%ebp),%edi
40003768:	c7 85 fc fc ff ff 00 	movl   $0x0,-0x304(%ebp)
4000376f:	00 00 00 
40003772:	31 f6                	xor    %esi,%esi
40003774:	c7 85 00 fd ff ff 00 	movl   $0x0,-0x300(%ebp)
4000377b:	00 00 00 
4000377e:	c7 85 08 fd ff ff 00 	movl   $0x0,-0x2f8(%ebp)
40003785:	00 00 00 
40003788:	89 85 d0 fc ff ff    	mov    %eax,-0x330(%ebp)
4000378e:	8a 07                	mov    (%edi),%al
40003790:	0f be c8             	movsbl %al,%ecx
40003793:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
40003796:	84 c0                	test   %al,%al
40003798:	74 4b                	je     400037e5 <__svfscanf_r+0x95>
4000379a:	8b 15 90 d8 00 40    	mov    0x4000d890,%edx
400037a0:	47                   	inc    %edi
400037a1:	f6 04 0a 08          	testb  $0x8,(%edx,%ecx,1)
400037a5:	0f 85 85 00 00 00    	jne    40003830 <__svfscanf_r+0xe0>
400037ab:	3c 25                	cmp    $0x25,%al
400037ad:	0f 84 b6 00 00 00    	je     40003869 <__svfscanf_r+0x119>
400037b3:	8b 53 04             	mov    0x4(%ebx),%edx
400037b6:	85 d2                	test   %edx,%edx
400037b8:	0f 8e 7b 00 00 00    	jle    40003839 <__svfscanf_r+0xe9>
400037be:	8b 03                	mov    (%ebx),%eax
400037c0:	31 d2                	xor    %edx,%edx
400037c2:	8a 10                	mov    (%eax),%dl
400037c4:	0f be 47 ff          	movsbl -0x1(%edi),%eax
400037c8:	39 c2                	cmp    %eax,%edx
400037ca:	75 19                	jne    400037e5 <__svfscanf_r+0x95>
400037cc:	8b 43 04             	mov    0x4(%ebx),%eax
400037cf:	46                   	inc    %esi
400037d0:	48                   	dec    %eax
400037d1:	89 43 04             	mov    %eax,0x4(%ebx)
400037d4:	8b 03                	mov    (%ebx),%eax
400037d6:	40                   	inc    %eax
400037d7:	89 03                	mov    %eax,(%ebx)
400037d9:	8a 07                	mov    (%edi),%al
400037db:	0f be c8             	movsbl %al,%ecx
400037de:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
400037e1:	84 c0                	test   %al,%al
400037e3:	75 b5                	jne    4000379a <__svfscanf_r+0x4a>
400037e5:	8b 85 fc fc ff ff    	mov    -0x304(%ebp),%eax
400037eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
400037ee:	5b                   	pop    %ebx
400037ef:	5e                   	pop    %esi
400037f0:	5f                   	pop    %edi
400037f1:	5d                   	pop    %ebp
400037f2:	c3                   	ret    
400037f3:	50                   	push   %eax
400037f4:	50                   	push   %eax
400037f5:	8b 45 08             	mov    0x8(%ebp),%eax
400037f8:	53                   	push   %ebx
400037f9:	50                   	push   %eax
400037fa:	e8 21 59 00 00       	call   40009120 <__srefill_r>
400037ff:	83 c4 10             	add    $0x10,%esp
40003802:	85 c0                	test   %eax,%eax
40003804:	75 88                	jne    4000378e <__svfscanf_r+0x3e>
40003806:	8b 15 90 d8 00 40    	mov    0x4000d890,%edx
4000380c:	8d 74 26 00          	lea    0x0(%esi),%esi
40003810:	8b 03                	mov    (%ebx),%eax
40003812:	8a 00                	mov    (%eax),%al
40003814:	25 ff 00 00 00       	and    $0xff,%eax
40003819:	f6 04 10 08          	testb  $0x8,(%eax,%edx,1)
4000381d:	0f 84 6b ff ff ff    	je     4000378e <__svfscanf_r+0x3e>
40003823:	8b 43 04             	mov    0x4(%ebx),%eax
40003826:	8b 0b                	mov    (%ebx),%ecx
40003828:	48                   	dec    %eax
40003829:	41                   	inc    %ecx
4000382a:	46                   	inc    %esi
4000382b:	89 43 04             	mov    %eax,0x4(%ebx)
4000382e:	89 0b                	mov    %ecx,(%ebx)
40003830:	8b 43 04             	mov    0x4(%ebx),%eax
40003833:	85 c0                	test   %eax,%eax
40003835:	7f d9                	jg     40003810 <__svfscanf_r+0xc0>
40003837:	eb ba                	jmp    400037f3 <__svfscanf_r+0xa3>
40003839:	50                   	push   %eax
4000383a:	50                   	push   %eax
4000383b:	8b 45 08             	mov    0x8(%ebp),%eax
4000383e:	53                   	push   %ebx
4000383f:	50                   	push   %eax
40003840:	e8 db 58 00 00       	call   40009120 <__srefill_r>
40003845:	83 c4 10             	add    $0x10,%esp
40003848:	85 c0                	test   %eax,%eax
4000384a:	0f 84 6e ff ff ff    	je     400037be <__svfscanf_r+0x6e>
40003850:	8b 85 fc fc ff ff    	mov    -0x304(%ebp),%eax
40003856:	85 c0                	test   %eax,%eax
40003858:	75 8b                	jne    400037e5 <__svfscanf_r+0x95>
4000385a:	c7 85 fc fc ff ff ff 	movl   $0xffffffff,-0x304(%ebp)
40003861:	ff ff ff 
40003864:	e9 7c ff ff ff       	jmp    400037e5 <__svfscanf_r+0x95>
40003869:	8a 07                	mov    (%edi),%al
4000386b:	c7 85 ec fc ff ff 00 	movl   $0x0,-0x314(%ebp)
40003872:	00 00 00 
40003875:	c7 85 f8 fc ff ff 00 	movl   $0x0,-0x308(%ebp)
4000387c:	00 00 00 
4000387f:	47                   	inc    %edi
40003880:	3c 78                	cmp    $0x78,%al
40003882:	0f be c8             	movsbl %al,%ecx
40003885:	0f 86 cc 00 00 00    	jbe    40003957 <__svfscanf_r+0x207>
4000388b:	f6 04 0a 01          	testb  $0x1,(%edx,%ecx,1)
4000388f:	74 0f                	je     400038a0 <__svfscanf_r+0x150>
40003891:	8b 95 f8 fc ff ff    	mov    -0x308(%ebp),%edx
40003897:	83 ca 01             	or     $0x1,%edx
4000389a:	89 95 f8 fc ff ff    	mov    %edx,-0x308(%ebp)
400038a0:	c7 85 08 fd ff ff f0 	movl   $0x4000a7f0,-0x2f8(%ebp)
400038a7:	a7 00 40 
400038aa:	c7 85 e8 fc ff ff 03 	movl   $0x3,-0x318(%ebp)
400038b1:	00 00 00 
400038b4:	c7 85 00 fd ff ff 0a 	movl   $0xa,-0x300(%ebp)
400038bb:	00 00 00 
400038be:	8b 43 04             	mov    0x4(%ebx),%eax
400038c1:	85 c0                	test   %eax,%eax
400038c3:	0f 8e eb 0f 00 00    	jle    400048b4 <__svfscanf_r+0x1164>
400038c9:	f6 85 f8 fc ff ff 40 	testb  $0x40,-0x308(%ebp)
400038d0:	75 6b                	jne    4000393d <__svfscanf_r+0x1ed>
400038d2:	8b 03                	mov    (%ebx),%eax
400038d4:	8b 15 90 d8 00 40    	mov    0x4000d890,%edx
400038da:	8a 00                	mov    (%eax),%al
400038dc:	25 ff 00 00 00       	and    $0xff,%eax
400038e1:	f6 04 10 08          	testb  $0x8,(%eax,%edx,1)
400038e5:	75 1e                	jne    40003905 <__svfscanf_r+0x1b5>
400038e7:	eb 54                	jmp    4000393d <__svfscanf_r+0x1ed>
400038e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
400038f0:	8b 03                	mov    (%ebx),%eax
400038f2:	46                   	inc    %esi
400038f3:	40                   	inc    %eax
400038f4:	89 03                	mov    %eax,(%ebx)
400038f6:	8b 03                	mov    (%ebx),%eax
400038f8:	8a 00                	mov    (%eax),%al
400038fa:	25 ff 00 00 00       	and    $0xff,%eax
400038ff:	f6 04 10 08          	testb  $0x8,(%eax,%edx,1)
40003903:	74 38                	je     4000393d <__svfscanf_r+0x1ed>
40003905:	8b 43 04             	mov    0x4(%ebx),%eax
40003908:	48                   	dec    %eax
40003909:	89 43 04             	mov    %eax,0x4(%ebx)
4000390c:	85 c0                	test   %eax,%eax
4000390e:	7f e0                	jg     400038f0 <__svfscanf_r+0x1a0>
40003910:	50                   	push   %eax
40003911:	50                   	push   %eax
40003912:	8b 45 08             	mov    0x8(%ebp),%eax
40003915:	53                   	push   %ebx
40003916:	50                   	push   %eax
40003917:	e8 04 58 00 00       	call   40009120 <__srefill_r>
4000391c:	83 c4 10             	add    $0x10,%esp
4000391f:	85 c0                	test   %eax,%eax
40003921:	0f 85 29 ff ff ff    	jne    40003850 <__svfscanf_r+0x100>
40003927:	8b 15 90 d8 00 40    	mov    0x4000d890,%edx
4000392d:	46                   	inc    %esi
4000392e:	8b 03                	mov    (%ebx),%eax
40003930:	8a 00                	mov    (%eax),%al
40003932:	25 ff 00 00 00       	and    $0xff,%eax
40003937:	f6 04 10 08          	testb  $0x8,(%eax,%edx,1)
4000393b:	75 c8                	jne    40003905 <__svfscanf_r+0x1b5>
4000393d:	83 bd e8 fc ff ff 04 	cmpl   $0x4,-0x318(%ebp)
40003944:	0f 87 44 fe ff ff    	ja     4000378e <__svfscanf_r+0x3e>
4000394a:	8b 85 e8 fc ff ff    	mov    -0x318(%ebp),%eax
40003950:	ff 24 85 40 be 00 40 	jmp    *0x4000be40(,%eax,4)
40003957:	25 ff 00 00 00       	and    $0xff,%eax
4000395c:	ff 24 85 54 be 00 40 	jmp    *0x4000be54(,%eax,4)
40003963:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
40003969:	48                   	dec    %eax
4000396a:	3d 5c 01 00 00       	cmp    $0x15c,%eax
4000396f:	0f 87 6b 07 00 00    	ja     400040e0 <__svfscanf_r+0x990>
40003975:	8b 85 f8 fc ff ff    	mov    -0x308(%ebp),%eax
4000397b:	c7 85 2c fd ff ff 00 	movl   $0x0,-0x2d4(%ebp)
40003982:	00 00 00 
40003985:	0d 80 07 00 00       	or     $0x780,%eax
4000398a:	89 85 6c fd ff ff    	mov    %eax,-0x294(%ebp)
40003990:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
40003996:	85 c0                	test   %eax,%eax
40003998:	0f 85 6f 07 00 00    	jne    4000410d <__svfscanf_r+0x9bd>
4000399e:	8d 8d 7e fd ff ff    	lea    -0x282(%ebp),%ecx
400039a4:	c7 85 1c fd ff ff 00 	movl   $0x0,-0x2e4(%ebp)
400039ab:	00 00 00 
400039ae:	89 8d e4 fc ff ff    	mov    %ecx,-0x31c(%ebp)
400039b4:	89 8d 40 fd ff ff    	mov    %ecx,-0x2c0(%ebp)
400039ba:	c7 85 20 fd ff ff 00 	movl   $0x0,-0x2e0(%ebp)
400039c1:	00 00 00 
400039c4:	c7 85 24 fd ff ff 00 	movl   $0x0,-0x2dc(%ebp)
400039cb:	00 00 00 
400039ce:	c7 85 28 fd ff ff 00 	movl   $0x0,-0x2d8(%ebp)
400039d5:	00 00 00 
400039d8:	f7 85 6c fd ff ff 00 	testl  $0x100,-0x294(%ebp)
400039df:	01 00 00 
400039e2:	74 60                	je     40003a44 <__svfscanf_r+0x2f4>
400039e4:	f7 85 6c fd ff ff 00 	testl  $0x400,-0x294(%ebp)
400039eb:	04 00 00 
400039ee:	0f 85 6a 12 00 00    	jne    40004c5e <__svfscanf_r+0x150e>
400039f4:	8b 8d 40 fd ff ff    	mov    -0x2c0(%ebp),%ecx
400039fa:	4e                   	dec    %esi
400039fb:	49                   	dec    %ecx
400039fc:	89 8d 40 fd ff ff    	mov    %ecx,-0x2c0(%ebp)
40003a02:	8b 95 40 fd ff ff    	mov    -0x2c0(%ebp),%edx
40003a08:	0f be 02             	movsbl (%edx),%eax
40003a0b:	83 f8 65             	cmp    $0x65,%eax
40003a0e:	74 28                	je     40003a38 <__svfscanf_r+0x2e8>
40003a10:	83 f8 45             	cmp    $0x45,%eax
40003a13:	74 23                	je     40003a38 <__svfscanf_r+0x2e8>
40003a15:	52                   	push   %edx
40003a16:	52                   	push   %edx
40003a17:	53                   	push   %ebx
40003a18:	50                   	push   %eax
40003a19:	e8 b2 73 00 00       	call   4000add0 <ungetc>
40003a1e:	8b 8d 40 fd ff ff    	mov    -0x2c0(%ebp),%ecx
40003a24:	49                   	dec    %ecx
40003a25:	4e                   	dec    %esi
40003a26:	89 8d 40 fd ff ff    	mov    %ecx,-0x2c0(%ebp)
40003a2c:	83 c4 10             	add    $0x10,%esp
40003a2f:	8b 8d 40 fd ff ff    	mov    -0x2c0(%ebp),%ecx
40003a35:	0f be 01             	movsbl (%ecx),%eax
40003a38:	52                   	push   %edx
40003a39:	52                   	push   %edx
40003a3a:	53                   	push   %ebx
40003a3b:	50                   	push   %eax
40003a3c:	e8 8f 73 00 00       	call   4000add0 <ungetc>
40003a41:	83 c4 10             	add    $0x10,%esp
40003a44:	f6 85 6c fd ff ff 10 	testb  $0x10,-0x294(%ebp)
40003a4b:	0f 85 3d fd ff ff    	jne    4000378e <__svfscanf_r+0x3e>
40003a51:	8b 85 40 fd ff ff    	mov    -0x2c0(%ebp),%eax
40003a57:	c6 00 00             	movb   $0x0,(%eax)
40003a5a:	8b 85 6c fd ff ff    	mov    -0x294(%ebp),%eax
40003a60:	25 00 06 00 00       	and    $0x600,%eax
40003a65:	3d 00 04 00 00       	cmp    $0x400,%eax
40003a6a:	0f 84 cc 11 00 00    	je     40004c3c <__svfscanf_r+0x14ec>
40003a70:	8b 85 24 fd ff ff    	mov    -0x2dc(%ebp),%eax
40003a76:	85 c0                	test   %eax,%eax
40003a78:	0f 85 69 11 00 00    	jne    40004be7 <__svfscanf_r+0x1497>
40003a7e:	8b 4d 08             	mov    0x8(%ebp),%ecx
40003a81:	50                   	push   %eax
40003a82:	8b 85 e4 fc ff ff    	mov    -0x31c(%ebp),%eax
40003a88:	6a 00                	push   $0x0
40003a8a:	50                   	push   %eax
40003a8b:	51                   	push   %ecx
40003a8c:	e8 0f 5b 00 00       	call   400095a0 <_strtod_r>
40003a91:	83 c4 10             	add    $0x10,%esp
40003a94:	f6 85 6c fd ff ff 01 	testb  $0x1,-0x294(%ebp)
40003a9b:	0f 84 8e 0e 00 00    	je     4000492f <__svfscanf_r+0x11df>
40003aa1:	8b 55 14             	mov    0x14(%ebp),%edx
40003aa4:	8b 4d 14             	mov    0x14(%ebp),%ecx
40003aa7:	83 c1 04             	add    $0x4,%ecx
40003aaa:	8b 02                	mov    (%edx),%eax
40003aac:	89 8d 64 fd ff ff    	mov    %ecx,-0x29c(%ebp)
40003ab2:	dd 18                	fstpl  (%eax)
40003ab4:	8b 95 fc fc ff ff    	mov    -0x304(%ebp),%edx
40003aba:	8b 85 64 fd ff ff    	mov    -0x29c(%ebp),%eax
40003ac0:	42                   	inc    %edx
40003ac1:	89 45 14             	mov    %eax,0x14(%ebp)
40003ac4:	89 95 fc fc ff ff    	mov    %edx,-0x304(%ebp)
40003aca:	e9 bf fc ff ff       	jmp    4000378e <__svfscanf_r+0x3e>
40003acf:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
40003ad5:	48                   	dec    %eax
40003ad6:	3d 5c 01 00 00       	cmp    $0x15c,%eax
40003adb:	0f 87 cf 03 00 00    	ja     40003eb0 <__svfscanf_r+0x760>
40003ae1:	8b 95 f8 fc ff ff    	mov    -0x308(%ebp),%edx
40003ae7:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
40003aed:	81 ca 80 0d 00 00    	or     $0xd80,%edx
40003af3:	85 c0                	test   %eax,%eax
40003af5:	89 95 68 fd ff ff    	mov    %edx,-0x298(%ebp)
40003afb:	0f 85 5a 10 00 00    	jne    40004b5b <__svfscanf_r+0x140b>
40003b01:	8d 8d 7e fd ff ff    	lea    -0x282(%ebp),%ecx
40003b07:	c7 85 18 fd ff ff 00 	movl   $0x0,-0x2e8(%ebp)
40003b0e:	00 00 00 
40003b11:	89 8d e4 fc ff ff    	mov    %ecx,-0x31c(%ebp)
40003b17:	89 8d 3c fd ff ff    	mov    %ecx,-0x2c4(%ebp)
40003b1d:	e9 ee 03 00 00       	jmp    40003f10 <__svfscanf_r+0x7c0>
40003b22:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40003b29:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40003b30:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
40003b36:	85 c0                	test   %eax,%eax
40003b38:	75 0a                	jne    40003b44 <__svfscanf_r+0x3f4>
40003b3a:	c7 85 ec fc ff ff ff 	movl   $0xffffffff,-0x314(%ebp)
40003b41:	ff ff ff 
40003b44:	f6 85 f8 fc ff ff 01 	testb  $0x1,-0x308(%ebp)
40003b4b:	0f 84 51 0a 00 00    	je     400045a2 <__svfscanf_r+0xe52>
40003b51:	8b 85 f8 fc ff ff    	mov    -0x308(%ebp),%eax
40003b57:	83 e0 10             	and    $0x10,%eax
40003b5a:	89 85 60 fd ff ff    	mov    %eax,-0x2a0(%ebp)
40003b60:	0f 85 cf 08 00 00    	jne    40004435 <__svfscanf_r+0xce5>
40003b66:	8b 4d 14             	mov    0x14(%ebp),%ecx
40003b69:	8b 45 14             	mov    0x14(%ebp),%eax
40003b6c:	83 c0 04             	add    $0x4,%eax
40003b6f:	8b 09                	mov    (%ecx),%ecx
40003b71:	89 45 14             	mov    %eax,0x14(%ebp)
40003b74:	89 8d 70 fd ff ff    	mov    %ecx,-0x290(%ebp)
40003b7a:	e9 bf 08 00 00       	jmp    4000443e <__svfscanf_r+0xcee>
40003b7f:	90                   	nop    
40003b80:	8b 8d ec fc ff ff    	mov    -0x314(%ebp),%ecx
40003b86:	85 c9                	test   %ecx,%ecx
40003b88:	75 0a                	jne    40003b94 <__svfscanf_r+0x444>
40003b8a:	c7 85 ec fc ff ff ff 	movl   $0xffffffff,-0x314(%ebp)
40003b91:	ff ff ff 
40003b94:	c7 85 4c fd ff ff 00 	movl   $0x0,-0x2b4(%ebp)
40003b9b:	00 00 00 
40003b9e:	f6 85 f8 fc ff ff 10 	testb  $0x10,-0x308(%ebp)
40003ba5:	0f 85 c9 00 00 00    	jne    40003c74 <__svfscanf_r+0x524>
40003bab:	8b 45 14             	mov    0x14(%ebp),%eax
40003bae:	8b 00                	mov    (%eax),%eax
40003bb0:	89 85 f0 fc ff ff    	mov    %eax,-0x310(%ebp)
40003bb6:	89 85 44 fd ff ff    	mov    %eax,-0x2bc(%ebp)
40003bbc:	8b 13                	mov    (%ebx),%edx
40003bbe:	31 c0                	xor    %eax,%eax
40003bc0:	8a 02                	mov    (%edx),%al
40003bc2:	80 bc 05 dc fe ff ff 	cmpb   $0x0,-0x124(%ebp,%eax,1)
40003bc9:	00 
40003bca:	74 51                	je     40003c1d <__svfscanf_r+0x4cd>
40003bcc:	8b 4b 04             	mov    0x4(%ebx),%ecx
40003bcf:	49                   	dec    %ecx
40003bd0:	89 4b 04             	mov    %ecx,0x4(%ebx)
40003bd3:	8b 8d f0 fc ff ff    	mov    -0x310(%ebp),%ecx
40003bd9:	8a 02                	mov    (%edx),%al
40003bdb:	88 01                	mov    %al,(%ecx)
40003bdd:	41                   	inc    %ecx
40003bde:	ff 8d ec fc ff ff    	decl   -0x314(%ebp)
40003be4:	8d 42 01             	lea    0x1(%edx),%eax
40003be7:	89 8d f0 fc ff ff    	mov    %ecx,-0x310(%ebp)
40003bed:	89 03                	mov    %eax,(%ebx)
40003bef:	74 2c                	je     40003c1d <__svfscanf_r+0x4cd>
40003bf1:	8b 53 04             	mov    0x4(%ebx),%edx
40003bf4:	85 d2                	test   %edx,%edx
40003bf6:	7f c4                	jg     40003bbc <__svfscanf_r+0x46c>
40003bf8:	50                   	push   %eax
40003bf9:	50                   	push   %eax
40003bfa:	8b 45 08             	mov    0x8(%ebp),%eax
40003bfd:	53                   	push   %ebx
40003bfe:	50                   	push   %eax
40003bff:	e8 1c 55 00 00       	call   40009120 <__srefill_r>
40003c04:	83 c4 10             	add    $0x10,%esp
40003c07:	85 c0                	test   %eax,%eax
40003c09:	74 b1                	je     40003bbc <__svfscanf_r+0x46c>
40003c0b:	8b 85 f0 fc ff ff    	mov    -0x310(%ebp),%eax
40003c11:	39 85 44 fd ff ff    	cmp    %eax,-0x2bc(%ebp)
40003c17:	0f 84 33 fc ff ff    	je     40003850 <__svfscanf_r+0x100>
40003c1d:	8b 95 f0 fc ff ff    	mov    -0x310(%ebp),%edx
40003c23:	2b 95 44 fd ff ff    	sub    -0x2bc(%ebp),%edx
40003c29:	89 95 4c fd ff ff    	mov    %edx,-0x2b4(%ebp)
40003c2f:	0f 84 b0 fb ff ff    	je     400037e5 <__svfscanf_r+0x95>
40003c35:	8b 45 14             	mov    0x14(%ebp),%eax
40003c38:	8b 8d f0 fc ff ff    	mov    -0x310(%ebp),%ecx
40003c3e:	83 c0 04             	add    $0x4,%eax
40003c41:	89 45 14             	mov    %eax,0x14(%ebp)
40003c44:	c6 01 00             	movb   $0x0,(%ecx)
40003c47:	8b 85 fc fc ff ff    	mov    -0x304(%ebp),%eax
40003c4d:	40                   	inc    %eax
40003c4e:	89 85 fc fc ff ff    	mov    %eax,-0x304(%ebp)
40003c54:	8b 85 4c fd ff ff    	mov    -0x2b4(%ebp),%eax
40003c5a:	01 c6                	add    %eax,%esi
40003c5c:	e9 2d fb ff ff       	jmp    4000378e <__svfscanf_r+0x3e>
40003c61:	50                   	push   %eax
40003c62:	50                   	push   %eax
40003c63:	8b 45 08             	mov    0x8(%ebp),%eax
40003c66:	53                   	push   %ebx
40003c67:	50                   	push   %eax
40003c68:	e8 b3 54 00 00       	call   40009120 <__srefill_r>
40003c6d:	83 c4 10             	add    $0x10,%esp
40003c70:	85 c0                	test   %eax,%eax
40003c72:	75 e0                	jne    40003c54 <__svfscanf_r+0x504>
40003c74:	8b 03                	mov    (%ebx),%eax
40003c76:	8a 00                	mov    (%eax),%al
40003c78:	25 ff 00 00 00       	and    $0xff,%eax
40003c7d:	80 bc 05 dc fe ff ff 	cmpb   $0x0,-0x124(%ebp,%eax,1)
40003c84:	00 
40003c85:	0f 84 df 0e 00 00    	je     40004b6a <__svfscanf_r+0x141a>
40003c8b:	8b 43 04             	mov    0x4(%ebx),%eax
40003c8e:	8b 95 4c fd ff ff    	mov    -0x2b4(%ebp),%edx
40003c94:	48                   	dec    %eax
40003c95:	42                   	inc    %edx
40003c96:	89 43 04             	mov    %eax,0x4(%ebx)
40003c99:	8b 03                	mov    (%ebx),%eax
40003c9b:	40                   	inc    %eax
40003c9c:	89 95 4c fd ff ff    	mov    %edx,-0x2b4(%ebp)
40003ca2:	8b 8d ec fc ff ff    	mov    -0x314(%ebp),%ecx
40003ca8:	89 03                	mov    %eax,(%ebx)
40003caa:	39 8d 4c fd ff ff    	cmp    %ecx,-0x2b4(%ebp)
40003cb0:	74 a2                	je     40003c54 <__svfscanf_r+0x504>
40003cb2:	8b 43 04             	mov    0x4(%ebx),%eax
40003cb5:	85 c0                	test   %eax,%eax
40003cb7:	7f bb                	jg     40003c74 <__svfscanf_r+0x524>
40003cb9:	eb a6                	jmp    40003c61 <__svfscanf_r+0x511>
40003cbb:	8b 8d ec fc ff ff    	mov    -0x314(%ebp),%ecx
40003cc1:	85 c9                	test   %ecx,%ecx
40003cc3:	75 0a                	jne    40003ccf <__svfscanf_r+0x57f>
40003cc5:	c7 85 ec fc ff ff 01 	movl   $0x1,-0x314(%ebp)
40003ccc:	00 00 00 
40003ccf:	f6 85 f8 fc ff ff 01 	testb  $0x1,-0x308(%ebp)
40003cd6:	0f 84 e3 09 00 00    	je     400046bf <__svfscanf_r+0xf6f>
40003cdc:	8b 95 f8 fc ff ff    	mov    -0x308(%ebp),%edx
40003ce2:	83 e2 10             	and    $0x10,%edx
40003ce5:	89 95 5c fd ff ff    	mov    %edx,-0x2a4(%ebp)
40003ceb:	0f 85 bf 09 00 00    	jne    400046b0 <__svfscanf_r+0xf60>
40003cf1:	8b 4d 14             	mov    0x14(%ebp),%ecx
40003cf4:	8b 45 14             	mov    0x14(%ebp),%eax
40003cf7:	83 c0 04             	add    $0x4,%eax
40003cfa:	8b 09                	mov    (%ecx),%ecx
40003cfc:	89 45 14             	mov    %eax,0x14(%ebp)
40003cff:	89 8d 04 fd ff ff    	mov    %ecx,-0x2fc(%ebp)
40003d05:	8b 15 98 d8 00 40    	mov    0x4000d898,%edx
40003d0b:	85 d2                	test   %edx,%edx
40003d0d:	0f 84 3d fb ff ff    	je     40003850 <__svfscanf_r+0x100>
40003d13:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
40003d19:	c7 85 f4 fc ff ff 00 	movl   $0x0,-0x30c(%ebp)
40003d20:	00 00 00 
40003d23:	89 95 e4 fc ff ff    	mov    %edx,-0x31c(%ebp)
40003d29:	eb 68                	jmp    40003d93 <__svfscanf_r+0x643>
40003d2b:	83 f8 fe             	cmp    $0xfffffffe,%eax
40003d2e:	74 38                	je     40003d68 <__svfscanf_r+0x618>
40003d30:	8b 85 f4 fc ff ff    	mov    -0x30c(%ebp),%eax
40003d36:	c7 85 f4 fc ff ff 00 	movl   $0x0,-0x30c(%ebp)
40003d3d:	00 00 00 
40003d40:	01 c6                	add    %eax,%esi
40003d42:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
40003d48:	48                   	dec    %eax
40003d49:	89 85 ec fc ff ff    	mov    %eax,-0x314(%ebp)
40003d4f:	8b 85 5c fd ff ff    	mov    -0x2a4(%ebp),%eax
40003d55:	85 c0                	test   %eax,%eax
40003d57:	75 0f                	jne    40003d68 <__svfscanf_r+0x618>
40003d59:	8b 85 04 fd ff ff    	mov    -0x2fc(%ebp),%eax
40003d5f:	83 c0 04             	add    $0x4,%eax
40003d62:	89 85 04 fd ff ff    	mov    %eax,-0x2fc(%ebp)
40003d68:	8b 43 04             	mov    0x4(%ebx),%eax
40003d6b:	85 c0                	test   %eax,%eax
40003d6d:	0f 8e ed 09 00 00    	jle    40004760 <__svfscanf_r+0x1010>
40003d73:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
40003d79:	85 c0                	test   %eax,%eax
40003d7b:	0f 84 04 0a 00 00    	je     40004785 <__svfscanf_r+0x1035>
40003d81:	8b 8d f4 fc ff ff    	mov    -0x30c(%ebp),%ecx
40003d87:	3b 0d 98 d8 00 40    	cmp    0x4000d898,%ecx
40003d8d:	0f 84 bd fa ff ff    	je     40003850 <__svfscanf_r+0x100>
40003d93:	8b 03                	mov    (%ebx),%eax
40003d95:	8b 95 f4 fc ff ff    	mov    -0x30c(%ebp),%edx
40003d9b:	8d 4d dc             	lea    -0x24(%ebp),%ecx
40003d9e:	8a 00                	mov    (%eax),%al
40003da0:	88 84 15 7e fd ff ff 	mov    %al,-0x282(%ebp,%edx,1)
40003da7:	42                   	inc    %edx
40003da8:	8b 43 04             	mov    0x4(%ebx),%eax
40003dab:	89 95 f4 fc ff ff    	mov    %edx,-0x30c(%ebp)
40003db1:	48                   	dec    %eax
40003db2:	89 43 04             	mov    %eax,0x4(%ebx)
40003db5:	8b 03                	mov    (%ebx),%eax
40003db7:	40                   	inc    %eax
40003db8:	89 03                	mov    %eax,(%ebx)
40003dba:	50                   	push   %eax
40003dbb:	6a 08                	push   $0x8
40003dbd:	6a 00                	push   $0x0
40003dbf:	51                   	push   %ecx
40003dc0:	e8 23 d2 ff ff       	call   40000fe8 <memset>
40003dc5:	8d 45 dc             	lea    -0x24(%ebp),%eax
40003dc8:	8b 4d 08             	mov    0x8(%ebp),%ecx
40003dcb:	89 04 24             	mov    %eax,(%esp)
40003dce:	8b 85 f4 fc ff ff    	mov    -0x30c(%ebp),%eax
40003dd4:	50                   	push   %eax
40003dd5:	8b 85 e4 fc ff ff    	mov    -0x31c(%ebp),%eax
40003ddb:	50                   	push   %eax
40003ddc:	8b 85 04 fd ff ff    	mov    -0x2fc(%ebp),%eax
40003de2:	50                   	push   %eax
40003de3:	51                   	push   %ecx
40003de4:	e8 67 3b 00 00       	call   40007950 <_mbrtowc_r>
40003de9:	83 c4 20             	add    $0x20,%esp
40003dec:	83 f8 ff             	cmp    $0xffffffff,%eax
40003def:	0f 84 5b fa ff ff    	je     40003850 <__svfscanf_r+0x100>
40003df5:	85 c0                	test   %eax,%eax
40003df7:	0f 85 2e ff ff ff    	jne    40003d2b <__svfscanf_r+0x5db>
40003dfd:	8b 95 5c fd ff ff    	mov    -0x2a4(%ebp),%edx
40003e03:	85 d2                	test   %edx,%edx
40003e05:	0f 85 25 ff ff ff    	jne    40003d30 <__svfscanf_r+0x5e0>
40003e0b:	8b 95 04 fd ff ff    	mov    -0x2fc(%ebp),%edx
40003e11:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
40003e17:	e9 14 ff ff ff       	jmp    40003d30 <__svfscanf_r+0x5e0>
40003e1c:	8b 85 f8 fc ff ff    	mov    -0x308(%ebp),%eax
40003e22:	83 c8 01             	or     $0x1,%eax
40003e25:	89 85 f8 fc ff ff    	mov    %eax,-0x308(%ebp)
40003e2b:	c7 85 e8 fc ff ff 02 	movl   $0x2,-0x318(%ebp)
40003e32:	00 00 00 
40003e35:	e9 84 fa ff ff       	jmp    400038be <__svfscanf_r+0x16e>
40003e3a:	8b 95 f8 fc ff ff    	mov    -0x308(%ebp),%edx
40003e40:	83 ca 01             	or     $0x1,%edx
40003e43:	89 95 f8 fc ff ff    	mov    %edx,-0x308(%ebp)
40003e49:	c7 85 e8 fc ff ff 03 	movl   $0x3,-0x318(%ebp)
40003e50:	00 00 00 
40003e53:	c7 85 00 fd ff ff 08 	movl   $0x8,-0x300(%ebp)
40003e5a:	00 00 00 
40003e5d:	c7 85 08 fd ff ff e0 	movl   $0x4000a9e0,-0x2f8(%ebp)
40003e64:	a9 00 40 
40003e67:	e9 52 fa ff ff       	jmp    400038be <__svfscanf_r+0x16e>
40003e6c:	f6 85 f8 fc ff ff 10 	testb  $0x10,-0x308(%ebp)
40003e73:	0f 85 15 f9 ff ff    	jne    4000378e <__svfscanf_r+0x3e>
40003e79:	f6 85 f8 fc ff ff 08 	testb  $0x8,-0x308(%ebp)
40003e80:	0f 85 a6 0c 00 00    	jne    40004b2c <__svfscanf_r+0x13dc>
40003e86:	f6 85 f8 fc ff ff 04 	testb  $0x4,-0x308(%ebp)
40003e8d:	0f 84 ad 0c 00 00    	je     40004b40 <__svfscanf_r+0x13f0>
40003e93:	8b 4d 14             	mov    0x14(%ebp),%ecx
40003e96:	8b 01                	mov    (%ecx),%eax
40003e98:	83 c1 04             	add    $0x4,%ecx
40003e9b:	89 4d 14             	mov    %ecx,0x14(%ebp)
40003e9e:	66 89 30             	mov    %si,(%eax)
40003ea1:	e9 e8 f8 ff ff       	jmp    4000378e <__svfscanf_r+0x3e>
40003ea6:	8d 76 00             	lea    0x0(%esi),%esi
40003ea9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40003eb0:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
40003eb6:	8b 95 f8 fc ff ff    	mov    -0x308(%ebp),%edx
40003ebc:	2d 5d 01 00 00       	sub    $0x15d,%eax
40003ec1:	81 ca 80 0d 00 00    	or     $0xd80,%edx
40003ec7:	89 85 14 fd ff ff    	mov    %eax,-0x2ec(%ebp)
40003ecd:	89 95 68 fd ff ff    	mov    %edx,-0x298(%ebp)
40003ed3:	c7 85 ec fc ff ff 5d 	movl   $0x15d,-0x314(%ebp)
40003eda:	01 00 00 
40003edd:	8d 8d 7e fd ff ff    	lea    -0x282(%ebp),%ecx
40003ee3:	8d 85 7f fd ff ff    	lea    -0x281(%ebp),%eax
40003ee9:	89 8d e4 fc ff ff    	mov    %ecx,-0x31c(%ebp)
40003eef:	89 8d 3c fd ff ff    	mov    %ecx,-0x2c4(%ebp)
40003ef5:	c7 85 18 fd ff ff 00 	movl   $0x0,-0x2e8(%ebp)
40003efc:	00 00 00 
40003eff:	89 85 d4 fc ff ff    	mov    %eax,-0x32c(%ebp)
40003f05:	8b 03                	mov    (%ebx),%eax
40003f07:	8a 10                	mov    (%eax),%dl
40003f09:	8d 42 d5             	lea    -0x2b(%edx),%eax
40003f0c:	3c 4d                	cmp    $0x4d,%al
40003f0e:	76 58                	jbe    40003f68 <__svfscanf_r+0x818>
40003f10:	f7 85 68 fd ff ff 00 	testl  $0x100,-0x298(%ebp)
40003f17:	01 00 00 
40003f1a:	0f 85 e5 0b 00 00    	jne    40004b05 <__svfscanf_r+0x13b5>
40003f20:	8b 8d 3c fd ff ff    	mov    -0x2c4(%ebp),%ecx
40003f26:	0f be 41 ff          	movsbl -0x1(%ecx),%eax
40003f2a:	83 f8 78             	cmp    $0x78,%eax
40003f2d:	0f 84 b4 0b 00 00    	je     40004ae7 <__svfscanf_r+0x1397>
40003f33:	83 f8 58             	cmp    $0x58,%eax
40003f36:	0f 84 ab 0b 00 00    	je     40004ae7 <__svfscanf_r+0x1397>
40003f3c:	f6 85 68 fd ff ff 10 	testb  $0x10,-0x298(%ebp)
40003f43:	0f 84 cf 0a 00 00    	je     40004a18 <__svfscanf_r+0x12c8>
40003f49:	8b 95 e4 fc ff ff    	mov    -0x31c(%ebp),%edx
40003f4f:	8b 8d 3c fd ff ff    	mov    -0x2c4(%ebp),%ecx
40003f55:	29 d6                	sub    %edx,%esi
40003f57:	8b 95 18 fd ff ff    	mov    -0x2e8(%ebp),%edx
40003f5d:	8d 04 16             	lea    (%esi,%edx,1),%eax
40003f60:	8d 34 08             	lea    (%eax,%ecx,1),%esi
40003f63:	e9 26 f8 ff ff       	jmp    4000378e <__svfscanf_r+0x3e>
40003f68:	25 ff 00 00 00       	and    $0xff,%eax
40003f6d:	ff 24 85 38 c0 00 40 	jmp    *0x4000c038(,%eax,4)
40003f74:	f7 85 68 fd ff ff 00 	testl  $0x200,-0x298(%ebp)
40003f7b:	02 00 00 
40003f7e:	74 90                	je     40003f10 <__svfscanf_r+0x7c0>
40003f80:	8b 85 3c fd ff ff    	mov    -0x2c4(%ebp),%eax
40003f86:	39 85 d4 fc ff ff    	cmp    %eax,-0x32c(%ebp)
40003f8c:	75 82                	jne    40003f10 <__svfscanf_r+0x7c0>
40003f8e:	8b 85 68 fd ff ff    	mov    -0x298(%ebp),%eax
40003f94:	c7 85 00 fd ff ff 10 	movl   $0x10,-0x300(%ebp)
40003f9b:	00 00 00 
40003f9e:	80 e4 fd             	and    $0xfd,%ah
40003fa1:	89 85 68 fd ff ff    	mov    %eax,-0x298(%ebp)
40003fa7:	8b 85 68 fd ff ff    	mov    -0x298(%ebp),%eax
40003fad:	80 cc 05             	or     $0x5,%ah
40003fb0:	89 85 68 fd ff ff    	mov    %eax,-0x298(%ebp)
40003fb6:	8b 8d 3c fd ff ff    	mov    -0x2c4(%ebp),%ecx
40003fbc:	88 11                	mov    %dl,(%ecx)
40003fbe:	41                   	inc    %ecx
40003fbf:	89 8d 3c fd ff ff    	mov    %ecx,-0x2c4(%ebp)
40003fc5:	8b 43 04             	mov    0x4(%ebx),%eax
40003fc8:	48                   	dec    %eax
40003fc9:	89 43 04             	mov    %eax,0x4(%ebx)
40003fcc:	85 c0                	test   %eax,%eax
40003fce:	0f 8e ec 00 00 00    	jle    400040c0 <__svfscanf_r+0x970>
40003fd4:	8b 03                	mov    (%ebx),%eax
40003fd6:	40                   	inc    %eax
40003fd7:	89 03                	mov    %eax,(%ebx)
40003fd9:	ff 8d ec fc ff ff    	decl   -0x314(%ebp)
40003fdf:	0f 85 20 ff ff ff    	jne    40003f05 <__svfscanf_r+0x7b5>
40003fe5:	e9 26 ff ff ff       	jmp    40003f10 <__svfscanf_r+0x7c0>
40003fea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40003ff0:	83 bd 00 fd ff ff 0a 	cmpl   $0xa,-0x300(%ebp)
40003ff7:	0f 8e 13 ff ff ff    	jle    40003f10 <__svfscanf_r+0x7c0>
40003ffd:	8b 8d 68 fd ff ff    	mov    -0x298(%ebp),%ecx
40004003:	81 e1 7f f4 ff ff    	and    $0xfffff47f,%ecx
40004009:	89 8d 68 fd ff ff    	mov    %ecx,-0x298(%ebp)
4000400f:	eb a5                	jmp    40003fb6 <__svfscanf_r+0x866>
40004011:	8b 8d 00 fd ff ff    	mov    -0x300(%ebp),%ecx
40004017:	0f bf 8c 09 80 c2 00 	movswl 0x4000c280(%ecx,%ecx,1),%ecx
4000401e:	40 
4000401f:	89 8d 00 fd ff ff    	mov    %ecx,-0x300(%ebp)
40004025:	83 f9 08             	cmp    $0x8,%ecx
40004028:	7f d3                	jg     40003ffd <__svfscanf_r+0x8ad>
4000402a:	e9 e1 fe ff ff       	jmp    40003f10 <__svfscanf_r+0x7c0>
4000402f:	90                   	nop    
40004030:	8b 85 00 fd ff ff    	mov    -0x300(%ebp),%eax
40004036:	0f bf 84 00 80 c2 00 	movswl 0x4000c280(%eax,%eax,1),%eax
4000403d:	40 
4000403e:	89 85 00 fd ff ff    	mov    %eax,-0x300(%ebp)
40004044:	8b 85 68 fd ff ff    	mov    -0x298(%ebp),%eax
4000404a:	25 7f f4 ff ff       	and    $0xfffff47f,%eax
4000404f:	89 85 68 fd ff ff    	mov    %eax,-0x298(%ebp)
40004055:	e9 5c ff ff ff       	jmp    40003fb6 <__svfscanf_r+0x866>
4000405a:	f7 85 68 fd ff ff 00 	testl  $0x800,-0x298(%ebp)
40004061:	08 00 00 
40004064:	0f 84 4c ff ff ff    	je     40003fb6 <__svfscanf_r+0x866>
4000406a:	8b 85 00 fd ff ff    	mov    -0x300(%ebp),%eax
40004070:	85 c0                	test   %eax,%eax
40004072:	0f 84 82 09 00 00    	je     400049fa <__svfscanf_r+0x12aa>
40004078:	f7 85 68 fd ff ff 00 	testl  $0x400,-0x298(%ebp)
4000407f:	04 00 00 
40004082:	0f 84 ed 09 00 00    	je     40004a75 <__svfscanf_r+0x1325>
40004088:	8b 8d 68 fd ff ff    	mov    -0x298(%ebp),%ecx
4000408e:	81 e1 7f fa ff ff    	and    $0xfffffa7f,%ecx
40004094:	89 8d 68 fd ff ff    	mov    %ecx,-0x298(%ebp)
4000409a:	e9 17 ff ff ff       	jmp    40003fb6 <__svfscanf_r+0x866>
4000409f:	90                   	nop    
400040a0:	80 bd 68 fd ff ff 00 	cmpb   $0x0,-0x298(%ebp)
400040a7:	0f 89 63 fe ff ff    	jns    40003f10 <__svfscanf_r+0x7c0>
400040ad:	8b 85 68 fd ff ff    	mov    -0x298(%ebp),%eax
400040b3:	24 7f                	and    $0x7f,%al
400040b5:	89 85 68 fd ff ff    	mov    %eax,-0x298(%ebp)
400040bb:	e9 f6 fe ff ff       	jmp    40003fb6 <__svfscanf_r+0x866>
400040c0:	50                   	push   %eax
400040c1:	50                   	push   %eax
400040c2:	8b 45 08             	mov    0x8(%ebp),%eax
400040c5:	53                   	push   %ebx
400040c6:	50                   	push   %eax
400040c7:	e8 54 50 00 00       	call   40009120 <__srefill_r>
400040cc:	83 c4 10             	add    $0x10,%esp
400040cf:	85 c0                	test   %eax,%eax
400040d1:	0f 84 02 ff ff ff    	je     40003fd9 <__svfscanf_r+0x889>
400040d7:	e9 34 fe ff ff       	jmp    40003f10 <__svfscanf_r+0x7c0>
400040dc:	8d 74 26 00          	lea    0x0(%esi),%esi
400040e0:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
400040e6:	8b 95 f8 fc ff ff    	mov    -0x308(%ebp),%edx
400040ec:	2d 5d 01 00 00       	sub    $0x15d,%eax
400040f1:	81 ca 80 07 00 00    	or     $0x780,%edx
400040f7:	89 85 2c fd ff ff    	mov    %eax,-0x2d4(%ebp)
400040fd:	89 95 6c fd ff ff    	mov    %edx,-0x294(%ebp)
40004103:	c7 85 ec fc ff ff 5d 	movl   $0x15d,-0x314(%ebp)
4000410a:	01 00 00 
4000410d:	8d 8d 7e fd ff ff    	lea    -0x282(%ebp),%ecx
40004113:	c7 85 1c fd ff ff 00 	movl   $0x0,-0x2e4(%ebp)
4000411a:	00 00 00 
4000411d:	89 8d e4 fc ff ff    	mov    %ecx,-0x31c(%ebp)
40004123:	89 8d 40 fd ff ff    	mov    %ecx,-0x2c0(%ebp)
40004129:	c7 85 20 fd ff ff 00 	movl   $0x0,-0x2e0(%ebp)
40004130:	00 00 00 
40004133:	c7 85 24 fd ff ff 00 	movl   $0x0,-0x2dc(%ebp)
4000413a:	00 00 00 
4000413d:	c7 85 28 fd ff ff 00 	movl   $0x0,-0x2d8(%ebp)
40004144:	00 00 00 
40004147:	c7 85 30 fd ff ff 00 	movl   $0x0,-0x2d0(%ebp)
4000414e:	00 00 00 
40004151:	8b 03                	mov    (%ebx),%eax
40004153:	8a 10                	mov    (%eax),%dl
40004155:	8d 42 d5             	lea    -0x2b(%edx),%eax
40004158:	3c 43                	cmp    $0x43,%al
4000415a:	0f 86 90 00 00 00    	jbe    400041f0 <__svfscanf_r+0xaa0>
40004160:	8b 85 30 fd ff ff    	mov    -0x2d0(%ebp),%eax
40004166:	85 c0                	test   %eax,%eax
40004168:	0f 95 c2             	setne  %dl
4000416b:	83 bd 30 fd ff ff 03 	cmpl   $0x3,-0x2d0(%ebp)
40004172:	0f 95 c0             	setne  %al
40004175:	8b 8d 20 fd ff ff    	mov    -0x2e0(%ebp),%ecx
4000417b:	85 c9                	test   %ecx,%ecx
4000417d:	74 0f                	je     4000418e <__svfscanf_r+0xa3e>
4000417f:	8b 8d 6c fd ff ff    	mov    -0x294(%ebp),%ecx
40004185:	80 e5 fe             	and    $0xfe,%ch
40004188:	89 8d 6c fd ff ff    	mov    %ecx,-0x294(%ebp)
4000418e:	84 c0                	test   %al,%al
40004190:	0f 84 42 f8 ff ff    	je     400039d8 <__svfscanf_r+0x288>
40004196:	84 d2                	test   %dl,%dl
40004198:	0f 84 3a f8 ff ff    	je     400039d8 <__svfscanf_r+0x288>
4000419e:	8b bd 30 fd ff ff    	mov    -0x2d0(%ebp),%edi
400041a4:	4f                   	dec    %edi
400041a5:	83 ff ff             	cmp    $0xffffffff,%edi
400041a8:	0f 84 37 f6 ff ff    	je     400037e5 <__svfscanf_r+0x95>
400041ae:	8b 95 40 fd ff ff    	mov    -0x2c0(%ebp),%edx
400041b4:	39 95 e4 fc ff ff    	cmp    %edx,-0x31c(%ebp)
400041ba:	0f 83 25 f6 ff ff    	jae    400037e5 <__svfscanf_r+0x95>
400041c0:	89 d6                	mov    %edx,%esi
400041c2:	50                   	push   %eax
400041c3:	50                   	push   %eax
400041c4:	53                   	push   %ebx
400041c5:	4f                   	dec    %edi
400041c6:	0f be 46 ff          	movsbl -0x1(%esi),%eax
400041ca:	50                   	push   %eax
400041cb:	e8 00 6c 00 00       	call   4000add0 <ungetc>
400041d0:	83 c4 10             	add    $0x10,%esp
400041d3:	83 ff ff             	cmp    $0xffffffff,%edi
400041d6:	0f 84 09 f6 ff ff    	je     400037e5 <__svfscanf_r+0x95>
400041dc:	4e                   	dec    %esi
400041dd:	39 b5 e4 fc ff ff    	cmp    %esi,-0x31c(%ebp)
400041e3:	72 dd                	jb     400041c2 <__svfscanf_r+0xa72>
400041e5:	e9 fb f5 ff ff       	jmp    400037e5 <__svfscanf_r+0x95>
400041ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
400041f0:	25 ff 00 00 00       	and    $0xff,%eax
400041f5:	ff 24 85 70 c1 00 40 	jmp    *0x4000c170(,%eax,4)
400041fc:	8b 85 30 fd ff ff    	mov    -0x2d0(%ebp),%eax
40004202:	85 c0                	test   %eax,%eax
40004204:	0f 85 46 07 00 00    	jne    40004950 <__svfscanf_r+0x1200>
4000420a:	8b 85 6c fd ff ff    	mov    -0x294(%ebp),%eax
40004210:	25 80 07 00 00       	and    $0x780,%eax
40004215:	3d 80 07 00 00       	cmp    $0x780,%eax
4000421a:	0f 85 d1 07 00 00    	jne    400049f1 <__svfscanf_r+0x12a1>
40004220:	8b 85 6c fd ff ff    	mov    -0x294(%ebp),%eax
40004226:	c7 85 30 fd ff ff 01 	movl   $0x1,-0x2d0(%ebp)
4000422d:	00 00 00 
40004230:	25 7f f8 ff ff       	and    $0xfffff87f,%eax
40004235:	89 85 6c fd ff ff    	mov    %eax,-0x294(%ebp)
4000423b:	e9 b7 00 00 00       	jmp    400042f7 <__svfscanf_r+0xba7>
40004240:	8b 85 6c fd ff ff    	mov    -0x294(%ebp),%eax
40004246:	25 00 05 00 00       	and    $0x500,%eax
4000424b:	3d 00 04 00 00       	cmp    $0x400,%eax
40004250:	74 1e                	je     40004270 <__svfscanf_r+0xb20>
40004252:	f7 85 6c fd ff ff 00 	testl  $0x400,-0x294(%ebp)
40004259:	04 00 00 
4000425c:	0f 84 fe fe ff ff    	je     40004160 <__svfscanf_r+0xa10>
40004262:	8b 85 20 fd ff ff    	mov    -0x2e0(%ebp),%eax
40004268:	85 c0                	test   %eax,%eax
4000426a:	0f 84 f0 fe ff ff    	je     40004160 <__svfscanf_r+0xa10>
40004270:	f7 85 6c fd ff ff 00 	testl  $0x200,-0x294(%ebp)
40004277:	02 00 00 
4000427a:	75 20                	jne    4000429c <__svfscanf_r+0xb4c>
4000427c:	8b 8d 1c fd ff ff    	mov    -0x2e4(%ebp),%ecx
40004282:	8b 85 20 fd ff ff    	mov    -0x2e0(%ebp),%eax
40004288:	29 c8                	sub    %ecx,%eax
4000428a:	8b 8d 40 fd ff ff    	mov    -0x2c0(%ebp),%ecx
40004290:	89 85 24 fd ff ff    	mov    %eax,-0x2dc(%ebp)
40004296:	89 8d 28 fd ff ff    	mov    %ecx,-0x2d8(%ebp)
4000429c:	8b 85 6c fd ff ff    	mov    -0x294(%ebp),%eax
400042a2:	c7 85 20 fd ff ff 00 	movl   $0x0,-0x2e0(%ebp)
400042a9:	00 00 00 
400042ac:	25 7f f8 ff ff       	and    $0xfffff87f,%eax
400042b1:	89 85 6c fd ff ff    	mov    %eax,-0x294(%ebp)
400042b7:	8b 85 6c fd ff ff    	mov    -0x294(%ebp),%eax
400042bd:	0d 80 01 00 00       	or     $0x180,%eax
400042c2:	89 85 6c fd ff ff    	mov    %eax,-0x294(%ebp)
400042c8:	eb 2d                	jmp    400042f7 <__svfscanf_r+0xba7>
400042ca:	f7 85 6c fd ff ff 00 	testl  $0x200,-0x294(%ebp)
400042d1:	02 00 00 
400042d4:	0f 84 86 fe ff ff    	je     40004160 <__svfscanf_r+0xa10>
400042da:	8b 85 6c fd ff ff    	mov    -0x294(%ebp),%eax
400042e0:	8b 8d 20 fd ff ff    	mov    -0x2e0(%ebp),%ecx
400042e6:	25 7f fd ff ff       	and    $0xfffffd7f,%eax
400042eb:	89 8d 1c fd ff ff    	mov    %ecx,-0x2e4(%ebp)
400042f1:	89 85 6c fd ff ff    	mov    %eax,-0x294(%ebp)
400042f7:	8b 85 40 fd ff ff    	mov    -0x2c0(%ebp),%eax
400042fd:	88 10                	mov    %dl,(%eax)
400042ff:	40                   	inc    %eax
40004300:	89 85 40 fd ff ff    	mov    %eax,-0x2c0(%ebp)
40004306:	8b 43 04             	mov    0x4(%ebx),%eax
40004309:	46                   	inc    %esi
4000430a:	48                   	dec    %eax
4000430b:	89 43 04             	mov    %eax,0x4(%ebx)
4000430e:	85 c0                	test   %eax,%eax
40004310:	0f 8e ca 00 00 00    	jle    400043e0 <__svfscanf_r+0xc90>
40004316:	8b 03                	mov    (%ebx),%eax
40004318:	40                   	inc    %eax
40004319:	89 03                	mov    %eax,(%ebx)
4000431b:	ff 8d ec fc ff ff    	decl   -0x314(%ebp)
40004321:	0f 85 2a fe ff ff    	jne    40004151 <__svfscanf_r+0xa01>
40004327:	e9 34 fe ff ff       	jmp    40004160 <__svfscanf_r+0xa10>
4000432c:	8d 74 26 00          	lea    0x0(%esi),%esi
40004330:	8b 8d 30 fd ff ff    	mov    -0x2d0(%ebp),%ecx
40004336:	85 c9                	test   %ecx,%ecx
40004338:	0f 85 a2 06 00 00    	jne    400049e0 <__svfscanf_r+0x1290>
4000433e:	8b 85 6c fd ff ff    	mov    -0x294(%ebp),%eax
40004344:	25 7f fe ff ff       	and    $0xfffffe7f,%eax
40004349:	89 85 6c fd ff ff    	mov    %eax,-0x294(%ebp)
4000434f:	eb a6                	jmp    400042f7 <__svfscanf_r+0xba7>
40004351:	80 bd 6c fd ff ff 00 	cmpb   $0x0,-0x294(%ebp)
40004358:	0f 89 02 fe ff ff    	jns    40004160 <__svfscanf_r+0xa10>
4000435e:	8b 85 6c fd ff ff    	mov    -0x294(%ebp),%eax
40004364:	24 7f                	and    $0x7f,%al
40004366:	89 85 6c fd ff ff    	mov    %eax,-0x294(%ebp)
4000436c:	eb 89                	jmp    400042f7 <__svfscanf_r+0xba7>
4000436e:	83 bd 30 fd ff ff 01 	cmpl   $0x1,-0x2d0(%ebp)
40004375:	0f 85 e5 fd ff ff    	jne    40004160 <__svfscanf_r+0xa10>
4000437b:	c7 85 30 fd ff ff 02 	movl   $0x2,-0x2d0(%ebp)
40004382:	00 00 00 
40004385:	e9 6d ff ff ff       	jmp    400042f7 <__svfscanf_r+0xba7>
4000438a:	f7 85 6c fd ff ff 00 	testl  $0x100,-0x294(%ebp)
40004391:	01 00 00 
40004394:	74 9a                	je     40004330 <__svfscanf_r+0xbe0>
40004396:	8b 85 6c fd ff ff    	mov    -0x294(%ebp),%eax
4000439c:	24 7f                	and    $0x7f,%al
4000439e:	89 85 6c fd ff ff    	mov    %eax,-0x294(%ebp)
400043a4:	8b 85 20 fd ff ff    	mov    -0x2e0(%ebp),%eax
400043aa:	40                   	inc    %eax
400043ab:	89 85 20 fd ff ff    	mov    %eax,-0x2e0(%ebp)
400043b1:	8b 85 2c fd ff ff    	mov    -0x2d4(%ebp),%eax
400043b7:	85 c0                	test   %eax,%eax
400043b9:	0f 84 47 ff ff ff    	je     40004306 <__svfscanf_r+0xbb6>
400043bf:	8b 85 2c fd ff ff    	mov    -0x2d4(%ebp),%eax
400043c5:	48                   	dec    %eax
400043c6:	89 85 2c fd ff ff    	mov    %eax,-0x2d4(%ebp)
400043cc:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
400043d2:	40                   	inc    %eax
400043d3:	89 85 ec fc ff ff    	mov    %eax,-0x314(%ebp)
400043d9:	e9 28 ff ff ff       	jmp    40004306 <__svfscanf_r+0xbb6>
400043de:	66 90                	xchg   %ax,%ax
400043e0:	50                   	push   %eax
400043e1:	50                   	push   %eax
400043e2:	8b 45 08             	mov    0x8(%ebp),%eax
400043e5:	53                   	push   %ebx
400043e6:	50                   	push   %eax
400043e7:	e8 34 4d 00 00       	call   40009120 <__srefill_r>
400043ec:	83 c4 10             	add    $0x10,%esp
400043ef:	85 c0                	test   %eax,%eax
400043f1:	0f 84 24 ff ff ff    	je     4000431b <__svfscanf_r+0xbcb>
400043f7:	e9 64 fd ff ff       	jmp    40004160 <__svfscanf_r+0xa10>
400043fc:	8d 74 26 00          	lea    0x0(%esi),%esi
40004400:	8b 8d f8 fc ff ff    	mov    -0x308(%ebp),%ecx
40004406:	c7 85 e8 fc ff ff 03 	movl   $0x3,-0x318(%ebp)
4000440d:	00 00 00 
40004410:	81 c9 20 02 00 00    	or     $0x220,%ecx
40004416:	c7 85 00 fd ff ff 10 	movl   $0x10,-0x300(%ebp)
4000441d:	00 00 00 
40004420:	89 8d f8 fc ff ff    	mov    %ecx,-0x308(%ebp)
40004426:	c7 85 08 fd ff ff e0 	movl   $0x4000a9e0,-0x2f8(%ebp)
4000442d:	a9 00 40 
40004430:	e9 89 f4 ff ff       	jmp    400038be <__svfscanf_r+0x16e>
40004435:	8d 55 e4             	lea    -0x1c(%ebp),%edx
40004438:	89 95 70 fd ff ff    	mov    %edx,-0x290(%ebp)
4000443e:	c7 85 50 fd ff ff 00 	movl   $0x0,-0x2b0(%ebp)
40004445:	00 00 00 
40004448:	8b 03                	mov    (%ebx),%eax
4000444a:	31 d2                	xor    %edx,%edx
4000444c:	8a 08                	mov    (%eax),%cl
4000444e:	a1 90 d8 00 40       	mov    0x4000d890,%eax
40004453:	88 ca                	mov    %cl,%dl
40004455:	f6 04 02 08          	testb  $0x8,(%edx,%eax,1)
40004459:	74 25                	je     40004480 <__svfscanf_r+0xd30>
4000445b:	8b 85 60 fd ff ff    	mov    -0x2a0(%ebp),%eax
40004461:	85 c0                	test   %eax,%eax
40004463:	0f 85 25 f3 ff ff    	jne    4000378e <__svfscanf_r+0x3e>
40004469:	8b 85 70 fd ff ff    	mov    -0x290(%ebp),%eax
4000446f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
40004475:	e9 b6 01 00 00       	jmp    40004630 <__svfscanf_r+0xee0>
4000447a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40004480:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
40004486:	85 c0                	test   %eax,%eax
40004488:	74 d1                	je     4000445b <__svfscanf_r+0xd0b>
4000448a:	8b 95 50 fd ff ff    	mov    -0x2b0(%ebp),%edx
40004490:	3b 15 98 d8 00 40    	cmp    0x4000d898,%edx
40004496:	0f 84 b4 f3 ff ff    	je     40003850 <__svfscanf_r+0x100>
4000449c:	88 8c 15 7e fd ff ff 	mov    %cl,-0x282(%ebp,%edx,1)
400044a3:	42                   	inc    %edx
400044a4:	8b 4b 04             	mov    0x4(%ebx),%ecx
400044a7:	89 95 50 fd ff ff    	mov    %edx,-0x2b0(%ebp)
400044ad:	8b 13                	mov    (%ebx),%edx
400044af:	49                   	dec    %ecx
400044b0:	42                   	inc    %edx
400044b1:	89 4b 04             	mov    %ecx,0x4(%ebx)
400044b4:	89 13                	mov    %edx,(%ebx)
400044b6:	8d 4d dc             	lea    -0x24(%ebp),%ecx
400044b9:	50                   	push   %eax
400044ba:	6a 08                	push   $0x8
400044bc:	6a 00                	push   $0x0
400044be:	51                   	push   %ecx
400044bf:	e8 24 cb ff ff       	call   40000fe8 <memset>
400044c4:	8d 45 dc             	lea    -0x24(%ebp),%eax
400044c7:	89 04 24             	mov    %eax,(%esp)
400044ca:	8b 85 50 fd ff ff    	mov    -0x2b0(%ebp),%eax
400044d0:	50                   	push   %eax
400044d1:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
400044d7:	8b 85 70 fd ff ff    	mov    -0x290(%ebp),%eax
400044dd:	52                   	push   %edx
400044de:	50                   	push   %eax
400044df:	8b 45 08             	mov    0x8(%ebp),%eax
400044e2:	50                   	push   %eax
400044e3:	89 95 e4 fc ff ff    	mov    %edx,-0x31c(%ebp)
400044e9:	e8 62 34 00 00       	call   40007950 <_mbrtowc_r>
400044ee:	83 c4 20             	add    $0x20,%esp
400044f1:	83 f8 ff             	cmp    $0xffffffff,%eax
400044f4:	0f 84 56 f3 ff ff    	je     40003850 <__svfscanf_r+0x100>
400044fa:	85 c0                	test   %eax,%eax
400044fc:	0f 85 8e 00 00 00    	jne    40004590 <__svfscanf_r+0xe40>
40004502:	8b 8d 70 fd ff ff    	mov    -0x290(%ebp),%ecx
40004508:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
4000450e:	83 ec 0c             	sub    $0xc,%esp
40004511:	50                   	push   %eax
40004512:	e8 d9 31 00 00       	call   400076f0 <iswspace>
40004517:	83 c4 10             	add    $0x10,%esp
4000451a:	85 c0                	test   %eax,%eax
4000451c:	0f 85 6d 06 00 00    	jne    40004b8f <__svfscanf_r+0x143f>
40004522:	8b 85 50 fd ff ff    	mov    -0x2b0(%ebp),%eax
40004528:	c7 85 50 fd ff ff 00 	movl   $0x0,-0x2b0(%ebp)
4000452f:	00 00 00 
40004532:	01 c6                	add    %eax,%esi
40004534:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
4000453a:	48                   	dec    %eax
4000453b:	89 85 ec fc ff ff    	mov    %eax,-0x314(%ebp)
40004541:	8b 85 60 fd ff ff    	mov    -0x2a0(%ebp),%eax
40004547:	85 c0                	test   %eax,%eax
40004549:	75 0f                	jne    4000455a <__svfscanf_r+0xe0a>
4000454b:	8b 85 70 fd ff ff    	mov    -0x290(%ebp),%eax
40004551:	83 c0 04             	add    $0x4,%eax
40004554:	89 85 70 fd ff ff    	mov    %eax,-0x290(%ebp)
4000455a:	8b 43 04             	mov    0x4(%ebx),%eax
4000455d:	85 c0                	test   %eax,%eax
4000455f:	0f 8f e3 fe ff ff    	jg     40004448 <__svfscanf_r+0xcf8>
40004565:	8b 4d 08             	mov    0x8(%ebp),%ecx
40004568:	50                   	push   %eax
40004569:	50                   	push   %eax
4000456a:	53                   	push   %ebx
4000456b:	51                   	push   %ecx
4000456c:	e8 af 4b 00 00       	call   40009120 <__srefill_r>
40004571:	83 c4 10             	add    $0x10,%esp
40004574:	85 c0                	test   %eax,%eax
40004576:	0f 84 cc fe ff ff    	je     40004448 <__svfscanf_r+0xcf8>
4000457c:	8b 95 50 fd ff ff    	mov    -0x2b0(%ebp),%edx
40004582:	85 d2                	test   %edx,%edx
40004584:	0f 84 d1 fe ff ff    	je     4000445b <__svfscanf_r+0xd0b>
4000458a:	e9 c1 f2 ff ff       	jmp    40003850 <__svfscanf_r+0x100>
4000458f:	90                   	nop    
40004590:	83 f8 fe             	cmp    $0xfffffffe,%eax
40004593:	74 c5                	je     4000455a <__svfscanf_r+0xe0a>
40004595:	8b 95 70 fd ff ff    	mov    -0x290(%ebp),%edx
4000459b:	8b 02                	mov    (%edx),%eax
4000459d:	e9 6c ff ff ff       	jmp    4000450e <__svfscanf_r+0xdbe>
400045a2:	f6 85 f8 fc ff ff 10 	testb  $0x10,-0x308(%ebp)
400045a9:	0f 85 a1 00 00 00    	jne    40004650 <__svfscanf_r+0xf00>
400045af:	8b 45 14             	mov    0x14(%ebp),%eax
400045b2:	8b 00                	mov    (%eax),%eax
400045b4:	89 85 38 fd ff ff    	mov    %eax,-0x2c8(%ebp)
400045ba:	89 85 48 fd ff ff    	mov    %eax,-0x2b8(%ebp)
400045c0:	eb 3e                	jmp    40004600 <__svfscanf_r+0xeb0>
400045c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
400045c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
400045d0:	8b 43 04             	mov    0x4(%ebx),%eax
400045d3:	8b 95 38 fd ff ff    	mov    -0x2c8(%ebp),%edx
400045d9:	48                   	dec    %eax
400045da:	89 43 04             	mov    %eax,0x4(%ebx)
400045dd:	8a 01                	mov    (%ecx),%al
400045df:	88 02                	mov    %al,(%edx)
400045e1:	42                   	inc    %edx
400045e2:	ff 8d ec fc ff ff    	decl   -0x314(%ebp)
400045e8:	8d 41 01             	lea    0x1(%ecx),%eax
400045eb:	89 95 38 fd ff ff    	mov    %edx,-0x2c8(%ebp)
400045f1:	89 03                	mov    %eax,(%ebx)
400045f3:	74 1c                	je     40004611 <__svfscanf_r+0xec1>
400045f5:	8b 43 04             	mov    0x4(%ebx),%eax
400045f8:	85 c0                	test   %eax,%eax
400045fa:	0f 8e e2 06 00 00    	jle    40004ce2 <__svfscanf_r+0x1592>
40004600:	8b 0b                	mov    (%ebx),%ecx
40004602:	31 d2                	xor    %edx,%edx
40004604:	a1 90 d8 00 40       	mov    0x4000d890,%eax
40004609:	8a 11                	mov    (%ecx),%dl
4000460b:	f6 04 02 08          	testb  $0x8,(%edx,%eax,1)
4000460f:	74 bf                	je     400045d0 <__svfscanf_r+0xe80>
40004611:	8b 4d 14             	mov    0x14(%ebp),%ecx
40004614:	89 f0                	mov    %esi,%eax
40004616:	83 c1 04             	add    $0x4,%ecx
40004619:	89 4d 14             	mov    %ecx,0x14(%ebp)
4000461c:	8b 8d 38 fd ff ff    	mov    -0x2c8(%ebp),%ecx
40004622:	c6 01 00             	movb   $0x0,(%ecx)
40004625:	8b 95 48 fd ff ff    	mov    -0x2b8(%ebp),%edx
4000462b:	29 d0                	sub    %edx,%eax
4000462d:	8d 34 08             	lea    (%eax,%ecx,1),%esi
40004630:	8b 85 fc fc ff ff    	mov    -0x304(%ebp),%eax
40004636:	40                   	inc    %eax
40004637:	89 85 fc fc ff ff    	mov    %eax,-0x304(%ebp)
4000463d:	e9 4c f1 ff ff       	jmp    4000378e <__svfscanf_r+0x3e>
40004642:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40004649:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40004650:	8b 15 90 d8 00 40    	mov    0x4000d890,%edx
40004656:	c7 85 54 fd ff ff 00 	movl   $0x0,-0x2ac(%ebp)
4000465d:	00 00 00 
40004660:	eb 32                	jmp    40004694 <__svfscanf_r+0xf44>
40004662:	8b 85 54 fd ff ff    	mov    -0x2ac(%ebp),%eax
40004668:	8b 8d ec fc ff ff    	mov    -0x314(%ebp),%ecx
4000466e:	40                   	inc    %eax
4000466f:	89 85 54 fd ff ff    	mov    %eax,-0x2ac(%ebp)
40004675:	8b 43 04             	mov    0x4(%ebx),%eax
40004678:	48                   	dec    %eax
40004679:	89 43 04             	mov    %eax,0x4(%ebx)
4000467c:	8b 03                	mov    (%ebx),%eax
4000467e:	40                   	inc    %eax
4000467f:	39 8d 54 fd ff ff    	cmp    %ecx,-0x2ac(%ebp)
40004685:	89 03                	mov    %eax,(%ebx)
40004687:	74 1a                	je     400046a3 <__svfscanf_r+0xf53>
40004689:	8b 4b 04             	mov    0x4(%ebx),%ecx
4000468c:	85 c9                	test   %ecx,%ecx
4000468e:	0f 8e 2c 06 00 00    	jle    40004cc0 <__svfscanf_r+0x1570>
40004694:	8b 03                	mov    (%ebx),%eax
40004696:	8a 00                	mov    (%eax),%al
40004698:	25 ff 00 00 00       	and    $0xff,%eax
4000469d:	f6 04 10 08          	testb  $0x8,(%eax,%edx,1)
400046a1:	74 bf                	je     40004662 <__svfscanf_r+0xf12>
400046a3:	8b 85 54 fd ff ff    	mov    -0x2ac(%ebp),%eax
400046a9:	01 c6                	add    %eax,%esi
400046ab:	e9 de f0 ff ff       	jmp    4000378e <__svfscanf_r+0x3e>
400046b0:	c7 85 04 fd ff ff 00 	movl   $0x0,-0x2fc(%ebp)
400046b7:	00 00 00 
400046ba:	e9 46 f6 ff ff       	jmp    40003d05 <__svfscanf_r+0x5b5>
400046bf:	f6 85 f8 fc ff ff 10 	testb  $0x10,-0x308(%ebp)
400046c6:	0f 84 c4 05 00 00    	je     40004c90 <__svfscanf_r+0x1540>
400046cc:	c7 85 10 fd ff ff 00 	movl   $0x0,-0x2f0(%ebp)
400046d3:	00 00 00 
400046d6:	eb 3f                	jmp    40004717 <__svfscanf_r+0xfc7>
400046d8:	8b 85 10 fd ff ff    	mov    -0x2f0(%ebp),%eax
400046de:	01 c8                	add    %ecx,%eax
400046e0:	89 85 10 fd ff ff    	mov    %eax,-0x2f0(%ebp)
400046e6:	8b 03                	mov    (%ebx),%eax
400046e8:	01 c8                	add    %ecx,%eax
400046ea:	89 03                	mov    %eax,(%ebx)
400046ec:	50                   	push   %eax
400046ed:	50                   	push   %eax
400046ee:	8b 45 08             	mov    0x8(%ebp),%eax
400046f1:	53                   	push   %ebx
400046f2:	50                   	push   %eax
400046f3:	e8 28 4a 00 00       	call   40009120 <__srefill_r>
400046f8:	83 c4 10             	add    $0x10,%esp
400046fb:	85 c0                	test   %eax,%eax
400046fd:	0f 85 fb 05 00 00    	jne    40004cfe <__svfscanf_r+0x15ae>
40004703:	8b 8d ec fc ff ff    	mov    -0x314(%ebp),%ecx
40004709:	8b 95 58 fd ff ff    	mov    -0x2a8(%ebp),%edx
4000470f:	29 d1                	sub    %edx,%ecx
40004711:	89 8d ec fc ff ff    	mov    %ecx,-0x314(%ebp)
40004717:	8b 4b 04             	mov    0x4(%ebx),%ecx
4000471a:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
40004720:	89 8d 58 fd ff ff    	mov    %ecx,-0x2a8(%ebp)
40004726:	39 c1                	cmp    %eax,%ecx
40004728:	7c ae                	jl     400046d8 <__svfscanf_r+0xf88>
4000472a:	8b 8d ec fc ff ff    	mov    -0x314(%ebp),%ecx
40004730:	8b 85 10 fd ff ff    	mov    -0x2f0(%ebp),%eax
40004736:	01 c8                	add    %ecx,%eax
40004738:	89 85 10 fd ff ff    	mov    %eax,-0x2f0(%ebp)
4000473e:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
40004744:	29 c8                	sub    %ecx,%eax
40004746:	89 85 58 fd ff ff    	mov    %eax,-0x2a8(%ebp)
4000474c:	8b 85 58 fd ff ff    	mov    -0x2a8(%ebp),%eax
40004752:	89 43 04             	mov    %eax,0x4(%ebx)
40004755:	8b 03                	mov    (%ebx),%eax
40004757:	01 c8                	add    %ecx,%eax
40004759:	89 03                	mov    %eax,(%ebx)
4000475b:	e9 ac 05 00 00       	jmp    40004d0c <__svfscanf_r+0x15bc>
40004760:	8b 4d 08             	mov    0x8(%ebp),%ecx
40004763:	50                   	push   %eax
40004764:	50                   	push   %eax
40004765:	53                   	push   %ebx
40004766:	51                   	push   %ecx
40004767:	e8 b4 49 00 00       	call   40009120 <__srefill_r>
4000476c:	83 c4 10             	add    $0x10,%esp
4000476f:	85 c0                	test   %eax,%eax
40004771:	0f 84 fc f5 ff ff    	je     40003d73 <__svfscanf_r+0x623>
40004777:	8b 95 f4 fc ff ff    	mov    -0x30c(%ebp),%edx
4000477d:	85 d2                	test   %edx,%edx
4000477f:	0f 85 cb f0 ff ff    	jne    40003850 <__svfscanf_r+0x100>
40004785:	8b 85 5c fd ff ff    	mov    -0x2a4(%ebp),%eax
4000478b:	85 c0                	test   %eax,%eax
4000478d:	0f 85 fb ef ff ff    	jne    4000378e <__svfscanf_r+0x3e>
40004793:	e9 98 fe ff ff       	jmp    40004630 <__svfscanf_r+0xee0>
40004798:	90                   	nop    
40004799:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
400047a0:	8b 85 f8 fc ff ff    	mov    -0x308(%ebp),%eax
400047a6:	83 c8 10             	or     $0x10,%eax
400047a9:	89 85 f8 fc ff ff    	mov    %eax,-0x308(%ebp)
400047af:	8a 07                	mov    (%edi),%al
400047b1:	e9 c9 f0 ff ff       	jmp    4000387f <__svfscanf_r+0x12f>
400047b6:	c7 85 e8 fc ff ff 03 	movl   $0x3,-0x318(%ebp)
400047bd:	00 00 00 
400047c0:	c7 85 00 fd ff ff 0a 	movl   $0xa,-0x300(%ebp)
400047c7:	00 00 00 
400047ca:	c7 85 08 fd ff ff e0 	movl   $0x4000a9e0,-0x2f8(%ebp)
400047d1:	a9 00 40 
400047d4:	e9 e5 f0 ff ff       	jmp    400038be <__svfscanf_r+0x16e>
400047d9:	8a 07                	mov    (%edi),%al
400047db:	3c 6c                	cmp    $0x6c,%al
400047dd:	0f 84 e6 01 00 00    	je     400049c9 <__svfscanf_r+0x1279>
400047e3:	8b 8d f8 fc ff ff    	mov    -0x308(%ebp),%ecx
400047e9:	83 c9 01             	or     $0x1,%ecx
400047ec:	89 8d f8 fc ff ff    	mov    %ecx,-0x308(%ebp)
400047f2:	e9 88 f0 ff ff       	jmp    4000387f <__svfscanf_r+0x12f>
400047f7:	89 f6                	mov    %esi,%esi
400047f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40004800:	c7 85 08 fd ff ff f0 	movl   $0x4000a7f0,-0x2f8(%ebp)
40004807:	a7 00 40 
4000480a:	c7 85 e8 fc ff ff 03 	movl   $0x3,-0x318(%ebp)
40004811:	00 00 00 
40004814:	c7 85 00 fd ff ff 00 	movl   $0x0,-0x300(%ebp)
4000481b:	00 00 00 
4000481e:	e9 9b f0 ff ff       	jmp    400038be <__svfscanf_r+0x16e>
40004823:	8b 85 f8 fc ff ff    	mov    -0x308(%ebp),%eax
40004829:	83 c8 01             	or     $0x1,%eax
4000482c:	89 85 f8 fc ff ff    	mov    %eax,-0x308(%ebp)
40004832:	8b 85 f8 fc ff ff    	mov    -0x308(%ebp),%eax
40004838:	c7 85 e8 fc ff ff 00 	movl   $0x0,-0x318(%ebp)
4000483f:	00 00 00 
40004842:	83 c8 40             	or     $0x40,%eax
40004845:	89 85 f8 fc ff ff    	mov    %eax,-0x308(%ebp)
4000484b:	e9 6e f0 ff ff       	jmp    400038be <__svfscanf_r+0x16e>
40004850:	8d 95 dc fe ff ff    	lea    -0x124(%ebp),%edx
40004856:	50                   	push   %eax
40004857:	50                   	push   %eax
40004858:	57                   	push   %edi
40004859:	52                   	push   %edx
4000485a:	e8 e1 4a 00 00       	call   40009340 <__sccl>
4000485f:	89 c7                	mov    %eax,%edi
40004861:	8b 85 f8 fc ff ff    	mov    -0x308(%ebp),%eax
40004867:	83 c8 40             	or     $0x40,%eax
4000486a:	83 c4 10             	add    $0x10,%esp
4000486d:	89 85 f8 fc ff ff    	mov    %eax,-0x308(%ebp)
40004873:	c7 85 e8 fc ff ff 01 	movl   $0x1,-0x318(%ebp)
4000487a:	00 00 00 
4000487d:	e9 3c f0 ff ff       	jmp    400038be <__svfscanf_r+0x16e>
40004882:	8b 85 f8 fc ff ff    	mov    -0x308(%ebp),%eax
40004888:	c7 85 e8 fc ff ff 03 	movl   $0x3,-0x318(%ebp)
4000488f:	00 00 00 
40004892:	80 cc 02             	or     $0x2,%ah
40004895:	c7 85 00 fd ff ff 10 	movl   $0x10,-0x300(%ebp)
4000489c:	00 00 00 
4000489f:	89 85 f8 fc ff ff    	mov    %eax,-0x308(%ebp)
400048a5:	c7 85 08 fd ff ff e0 	movl   $0x4000a9e0,-0x2f8(%ebp)
400048ac:	a9 00 40 
400048af:	e9 0a f0 ff ff       	jmp    400038be <__svfscanf_r+0x16e>
400048b4:	50                   	push   %eax
400048b5:	50                   	push   %eax
400048b6:	8b 45 08             	mov    0x8(%ebp),%eax
400048b9:	53                   	push   %ebx
400048ba:	50                   	push   %eax
400048bb:	e8 60 48 00 00       	call   40009120 <__srefill_r>
400048c0:	83 c4 10             	add    $0x10,%esp
400048c3:	85 c0                	test   %eax,%eax
400048c5:	0f 84 fe ef ff ff    	je     400038c9 <__svfscanf_r+0x179>
400048cb:	e9 80 ef ff ff       	jmp    40003850 <__svfscanf_r+0x100>
400048d0:	8a 07                	mov    (%edi),%al
400048d2:	3c 68                	cmp    $0x68,%al
400048d4:	0f 84 92 00 00 00    	je     4000496c <__svfscanf_r+0x121c>
400048da:	8b 8d f8 fc ff ff    	mov    -0x308(%ebp),%ecx
400048e0:	83 c9 04             	or     $0x4,%ecx
400048e3:	89 8d f8 fc ff ff    	mov    %ecx,-0x308(%ebp)
400048e9:	e9 91 ef ff ff       	jmp    4000387f <__svfscanf_r+0x12f>
400048ee:	66 90                	xchg   %ax,%ax
400048f0:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
400048f6:	8d 04 80             	lea    (%eax,%eax,4),%eax
400048f9:	8d 4c 41 d0          	lea    -0x30(%ecx,%eax,2),%ecx
400048fd:	89 8d ec fc ff ff    	mov    %ecx,-0x314(%ebp)
40004903:	8a 07                	mov    (%edi),%al
40004905:	e9 75 ef ff ff       	jmp    4000387f <__svfscanf_r+0x12f>
4000490a:	c7 85 e8 fc ff ff 04 	movl   $0x4,-0x318(%ebp)
40004911:	00 00 00 
40004914:	e9 a5 ef ff ff       	jmp    400038be <__svfscanf_r+0x16e>
40004919:	8b 85 f8 fc ff ff    	mov    -0x308(%ebp),%eax
4000491f:	83 c8 02             	or     $0x2,%eax
40004922:	89 85 f8 fc ff ff    	mov    %eax,-0x308(%ebp)
40004928:	8a 07                	mov    (%edi),%al
4000492a:	e9 50 ef ff ff       	jmp    4000387f <__svfscanf_r+0x12f>
4000492f:	f6 85 6c fd ff ff 02 	testb  $0x2,-0x294(%ebp)
40004936:	74 4b                	je     40004983 <__svfscanf_r+0x1233>
40004938:	8b 55 14             	mov    0x14(%ebp),%edx
4000493b:	8b 4d 14             	mov    0x14(%ebp),%ecx
4000493e:	83 c1 04             	add    $0x4,%ecx
40004941:	8b 02                	mov    (%edx),%eax
40004943:	89 8d 64 fd ff ff    	mov    %ecx,-0x29c(%ebp)
40004949:	db 38                	fstpt  (%eax)
4000494b:	e9 64 f1 ff ff       	jmp    40003ab4 <__svfscanf_r+0x364>
40004950:	83 bd 30 fd ff ff 02 	cmpl   $0x2,-0x2d0(%ebp)
40004957:	0f 85 83 00 00 00    	jne    400049e0 <__svfscanf_r+0x1290>
4000495d:	c7 85 30 fd ff ff 03 	movl   $0x3,-0x2d0(%ebp)
40004964:	00 00 00 
40004967:	e9 8b f9 ff ff       	jmp    400042f7 <__svfscanf_r+0xba7>
4000496c:	8b 85 f8 fc ff ff    	mov    -0x308(%ebp),%eax
40004972:	47                   	inc    %edi
40004973:	83 c8 08             	or     $0x8,%eax
40004976:	89 85 f8 fc ff ff    	mov    %eax,-0x308(%ebp)
4000497c:	8a 07                	mov    (%edi),%al
4000497e:	e9 fc ee ff ff       	jmp    4000387f <__svfscanf_r+0x12f>
40004983:	83 ec 10             	sub    $0x10,%esp
40004986:	8b 45 14             	mov    0x14(%ebp),%eax
40004989:	8b 4d 14             	mov    0x14(%ebp),%ecx
4000498c:	8b 00                	mov    (%eax),%eax
4000498e:	83 c1 04             	add    $0x4,%ecx
40004991:	dd 14 24             	fstl   (%esp)
40004994:	89 8d 64 fd ff ff    	mov    %ecx,-0x29c(%ebp)
4000499a:	89 85 0c fd ff ff    	mov    %eax,-0x2f4(%ebp)
400049a0:	dd 9d d8 fc ff ff    	fstpl  -0x328(%ebp)
400049a6:	e8 65 49 00 00       	call   40009310 <__isnand>
400049ab:	83 c4 10             	add    $0x10,%esp
400049ae:	dd 85 d8 fc ff ff    	fldl   -0x328(%ebp)
400049b4:	85 c0                	test   %eax,%eax
400049b6:	0f 85 5d 03 00 00    	jne    40004d19 <__svfscanf_r+0x15c9>
400049bc:	8b 8d 0c fd ff ff    	mov    -0x2f4(%ebp),%ecx
400049c2:	d9 19                	fstps  (%ecx)
400049c4:	e9 eb f0 ff ff       	jmp    40003ab4 <__svfscanf_r+0x364>
400049c9:	8b 85 f8 fc ff ff    	mov    -0x308(%ebp),%eax
400049cf:	47                   	inc    %edi
400049d0:	83 c8 02             	or     $0x2,%eax
400049d3:	89 85 f8 fc ff ff    	mov    %eax,-0x308(%ebp)
400049d9:	8a 07                	mov    (%edi),%al
400049db:	e9 9f ee ff ff       	jmp    4000387f <__svfscanf_r+0x12f>
400049e0:	83 bd 30 fd ff ff 03 	cmpl   $0x3,-0x2d0(%ebp)
400049e7:	b2 01                	mov    $0x1,%dl
400049e9:	0f 95 c0             	setne  %al
400049ec:	e9 84 f7 ff ff       	jmp    40004175 <__svfscanf_r+0xa25>
400049f1:	31 d2                	xor    %edx,%edx
400049f3:	b0 01                	mov    $0x1,%al
400049f5:	e9 7b f7 ff ff       	jmp    40004175 <__svfscanf_r+0xa25>
400049fa:	8b 85 68 fd ff ff    	mov    -0x298(%ebp),%eax
40004a00:	c7 85 00 fd ff ff 08 	movl   $0x8,-0x300(%ebp)
40004a07:	00 00 00 
40004a0a:	80 cc 02             	or     $0x2,%ah
40004a0d:	89 85 68 fd ff ff    	mov    %eax,-0x298(%ebp)
40004a13:	e9 60 f6 ff ff       	jmp    40004078 <__svfscanf_r+0x928>
40004a18:	8b 85 3c fd ff ff    	mov    -0x2c4(%ebp),%eax
40004a1e:	c6 00 00             	movb   $0x0,(%eax)
40004a21:	8b 85 00 fd ff ff    	mov    -0x300(%ebp),%eax
40004a27:	50                   	push   %eax
40004a28:	8b 85 e4 fc ff ff    	mov    -0x31c(%ebp),%eax
40004a2e:	6a 00                	push   $0x0
40004a30:	50                   	push   %eax
40004a31:	8b 45 08             	mov    0x8(%ebp),%eax
40004a34:	50                   	push   %eax
40004a35:	ff 95 08 fd ff ff    	call   *-0x2f8(%ebp)
40004a3b:	83 c4 10             	add    $0x10,%esp
40004a3e:	89 c2                	mov    %eax,%edx
40004a40:	f6 85 68 fd ff ff 20 	testb  $0x20,-0x298(%ebp)
40004a47:	0f 85 88 00 00 00    	jne    40004ad5 <__svfscanf_r+0x1385>
40004a4d:	f6 85 68 fd ff ff 08 	testb  $0x8,-0x298(%ebp)
40004a54:	74 66                	je     40004abc <__svfscanf_r+0x136c>
40004a56:	8b 4d 14             	mov    0x14(%ebp),%ecx
40004a59:	8b 01                	mov    (%ecx),%eax
40004a5b:	83 c1 04             	add    $0x4,%ecx
40004a5e:	88 10                	mov    %dl,(%eax)
40004a60:	89 4d 14             	mov    %ecx,0x14(%ebp)
40004a63:	8b 8d fc fc ff ff    	mov    -0x304(%ebp),%ecx
40004a69:	41                   	inc    %ecx
40004a6a:	89 8d fc fc ff ff    	mov    %ecx,-0x304(%ebp)
40004a70:	e9 d4 f4 ff ff       	jmp    40003f49 <__svfscanf_r+0x7f9>
40004a75:	8b 85 14 fd ff ff    	mov    -0x2ec(%ebp),%eax
40004a7b:	85 c0                	test   %eax,%eax
40004a7d:	74 1a                	je     40004a99 <__svfscanf_r+0x1349>
40004a7f:	8b 85 14 fd ff ff    	mov    -0x2ec(%ebp),%eax
40004a85:	48                   	dec    %eax
40004a86:	89 85 14 fd ff ff    	mov    %eax,-0x2ec(%ebp)
40004a8c:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
40004a92:	40                   	inc    %eax
40004a93:	89 85 ec fc ff ff    	mov    %eax,-0x314(%ebp)
40004a99:	8b 85 68 fd ff ff    	mov    -0x298(%ebp),%eax
40004a9f:	25 7f fc ff ff       	and    $0xfffffc7f,%eax
40004aa4:	89 85 68 fd ff ff    	mov    %eax,-0x298(%ebp)
40004aaa:	8b 85 18 fd ff ff    	mov    -0x2e8(%ebp),%eax
40004ab0:	40                   	inc    %eax
40004ab1:	89 85 18 fd ff ff    	mov    %eax,-0x2e8(%ebp)
40004ab7:	e9 09 f5 ff ff       	jmp    40003fc5 <__svfscanf_r+0x875>
40004abc:	f6 85 68 fd ff ff 04 	testb  $0x4,-0x298(%ebp)
40004ac3:	74 10                	je     40004ad5 <__svfscanf_r+0x1385>
40004ac5:	8b 4d 14             	mov    0x14(%ebp),%ecx
40004ac8:	8b 01                	mov    (%ecx),%eax
40004aca:	83 c1 04             	add    $0x4,%ecx
40004acd:	89 4d 14             	mov    %ecx,0x14(%ebp)
40004ad0:	66 89 10             	mov    %dx,(%eax)
40004ad3:	eb 8e                	jmp    40004a63 <__svfscanf_r+0x1313>
40004ad5:	8b 4d 14             	mov    0x14(%ebp),%ecx
40004ad8:	8b 01                	mov    (%ecx),%eax
40004ada:	83 c1 04             	add    $0x4,%ecx
40004add:	89 10                	mov    %edx,(%eax)
40004adf:	89 4d 14             	mov    %ecx,0x14(%ebp)
40004ae2:	e9 7c ff ff ff       	jmp    40004a63 <__svfscanf_r+0x1313>
40004ae7:	8b 8d 3c fd ff ff    	mov    -0x2c4(%ebp),%ecx
40004aed:	52                   	push   %edx
40004aee:	49                   	dec    %ecx
40004aef:	52                   	push   %edx
40004af0:	89 8d 3c fd ff ff    	mov    %ecx,-0x2c4(%ebp)
40004af6:	53                   	push   %ebx
40004af7:	50                   	push   %eax
40004af8:	e8 d3 62 00 00       	call   4000add0 <ungetc>
40004afd:	83 c4 10             	add    $0x10,%esp
40004b00:	e9 37 f4 ff ff       	jmp    40003f3c <__svfscanf_r+0x7ec>
40004b05:	8b 85 3c fd ff ff    	mov    -0x2c4(%ebp),%eax
40004b0b:	39 85 e4 fc ff ff    	cmp    %eax,-0x31c(%ebp)
40004b11:	0f 83 ce ec ff ff    	jae    400037e5 <__svfscanf_r+0x95>
40004b17:	56                   	push   %esi
40004b18:	56                   	push   %esi
40004b19:	53                   	push   %ebx
40004b1a:	0f be 40 ff          	movsbl -0x1(%eax),%eax
40004b1e:	50                   	push   %eax
40004b1f:	e8 ac 62 00 00       	call   4000add0 <ungetc>
40004b24:	83 c4 10             	add    $0x10,%esp
40004b27:	e9 b9 ec ff ff       	jmp    400037e5 <__svfscanf_r+0x95>
40004b2c:	8b 4d 14             	mov    0x14(%ebp),%ecx
40004b2f:	89 f2                	mov    %esi,%edx
40004b31:	8b 01                	mov    (%ecx),%eax
40004b33:	83 c1 04             	add    $0x4,%ecx
40004b36:	88 10                	mov    %dl,(%eax)
40004b38:	89 4d 14             	mov    %ecx,0x14(%ebp)
40004b3b:	e9 4e ec ff ff       	jmp    4000378e <__svfscanf_r+0x3e>
40004b40:	f6 85 f8 fc ff ff 01 	testb  $0x1,-0x308(%ebp)
40004b47:	74 34                	je     40004b7d <__svfscanf_r+0x142d>
40004b49:	8b 55 14             	mov    0x14(%ebp),%edx
40004b4c:	8b 02                	mov    (%edx),%eax
40004b4e:	83 c2 04             	add    $0x4,%edx
40004b51:	89 55 14             	mov    %edx,0x14(%ebp)
40004b54:	89 30                	mov    %esi,(%eax)
40004b56:	e9 33 ec ff ff       	jmp    4000378e <__svfscanf_r+0x3e>
40004b5b:	c7 85 14 fd ff ff 00 	movl   $0x0,-0x2ec(%ebp)
40004b62:	00 00 00 
40004b65:	e9 73 f3 ff ff       	jmp    40003edd <__svfscanf_r+0x78d>
40004b6a:	8b 85 4c fd ff ff    	mov    -0x2b4(%ebp),%eax
40004b70:	85 c0                	test   %eax,%eax
40004b72:	0f 85 dc f0 ff ff    	jne    40003c54 <__svfscanf_r+0x504>
40004b78:	e9 68 ec ff ff       	jmp    400037e5 <__svfscanf_r+0x95>
40004b7d:	8b 4d 14             	mov    0x14(%ebp),%ecx
40004b80:	8b 01                	mov    (%ecx),%eax
40004b82:	83 c1 04             	add    $0x4,%ecx
40004b85:	89 4d 14             	mov    %ecx,0x14(%ebp)
40004b88:	89 30                	mov    %esi,(%eax)
40004b8a:	e9 ff eb ff ff       	jmp    4000378e <__svfscanf_r+0x3e>
40004b8f:	8b 85 50 fd ff ff    	mov    -0x2b0(%ebp),%eax
40004b95:	85 c0                	test   %eax,%eax
40004b97:	0f 84 be f8 ff ff    	je     4000445b <__svfscanf_r+0xd0b>
40004b9d:	8b 8d e4 fc ff ff    	mov    -0x31c(%ebp),%ecx
40004ba3:	8b 85 50 fd ff ff    	mov    -0x2b0(%ebp),%eax
40004ba9:	01 c1                	add    %eax,%ecx
40004bab:	89 8d 34 fd ff ff    	mov    %ecx,-0x2cc(%ebp)
40004bb1:	8b 95 34 fd ff ff    	mov    -0x2cc(%ebp),%edx
40004bb7:	51                   	push   %ecx
40004bb8:	51                   	push   %ecx
40004bb9:	53                   	push   %ebx
40004bba:	0f be 42 ff          	movsbl -0x1(%edx),%eax
40004bbe:	50                   	push   %eax
40004bbf:	e8 0c 62 00 00       	call   4000add0 <ungetc>
40004bc4:	8b 95 34 fd ff ff    	mov    -0x2cc(%ebp),%edx
40004bca:	8b 8d e4 fc ff ff    	mov    -0x31c(%ebp),%ecx
40004bd0:	4a                   	dec    %edx
40004bd1:	83 c4 10             	add    $0x10,%esp
40004bd4:	89 95 34 fd ff ff    	mov    %edx,-0x2cc(%ebp)
40004bda:	39 8d 34 fd ff ff    	cmp    %ecx,-0x2cc(%ebp)
40004be0:	75 cf                	jne    40004bb1 <__svfscanf_r+0x1461>
40004be2:	e9 74 f8 ff ff       	jmp    4000445b <__svfscanf_r+0xd0b>
40004be7:	8b 85 28 fd ff ff    	mov    -0x2d8(%ebp),%eax
40004bed:	6a 0a                	push   $0xa
40004bef:	40                   	inc    %eax
40004bf0:	6a 00                	push   $0x0
40004bf2:	50                   	push   %eax
40004bf3:	8b 45 08             	mov    0x8(%ebp),%eax
40004bf6:	50                   	push   %eax
40004bf7:	e8 f4 5b 00 00       	call   4000a7f0 <_strtol_r>
40004bfc:	8b 8d 24 fd ff ff    	mov    -0x2dc(%ebp),%ecx
40004c02:	83 c4 10             	add    $0x10,%esp
40004c05:	29 c8                	sub    %ecx,%eax
40004c07:	8b 8d 28 fd ff ff    	mov    -0x2d8(%ebp),%ecx
40004c0d:	39 8d d0 fc ff ff    	cmp    %ecx,-0x330(%ebp)
40004c13:	77 0c                	ja     40004c21 <__svfscanf_r+0x14d1>
40004c15:	8d 95 d0 fe ff ff    	lea    -0x130(%ebp),%edx
40004c1b:	89 95 28 fd ff ff    	mov    %edx,-0x2d8(%ebp)
40004c21:	52                   	push   %edx
40004c22:	50                   	push   %eax
40004c23:	8b 85 28 fd ff ff    	mov    -0x2d8(%ebp),%eax
40004c29:	68 20 be 00 40       	push   $0x4000be20
40004c2e:	50                   	push   %eax
40004c2f:	e8 fc 47 00 00       	call   40009430 <sprintf>
40004c34:	83 c4 10             	add    $0x10,%esp
40004c37:	e9 42 ee ff ff       	jmp    40003a7e <__svfscanf_r+0x32e>
40004c3c:	8b 85 20 fd ff ff    	mov    -0x2e0(%ebp),%eax
40004c42:	2b 85 1c fd ff ff    	sub    -0x2e4(%ebp),%eax
40004c48:	0f 84 30 ee ff ff    	je     40003a7e <__svfscanf_r+0x32e>
40004c4e:	8b 95 40 fd ff ff    	mov    -0x2c0(%ebp),%edx
40004c54:	f7 d8                	neg    %eax
40004c56:	89 95 28 fd ff ff    	mov    %edx,-0x2d8(%ebp)
40004c5c:	eb a9                	jmp    40004c07 <__svfscanf_r+0x14b7>
40004c5e:	8b 85 40 fd ff ff    	mov    -0x2c0(%ebp),%eax
40004c64:	39 85 e4 fc ff ff    	cmp    %eax,-0x31c(%ebp)
40004c6a:	0f 83 75 eb ff ff    	jae    400037e5 <__svfscanf_r+0x95>
40004c70:	89 c6                	mov    %eax,%esi
40004c72:	57                   	push   %edi
40004c73:	57                   	push   %edi
40004c74:	53                   	push   %ebx
40004c75:	0f be 46 ff          	movsbl -0x1(%esi),%eax
40004c79:	4e                   	dec    %esi
40004c7a:	50                   	push   %eax
40004c7b:	e8 50 61 00 00       	call   4000add0 <ungetc>
40004c80:	83 c4 10             	add    $0x10,%esp
40004c83:	39 b5 e4 fc ff ff    	cmp    %esi,-0x31c(%ebp)
40004c89:	72 e7                	jb     40004c72 <__svfscanf_r+0x1522>
40004c8b:	e9 55 eb ff ff       	jmp    400037e5 <__svfscanf_r+0x95>
40004c90:	8b 85 ec fc ff ff    	mov    -0x314(%ebp),%eax
40004c96:	8b 55 14             	mov    0x14(%ebp),%edx
40004c99:	53                   	push   %ebx
40004c9a:	50                   	push   %eax
40004c9b:	6a 01                	push   $0x1
40004c9d:	8b 0a                	mov    (%edx),%ecx
40004c9f:	51                   	push   %ecx
40004ca0:	e8 9b 21 00 00       	call   40006e40 <fread>
40004ca5:	83 c4 10             	add    $0x10,%esp
40004ca8:	85 c0                	test   %eax,%eax
40004caa:	0f 84 a0 eb ff ff    	je     40003850 <__svfscanf_r+0x100>
40004cb0:	8b 55 14             	mov    0x14(%ebp),%edx
40004cb3:	01 c6                	add    %eax,%esi
40004cb5:	83 c2 04             	add    $0x4,%edx
40004cb8:	89 55 14             	mov    %edx,0x14(%ebp)
40004cbb:	e9 70 f9 ff ff       	jmp    40004630 <__svfscanf_r+0xee0>
40004cc0:	8b 45 08             	mov    0x8(%ebp),%eax
40004cc3:	52                   	push   %edx
40004cc4:	52                   	push   %edx
40004cc5:	53                   	push   %ebx
40004cc6:	50                   	push   %eax
40004cc7:	e8 54 44 00 00       	call   40009120 <__srefill_r>
40004ccc:	83 c4 10             	add    $0x10,%esp
40004ccf:	85 c0                	test   %eax,%eax
40004cd1:	0f 85 cc f9 ff ff    	jne    400046a3 <__svfscanf_r+0xf53>
40004cd7:	8b 15 90 d8 00 40    	mov    0x4000d890,%edx
40004cdd:	e9 b2 f9 ff ff       	jmp    40004694 <__svfscanf_r+0xf44>
40004ce2:	50                   	push   %eax
40004ce3:	50                   	push   %eax
40004ce4:	8b 45 08             	mov    0x8(%ebp),%eax
40004ce7:	53                   	push   %ebx
40004ce8:	50                   	push   %eax
40004ce9:	e8 32 44 00 00       	call   40009120 <__srefill_r>
40004cee:	83 c4 10             	add    $0x10,%esp
40004cf1:	85 c0                	test   %eax,%eax
40004cf3:	0f 84 07 f9 ff ff    	je     40004600 <__svfscanf_r+0xeb0>
40004cf9:	e9 13 f9 ff ff       	jmp    40004611 <__svfscanf_r+0xec1>
40004cfe:	8b 85 10 fd ff ff    	mov    -0x2f0(%ebp),%eax
40004d04:	85 c0                	test   %eax,%eax
40004d06:	0f 84 44 eb ff ff    	je     40003850 <__svfscanf_r+0x100>
40004d0c:	8b 85 10 fd ff ff    	mov    -0x2f0(%ebp),%eax
40004d12:	01 c6                	add    %eax,%esi
40004d14:	e9 75 ea ff ff       	jmp    4000378e <__svfscanf_r+0x3e>
40004d19:	dd d8                	fstp   %st(0)
40004d1b:	83 ec 0c             	sub    $0xc,%esp
40004d1e:	6a 00                	push   $0x0
40004d20:	e8 eb 46 00 00       	call   40009410 <nanf>
40004d25:	8b 95 0c fd ff ff    	mov    -0x2f4(%ebp),%edx
40004d2b:	83 c4 10             	add    $0x10,%esp
40004d2e:	d9 1a                	fstps  (%edx)
40004d30:	e9 7f ed ff ff       	jmp    40003ab4 <__svfscanf_r+0x364>
40004d35:	8d 74 26 00          	lea    0x0(%esi),%esi
40004d39:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40004d40 <__svfscanf>:
40004d40:	55                   	push   %ebp
40004d41:	89 e5                	mov    %esp,%ebp
40004d43:	83 ec 08             	sub    $0x8,%esp
40004d46:	8b 45 08             	mov    0x8(%ebp),%eax
40004d49:	8b 4d 10             	mov    0x10(%ebp),%ecx
40004d4c:	8b 55 0c             	mov    0xc(%ebp),%edx
40004d4f:	51                   	push   %ecx
40004d50:	52                   	push   %edx
40004d51:	50                   	push   %eax
40004d52:	a1 60 d0 00 40       	mov    0x4000d060,%eax
40004d57:	50                   	push   %eax
40004d58:	e8 f3 e9 ff ff       	call   40003750 <__svfscanf_r>
40004d5d:	c9                   	leave  
40004d5e:	c3                   	ret    
40004d5f:	90                   	nop    

40004d60 <_vfscanf_r>:
40004d60:	55                   	push   %ebp
40004d61:	89 e5                	mov    %esp,%ebp
40004d63:	57                   	push   %edi
40004d64:	56                   	push   %esi
40004d65:	53                   	push   %ebx
40004d66:	83 ec 0c             	sub    $0xc,%esp
40004d69:	8b 5d 08             	mov    0x8(%ebp),%ebx
40004d6c:	8b 45 0c             	mov    0xc(%ebp),%eax
40004d6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
40004d72:	8b 7d 10             	mov    0x10(%ebp),%edi
40004d75:	8b 75 14             	mov    0x14(%ebp),%esi
40004d78:	85 db                	test   %ebx,%ebx
40004d7a:	74 07                	je     40004d83 <_vfscanf_r+0x23>
40004d7c:	8b 43 38             	mov    0x38(%ebx),%eax
40004d7f:	85 c0                	test   %eax,%eax
40004d81:	74 1d                	je     40004da0 <_vfscanf_r+0x40>
40004d83:	8b 45 f0             	mov    -0x10(%ebp),%eax
40004d86:	89 75 14             	mov    %esi,0x14(%ebp)
40004d89:	89 7d 10             	mov    %edi,0x10(%ebp)
40004d8c:	89 45 0c             	mov    %eax,0xc(%ebp)
40004d8f:	89 5d 08             	mov    %ebx,0x8(%ebp)
40004d92:	8d 65 f4             	lea    -0xc(%ebp),%esp
40004d95:	5b                   	pop    %ebx
40004d96:	5e                   	pop    %esi
40004d97:	5f                   	pop    %edi
40004d98:	5d                   	pop    %ebp
40004d99:	e9 b2 e9 ff ff       	jmp    40003750 <__svfscanf_r>
40004d9e:	66 90                	xchg   %ax,%ax
40004da0:	83 ec 0c             	sub    $0xc,%esp
40004da3:	53                   	push   %ebx
40004da4:	e8 57 b6 ff ff       	call   40000400 <__sinit>
40004da9:	83 c4 10             	add    $0x10,%esp
40004dac:	eb d5                	jmp    40004d83 <_vfscanf_r+0x23>
40004dae:	66 90                	xchg   %ax,%ax

40004db0 <vfscanf>:
40004db0:	55                   	push   %ebp
40004db1:	89 e5                	mov    %esp,%ebp
40004db3:	83 ec 08             	sub    $0x8,%esp
40004db6:	a1 60 d0 00 40       	mov    0x4000d060,%eax
40004dbb:	85 c0                	test   %eax,%eax
40004dbd:	74 07                	je     40004dc6 <vfscanf+0x16>
40004dbf:	8b 50 38             	mov    0x38(%eax),%edx
40004dc2:	85 d2                	test   %edx,%edx
40004dc4:	74 1a                	je     40004de0 <vfscanf+0x30>
40004dc6:	8b 45 10             	mov    0x10(%ebp),%eax
40004dc9:	50                   	push   %eax
40004dca:	8b 45 0c             	mov    0xc(%ebp),%eax
40004dcd:	50                   	push   %eax
40004dce:	8b 45 08             	mov    0x8(%ebp),%eax
40004dd1:	50                   	push   %eax
40004dd2:	a1 60 d0 00 40       	mov    0x4000d060,%eax
40004dd7:	50                   	push   %eax
40004dd8:	e8 73 e9 ff ff       	call   40003750 <__svfscanf_r>
40004ddd:	c9                   	leave  
40004dde:	c3                   	ret    
40004ddf:	90                   	nop    
40004de0:	83 ec 0c             	sub    $0xc,%esp
40004de3:	50                   	push   %eax
40004de4:	e8 17 b6 ff ff       	call   40000400 <__sinit>
40004de9:	83 c4 10             	add    $0x10,%esp
40004dec:	eb d8                	jmp    40004dc6 <vfscanf+0x16>
40004dee:	90                   	nop    
40004def:	90                   	nop    

40004df0 <_wcrtomb_r>:
  to dl@cs.oswego.edu

* VERSION 2.6.4  Thu Nov 28 07:54:55 1996  Doug Lea  (dl at gee)
  
   Note: There may be an updated version of this malloc obtainable at
           ftp://g.oswego.edu/pub/misc/malloc.c
40004df0:	55                   	push   %ebp
40004df1:	89 e5                	mov    %esp,%ebp
40004df3:	56                   	push   %esi
40004df4:	53                   	push   %ebx
40004df5:	83 ec 10             	sub    $0x10,%esp
40004df8:	8b 45 0c             	mov    0xc(%ebp),%eax
40004dfb:	8b 75 08             	mov    0x8(%ebp),%esi
40004dfe:	8b 5d 14             	mov    0x14(%ebp),%ebx
  while also being among the most space-conserving, portable and tunable.
  Consistent balance across these factors results in a good general-purpose 
  allocator. For a high-level description, see 
     http://g.oswego.edu/dl/html/malloc.html

* Synopsis of public routines
40004e01:	85 c0                	test   %eax,%eax
40004e03:	74 2b                	je     40004e30 <_wcrtomb_r+0x40>

  (Much fuller descriptions are contained in the program documentation below.)

40004e05:	8b 55 10             	mov    0x10(%ebp),%edx
40004e08:	53                   	push   %ebx
40004e09:	52                   	push   %edx
40004e0a:	50                   	push   %eax
40004e0b:	56                   	push   %esi
40004e0c:	e8 bf 01 00 00       	call   40004fd0 <_wctomb_r>
40004e11:	83 c4 10             	add    $0x10,%esp
  malloc(size_t n);
     Return a pointer to a newly allocated chunk of at least n bytes, or null
40004e14:	83 f8 ff             	cmp    $0xffffffff,%eax
40004e17:	75 0c                	jne    40004e25 <_wcrtomb_r+0x35>
     if no space is available.
  free(Void_t* p);
40004e19:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
     Release the chunk of memory pointed to by p, or no effect if p is null.
40004e1f:	c7 06 8a 00 00 00    	movl   $0x8a,(%esi)
  realloc(Void_t* p, size_t n);
     Return a pointer to a chunk of size n that contains the same data
     as does chunk p up to the minimum of (n, p's size) bytes, or null
     if no space is available. The returned pointer may or may not be
     the same as p. If p is null, equivalent to malloc.  Unless the
40004e25:	8d 65 f8             	lea    -0x8(%ebp),%esp
40004e28:	5b                   	pop    %ebx
40004e29:	5e                   	pop    %esi
40004e2a:	5d                   	pop    %ebp
40004e2b:	c3                   	ret    
40004e2c:	8d 74 26 00          	lea    0x0(%esi),%esi
  Consistent balance across these factors results in a good general-purpose 
  allocator. For a high-level description, see 
     http://g.oswego.edu/dl/html/malloc.html

* Synopsis of public routines

40004e30:	8d 45 ee             	lea    -0x12(%ebp),%eax
40004e33:	53                   	push   %ebx
40004e34:	6a 00                	push   $0x0
40004e36:	50                   	push   %eax
40004e37:	56                   	push   %esi
40004e38:	e8 93 01 00 00       	call   40004fd0 <_wctomb_r>
40004e3d:	83 c4 10             	add    $0x10,%esp
40004e40:	eb d2                	jmp    40004e14 <_wcrtomb_r+0x24>
40004e42:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40004e49:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40004e50 <wcrtomb>:
  memalign(size_t alignment, size_t n);
     Return a pointer to a newly allocated chunk of n bytes, aligned
     in accord with the alignment argument, which must be a power of
     two.
  valloc(size_t n);
     Equivalent to memalign(pagesize, n), where pagesize is the page
40004e50:	55                   	push   %ebp
40004e51:	89 e5                	mov    %esp,%ebp
40004e53:	83 ec 08             	sub    $0x8,%esp
     size of the system (or as near to this as can be figured out from
40004e56:	8b 0d 60 d0 00 40    	mov    0x4000d060,%ecx
40004e5c:	8b 45 10             	mov    0x10(%ebp),%eax
40004e5f:	50                   	push   %eax
40004e60:	8b 45 0c             	mov    0xc(%ebp),%eax
40004e63:	50                   	push   %eax
40004e64:	8b 45 08             	mov    0x8(%ebp),%eax
40004e67:	50                   	push   %eax
40004e68:	51                   	push   %ecx
40004e69:	e8 82 ff ff ff       	call   40004df0 <_wcrtomb_r>
     all the includes/defines below.)
40004e6e:	c9                   	leave  
40004e6f:	c3                   	ret    

40004e70 <_wcsrtombs_r>:

* VERSION 2.6.4  Thu Nov 28 07:54:55 1996  Doug Lea  (dl at gee)
  
   Note: There may be an updated version of this malloc obtainable at
           ftp://g.oswego.edu/pub/misc/malloc.c
         Check before installing!
40004e70:	55                   	push   %ebp
40004e71:	89 e5                	mov    %esp,%ebp
40004e73:	57                   	push   %edi
40004e74:	56                   	push   %esi
40004e75:	53                   	push   %ebx
40004e76:	83 ec 1c             	sub    $0x1c,%esp
* Synopsis of public routines

  (Much fuller descriptions are contained in the program documentation below.)

  malloc(size_t n);
     Return a pointer to a newly allocated chunk of at least n bytes, or null
40004e79:	8b 45 0c             	mov    0xc(%ebp),%eax

* VERSION 2.6.4  Thu Nov 28 07:54:55 1996  Doug Lea  (dl at gee)
  
   Note: There may be an updated version of this malloc obtainable at
           ftp://g.oswego.edu/pub/misc/malloc.c
         Check before installing!
40004e7c:	8b 75 18             	mov    0x18(%ebp),%esi
* Synopsis of public routines

  (Much fuller descriptions are contained in the program documentation below.)

  malloc(size_t n);
     Return a pointer to a newly allocated chunk of at least n bytes, or null
40004e7f:	85 c0                	test   %eax,%eax
40004e81:	0f 84 d0 00 00 00    	je     40004f57 <_wcsrtombs_r+0xe7>
     if no space is available.
  free(Void_t* p);
     Release the chunk of memory pointed to by p, or no effect if p is null.
  realloc(Void_t* p, size_t n);
40004e87:	8b 45 10             	mov    0x10(%ebp),%eax
40004e8a:	8b 38                	mov    (%eax),%edi
     Return a pointer to a chunk of size n that contains the same data
     as does chunk p up to the minimum of (n, p's size) bytes, or null
40004e8c:	8b 45 14             	mov    0x14(%ebp),%eax
40004e8f:	85 c0                	test   %eax,%eax
40004e91:	0f 84 f9 00 00 00    	je     40004f90 <_wcsrtombs_r+0x120>
  malloc(size_t n);
     Return a pointer to a newly allocated chunk of at least n bytes, or null
     if no space is available.
  free(Void_t* p);
     Release the chunk of memory pointed to by p, or no effect if p is null.
  realloc(Void_t* p, size_t n);
40004e97:	8b 5d 0c             	mov    0xc(%ebp),%ebx
40004e9a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
     Return a pointer to a chunk of size n that contains the same data
     as does chunk p up to the minimum of (n, p's size) bytes, or null
     if no space is available. The returned pointer may or may not be
     the same as p. If p is null, equivalent to malloc.  Unless the
40004ea1:	8b 06                	mov    (%esi),%eax
40004ea3:	89 45 dc             	mov    %eax,-0x24(%ebp)
     #define REALLOC_ZERO_BYTES_FREES below is set, realloc with a
40004ea6:	8b 46 04             	mov    0x4(%esi),%eax
40004ea9:	89 45 e0             	mov    %eax,-0x20(%ebp)
     size argument of zero (re)allocates a minimum-sized chunk.
40004eac:	56                   	push   %esi
40004ead:	8b 07                	mov    (%edi),%eax
40004eaf:	50                   	push   %eax
40004eb0:	8d 45 ea             	lea    -0x16(%ebp),%eax
40004eb3:	50                   	push   %eax
40004eb4:	8b 45 08             	mov    0x8(%ebp),%eax
40004eb7:	50                   	push   %eax
40004eb8:	e8 33 ff ff ff       	call   40004df0 <_wcrtomb_r>
  memalign(size_t alignment, size_t n);
40004ebd:	83 c4 10             	add    $0x10,%esp
     Return a pointer to a chunk of size n that contains the same data
     as does chunk p up to the minimum of (n, p's size) bytes, or null
     if no space is available. The returned pointer may or may not be
     the same as p. If p is null, equivalent to malloc.  Unless the
     #define REALLOC_ZERO_BYTES_FREES below is set, realloc with a
     size argument of zero (re)allocates a minimum-sized chunk.
40004ec0:	89 c1                	mov    %eax,%ecx
  memalign(size_t alignment, size_t n);
40004ec2:	83 f8 ff             	cmp    $0xffffffff,%eax
40004ec5:	74 6f                	je     40004f36 <_wcsrtombs_r+0xc6>
     Return a pointer to a newly allocated chunk of n bytes, aligned
     in accord with the alignment argument, which must be a power of
     two.
  valloc(size_t n);
     Equivalent to memalign(pagesize, n), where pagesize is the page
     size of the system (or as near to this as can be figured out from
40004ec7:	8b 45 14             	mov    0x14(%ebp),%eax
40004eca:	29 c8                	sub    %ecx,%eax
40004ecc:	3b 45 d8             	cmp    -0x28(%ebp),%eax
40004ecf:	72 4f                	jb     40004f20 <_wcsrtombs_r+0xb0>
40004ed1:	3b 4d 14             	cmp    0x14(%ebp),%ecx
40004ed4:	73 4a                	jae    40004f20 <_wcsrtombs_r+0xb0>
     all the includes/defines below.)
  pvalloc(size_t n);
40004ed6:	8b 45 d8             	mov    -0x28(%ebp),%eax
40004ed9:	01 c8                	add    %ecx,%eax
40004edb:	89 45 d8             	mov    %eax,-0x28(%ebp)
     Equivalent to valloc(minimum-page-that-holds(n)), that is,
40004ede:	8b 45 0c             	mov    0xc(%ebp),%eax
40004ee1:	85 c0                	test   %eax,%eax
40004ee3:	74 23                	je     40004f08 <_wcsrtombs_r+0x98>
     round up n to nearest pagesize.
  calloc(size_t unit, size_t quantity);
40004ee5:	85 c9                	test   %ecx,%ecx
40004ee7:	7e 15                	jle    40004efe <_wcsrtombs_r+0x8e>
40004ee9:	31 d2                	xor    %edx,%edx
40004eeb:	90                   	nop    
40004eec:	8d 74 26 00          	lea    0x0(%esi),%esi
     Returns a pointer to quantity * unit bytes, with all locations
40004ef0:	8a 44 2a ea          	mov    -0x16(%edx,%ebp,1),%al
40004ef4:	88 04 1a             	mov    %al,(%edx,%ebx,1)
     size of the system (or as near to this as can be figured out from
     all the includes/defines below.)
  pvalloc(size_t n);
     Equivalent to valloc(minimum-page-that-holds(n)), that is,
     round up n to nearest pagesize.
  calloc(size_t unit, size_t quantity);
40004ef7:	42                   	inc    %edx
40004ef8:	39 d1                	cmp    %edx,%ecx
40004efa:	75 f4                	jne    40004ef0 <_wcsrtombs_r+0x80>
40004efc:	01 cb                	add    %ecx,%ebx
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
40004efe:	8b 45 10             	mov    0x10(%ebp),%eax
40004f01:	8b 10                	mov    (%eax),%edx
40004f03:	83 c2 04             	add    $0x4,%edx
40004f06:	89 10                	mov    %edx,(%eax)
  cfree(Void_t* p);
     Equivalent to free(p).
40004f08:	8b 0f                	mov    (%edi),%ecx
40004f0a:	85 c9                	test   %ecx,%ecx
40004f0c:	74 5a                	je     40004f68 <_wcsrtombs_r+0xf8>
     if no space is available.
  free(Void_t* p);
     Release the chunk of memory pointed to by p, or no effect if p is null.
  realloc(Void_t* p, size_t n);
     Return a pointer to a chunk of size n that contains the same data
     as does chunk p up to the minimum of (n, p's size) bytes, or null
40004f0e:	8b 45 14             	mov    0x14(%ebp),%eax
40004f11:	39 45 d8             	cmp    %eax,-0x28(%ebp)
40004f14:	73 15                	jae    40004f2b <_wcsrtombs_r+0xbb>
     round up n to nearest pagesize.
  calloc(size_t unit, size_t quantity);
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
  cfree(Void_t* p);
     Equivalent to free(p).
40004f16:	83 c7 04             	add    $0x4,%edi
40004f19:	eb 86                	jmp    40004ea1 <_wcsrtombs_r+0x31>
40004f1b:	90                   	nop    
40004f1c:	8d 74 26 00          	lea    0x0(%esi),%esi
     chunk p. This may or may not report more bytes than were requested,
     due to alignment and minimum size constraints.
  malloc_stats();
     Prints brief summary statistics on stderr.
  mallinfo()
     Returns (by copy) a struct containing various summary statistics.
40004f20:	8b 45 dc             	mov    -0x24(%ebp),%eax
40004f23:	89 06                	mov    %eax,(%esi)
  mallopt(int parameter_number, int parameter_value)
40004f25:	8b 45 e0             	mov    -0x20(%ebp),%eax
40004f28:	89 46 04             	mov    %eax,0x4(%esi)
     Changes one of the tunable parameters described below. Returns
     1 if successful in changing the parameter, else 0.

* Vital statistics:

  Alignment:                            8-byte
40004f2b:	8b 45 d8             	mov    -0x28(%ebp),%eax
40004f2e:	8d 65 f4             	lea    -0xc(%ebp),%esp
40004f31:	5b                   	pop    %ebx
40004f32:	5e                   	pop    %esi
40004f33:	5f                   	pop    %edi
40004f34:	5d                   	pop    %ebp
40004f35:	c3                   	ret    
     the same as p. If p is null, equivalent to malloc.  Unless the
     #define REALLOC_ZERO_BYTES_FREES below is set, realloc with a
     size argument of zero (re)allocates a minimum-sized chunk.
  memalign(size_t alignment, size_t n);
     Return a pointer to a newly allocated chunk of n bytes, aligned
     in accord with the alignment argument, which must be a power of
40004f36:	8b 45 08             	mov    0x8(%ebp),%eax
     two.
40004f39:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
     the same as p. If p is null, equivalent to malloc.  Unless the
     #define REALLOC_ZERO_BYTES_FREES below is set, realloc with a
     size argument of zero (re)allocates a minimum-sized chunk.
  memalign(size_t alignment, size_t n);
     Return a pointer to a newly allocated chunk of n bytes, aligned
     in accord with the alignment argument, which must be a power of
40004f40:	c7 00 8a 00 00 00    	movl   $0x8a,(%eax)
     two.
40004f46:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
     Changes one of the tunable parameters described below. Returns
     1 if successful in changing the parameter, else 0.

* Vital statistics:

  Alignment:                            8-byte
40004f4c:	8b 45 d8             	mov    -0x28(%ebp),%eax
40004f4f:	8d 65 f4             	lea    -0xc(%ebp),%esp
40004f52:	5b                   	pop    %ebx
40004f53:	5e                   	pop    %esi
40004f54:	5f                   	pop    %edi
40004f55:	5d                   	pop    %ebp
40004f56:	c3                   	ret    
  malloc(size_t n);
     Return a pointer to a newly allocated chunk of at least n bytes, or null
     if no space is available.
  free(Void_t* p);
     Release the chunk of memory pointed to by p, or no effect if p is null.
  realloc(Void_t* p, size_t n);
40004f57:	8b 45 10             	mov    0x10(%ebp),%eax
40004f5a:	c7 45 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebp)
40004f61:	8b 38                	mov    (%eax),%edi
40004f63:	e9 2f ff ff ff       	jmp    40004e97 <_wcsrtombs_r+0x27>
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
  cfree(Void_t* p);
     Equivalent to free(p).
  malloc_trim(size_t pad);
     Release all but pad bytes of freed top-most memory back 
40004f68:	8b 55 0c             	mov    0xc(%ebp),%edx
40004f6b:	85 d2                	test   %edx,%edx
40004f6d:	74 09                	je     40004f78 <_wcsrtombs_r+0x108>
     to the system. Return 1 if successful, else 0.
40004f6f:	8b 45 10             	mov    0x10(%ebp),%eax
40004f72:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  malloc_usable_size(Void_t* p);
     Report the number usable allocated bytes associated with allocated
40004f78:	8b 45 d8             	mov    -0x28(%ebp),%eax
  cfree(Void_t* p);
     Equivalent to free(p).
  malloc_trim(size_t pad);
     Release all but pad bytes of freed top-most memory back 
     to the system. Return 1 if successful, else 0.
  malloc_usable_size(Void_t* p);
40004f7b:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
     Report the number usable allocated bytes associated with allocated
40004f81:	48                   	dec    %eax
40004f82:	89 45 d8             	mov    %eax,-0x28(%ebp)
     Changes one of the tunable parameters described below. Returns
     1 if successful in changing the parameter, else 0.

* Vital statistics:

  Alignment:                            8-byte
40004f85:	8b 45 d8             	mov    -0x28(%ebp),%eax
40004f88:	8d 65 f4             	lea    -0xc(%ebp),%esp
40004f8b:	5b                   	pop    %ebx
40004f8c:	5e                   	pop    %esi
40004f8d:	5f                   	pop    %edi
40004f8e:	5d                   	pop    %ebp
40004f8f:	c3                   	ret    
     round up n to nearest pagesize.
  calloc(size_t unit, size_t quantity);
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
  cfree(Void_t* p);
     Equivalent to free(p).
40004f90:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
40004f97:	eb 92                	jmp    40004f2b <_wcsrtombs_r+0xbb>
40004f99:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

40004fa0 <wcsrtombs>:
  Assumed pointer representation:       4 or 8 bytes
       Code for 8-byte pointers is untested by me but has worked
       reliably by Wolfram Gloger, who contributed most of the
       changes supporting this.

  Assumed size_t  representation:       4 or 8 bytes
40004fa0:	55                   	push   %ebp
40004fa1:	89 e5                	mov    %esp,%ebp
40004fa3:	83 ec 14             	sub    $0x14,%esp
       Note that size_t is allowed to be 4 bytes even if pointers are 8.        
40004fa6:	8b 15 60 d0 00 40    	mov    0x4000d060,%edx
40004fac:	8b 45 14             	mov    0x14(%ebp),%eax
40004faf:	8b 4d 08             	mov    0x8(%ebp),%ecx
40004fb2:	50                   	push   %eax
40004fb3:	8b 45 10             	mov    0x10(%ebp),%eax
40004fb6:	50                   	push   %eax
40004fb7:	8b 45 0c             	mov    0xc(%ebp),%eax
40004fba:	50                   	push   %eax
40004fbb:	51                   	push   %ecx
40004fbc:	52                   	push   %edx
40004fbd:	e8 ae fe ff ff       	call   40004e70 <_wcsrtombs_r>

40004fc2:	c9                   	leave  
40004fc3:	c3                   	ret    
40004fc4:	90                   	nop    
40004fc5:	90                   	nop    
40004fc6:	90                   	nop    
40004fc7:	90                   	nop    
40004fc8:	90                   	nop    
40004fc9:	90                   	nop    
40004fca:	90                   	nop    
40004fcb:	90                   	nop    
40004fcc:	90                   	nop    
40004fcd:	90                   	nop    
40004fce:	90                   	nop    
40004fcf:	90                   	nop    

40004fd0 <_wctomb_r>:
   Note: There may be an updated version of this malloc obtainable at
           ftp://g.oswego.edu/pub/misc/malloc.c
         Check before installing!

* Why use this malloc?

40004fd0:	55                   	push   %ebp
40004fd1:	89 e5                	mov    %esp,%ebp
40004fd3:	56                   	push   %esi
40004fd4:	53                   	push   %ebx
  This is not the fastest, most space-conserving, most portable, or
40004fd5:	83 ec 0c             	sub    $0xc,%esp
   Note: There may be an updated version of this malloc obtainable at
           ftp://g.oswego.edu/pub/misc/malloc.c
         Check before installing!

* Why use this malloc?

40004fd8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  This is not the fastest, most space-conserving, most portable, or
40004fdb:	68 9c d8 00 40       	push   $0x4000d89c
40004fe0:	e8 e7 c2 ff ff       	call   400012cc <strlen>
40004fe5:	83 c4 10             	add    $0x10,%esp
40004fe8:	83 f8 01             	cmp    $0x1,%eax
40004feb:	76 43                	jbe    40005030 <_wctomb_r+0x60>
  most tunable malloc ever written. However it is among the fastest
  while also being among the most space-conserving, portable and tunable.
40004fed:	56                   	push   %esi
40004fee:	56                   	push   %esi
40004fef:	68 a2 c2 00 40       	push   $0x4000c2a2
40004ff4:	68 9c d8 00 40       	push   $0x4000d89c
40004ff9:	e8 d2 44 00 00       	call   400094d0 <strcmp>
40004ffe:	83 c4 10             	add    $0x10,%esp
40005001:	85 c0                	test   %eax,%eax
40005003:	75 7b                	jne    40005080 <_wctomb_r+0xb0>
  Consistent balance across these factors results in a good general-purpose 
  allocator. For a high-level description, see 
40005005:	85 db                	test   %ebx,%ebx
40005007:	74 2b                	je     40005034 <_wctomb_r+0x64>
     http://g.oswego.edu/dl/html/malloc.html

* Synopsis of public routines
40005009:	83 7d 10 7f          	cmpl   $0x7f,0x10(%ebp)
4000500d:	7f 31                	jg     40005040 <_wctomb_r+0x70>
4000500f:	90                   	nop    
     MALLOC_LOCK may be called more than once before the corresponding
     MALLOC_UNLOCK calls.  MALLOC_LOCK must avoid waiting for a lock
     that it already holds.
  MALLOC_ALIGNMENT          (default: NOT defined)
     Define this to 16 if you need 16 byte alignment instead of 8 byte alignment
     which is the normal default.
40005010:	8a 45 10             	mov    0x10(%ebp),%al
40005013:	88 03                	mov    %al,(%ebx)
40005015:	b8 01 00 00 00       	mov    $0x1,%eax
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
     Define this if you think that realloc(p, 0) should be equivalent
4000501a:	8d 65 f8             	lea    -0x8(%ebp),%esp
4000501d:	5b                   	pop    %ebx
4000501e:	5e                   	pop    %esi
4000501f:	5d                   	pop    %ebp
40005020:	c3                   	ret    
40005021:	eb 0d                	jmp    40005030 <_wctomb_r+0x60>
40005023:	90                   	nop    
40005024:	90                   	nop    
40005025:	90                   	nop    
40005026:	90                   	nop    
40005027:	90                   	nop    
40005028:	90                   	nop    
40005029:	90                   	nop    
4000502a:	90                   	nop    
4000502b:	90                   	nop    
4000502c:	90                   	nop    
4000502d:	90                   	nop    
4000502e:	90                   	nop    
4000502f:	90                   	nop    
  MALLOC_LOCK		   (default: NOT defined)
  MALLOC_UNLOCK		   (default: NOT defined)
     Define these to C expressions which are run to lock and unlock
     the malloc data structures.  Calls may be nested; that is,
     MALLOC_LOCK may be called more than once before the corresponding
     MALLOC_UNLOCK calls.  MALLOC_LOCK must avoid waiting for a lock
40005030:	85 db                	test   %ebx,%ebx
40005032:	75 dc                	jne    40005010 <_wctomb_r+0x40>
     that it already holds.
  MALLOC_ALIGNMENT          (default: NOT defined)
     Define this to 16 if you need 16 byte alignment instead of 8 byte alignment
     which is the normal default.
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
     Define this if you think that realloc(p, 0) should be equivalent
40005034:	8d 65 f8             	lea    -0x8(%ebp),%esp
     MALLOC_UNLOCK calls.  MALLOC_LOCK must avoid waiting for a lock
     that it already holds.
  MALLOC_ALIGNMENT          (default: NOT defined)
     Define this to 16 if you need 16 byte alignment instead of 8 byte alignment
     which is the normal default.
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
40005037:	31 c0                	xor    %eax,%eax
     Define this if you think that realloc(p, 0) should be equivalent
40005039:	5b                   	pop    %ebx
4000503a:	5e                   	pop    %esi
4000503b:	5d                   	pop    %ebp
4000503c:	c3                   	ret    
4000503d:	8d 76 00             	lea    0x0(%esi),%esi
* Synopsis of public routines

  (Much fuller descriptions are contained in the program documentation below.)

  malloc(size_t n);
     Return a pointer to a newly allocated chunk of at least n bytes, or null
40005040:	8b 45 10             	mov    0x10(%ebp),%eax
40005043:	83 c0 80             	add    $0xffffff80,%eax
40005046:	3d 7f 07 00 00       	cmp    $0x77f,%eax
4000504b:	0f 87 34 01 00 00    	ja     40005185 <_wctomb_r+0x1b5>
     if no space is available.
  free(Void_t* p);
40005051:	8b 45 10             	mov    0x10(%ebp),%eax
40005054:	25 c0 07 00 00       	and    $0x7c0,%eax
40005059:	c1 f8 06             	sar    $0x6,%eax
4000505c:	83 c8 c0             	or     $0xffffffc0,%eax
4000505f:	88 03                	mov    %al,(%ebx)
     Release the chunk of memory pointed to by p, or no effect if p is null.
40005061:	8a 45 10             	mov    0x10(%ebp),%al
40005064:	83 e0 3f             	and    $0x3f,%eax
40005067:	83 c8 80             	or     $0xffffff80,%eax
4000506a:	88 43 01             	mov    %al,0x1(%ebx)
     that it already holds.
  MALLOC_ALIGNMENT          (default: NOT defined)
     Define this to 16 if you need 16 byte alignment instead of 8 byte alignment
     which is the normal default.
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
     Define this if you think that realloc(p, 0) should be equivalent
4000506d:	8d 65 f8             	lea    -0x8(%ebp),%esp

  malloc(size_t n);
     Return a pointer to a newly allocated chunk of at least n bytes, or null
     if no space is available.
  free(Void_t* p);
     Release the chunk of memory pointed to by p, or no effect if p is null.
40005070:	b8 02 00 00 00       	mov    $0x2,%eax
     that it already holds.
  MALLOC_ALIGNMENT          (default: NOT defined)
     Define this to 16 if you need 16 byte alignment instead of 8 byte alignment
     which is the normal default.
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
     Define this if you think that realloc(p, 0) should be equivalent
40005075:	5b                   	pop    %ebx
40005076:	5e                   	pop    %esi
40005077:	5d                   	pop    %ebp
40005078:	c3                   	ret    
40005079:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
* Vital statistics:

  Alignment:                            8-byte
       8 byte alignment is currently hardwired into the design.  This
       seems to suffice for all current machines and C compilers.

40005080:	51                   	push   %ecx
40005081:	51                   	push   %ecx
40005082:	68 aa c2 00 40       	push   $0x4000c2aa
40005087:	68 9c d8 00 40       	push   $0x4000d89c
4000508c:	e8 3f 44 00 00       	call   400094d0 <strcmp>
40005091:	83 c4 10             	add    $0x10,%esp
40005094:	85 c0                	test   %eax,%eax
40005096:	75 48                	jne    400050e0 <_wctomb_r+0x110>
  Assumed pointer representation:       4 or 8 bytes
       Code for 8-byte pointers is untested by me but has worked
       reliably by Wolfram Gloger, who contributed most of the
       changes supporting this.

40005098:	85 db                	test   %ebx,%ebx
4000509a:	74 98                	je     40005034 <_wctomb_r+0x64>
       8 byte alignment is currently hardwired into the design.  This
       seems to suffice for all current machines and C compilers.

  Assumed pointer representation:       4 or 8 bytes
       Code for 8-byte pointers is untested by me but has worked
       reliably by Wolfram Gloger, who contributed most of the
4000509c:	8b 4d 10             	mov    0x10(%ebp),%ecx
4000509f:	c1 f9 08             	sar    $0x8,%ecx
       changes supporting this.

  Assumed size_t  representation:       4 or 8 bytes
       Note that size_t is allowed to be 4 bytes even if pointers are 8.        

400050a2:	84 c9                	test   %cl,%cl
400050a4:	0f 84 66 ff ff ff    	je     40005010 <_wctomb_r+0x40>
  Minimum overhead per allocated chunk: 4 or 8 bytes
       Each malloced chunk has a hidden overhead of 4 bytes holding size
       and status information.  
400050aa:	8d 41 7f             	lea    0x7f(%ecx),%eax
400050ad:	3c 1e                	cmp    $0x1e,%al
400050af:	0f 87 3e 01 00 00    	ja     400051f3 <_wctomb_r+0x223>
  Alignment:                            8-byte
       8 byte alignment is currently hardwired into the design.  This
       seems to suffice for all current machines and C compilers.

  Assumed pointer representation:       4 or 8 bytes
       Code for 8-byte pointers is untested by me but has worked
400050b5:	8a 55 10             	mov    0x10(%ebp),%dl
  Assumed size_t  representation:       4 or 8 bytes
       Note that size_t is allowed to be 4 bytes even if pointers are 8.        

  Minimum overhead per allocated chunk: 4 or 8 bytes
       Each malloced chunk has a hidden overhead of 4 bytes holding size
       and status information.  
400050b8:	8d 42 c0             	lea    -0x40(%edx),%eax
400050bb:	3c 3e                	cmp    $0x3e,%al
400050bd:	76 07                	jbe    400050c6 <_wctomb_r+0xf6>
400050bf:	8d 42 80             	lea    -0x80(%edx),%eax
400050c2:	3c 7c                	cmp    $0x7c,%al
400050c4:	77 55                	ja     4000511b <_wctomb_r+0x14b>

  Minimum allocated size: 4-byte ptrs:  16 bytes    (including 4 overhead)
400050c6:	88 0b                	mov    %cl,(%ebx)
                          8-byte ptrs:  24/32 bytes (including, 4/8 overhead)
400050c8:	b8 02 00 00 00       	mov    $0x2,%eax
400050cd:	8a 55 10             	mov    0x10(%ebp),%dl
400050d0:	88 53 01             	mov    %dl,0x1(%ebx)
400050d3:	e9 42 ff ff ff       	jmp    4000501a <_wctomb_r+0x4a>
400050d8:	90                   	nop    
400050d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
       When a chunk is freed, 12 (for 4byte ptrs) or 20 (for 8 byte
       ptrs but 4 byte size) or 24 (for 8/8) additional bytes are 
       needed; 4 (8) for a trailing size field
       and 8 (16) bytes for free list pointers. Thus, the minimum
       allocatable size is 16/24/32 bytes.

400050e0:	52                   	push   %edx
400050e1:	52                   	push   %edx
400050e2:	68 b1 c2 00 40       	push   $0x4000c2b1
400050e7:	68 9c d8 00 40       	push   $0x4000d89c
400050ec:	e8 df 43 00 00       	call   400094d0 <strcmp>
400050f1:	83 c4 10             	add    $0x10,%esp
400050f4:	85 c0                	test   %eax,%eax
400050f6:	75 2b                	jne    40005123 <_wctomb_r+0x153>
       Even a request for zero bytes (i.e., malloc(0)) returns a
       pointer to something of the minimum allocatable size.

  Maximum allocated size: 4-byte size_t: 2^31 -  8 bytes
                          8-byte size_t: 2^63 - 16 bytes
400050f8:	85 db                	test   %ebx,%ebx
400050fa:	0f 84 34 ff ff ff    	je     40005034 <_wctomb_r+0x64>
       and 8 (16) bytes for free list pointers. Thus, the minimum
       allocatable size is 16/24/32 bytes.

       Even a request for zero bytes (i.e., malloc(0)) returns a
       pointer to something of the minimum allocatable size.

40005100:	8b 55 10             	mov    0x10(%ebp),%edx
40005103:	c1 fa 08             	sar    $0x8,%edx
40005106:	88 d0                	mov    %dl,%al
  Maximum allocated size: 4-byte size_t: 2^31 -  8 bytes
                          8-byte size_t: 2^63 - 16 bytes

       It is assumed that (possibly signed) size_t bit values suffice to
       represent chunk sizes. `Possibly signed' is due to the fact
40005108:	84 d2                	test   %dl,%dl
4000510a:	0f 84 00 ff ff ff    	je     40005010 <_wctomb_r+0x40>
       that `size_t' may be defined on a system as either a signed or
       an unsigned type. To be conservative, values that would appear
       as negative numbers are avoided.  
40005110:	83 c0 5f             	add    $0x5f,%eax
40005113:	3c 5d                	cmp    $0x5d,%al
40005115:	0f 86 eb 01 00 00    	jbe    40005306 <_wctomb_r+0x336>
     MALLOC_UNLOCK calls.  MALLOC_LOCK must avoid waiting for a lock
     that it already holds.
  MALLOC_ALIGNMENT          (default: NOT defined)
     Define this to 16 if you need 16 byte alignment instead of 8 byte alignment
     which is the normal default.
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
4000511b:	83 c8 ff             	or     $0xffffffff,%eax
4000511e:	e9 f7 fe ff ff       	jmp    4000501a <_wctomb_r+0x4a>

       Alignnment demands, plus the minimum allocatable size restriction
       make the normal worst-case wastage 15 bytes (i.e., up to 15
       more bytes will be allocated than were requested in malloc), with 
       two exceptions:
         1. Because requests for zero bytes allocate non-zero space,
40005123:	50                   	push   %eax
40005124:	50                   	push   %eax
40005125:	68 b9 c2 00 40       	push   $0x4000c2b9
4000512a:	68 9c d8 00 40       	push   $0x4000d89c
4000512f:	e8 9c 43 00 00       	call   400094d0 <strcmp>
40005134:	83 c4 10             	add    $0x10,%esp
40005137:	85 c0                	test   %eax,%eax
40005139:	0f 85 f1 fe ff ff    	jne    40005030 <_wctomb_r+0x60>
            the worst case wastage for a request of zero bytes is 24 bytes.
         2. For requests >= mmap_threshold that are serviced via
            mmap(), the worst case wastage is 8 bytes plus the remainder
            from a system page (the minimal mmap unit); typically 4096 bytes.

* Limitations
4000513f:	b0 01                	mov    $0x1,%al
40005141:	85 db                	test   %ebx,%ebx
40005143:	0f 84 d1 fe ff ff    	je     4000501a <_wctomb_r+0x4a>
       two exceptions:
         1. Because requests for zero bytes allocate non-zero space,
            the worst case wastage for a request of zero bytes is 24 bytes.
         2. For requests >= mmap_threshold that are serviced via
            mmap(), the worst case wastage is 8 bytes plus the remainder
            from a system page (the minimal mmap unit); typically 4096 bytes.
40005149:	8b 55 10             	mov    0x10(%ebp),%edx
       more bytes will be allocated than were requested in malloc), with 
       two exceptions:
         1. Because requests for zero bytes allocate non-zero space,
            the worst case wastage for a request of zero bytes is 24 bytes.
         2. For requests >= mmap_threshold that are serviced via
            mmap(), the worst case wastage is 8 bytes plus the remainder
4000514c:	8a 4d 10             	mov    0x10(%ebp),%cl
            from a system page (the minimal mmap unit); typically 4096 bytes.
4000514f:	c1 ea 08             	shr    $0x8,%edx

* Limitations

    Here are some features that are NOT currently supported

40005152:	84 d2                	test   %dl,%dl
40005154:	0f 85 a9 00 00 00    	jne    40005203 <_wctomb_r+0x233>
    (for example gcc -O2) that can simplify expressions and control
    paths.

  __STD_C                  (default: derived from C compiler defines)
     Nonzero if using ANSI-standard C compiler, a C++ compiler, or
     a C compiler sufficiently close to ANSI to get away with it.
4000515a:	8b 55 14             	mov    0x14(%ebp),%edx
4000515d:	b8 01 00 00 00       	mov    $0x1,%eax
40005162:	8b 32                	mov    (%edx),%esi
40005164:	85 f6                	test   %esi,%esi
40005166:	74 16                	je     4000517e <_wctomb_r+0x1ae>
  DEBUG                    (default: NOT defined)
     Define to enable debugging. Adds fairly extensive assertion-based 
     checking to help track down memory errors, but noticeably slows down
40005168:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
     execution.
  SEPARATE_OBJECTS	   (default: NOT defined)
     Define this to compile into separate .o files.  You must then
4000516e:	b0 04                	mov    $0x4,%al
     Nonzero if using ANSI-standard C compiler, a C++ compiler, or
     a C compiler sufficiently close to ANSI to get away with it.
  DEBUG                    (default: NOT defined)
     Define to enable debugging. Adds fairly extensive assertion-based 
     checking to help track down memory errors, but noticeably slows down
     execution.
40005170:	c6 03 1b             	movb   $0x1b,(%ebx)
  SEPARATE_OBJECTS	   (default: NOT defined)
40005173:	c6 43 01 28          	movb   $0x28,0x1(%ebx)
     Define this to compile into separate .o files.  You must then
40005177:	c6 43 02 42          	movb   $0x42,0x2(%ebx)
4000517b:	83 c3 03             	add    $0x3,%ebx
     compile malloc.c several times, defining a DEFINE_* macro each
     time.  The list of DEFINE_* macros appears below.
  MALLOC_LOCK		   (default: NOT defined)
4000517e:	88 0b                	mov    %cl,(%ebx)
40005180:	e9 95 fe ff ff       	jmp    4000501a <_wctomb_r+0x4a>
     if no space is available.
  free(Void_t* p);
     Release the chunk of memory pointed to by p, or no effect if p is null.
  realloc(Void_t* p, size_t n);
     Return a pointer to a chunk of size n that contains the same data
     as does chunk p up to the minimum of (n, p's size) bytes, or null
40005185:	8b 45 10             	mov    0x10(%ebp),%eax
40005188:	2d 00 08 00 00       	sub    $0x800,%eax
4000518d:	3d ff f7 00 00       	cmp    $0xf7ff,%eax
40005192:	0f 86 24 01 00 00    	jbe    400052bc <_wctomb_r+0x2ec>
     Return a pointer to a newly allocated chunk of n bytes, aligned
     in accord with the alignment argument, which must be a power of
     two.
  valloc(size_t n);
     Equivalent to memalign(pagesize, n), where pagesize is the page
     size of the system (or as near to this as can be figured out from
40005198:	8b 45 10             	mov    0x10(%ebp),%eax
4000519b:	2d 00 00 01 00       	sub    $0x10000,%eax
400051a0:	3d ff ff 1e 00       	cmp    $0x1effff,%eax
400051a5:	0f 87 a5 00 00 00    	ja     40005250 <_wctomb_r+0x280>
     all the includes/defines below.)
  pvalloc(size_t n);
400051ab:	8b 45 10             	mov    0x10(%ebp),%eax
400051ae:	25 00 00 1c 00       	and    $0x1c0000,%eax
400051b3:	c1 f8 12             	sar    $0x12,%eax
400051b6:	83 c8 f0             	or     $0xfffffff0,%eax
400051b9:	88 03                	mov    %al,(%ebx)
     Equivalent to valloc(minimum-page-that-holds(n)), that is,
400051bb:	8b 45 10             	mov    0x10(%ebp),%eax
400051be:	25 00 f0 03 00       	and    $0x3f000,%eax
400051c3:	c1 f8 0c             	sar    $0xc,%eax
400051c6:	83 c8 80             	or     $0xffffff80,%eax
400051c9:	88 43 01             	mov    %al,0x1(%ebx)
     round up n to nearest pagesize.
400051cc:	8b 45 10             	mov    0x10(%ebp),%eax
400051cf:	25 c0 0f 00 00       	and    $0xfc0,%eax
400051d4:	c1 f8 06             	sar    $0x6,%eax
400051d7:	83 c8 80             	or     $0xffffff80,%eax
400051da:	88 43 02             	mov    %al,0x2(%ebx)
  calloc(size_t unit, size_t quantity);
400051dd:	8a 45 10             	mov    0x10(%ebp),%al
400051e0:	83 e0 3f             	and    $0x3f,%eax
400051e3:	83 c8 80             	or     $0xffffff80,%eax
400051e6:	88 43 03             	mov    %al,0x3(%ebx)
400051e9:	b8 04 00 00 00       	mov    $0x4,%eax
400051ee:	e9 27 fe ff ff       	jmp    4000501a <_wctomb_r+0x4a>
  Assumed size_t  representation:       4 or 8 bytes
       Note that size_t is allowed to be 4 bytes even if pointers are 8.        

  Minimum overhead per allocated chunk: 4 or 8 bytes
       Each malloced chunk has a hidden overhead of 4 bytes holding size
       and status information.  
400051f3:	8d 41 20             	lea    0x20(%ecx),%eax
400051f6:	3c 0f                	cmp    $0xf,%al
400051f8:	0f 87 1d ff ff ff    	ja     4000511b <_wctomb_r+0x14b>
400051fe:	e9 b2 fe ff ff       	jmp    400050b5 <_wctomb_r+0xe5>

    Here are some features that are NOT currently supported

    * No user-definable hooks for callbacks and the like.
    * No automated mechanism for fully checking that all accesses
      to malloced memory stay within their bounds.
40005203:	8d 42 df             	lea    -0x21(%edx),%eax
40005206:	3c 5d                	cmp    $0x5d,%al
40005208:	0f 87 0d ff ff ff    	ja     4000511b <_wctomb_r+0x14b>
4000520e:	8d 41 df             	lea    -0x21(%ecx),%eax
40005211:	3c 5d                	cmp    $0x5d,%al
40005213:	0f 87 02 ff ff ff    	ja     4000511b <_wctomb_r+0x14b>
    * No support for compaction.

40005219:	8b 75 14             	mov    0x14(%ebp),%esi
4000521c:	b8 02 00 00 00       	mov    $0x2,%eax
40005221:	83 3e 00             	cmpl   $0x0,(%esi)
40005224:	75 16                	jne    4000523c <_wctomb_r+0x26c>
* Synopsis of compile-time options:

    People have reported using previous versions of this malloc on all
40005226:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
    versions of Unix, sometimes by tweaking some of the defines
    below. It has been tested most extensively on Solaris and
    Linux. It is also reported to work on WIN32 platforms.
4000522c:	b0 05                	mov    $0x5,%al
    * No support for compaction.

* Synopsis of compile-time options:

    People have reported using previous versions of this malloc on all
    versions of Unix, sometimes by tweaking some of the defines
4000522e:	c6 03 1b             	movb   $0x1b,(%ebx)
    below. It has been tested most extensively on Solaris and
40005231:	c6 43 01 24          	movb   $0x24,0x1(%ebx)
    Linux. It is also reported to work on WIN32 platforms.
40005235:	c6 43 02 42          	movb   $0x42,0x2(%ebx)
40005239:	83 c3 03             	add    $0x3,%ebx
    People have also reported adapting this malloc for use in
    stand-alone embedded systems.

4000523c:	88 13                	mov    %dl,(%ebx)
    The implementation is in straight, hand-tuned ANSI C.  Among other
4000523e:	88 4b 01             	mov    %cl,0x1(%ebx)
40005241:	e9 d4 fd ff ff       	jmp    4000501a <_wctomb_r+0x4a>
40005246:	8d 76 00             	lea    0x0(%esi),%esi
40005249:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
     Equivalent to valloc(minimum-page-that-holds(n)), that is,
     round up n to nearest pagesize.
  calloc(size_t unit, size_t quantity);
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
  cfree(Void_t* p);
40005250:	8b 45 10             	mov    0x10(%ebp),%eax
40005253:	2d 00 00 20 00       	sub    $0x200000,%eax
40005258:	3d ff ff df 03       	cmp    $0x3dfffff,%eax
4000525d:	0f 87 c3 00 00 00    	ja     40005326 <_wctomb_r+0x356>
     Equivalent to free(p).
  malloc_trim(size_t pad);
40005263:	8b 45 10             	mov    0x10(%ebp),%eax
40005266:	25 00 00 00 03       	and    $0x3000000,%eax
4000526b:	c1 f8 18             	sar    $0x18,%eax
4000526e:	83 c8 f8             	or     $0xfffffff8,%eax
40005271:	88 03                	mov    %al,(%ebx)
     Release all but pad bytes of freed top-most memory back 
40005273:	8b 45 10             	mov    0x10(%ebp),%eax
40005276:	25 00 00 fc 00       	and    $0xfc0000,%eax
4000527b:	c1 f8 12             	sar    $0x12,%eax
4000527e:	83 c8 80             	or     $0xffffff80,%eax
40005281:	88 43 01             	mov    %al,0x1(%ebx)
     to the system. Return 1 if successful, else 0.
40005284:	8b 45 10             	mov    0x10(%ebp),%eax
40005287:	25 00 f0 03 00       	and    $0x3f000,%eax
4000528c:	c1 f8 0c             	sar    $0xc,%eax
4000528f:	83 c8 80             	or     $0xffffff80,%eax
40005292:	88 43 02             	mov    %al,0x2(%ebx)
  malloc_usable_size(Void_t* p);
40005295:	8b 45 10             	mov    0x10(%ebp),%eax
40005298:	25 c0 0f 00 00       	and    $0xfc0,%eax
4000529d:	c1 f8 06             	sar    $0x6,%eax
400052a0:	83 c8 80             	or     $0xffffff80,%eax
400052a3:	88 43 03             	mov    %al,0x3(%ebx)
     Report the number usable allocated bytes associated with allocated
400052a6:	8a 45 10             	mov    0x10(%ebp),%al
400052a9:	83 e0 3f             	and    $0x3f,%eax
400052ac:	83 c8 80             	or     $0xffffff80,%eax
400052af:	88 43 04             	mov    %al,0x4(%ebx)
400052b2:	b8 05 00 00 00       	mov    $0x5,%eax
400052b7:	e9 5e fd ff ff       	jmp    4000501a <_wctomb_r+0x4a>
  realloc(Void_t* p, size_t n);
     Return a pointer to a chunk of size n that contains the same data
     as does chunk p up to the minimum of (n, p's size) bytes, or null
     if no space is available. The returned pointer may or may not be
     the same as p. If p is null, equivalent to malloc.  Unless the
     #define REALLOC_ZERO_BYTES_FREES below is set, realloc with a
400052bc:	8b 45 10             	mov    0x10(%ebp),%eax
400052bf:	2d 00 d8 00 00       	sub    $0xd800,%eax
400052c4:	3d ff 07 00 00       	cmp    $0x7ff,%eax
400052c9:	0f 86 4c fe ff ff    	jbe    4000511b <_wctomb_r+0x14b>
     size argument of zero (re)allocates a minimum-sized chunk.
  memalign(size_t alignment, size_t n);
     Return a pointer to a newly allocated chunk of n bytes, aligned
400052cf:	8b 45 10             	mov    0x10(%ebp),%eax
400052d2:	25 00 f0 00 00       	and    $0xf000,%eax
400052d7:	c1 f8 0c             	sar    $0xc,%eax
400052da:	83 c8 e0             	or     $0xffffffe0,%eax
400052dd:	88 03                	mov    %al,(%ebx)
     in accord with the alignment argument, which must be a power of
400052df:	8b 45 10             	mov    0x10(%ebp),%eax
400052e2:	25 c0 0f 00 00       	and    $0xfc0,%eax
400052e7:	c1 f8 06             	sar    $0x6,%eax
400052ea:	83 c8 80             	or     $0xffffff80,%eax
400052ed:	88 43 01             	mov    %al,0x1(%ebx)
     two.
400052f0:	8a 45 10             	mov    0x10(%ebp),%al
400052f3:	83 e0 3f             	and    $0x3f,%eax
400052f6:	83 c8 80             	or     $0xffffff80,%eax
400052f9:	88 43 02             	mov    %al,0x2(%ebx)
400052fc:	b8 03 00 00 00       	mov    $0x3,%eax
40005301:	e9 14 fd ff ff       	jmp    4000501a <_wctomb_r+0x4a>

       It is assumed that (possibly signed) size_t bit values suffice to
       represent chunk sizes. `Possibly signed' is due to the fact
       that `size_t' may be defined on a system as either a signed or
       an unsigned type. To be conservative, values that would appear
       as negative numbers are avoided.  
40005306:	8a 45 10             	mov    0x10(%ebp),%al
40005309:	83 c0 5f             	add    $0x5f,%eax
4000530c:	3c 5d                	cmp    $0x5d,%al
4000530e:	0f 87 07 fe ff ff    	ja     4000511b <_wctomb_r+0x14b>
       Requests for sizes with a negative sign bit will return a
       minimum-sized chunk.
40005314:	88 13                	mov    %dl,(%ebx)

40005316:	8a 45 10             	mov    0x10(%ebp),%al
40005319:	88 43 01             	mov    %al,0x1(%ebx)
4000531c:	b8 02 00 00 00       	mov    $0x2,%eax
40005321:	e9 f4 fc ff ff       	jmp    4000501a <_wctomb_r+0x4a>
     to the system. Return 1 if successful, else 0.
  malloc_usable_size(Void_t* p);
     Report the number usable allocated bytes associated with allocated
     chunk p. This may or may not report more bytes than were requested,
     due to alignment and minimum size constraints.
  malloc_stats();
40005326:	81 7d 10 ff ff ff 03 	cmpl   $0x3ffffff,0x10(%ebp)
4000532d:	0f 8e e8 fd ff ff    	jle    4000511b <_wctomb_r+0x14b>
     Prints brief summary statistics on stderr.
  mallinfo()
40005333:	8b 45 10             	mov    0x10(%ebp),%eax
40005336:	25 00 00 00 40       	and    $0x40000000,%eax
4000533b:	c1 f8 1e             	sar    $0x1e,%eax
4000533e:	83 c8 fc             	or     $0xfffffffc,%eax
40005341:	88 03                	mov    %al,(%ebx)
     Returns (by copy) a struct containing various summary statistics.
40005343:	8b 45 10             	mov    0x10(%ebp),%eax
40005346:	25 00 00 00 3f       	and    $0x3f000000,%eax
4000534b:	c1 f8 18             	sar    $0x18,%eax
4000534e:	83 c8 80             	or     $0xffffff80,%eax
40005351:	88 43 01             	mov    %al,0x1(%ebx)
  mallopt(int parameter_number, int parameter_value)
40005354:	8b 45 10             	mov    0x10(%ebp),%eax
40005357:	25 00 00 fc 00       	and    $0xfc0000,%eax
4000535c:	c1 f8 12             	sar    $0x12,%eax
4000535f:	83 c8 80             	or     $0xffffff80,%eax
40005362:	88 43 02             	mov    %al,0x2(%ebx)
     Changes one of the tunable parameters described below. Returns
40005365:	8b 45 10             	mov    0x10(%ebp),%eax
40005368:	25 00 f0 03 00       	and    $0x3f000,%eax
4000536d:	c1 f8 0c             	sar    $0xc,%eax
40005370:	83 c8 80             	or     $0xffffff80,%eax
40005373:	88 43 03             	mov    %al,0x3(%ebx)
     1 if successful in changing the parameter, else 0.
40005376:	8b 45 10             	mov    0x10(%ebp),%eax
40005379:	25 c0 0f 00 00       	and    $0xfc0,%eax
4000537e:	c1 f8 06             	sar    $0x6,%eax
40005381:	83 c8 80             	or     $0xffffff80,%eax
40005384:	88 43 04             	mov    %al,0x4(%ebx)

40005387:	8a 45 10             	mov    0x10(%ebp),%al
4000538a:	83 e0 3f             	and    $0x3f,%eax
4000538d:	83 c8 80             	or     $0xffffff80,%eax
40005390:	88 43 05             	mov    %al,0x5(%ebx)
40005393:	b8 06 00 00 00       	mov    $0x6,%eax
40005398:	e9 7d fc ff ff       	jmp    4000501a <_wctomb_r+0x4a>
4000539d:	90                   	nop    
4000539e:	90                   	nop    
4000539f:	90                   	nop    

400053a0 <_write_r>:
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
*/

#include <_ansi.h>
400053a0:	55                   	push   %ebp
400053a1:	89 e5                	mov    %esp,%ebp
400053a3:	83 ec 0c             	sub    $0xc,%esp
#include <stdio.h>
#include "local.h"

400053a6:	c7 05 60 d9 00 40 00 	movl   $0x0,0x4000d960
400053ad:	00 00 00 
/* Flush a single file, or (if fp is NULL) all files.  */
400053b0:	8b 4d 14             	mov    0x14(%ebp),%ecx
400053b3:	51                   	push   %ecx
400053b4:	8b 55 10             	mov    0x10(%ebp),%edx
400053b7:	52                   	push   %edx
400053b8:	8b 45 0c             	mov    0xc(%ebp),%eax
400053bb:	50                   	push   %eax
400053bc:	e8 2f c1 ff ff       	call   400014f0 <write>
400053c1:	83 c4 10             	add    $0x10,%esp
400053c4:	83 f8 ff             	cmp    $0xffffffff,%eax
400053c7:	74 07                	je     400053d0 <_write_r+0x30>

int
_DEFUN(fflush, (fp),
400053c9:	c9                   	leave  
400053ca:	c3                   	ret    
400053cb:	90                   	nop    
400053cc:	8d 74 26 00          	lea    0x0(%esi),%esi

#include <_ansi.h>
#include <stdio.h>
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */
400053d0:	8b 15 60 d9 00 40    	mov    0x4000d960,%edx
400053d6:	85 d2                	test   %edx,%edx
400053d8:	74 ef                	je     400053c9 <_write_r+0x29>

400053da:	8b 4d 08             	mov    0x8(%ebp),%ecx
400053dd:	89 11                	mov    %edx,(%ecx)
int
_DEFUN(fflush, (fp),
400053df:	c9                   	leave  
400053e0:	c3                   	ret    
400053e1:	90                   	nop    
400053e2:	90                   	nop    
400053e3:	90                   	nop    
400053e4:	90                   	nop    
400053e5:	90                   	nop    
400053e6:	90                   	nop    
400053e7:	90                   	nop    
400053e8:	90                   	nop    
400053e9:	90                   	nop    
400053ea:	90                   	nop    
400053eb:	90                   	nop    
400053ec:	90                   	nop    
400053ed:	90                   	nop    
400053ee:	90                   	nop    
400053ef:	90                   	nop    

400053f0 <__swsetup>:
TRAD_SYNOPSIS
	#include <stdio.h>
	int fflush(<[fp]>)
	FILE *<[fp]>;

DESCRIPTION
400053f0:	55                   	push   %ebp
400053f1:	89 e5                	mov    %esp,%ebp
400053f3:	53                   	push   %ebx
400053f4:	83 ec 04             	sub    $0x4,%esp
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

400053f7:	a1 60 d0 00 40       	mov    0x4000d060,%eax
TRAD_SYNOPSIS
	#include <stdio.h>
	int fflush(<[fp]>)
	FILE *<[fp]>;

DESCRIPTION
400053fc:	8b 5d 08             	mov    0x8(%ebp),%ebx
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

400053ff:	85 c0                	test   %eax,%eax
40005401:	74 07                	je     4000540a <__swsetup+0x1a>
40005403:	8b 50 38             	mov    0x38(%eax),%edx
40005406:	85 d2                	test   %edx,%edx
40005408:	74 56                	je     40005460 <__swsetup+0x70>
Use <<fflush>> to deliver any such pending output (for the file
or stream identified by <[fp]>) to the host system.

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
open files.

4000540a:	0f bf 53 0c          	movswl 0xc(%ebx),%edx
4000540e:	f6 c2 08             	test   $0x8,%dl
40005411:	74 7d                	je     40005490 <__swsetup+0xa0>

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  register unsigned char *p;
40005413:	8b 43 10             	mov    0x10(%ebx),%eax
40005416:	85 c0                	test   %eax,%eax
40005418:	74 56                	je     40005470 <__swsetup+0x80>
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);
4000541a:	f6 c2 01             	test   $0x1,%dl
4000541d:	75 21                	jne    40005440 <__swsetup+0x50>
  t = fp->_flags;
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
4000541f:	31 c0                	xor    %eax,%eax
40005421:	83 e2 02             	and    $0x2,%edx
40005424:	75 03                	jne    40005429 <__swsetup+0x39>
40005426:	8b 43 14             	mov    0x14(%ebx),%eax
40005429:	89 43 08             	mov    %eax,0x8(%ebx)
4000542c:	31 c0                	xor    %eax,%eax
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
4000542e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40005431:	c9                   	leave  
40005432:	c3                   	ret    
40005433:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40005439:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

  _flockfile (fp);

  t = fp->_flags;
  if ((t & __SWR) == 0)
    {
40005440:	8b 43 14             	mov    0x14(%ebx),%eax
  CHECK_INIT (_REENT, fp);

  _flockfile (fp);

  t = fp->_flags;
  if ((t & __SWR) == 0)
40005443:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    {
4000544a:	f7 d8                	neg    %eax
4000544c:	89 43 18             	mov    %eax,0x18(%ebx)
4000544f:	31 c0                	xor    %eax,%eax
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
40005451:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40005454:	c9                   	leave  
40005455:	c3                   	ret    
40005456:	8d 76 00             	lea    0x0(%esi),%esi
40005459:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
	FILE *<[fp]>;

DESCRIPTION
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

40005460:	83 ec 0c             	sub    $0xc,%esp
40005463:	50                   	push   %eax
40005464:	e8 97 af ff ff       	call   40000400 <__sinit>
40005469:	83 c4 10             	add    $0x10,%esp
4000546c:	eb 9c                	jmp    4000540a <__swsetup+0x1a>
4000546e:	66 90                	xchg   %ax,%ax

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  register unsigned char *p;
40005470:	89 d0                	mov    %edx,%eax
40005472:	25 80 02 00 00       	and    $0x280,%eax
40005477:	3d 00 02 00 00       	cmp    $0x200,%eax
4000547c:	74 9c                	je     4000541a <__swsetup+0x2a>
  register int n, t;

4000547e:	83 ec 0c             	sub    $0xc,%esp
40005481:	53                   	push   %ebx
40005482:	e8 99 23 00 00       	call   40007820 <__smakebuf>
40005487:	0f bf 53 0c          	movswl 0xc(%ebx),%edx
4000548b:	83 c4 10             	add    $0x10,%esp
4000548e:	eb 8a                	jmp    4000541a <__swsetup+0x2a>

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
open files.

RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
40005490:	83 c8 ff             	or     $0xffffffff,%eax
40005493:	f6 c2 10             	test   $0x10,%dl
40005496:	74 96                	je     4000542e <__swsetup+0x3e>
situation, it returns <<EOF>>.

40005498:	83 e2 04             	and    $0x4,%edx
4000549b:	74 38                	je     400054d5 <__swsetup+0xe5>
PORTABILITY
ANSI C requires <<fflush>>.

4000549d:	8b 53 30             	mov    0x30(%ebx),%edx
400054a0:	85 d2                	test   %edx,%edx
400054a2:	74 20                	je     400054c4 <__swsetup+0xd4>
No supporting OS subroutines are required.
400054a4:	8d 43 40             	lea    0x40(%ebx),%eax
400054a7:	39 c2                	cmp    %eax,%edx
400054a9:	74 12                	je     400054bd <__swsetup+0xcd>
400054ab:	51                   	push   %ecx
400054ac:	51                   	push   %ecx
400054ad:	52                   	push   %edx
400054ae:	8b 15 60 d0 00 40    	mov    0x4000d060,%edx
400054b4:	52                   	push   %edx
400054b5:	e8 a6 1a 00 00       	call   40006f60 <_free_r>
400054ba:	83 c4 10             	add    $0x10,%esp
400054bd:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
*/
400054c4:	66 83 63 0c db       	andw   $0xffffffdb,0xc(%ebx)

#include <_ansi.h>
400054c9:	8b 43 10             	mov    0x10(%ebx),%eax
PORTABILITY
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
*/

400054cc:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#include <_ansi.h>
400054d3:	89 03                	mov    %eax,(%ebx)
#include <stdio.h>
#include "local.h"
400054d5:	8b 43 0c             	mov    0xc(%ebx),%eax
400054d8:	83 c8 08             	or     $0x8,%eax
400054db:	0f bf d0             	movswl %ax,%edx
400054de:	66 89 43 0c          	mov    %ax,0xc(%ebx)
400054e2:	e9 2c ff ff ff       	jmp    40005413 <__swsetup+0x23>
400054e7:	90                   	nop    
400054e8:	90                   	nop    
400054e9:	90                   	nop    
400054ea:	90                   	nop    
400054eb:	90                   	nop    
400054ec:	90                   	nop    
400054ed:	90                   	nop    
400054ee:	90                   	nop    
400054ef:	90                   	nop    

400054f0 <_close_r>:
RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.

PORTABILITY
ANSI C requires <<fflush>>.
400054f0:	55                   	push   %ebp
400054f1:	89 e5                	mov    %esp,%ebp
400054f3:	83 ec 14             	sub    $0x14,%esp

No supporting OS subroutines are required.
*/
400054f6:	c7 05 60 d9 00 40 00 	movl   $0x0,0x4000d960
400054fd:	00 00 00 

40005500:	8b 45 0c             	mov    0xc(%ebp),%eax
40005503:	50                   	push   %eax
40005504:	e8 37 be ff ff       	call   40001340 <close>
40005509:	83 c4 10             	add    $0x10,%esp
4000550c:	83 f8 ff             	cmp    $0xffffffff,%eax
4000550f:	74 0f                	je     40005520 <_close_r+0x30>
#include <_ansi.h>
#include <stdio.h>
#include "local.h"
40005511:	c9                   	leave  
40005512:	c3                   	ret    
40005513:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40005519:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
PORTABILITY
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
*/

40005520:	8b 15 60 d9 00 40    	mov    0x4000d960,%edx
40005526:	85 d2                	test   %edx,%edx
40005528:	74 e7                	je     40005511 <_close_r+0x21>
#include <_ansi.h>
4000552a:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000552d:	89 11                	mov    %edx,(%ecx)
#include <stdio.h>
#include "local.h"
4000552f:	c9                   	leave  
40005530:	c3                   	ret    
40005531:	90                   	nop    
40005532:	90                   	nop    
40005533:	90                   	nop    
40005534:	90                   	nop    
40005535:	90                   	nop    
40005536:	90                   	nop    
40005537:	90                   	nop    
40005538:	90                   	nop    
40005539:	90                   	nop    
4000553a:	90                   	nop    
4000553b:	90                   	nop    
4000553c:	90                   	nop    
4000553d:	90                   	nop    
4000553e:	90                   	nop    
4000553f:	90                   	nop    

40005540 <quorem>:
DESCRIPTION
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

Use <<fflush>> to deliver any such pending output (for the file
or stream identified by <[fp]>) to the host system.
40005540:	55                   	push   %ebp
40005541:	89 e5                	mov    %esp,%ebp
40005543:	57                   	push   %edi
40005544:	56                   	push   %esi
40005545:	53                   	push   %ebx
40005546:	83 ec 2c             	sub    $0x2c,%esp
40005549:	89 45 d0             	mov    %eax,-0x30(%ebp)
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
*/

#include <_ansi.h>
4000554c:	8b 4d d0             	mov    -0x30(%ebp),%ecx
DESCRIPTION
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

Use <<fflush>> to deliver any such pending output (for the file
or stream identified by <[fp]>) to the host system.
4000554f:	89 55 cc             	mov    %edx,-0x34(%ebp)
RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.

PORTABILITY
ANSI C requires <<fflush>>.
40005552:	8b 52 10             	mov    0x10(%edx),%edx

No supporting OS subroutines are required.
*/

#include <_ansi.h>
40005555:	31 c0                	xor    %eax,%eax
40005557:	3b 51 10             	cmp    0x10(%ecx),%edx
4000555a:	0f 8f 11 01 00 00    	jg     40005671 <quorem+0x131>
#include <stdio.h>
#include "local.h"

40005560:	4a                   	dec    %edx
40005561:	8b 45 cc             	mov    -0x34(%ebp),%eax
/* Flush a single file, or (if fp is NULL) all files.  */
40005564:	83 c1 14             	add    $0x14,%ecx
*/

#include <_ansi.h>
#include <stdio.h>
#include "local.h"

40005567:	89 55 d4             	mov    %edx,-0x2c(%ebp)
4000556a:	8d 44 90 14          	lea    0x14(%eax,%edx,4),%eax
/* Flush a single file, or (if fp is NULL) all files.  */
4000556e:	89 4d e8             	mov    %ecx,-0x18(%ebp)
*/

#include <_ansi.h>
#include <stdio.h>
#include "local.h"

40005571:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/* Flush a single file, or (if fp is NULL) all files.  */

int
40005574:	8b 4d cc             	mov    -0x34(%ebp),%ecx
40005577:	8b 45 d0             	mov    -0x30(%ebp),%eax
No supporting OS subroutines are required.
*/

#include <_ansi.h>
#include <stdio.h>
#include "local.h"
4000557a:	8b 5d cc             	mov    -0x34(%ebp),%ebx

/* Flush a single file, or (if fp is NULL) all files.  */

int
4000557d:	8b 74 91 14          	mov    0x14(%ecx,%edx,4),%esi
No supporting OS subroutines are required.
*/

#include <_ansi.h>
#include <stdio.h>
#include "local.h"
40005581:	83 c3 14             	add    $0x14,%ebx

/* Flush a single file, or (if fp is NULL) all files.  */

int
40005584:	8b 54 90 14          	mov    0x14(%eax,%edx,4),%edx
40005588:	46                   	inc    %esi
40005589:	89 d0                	mov    %edx,%eax
4000558b:	31 d2                	xor    %edx,%edx
4000558d:	f7 f6                	div    %esi
No supporting OS subroutines are required.
*/

#include <_ansi.h>
#include <stdio.h>
#include "local.h"
4000558f:	89 5d ec             	mov    %ebx,-0x14(%ebp)

/* Flush a single file, or (if fp is NULL) all files.  */

int
40005592:	89 45 c8             	mov    %eax,-0x38(%ebp)
40005595:	89 45 e0             	mov    %eax,-0x20(%ebp)
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  register unsigned char *p;
  register int n, t;
40005598:	85 c0                	test   %eax,%eax
4000559a:	0f 85 d9 00 00 00    	jne    40005679 <quorem+0x139>
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
            {
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
400055a0:	8b 75 cc             	mov    -0x34(%ebp),%esi
400055a3:	8b 5d d0             	mov    -0x30(%ebp),%ebx
400055a6:	57                   	push   %edi
400055a7:	57                   	push   %edi
400055a8:	56                   	push   %esi
400055a9:	53                   	push   %ebx
400055aa:	e8 91 26 00 00       	call   40007c40 <__mcmp>
400055af:	83 c4 10             	add    $0x10,%esp
400055b2:	85 c0                	test   %eax,%eax
400055b4:	0f 88 b4 00 00 00    	js     4000566e <quorem+0x12e>
              if (curoff == -1L)
                {
400055ba:	8b 45 c8             	mov    -0x38(%ebp),%eax
400055bd:	8b 75 e8             	mov    -0x18(%ebp),%esi
400055c0:	40                   	inc    %eax
400055c1:	31 ff                	xor    %edi,%edi
400055c3:	89 45 e0             	mov    %eax,-0x20(%ebp)
400055c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
400055cd:	8d 76 00             	lea    0x0(%esi),%esi
                }
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
400055d0:	8b 55 ec             	mov    -0x14(%ebp),%edx
              curoff -= fp->_r;
400055d3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
                }
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
400055d6:	8b 02                	mov    (%edx),%eax
400055d8:	83 c2 04             	add    $0x4,%edx
400055db:	89 55 ec             	mov    %edx,-0x14(%ebp)
              curoff -= fp->_r;
400055de:	0f b7 d0             	movzwl %ax,%edx
              if (HASUB (fp))
400055e1:	c1 e8 10             	shr    $0x10,%eax
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
400055e4:	01 ca                	add    %ecx,%edx
              if (HASUB (fp))
400055e6:	89 d1                	mov    %edx,%ecx
                curoff -= fp->_ur;
            }
400055e8:	81 e2 ff ff 00 00    	and    $0xffff,%edx
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
              if (HASUB (fp))
400055ee:	c1 e9 10             	shr    $0x10,%ecx
400055f1:	01 c1                	add    %eax,%ecx
                curoff -= fp->_ur;
            }
400055f3:	8b 06                	mov    (%esi),%eax
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
              if (HASUB (fp))
                curoff -= fp->_ur;
400055f5:	89 cb                	mov    %ecx,%ebx
            }
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
400055f7:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
              if (HASUB (fp))
                curoff -= fp->_ur;
400055fd:	c1 eb 10             	shr    $0x10,%ebx
40005600:	89 5d f0             	mov    %ebx,-0x10(%ebp)
            }
40005603:	0f b7 d8             	movzwl %ax,%ebx
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
40005606:	c1 e8 10             	shr    $0x10,%eax
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
              if (HASUB (fp))
                curoff -= fp->_ur;
            }
40005609:	8d 1c 1f             	lea    (%edi,%ebx,1),%ebx
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
4000560c:	29 c8                	sub    %ecx,%eax
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
              if (HASUB (fp))
                curoff -= fp->_ur;
            }
4000560e:	29 d3                	sub    %edx,%ebx
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
40005610:	89 da                	mov    %ebx,%edx
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
40005612:	66 89 1e             	mov    %bx,(%esi)
              if (HASUB (fp))
                curoff -= fp->_ur;
            }
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
40005615:	c1 fa 10             	sar    $0x10,%edx
40005618:	01 d0                	add    %edx,%eax
              /* Seek successful.  We can clear read buffer now.  */
4000561a:	89 c7                	mov    %eax,%edi
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
4000561c:	66 89 46 02          	mov    %ax,0x2(%esi)
        } 
      _funlockfile (fp);
      return 0;
    }
  if ((p = fp->_bf._base) == NULL)
    {
40005620:	8b 45 ec             	mov    -0x14(%ebp),%eax
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
40005623:	83 c6 04             	add    $0x4,%esi
                curoff -= fp->_ur;
            }
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
              /* Seek successful.  We can clear read buffer now.  */
40005626:	c1 ff 10             	sar    $0x10,%edi
        } 
      _funlockfile (fp);
      return 0;
    }
  if ((p = fp->_bf._base) == NULL)
    {
40005629:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
4000562c:	73 a2                	jae    400055d0 <quorem+0x90>
      /* Nothing to flush.  */
      _funlockfile (fp);
      return 0;
4000562e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
40005631:	8b 4d d0             	mov    -0x30(%ebp),%ecx
40005634:	8b 5c 91 14          	mov    0x14(%ecx,%edx,4),%ebx
40005638:	85 db                	test   %ebx,%ebx
4000563a:	75 32                	jne    4000566e <quorem+0x12e>
    }
  n = fp->_p - p;		/* write this much */
4000563c:	8d 44 91 10          	lea    0x10(%ecx,%edx,4),%eax
40005640:	39 45 e8             	cmp    %eax,-0x18(%ebp)
40005643:	72 1a                	jb     4000565f <quorem+0x11f>
40005645:	eb 1e                	jmp    40005665 <quorem+0x125>
40005647:	89 f6                	mov    %esi,%esi
40005649:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40005650:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    {
      /* Nothing to flush.  */
      _funlockfile (fp);
      return 0;
    }
  n = fp->_p - p;		/* write this much */
40005653:	83 e8 04             	sub    $0x4,%eax

40005656:	4a                   	dec    %edx
    {
      /* Nothing to flush.  */
      _funlockfile (fp);
      return 0;
    }
  n = fp->_p - p;		/* write this much */
40005657:	39 45 e8             	cmp    %eax,-0x18(%ebp)

4000565a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    {
      /* Nothing to flush.  */
      _funlockfile (fp);
      return 0;
    }
  n = fp->_p - p;		/* write this much */
4000565d:	73 06                	jae    40005665 <quorem+0x125>
4000565f:	8b 08                	mov    (%eax),%ecx
40005661:	85 c9                	test   %ecx,%ecx
40005663:	74 eb                	je     40005650 <quorem+0x110>

  /*
40005665:	8b 45 d0             	mov    -0x30(%ebp),%eax
40005668:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
4000566b:	89 58 10             	mov    %ebx,0x10(%eax)
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
4000566e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   */
40005671:	8d 65 f4             	lea    -0xc(%ebp),%esp
40005674:	5b                   	pop    %ebx
40005675:	5e                   	pop    %esi
40005676:	5f                   	pop    %edi
40005677:	5d                   	pop    %ebp
40005678:	c3                   	ret    
int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  register unsigned char *p;
  register int n, t;
40005679:	8b 75 e8             	mov    -0x18(%ebp),%esi
4000567c:	8b 7d ec             	mov    -0x14(%ebp),%edi
4000567f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
40005686:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
4000568d:	8d 76 00             	lea    0x0(%esi),%esi
  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);

  _flockfile (fp);
40005690:	8b 07                	mov    (%edi),%eax

40005692:	8b 4d c8             	mov    -0x38(%ebp),%ecx
40005695:	0f b7 d0             	movzwl %ax,%edx
40005698:	0f af d1             	imul   %ecx,%edx
  t = fp->_flags;
4000569b:	c1 e8 10             	shr    $0x10,%eax
4000569e:	8b 4d c8             	mov    -0x38(%ebp),%ecx
400056a1:	0f af c1             	imul   %ecx,%eax
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);

  _flockfile (fp);

400056a4:	8b 5d dc             	mov    -0x24(%ebp),%ebx
  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);

  _flockfile (fp);
400056a7:	83 c7 04             	add    $0x4,%edi

400056aa:	01 da                	add    %ebx,%edx
  t = fp->_flags;
400056ac:	89 d3                	mov    %edx,%ebx
  if ((t & __SWR) == 0)
    {
400056ae:	81 e2 ff ff 00 00    	and    $0xffff,%edx

  CHECK_INIT (_REENT, fp);

  _flockfile (fp);

  t = fp->_flags;
400056b4:	c1 eb 10             	shr    $0x10,%ebx
400056b7:	01 c3                	add    %eax,%ebx
  if ((t & __SWR) == 0)
    {
400056b9:	8b 06                	mov    (%esi),%eax
  CHECK_INIT (_REENT, fp);

  _flockfile (fp);

  t = fp->_flags;
  if ((t & __SWR) == 0)
400056bb:	89 d9                	mov    %ebx,%ecx
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
400056bd:	81 e3 ff ff 00 00    	and    $0xffff,%ebx
  CHECK_INIT (_REENT, fp);

  _flockfile (fp);

  t = fp->_flags;
  if ((t & __SWR) == 0)
400056c3:	c1 e9 10             	shr    $0x10,%ecx
400056c6:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    {
400056c9:	0f b7 c8             	movzwl %ax,%ecx
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
400056cc:	c1 e8 10             	shr    $0x10,%eax

  _flockfile (fp);

  t = fp->_flags;
  if ((t & __SWR) == 0)
    {
400056cf:	03 4d d8             	add    -0x28(%ebp),%ecx
400056d2:	29 d1                	sub    %edx,%ecx
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
400056d4:	29 d8                	sub    %ebx,%eax
400056d6:	89 ca                	mov    %ecx,%edx
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
400056d8:	66 89 0e             	mov    %cx,(%esi)
  t = fp->_flags;
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
400056db:	c1 fa 10             	sar    $0x10,%edx
400056de:	01 d0                	add    %edx,%eax
         unoptimized (i.e. forces a system-level seek).  This conforms
400056e0:	89 c3                	mov    %eax,%ebx
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
400056e2:	66 89 46 02          	mov    %ax,0x2(%esi)
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
400056e6:	c1 fb 10             	sar    $0x10,%ebx
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
400056e9:	83 c6 04             	add    $0x4,%esi
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
400056ec:	89 5d d8             	mov    %ebx,-0x28(%ebp)
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
400056ef:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
400056f2:	73 9c                	jae    40005690 <quorem+0x150>
          _fpos_t curoff;
400056f4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
400056f7:	8b 55 d0             	mov    -0x30(%ebp),%edx
400056fa:	8b 5c 82 14          	mov    0x14(%edx,%eax,4),%ebx
400056fe:	85 db                	test   %ebx,%ebx
40005700:	0f 85 9a fe ff ff    	jne    400055a0 <quorem+0x60>

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
40005706:	8d 44 82 10          	lea    0x10(%edx,%eax,4),%eax
4000570a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
4000570d:	72 20                	jb     4000572f <quorem+0x1ef>
4000570f:	eb 24                	jmp    40005735 <quorem+0x1f5>
40005711:	eb 0d                	jmp    40005720 <quorem+0x1e0>
40005713:	90                   	nop    
40005714:	90                   	nop    
40005715:	90                   	nop    
40005716:	90                   	nop    
40005717:	90                   	nop    
40005718:	90                   	nop    
40005719:	90                   	nop    
4000571a:	90                   	nop    
4000571b:	90                   	nop    
4000571c:	90                   	nop    
4000571d:	90                   	nop    
4000571e:	90                   	nop    
4000571f:	90                   	nop    
            curoff = fp->_offset;
40005720:	8b 55 d4             	mov    -0x2c(%ebp),%edx
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
40005723:	83 e8 04             	sub    $0x4,%eax
            curoff = fp->_offset;
40005726:	4a                   	dec    %edx
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
40005727:	39 45 e8             	cmp    %eax,-0x18(%ebp)
            curoff = fp->_offset;
4000572a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
4000572d:	73 06                	jae    40005735 <quorem+0x1f5>
4000572f:	8b 08                	mov    (%eax),%ecx
40005731:	85 c9                	test   %ecx,%ecx
40005733:	74 eb                	je     40005720 <quorem+0x1e0>
            curoff = fp->_offset;
          else
40005735:	8b 5d d0             	mov    -0x30(%ebp),%ebx
40005738:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
4000573b:	89 4b 10             	mov    %ecx,0x10(%ebx)
4000573e:	e9 5d fe ff ff       	jmp    400055a0 <quorem+0x60>
40005743:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40005749:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40005750 <_dtoa_r>:
40005750:	55                   	push   %ebp
40005751:	89 e5                	mov    %esp,%ebp
40005753:	57                   	push   %edi
40005754:	56                   	push   %esi
40005755:	53                   	push   %ebx
40005756:	81 ec dc 00 00 00    	sub    $0xdc,%esp
4000575c:	8b 45 08             	mov    0x8(%ebp),%eax
4000575f:	8b 75 0c             	mov    0xc(%ebp),%esi
40005762:	8b 7d 10             	mov    0x10(%ebp),%edi
40005765:	8b 50 40             	mov    0x40(%eax),%edx
40005768:	85 d2                	test   %edx,%edx
4000576a:	74 29                	je     40005795 <_dtoa_r+0x45>
4000576c:	8b 48 44             	mov    0x44(%eax),%ecx
4000576f:	b8 01 00 00 00       	mov    $0x1,%eax
40005774:	d3 e0                	shl    %cl,%eax
40005776:	89 42 08             	mov    %eax,0x8(%edx)
40005779:	89 4a 04             	mov    %ecx,0x4(%edx)
4000577c:	50                   	push   %eax
4000577d:	50                   	push   %eax
4000577e:	52                   	push   %edx
4000577f:	8b 5d 08             	mov    0x8(%ebp),%ebx
40005782:	53                   	push   %ebx
40005783:	e8 a8 23 00 00       	call   40007b30 <_Bfree>
40005788:	8b 55 08             	mov    0x8(%ebp),%edx
4000578b:	83 c4 10             	add    $0x10,%esp
4000578e:	c7 42 40 00 00 00 00 	movl   $0x0,0x40(%edx)
40005795:	89 fb                	mov    %edi,%ebx
40005797:	85 ff                	test   %edi,%edi
40005799:	0f 88 84 03 00 00    	js     40005b23 <_dtoa_r+0x3d3>
4000579f:	8b 45 20             	mov    0x20(%ebp),%eax
400057a2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
400057a8:	89 d8                	mov    %ebx,%eax
400057aa:	25 00 00 f0 7f       	and    $0x7ff00000,%eax
400057af:	3d 00 00 f0 7f       	cmp    $0x7ff00000,%eax
400057b4:	0f 84 36 03 00 00    	je     40005af0 <_dtoa_r+0x3a0>
400057ba:	89 75 a0             	mov    %esi,-0x60(%ebp)
400057bd:	89 7d a4             	mov    %edi,-0x5c(%ebp)
400057c0:	d9 ee                	fldz   
400057c2:	dd 45 a0             	fldl   -0x60(%ebp)
400057c5:	da e9                	fucompp 
400057c7:	df e0                	fnstsw %ax
400057c9:	80 e4 45             	and    $0x45,%ah
400057cc:	80 f4 40             	xor    $0x40,%ah
400057cf:	75 26                	jne    400057f7 <_dtoa_r+0xa7>
400057d1:	8b 45 1c             	mov    0x1c(%ebp),%eax
400057d4:	8b 55 24             	mov    0x24(%ebp),%edx
400057d7:	85 d2                	test   %edx,%edx
400057d9:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
400057df:	b8 88 bc 00 40       	mov    $0x4000bc88,%eax
400057e4:	74 09                	je     400057ef <_dtoa_r+0x9f>
400057e6:	8b 55 24             	mov    0x24(%ebp),%edx
400057e9:	c7 02 89 bc 00 40    	movl   $0x4000bc89,(%edx)
400057ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
400057f2:	5b                   	pop    %ebx
400057f3:	5e                   	pop    %esi
400057f4:	5f                   	pop    %edi
400057f5:	5d                   	pop    %ebp
400057f6:	c3                   	ret    
400057f7:	83 ec 0c             	sub    $0xc,%esp
400057fa:	8d 45 ec             	lea    -0x14(%ebp),%eax
400057fd:	50                   	push   %eax
400057fe:	8d 45 e8             	lea    -0x18(%ebp),%eax
40005801:	50                   	push   %eax
40005802:	8b 45 a4             	mov    -0x5c(%ebp),%eax
40005805:	50                   	push   %eax
40005806:	8b 45 a0             	mov    -0x60(%ebp),%eax
40005809:	50                   	push   %eax
4000580a:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000580d:	51                   	push   %ecx
4000580e:	e8 9d 28 00 00       	call   400080b0 <__d2b>
40005813:	89 45 90             	mov    %eax,-0x70(%ebp)
40005816:	89 d8                	mov    %ebx,%eax
40005818:	c1 e8 14             	shr    $0x14,%eax
4000581b:	83 c4 20             	add    $0x20,%esp
4000581e:	89 c2                	mov    %eax,%edx
40005820:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
40005826:	0f 85 21 03 00 00    	jne    40005b4d <_dtoa_r+0x3fd>
4000582c:	8b 55 ec             	mov    -0x14(%ebp),%edx
4000582f:	8b 45 e8             	mov    -0x18(%ebp),%eax
40005832:	01 d0                	add    %edx,%eax
40005834:	8d 90 32 04 00 00    	lea    0x432(%eax),%edx
4000583a:	89 55 d0             	mov    %edx,-0x30(%ebp)
4000583d:	83 fa 20             	cmp    $0x20,%edx
40005840:	0f 8e 90 09 00 00    	jle    400061d6 <_dtoa_r+0xa86>
40005846:	b9 40 00 00 00       	mov    $0x40,%ecx
4000584b:	29 d1                	sub    %edx,%ecx
4000584d:	89 da                	mov    %ebx,%edx
4000584f:	d3 e2                	shl    %cl,%edx
40005851:	8d 88 12 04 00 00    	lea    0x412(%eax),%ecx
40005857:	89 f0                	mov    %esi,%eax
40005859:	d3 e8                	shr    %cl,%eax
4000585b:	09 c2                	or     %eax,%edx
4000585d:	89 d0                	mov    %edx,%eax
4000585f:	31 d2                	xor    %edx,%edx
40005861:	52                   	push   %edx
40005862:	50                   	push   %eax
40005863:	df 2c 24             	fildll (%esp)
40005866:	8b 55 d0             	mov    -0x30(%ebp),%edx
40005869:	83 c4 08             	add    $0x8,%esp
4000586c:	dd 9d 48 ff ff ff    	fstpl  -0xb8(%ebp)
40005872:	8b 9d 4c ff ff ff    	mov    -0xb4(%ebp),%ebx
40005878:	81 ea 33 04 00 00    	sub    $0x433,%edx
4000587e:	81 eb 00 00 f0 01    	sub    $0x1f00000,%ebx
40005884:	c7 45 8c 01 00 00 00 	movl   $0x1,-0x74(%ebp)
4000588b:	89 9d 4c ff ff ff    	mov    %ebx,-0xb4(%ebp)
40005891:	dd 85 48 ff ff ff    	fldl   -0xb8(%ebp)
40005897:	d8 25 88 c5 00 40    	fsubs  0x4000c588
4000589d:	52                   	push   %edx
4000589e:	dc 0d a0 c5 00 40    	fmull  0x4000c5a0
400058a4:	dc 05 a8 c5 00 40    	faddl  0x4000c5a8
400058aa:	db 04 24             	fildl  (%esp)
400058ad:	d9 7d de             	fnstcw -0x22(%ebp)
400058b0:	dc 0d b0 c5 00 40    	fmull  0x4000c5b0
400058b6:	66 8b 45 de          	mov    -0x22(%ebp),%ax
400058ba:	b4 0c                	mov    $0xc,%ah
400058bc:	83 c4 04             	add    $0x4,%esp
400058bf:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
400058c3:	de c1                	faddp  %st,%st(1)
400058c5:	d9 6d dc             	fldcw  -0x24(%ebp)
400058c8:	db 95 6c ff ff ff    	fistl  -0x94(%ebp)
400058ce:	d9 6d de             	fldcw  -0x22(%ebp)
400058d1:	d9 ee                	fldz   
400058d3:	dd e9                	fucomp %st(1)
400058d5:	df e0                	fnstsw %ax
400058d7:	f6 c4 45             	test   $0x45,%ah
400058da:	0f 84 bc 0b 00 00    	je     4000649c <_dtoa_r+0xd4c>
400058e0:	dd d8                	fstp   %st(0)
400058e2:	c7 85 70 ff ff ff 01 	movl   $0x1,-0x90(%ebp)
400058e9:	00 00 00 
400058ec:	83 bd 6c ff ff ff 16 	cmpl   $0x16,-0x94(%ebp)
400058f3:	77 2c                	ja     40005921 <_dtoa_r+0x1d1>
400058f5:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
400058fb:	c7 85 70 ff ff ff 00 	movl   $0x0,-0x90(%ebp)
40005902:	00 00 00 
40005905:	dd 04 cd 20 c6 00 40 	fldl   0x4000c620(,%ecx,8)
4000590c:	dd 45 a0             	fldl   -0x60(%ebp)
4000590f:	d9 c9                	fxch   %st(1)
40005911:	da e9                	fucompp 
40005913:	df e0                	fnstsw %ax
40005915:	f6 c4 45             	test   $0x45,%ah
40005918:	75 07                	jne    40005921 <_dtoa_r+0x1d1>
4000591a:	49                   	dec    %ecx
4000591b:	89 8d 6c ff ff ff    	mov    %ecx,-0x94(%ebp)
40005921:	89 d0                	mov    %edx,%eax
40005923:	83 f0 ff             	xor    $0xffffffff,%eax
40005926:	03 45 ec             	add    -0x14(%ebp),%eax
40005929:	0f 88 59 0b 00 00    	js     40006488 <_dtoa_r+0xd38>
4000592f:	89 45 80             	mov    %eax,-0x80(%ebp)
40005932:	c7 85 54 ff ff ff 00 	movl   $0x0,-0xac(%ebp)
40005939:	00 00 00 
4000593c:	8b 9d 6c ff ff ff    	mov    -0x94(%ebp),%ebx
40005942:	85 db                	test   %ebx,%ebx
40005944:	0f 88 16 0b 00 00    	js     40006460 <_dtoa_r+0xd10>
4000594a:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
40005950:	8b 4d 80             	mov    -0x80(%ebp),%ecx
40005953:	01 c1                	add    %eax,%ecx
40005955:	89 45 84             	mov    %eax,-0x7c(%ebp)
40005958:	89 4d 80             	mov    %ecx,-0x80(%ebp)
4000595b:	c7 85 58 ff ff ff 00 	movl   $0x0,-0xa8(%ebp)
40005962:	00 00 00 
40005965:	83 7d 14 09          	cmpl   $0x9,0x14(%ebp)
40005969:	0f 86 40 04 00 00    	jbe    40005daf <_dtoa_r+0x65f>
4000596f:	c7 45 14 00 00 00 00 	movl   $0x0,0x14(%ebp)
40005976:	c6 45 af 01          	movb   $0x1,-0x51(%ebp)
4000597a:	c7 45 18 00 00 00 00 	movl   $0x0,0x18(%ebp)
40005981:	c7 85 60 ff ff ff ff 	movl   $0xffffffff,-0xa0(%ebp)
40005988:	ff ff ff 
4000598b:	c7 85 64 ff ff ff ff 	movl   $0xffffffff,-0x9c(%ebp)
40005992:	ff ff ff 
40005995:	c7 85 74 ff ff ff 01 	movl   $0x1,-0x8c(%ebp)
4000599c:	00 00 00 
4000599f:	31 db                	xor    %ebx,%ebx
400059a1:	8b 4d 08             	mov    0x8(%ebp),%ecx
400059a4:	c7 41 44 00 00 00 00 	movl   $0x0,0x44(%ecx)
400059ab:	51                   	push   %ecx
400059ac:	51                   	push   %ecx
400059ad:	8b 45 08             	mov    0x8(%ebp),%eax
400059b0:	8b 50 44             	mov    0x44(%eax),%edx
400059b3:	52                   	push   %edx
400059b4:	50                   	push   %eax
400059b5:	e8 66 26 00 00       	call   40008020 <_Balloc>
400059ba:	8b 55 08             	mov    0x8(%ebp),%edx
400059bd:	83 c4 10             	add    $0x10,%esp
400059c0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
400059c3:	89 42 40             	mov    %eax,0x40(%edx)
400059c6:	84 db                	test   %bl,%bl
400059c8:	0f 84 c6 02 00 00    	je     40005c94 <_dtoa_r+0x544>
400059ce:	80 7d af 00          	cmpb   $0x0,-0x51(%ebp)
400059d2:	0f 84 bc 02 00 00    	je     40005c94 <_dtoa_r+0x544>
400059d8:	8b 9d 6c ff ff ff    	mov    -0x94(%ebp),%ebx
400059de:	85 db                	test   %ebx,%ebx
400059e0:	0f 8e df 0b 00 00    	jle    400065c5 <_dtoa_r+0xe75>
400059e6:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
400059ec:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
400059f2:	83 e0 0f             	and    $0xf,%eax
400059f5:	bb 02 00 00 00       	mov    $0x2,%ebx
400059fa:	c1 fa 04             	sar    $0x4,%edx
400059fd:	dd 04 c5 20 c6 00 40 	fldl   0x4000c620(,%eax,8)
40005a04:	f6 c2 10             	test   $0x10,%dl
40005a07:	0f 85 dc 07 00 00    	jne    400061e9 <_dtoa_r+0xa99>
40005a0d:	85 d2                	test   %edx,%edx
40005a0f:	74 21                	je     40005a32 <_dtoa_r+0x2e2>
40005a11:	31 c9                	xor    %ecx,%ecx
40005a13:	eb 0c                	jmp    40005a21 <_dtoa_r+0x2d1>
40005a15:	8d 74 26 00          	lea    0x0(%esi),%esi
40005a19:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40005a20:	41                   	inc    %ecx
40005a21:	f6 c2 01             	test   $0x1,%dl
40005a24:	74 08                	je     40005a2e <_dtoa_r+0x2de>
40005a26:	dc 0c cd 00 c7 00 40 	fmull  0x4000c700(,%ecx,8)
40005a2d:	43                   	inc    %ebx
40005a2e:	d1 fa                	sar    %edx
40005a30:	75 ee                	jne    40005a20 <_dtoa_r+0x2d0>
40005a32:	89 b5 18 ff ff ff    	mov    %esi,-0xe8(%ebp)
40005a38:	89 bd 1c ff ff ff    	mov    %edi,-0xe4(%ebp)
40005a3e:	dd 85 18 ff ff ff    	fldl   -0xe8(%ebp)
40005a44:	de f1                	fdivp  %st,%st(1)
40005a46:	dd 95 38 ff ff ff    	fstl   -0xc8(%ebp)
40005a4c:	8b b5 38 ff ff ff    	mov    -0xc8(%ebp),%esi
40005a52:	8b bd 3c ff ff ff    	mov    -0xc4(%ebp),%edi
40005a58:	8b 8d 70 ff ff ff    	mov    -0x90(%ebp),%ecx
40005a5e:	85 c9                	test   %ecx,%ecx
40005a60:	0f 84 18 01 00 00    	je     40005b7e <_dtoa_r+0x42e>
40005a66:	d9 05 8c c5 00 40    	flds   0x4000c58c
40005a6c:	dd e9                	fucomp %st(1)
40005a6e:	df e0                	fnstsw %ax
40005a70:	f6 c4 45             	test   $0x45,%ah
40005a73:	0f 85 05 01 00 00    	jne    40005b7e <_dtoa_r+0x42e>
40005a79:	8b 95 60 ff ff ff    	mov    -0xa0(%ebp),%edx
40005a7f:	85 d2                	test   %edx,%edx
40005a81:	0f 8e f7 00 00 00    	jle    40005b7e <_dtoa_r+0x42e>
40005a87:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
40005a8d:	85 c0                	test   %eax,%eax
40005a8f:	0f 8e 52 0d 00 00    	jle    400067e7 <_dtoa_r+0x1097>
40005a95:	d8 0d 90 c5 00 40    	fmuls  0x4000c590
40005a9b:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
40005aa1:	4a                   	dec    %edx
40005aa2:	89 55 cc             	mov    %edx,-0x34(%ebp)
40005aa5:	dd 95 18 ff ff ff    	fstl   -0xe8(%ebp)
40005aab:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
40005ab1:	8b 95 1c ff ff ff    	mov    -0xe4(%ebp),%edx
40005ab7:	89 c6                	mov    %eax,%esi
40005ab9:	8d 43 01             	lea    0x1(%ebx),%eax
40005abc:	50                   	push   %eax
40005abd:	89 d7                	mov    %edx,%edi
40005abf:	db 04 24             	fildl  (%esp)
40005ac2:	de c9                	fmulp  %st,%st(1)
40005ac4:	83 c4 04             	add    $0x4,%esp
40005ac7:	8b 8d 64 ff ff ff    	mov    -0x9c(%ebp),%ecx
40005acd:	d8 05 94 c5 00 40    	fadds  0x4000c594
40005ad3:	dd 9d 40 ff ff ff    	fstpl  -0xc0(%ebp)
40005ad9:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
40005adf:	2d 00 00 40 03       	sub    $0x3400000,%eax
40005ae4:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
40005aea:	e9 30 07 00 00       	jmp    4000621f <_dtoa_r+0xacf>
40005aef:	90                   	nop    
40005af0:	8b 55 1c             	mov    0x1c(%ebp),%edx
40005af3:	85 f6                	test   %esi,%esi
40005af5:	c7 02 0f 27 00 00    	movl   $0x270f,(%edx)
40005afb:	74 3c                	je     40005b39 <_dtoa_r+0x3e9>
40005afd:	b8 69 c5 00 40       	mov    $0x4000c569,%eax
40005b02:	8b 4d 24             	mov    0x24(%ebp),%ecx
40005b05:	85 c9                	test   %ecx,%ecx
40005b07:	0f 84 e2 fc ff ff    	je     400057ef <_dtoa_r+0x9f>
40005b0d:	8d 50 03             	lea    0x3(%eax),%edx
40005b10:	80 78 03 00          	cmpb   $0x0,0x3(%eax)
40005b14:	75 32                	jne    40005b48 <_dtoa_r+0x3f8>
40005b16:	8b 4d 24             	mov    0x24(%ebp),%ecx
40005b19:	89 11                	mov    %edx,(%ecx)
40005b1b:	8d 65 f4             	lea    -0xc(%ebp),%esp
40005b1e:	5b                   	pop    %ebx
40005b1f:	5e                   	pop    %esi
40005b20:	5f                   	pop    %edi
40005b21:	5d                   	pop    %ebp
40005b22:	c3                   	ret    
40005b23:	8b 4d 20             	mov    0x20(%ebp),%ecx
40005b26:	81 e3 ff ff ff 7f    	and    $0x7fffffff,%ebx
40005b2c:	89 df                	mov    %ebx,%edi
40005b2e:	c7 01 01 00 00 00    	movl   $0x1,(%ecx)
40005b34:	e9 6f fc ff ff       	jmp    400057a8 <_dtoa_r+0x58>
40005b39:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
40005b3f:	b8 60 c5 00 40       	mov    $0x4000c560,%eax
40005b44:	74 bc                	je     40005b02 <_dtoa_r+0x3b2>
40005b46:	eb b5                	jmp    40005afd <_dtoa_r+0x3ad>
40005b48:	8d 50 08             	lea    0x8(%eax),%edx
40005b4b:	eb c9                	jmp    40005b16 <_dtoa_r+0x3c6>
40005b4d:	dd 45 a0             	fldl   -0x60(%ebp)
40005b50:	81 ea ff 03 00 00    	sub    $0x3ff,%edx
40005b56:	c7 45 8c 00 00 00 00 	movl   $0x0,-0x74(%ebp)
40005b5d:	dd 9d 48 ff ff ff    	fstpl  -0xb8(%ebp)
40005b63:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
40005b69:	25 ff ff 0f 00       	and    $0xfffff,%eax
40005b6e:	0d 00 00 f0 3f       	or     $0x3ff00000,%eax
40005b73:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
40005b79:	e9 13 fd ff ff       	jmp    40005891 <_dtoa_r+0x141>
40005b7e:	53                   	push   %ebx
40005b7f:	db 04 24             	fildl  (%esp)
40005b82:	d8 c9                	fmul   %st(1),%st
40005b84:	83 c4 04             	add    $0x4,%esp
40005b87:	d8 05 94 c5 00 40    	fadds  0x4000c594
40005b8d:	dd 9d 40 ff ff ff    	fstpl  -0xc0(%ebp)
40005b93:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
40005b99:	2d 00 00 40 03       	sub    $0x3400000,%eax
40005b9e:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
40005ba4:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
40005baa:	85 c0                	test   %eax,%eax
40005bac:	0f 85 5c 06 00 00    	jne    4000620e <_dtoa_r+0xabe>
40005bb2:	d8 25 98 c5 00 40    	fsubs  0x4000c598
40005bb8:	dd 85 40 ff ff ff    	fldl   -0xc0(%ebp)
40005bbe:	d9 c9                	fxch   %st(1)
40005bc0:	dd e1                	fucom  %st(1)
40005bc2:	df e0                	fnstsw %ax
40005bc4:	f6 c4 45             	test   $0x45,%ah
40005bc7:	0f 84 92 0a 00 00    	je     4000665f <_dtoa_r+0xf0f>
40005bcd:	d9 c9                	fxch   %st(1)
40005bcf:	d9 e0                	fchs   
40005bd1:	da e9                	fucompp 
40005bd3:	df e0                	fnstsw %ax
40005bd5:	f6 c4 45             	test   $0x45,%ah
40005bd8:	0f 85 b0 00 00 00    	jne    40005c8e <_dtoa_r+0x53e>
40005bde:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
40005be5:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
40005bec:	8b 55 18             	mov    0x18(%ebp),%edx
40005bef:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
40005bf2:	83 f2 ff             	xor    $0xffffffff,%edx
40005bf5:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
40005bfc:	89 95 6c ff ff ff    	mov    %edx,-0x94(%ebp)
40005c02:	50                   	push   %eax
40005c03:	50                   	push   %eax
40005c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
40005c07:	50                   	push   %eax
40005c08:	8b 45 08             	mov    0x8(%ebp),%eax
40005c0b:	50                   	push   %eax
40005c0c:	e8 1f 1f 00 00       	call   40007b30 <_Bfree>
40005c11:	8b 7d 98             	mov    -0x68(%ebp),%edi
40005c14:	83 c4 10             	add    $0x10,%esp
40005c17:	85 ff                	test   %edi,%edi
40005c19:	74 33                	je     40005c4e <_dtoa_r+0x4fe>
40005c1b:	8b 75 94             	mov    -0x6c(%ebp),%esi
40005c1e:	85 f6                	test   %esi,%esi
40005c20:	74 1a                	je     40005c3c <_dtoa_r+0x4ec>
40005c22:	8b 45 98             	mov    -0x68(%ebp),%eax
40005c25:	39 45 94             	cmp    %eax,-0x6c(%ebp)
40005c28:	74 12                	je     40005c3c <_dtoa_r+0x4ec>
40005c2a:	51                   	push   %ecx
40005c2b:	51                   	push   %ecx
40005c2c:	8b 55 94             	mov    -0x6c(%ebp),%edx
40005c2f:	52                   	push   %edx
40005c30:	8b 45 08             	mov    0x8(%ebp),%eax
40005c33:	50                   	push   %eax
40005c34:	e8 f7 1e 00 00       	call   40007b30 <_Bfree>
40005c39:	83 c4 10             	add    $0x10,%esp
40005c3c:	50                   	push   %eax
40005c3d:	50                   	push   %eax
40005c3e:	8b 45 98             	mov    -0x68(%ebp),%eax
40005c41:	50                   	push   %eax
40005c42:	8b 45 08             	mov    0x8(%ebp),%eax
40005c45:	50                   	push   %eax
40005c46:	e8 e5 1e 00 00       	call   40007b30 <_Bfree>
40005c4b:	83 c4 10             	add    $0x10,%esp
40005c4e:	50                   	push   %eax
40005c4f:	50                   	push   %eax
40005c50:	8b 45 90             	mov    -0x70(%ebp),%eax
40005c53:	50                   	push   %eax
40005c54:	8b 7d 08             	mov    0x8(%ebp),%edi
40005c57:	57                   	push   %edi
40005c58:	e8 d3 1e 00 00       	call   40007b30 <_Bfree>
40005c5d:	c6 03 00             	movb   $0x0,(%ebx)
40005c60:	83 c4 10             	add    $0x10,%esp
40005c63:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
40005c69:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
40005c6c:	40                   	inc    %eax
40005c6d:	8b 75 24             	mov    0x24(%ebp),%esi
40005c70:	89 01                	mov    %eax,(%ecx)
40005c72:	85 f6                	test   %esi,%esi
40005c74:	8b 45 d4             	mov    -0x2c(%ebp),%eax
40005c77:	0f 84 72 fb ff ff    	je     400057ef <_dtoa_r+0x9f>
40005c7d:	8b 75 24             	mov    0x24(%ebp),%esi
40005c80:	89 1e                	mov    %ebx,(%esi)
40005c82:	8d 65 f4             	lea    -0xc(%ebp),%esp
40005c85:	5b                   	pop    %ebx
40005c86:	5e                   	pop    %esi
40005c87:	5f                   	pop    %edi
40005c88:	5d                   	pop    %ebp
40005c89:	c3                   	ret    
40005c8a:	dd d8                	fstp   %st(0)
40005c8c:	dd d8                	fstp   %st(0)
40005c8e:	8b 75 a0             	mov    -0x60(%ebp),%esi
40005c91:	8b 7d a4             	mov    -0x5c(%ebp),%edi
40005c94:	8b 45 e8             	mov    -0x18(%ebp),%eax
40005c97:	85 c0                	test   %eax,%eax
40005c99:	0f 88 96 01 00 00    	js     40005e35 <_dtoa_r+0x6e5>
40005c9f:	83 bd 6c ff ff ff 0e 	cmpl   $0xe,-0x94(%ebp)
40005ca6:	0f 8f 89 01 00 00    	jg     40005e35 <_dtoa_r+0x6e5>
40005cac:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
40005cb2:	8b 45 18             	mov    0x18(%ebp),%eax
40005cb5:	85 c0                	test   %eax,%eax
40005cb7:	dd 04 d5 20 c6 00 40 	fldl   0x4000c620(,%edx,8)
40005cbe:	0f 88 9a 0a 00 00    	js     4000675e <_dtoa_r+0x100e>
40005cc4:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
40005cca:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
40005ccd:	89 b5 18 ff ff ff    	mov    %esi,-0xe8(%ebp)
40005cd3:	89 bd 1c ff ff ff    	mov    %edi,-0xe4(%ebp)
40005cd9:	dd 85 18 ff ff ff    	fldl   -0xe8(%ebp)
40005cdf:	d9 7d de             	fnstcw -0x22(%ebp)
40005ce2:	8d 0c 18             	lea    (%eax,%ebx,1),%ecx
40005ce5:	66 8b 45 de          	mov    -0x22(%ebp),%ax
40005ce9:	b4 0c                	mov    $0xc,%ah
40005ceb:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
40005cef:	eb 2b                	jmp    40005d1c <_dtoa_r+0x5cc>
40005cf1:	eb 0d                	jmp    40005d00 <_dtoa_r+0x5b0>
40005cf3:	90                   	nop    
40005cf4:	90                   	nop    
40005cf5:	90                   	nop    
40005cf6:	90                   	nop    
40005cf7:	90                   	nop    
40005cf8:	90                   	nop    
40005cf9:	90                   	nop    
40005cfa:	90                   	nop    
40005cfb:	90                   	nop    
40005cfc:	90                   	nop    
40005cfd:	90                   	nop    
40005cfe:	90                   	nop    
40005cff:	90                   	nop    
40005d00:	d8 0d 90 c5 00 40    	fmuls  0x4000c590
40005d06:	d9 ee                	fldz   
40005d08:	d9 c9                	fxch   %st(1)
40005d0a:	dd e1                	fucom  %st(1)
40005d0c:	df e0                	fnstsw %ax
40005d0e:	dd d9                	fstp   %st(1)
40005d10:	80 e4 45             	and    $0x45,%ah
40005d13:	80 fc 40             	cmp    $0x40,%ah
40005d16:	0f 84 77 09 00 00    	je     40006693 <_dtoa_r+0xf43>
40005d1c:	d9 c0                	fld    %st(0)
40005d1e:	d8 f2                	fdiv   %st(2),%st
40005d20:	d9 6d dc             	fldcw  -0x24(%ebp)
40005d23:	db 5d d8             	fistpl -0x28(%ebp)
40005d26:	d9 6d de             	fldcw  -0x22(%ebp)
40005d29:	8b 55 d8             	mov    -0x28(%ebp),%edx
40005d2c:	52                   	push   %edx
40005d2d:	db 04 24             	fildl  (%esp)
40005d30:	d8 ca                	fmul   %st(2),%st
40005d32:	8d 42 30             	lea    0x30(%edx),%eax
40005d35:	88 03                	mov    %al,(%ebx)
40005d37:	43                   	inc    %ebx
40005d38:	83 c4 04             	add    $0x4,%esp
40005d3b:	39 cb                	cmp    %ecx,%ebx
40005d3d:	de e9                	fsubrp %st,%st(1)
40005d3f:	75 bf                	jne    40005d00 <_dtoa_r+0x5b0>
40005d41:	d8 c0                	fadd   %st(0),%st
40005d43:	dd e1                	fucom  %st(1)
40005d45:	df e0                	fnstsw %ax
40005d47:	f6 c4 45             	test   $0x45,%ah
40005d4a:	0f 84 99 0b 00 00    	je     400068e9 <_dtoa_r+0x1199>
40005d50:	d9 c9                	fxch   %st(1)
40005d52:	da e9                	fucompp 
40005d54:	df e0                	fnstsw %ax
40005d56:	80 e4 45             	and    $0x45,%ah
40005d59:	80 f4 40             	xor    $0x40,%ah
40005d5c:	0f 85 ec fe ff ff    	jne    40005c4e <_dtoa_r+0x4fe>
40005d62:	83 e2 01             	and    $0x1,%edx
40005d65:	0f 84 e3 fe ff ff    	je     40005c4e <_dtoa_r+0x4fe>
40005d6b:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
40005d71:	89 4d cc             	mov    %ecx,-0x34(%ebp)
40005d74:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40005d7a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
40005d80:	4b                   	dec    %ebx
40005d81:	8a 03                	mov    (%ebx),%al
40005d83:	3c 39                	cmp    $0x39,%al
40005d85:	75 16                	jne    40005d9d <_dtoa_r+0x64d>
40005d87:	39 5d d4             	cmp    %ebx,-0x2c(%ebp)
40005d8a:	75 f4                	jne    40005d80 <_dtoa_r+0x630>
40005d8c:	8b 75 cc             	mov    -0x34(%ebp),%esi
40005d8f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
40005d92:	46                   	inc    %esi
40005d93:	89 d3                	mov    %edx,%ebx
40005d95:	89 75 cc             	mov    %esi,-0x34(%ebp)
40005d98:	b0 30                	mov    $0x30,%al
40005d9a:	c6 02 30             	movb   $0x30,(%edx)
40005d9d:	40                   	inc    %eax
40005d9e:	88 03                	mov    %al,(%ebx)
40005da0:	43                   	inc    %ebx
40005da1:	8b 75 cc             	mov    -0x34(%ebp),%esi
40005da4:	89 b5 6c ff ff ff    	mov    %esi,-0x94(%ebp)
40005daa:	e9 9f fe ff ff       	jmp    40005c4e <_dtoa_r+0x4fe>
40005daf:	c7 45 88 01 00 00 00 	movl   $0x1,-0x78(%ebp)
40005db6:	83 7d 14 05          	cmpl   $0x5,0x14(%ebp)
40005dba:	7e 10                	jle    40005dcc <_dtoa_r+0x67c>
40005dbc:	8b 5d 14             	mov    0x14(%ebp),%ebx
40005dbf:	c7 45 88 00 00 00 00 	movl   $0x0,-0x78(%ebp)
40005dc6:	83 eb 04             	sub    $0x4,%ebx
40005dc9:	89 5d 14             	mov    %ebx,0x14(%ebp)
40005dcc:	83 7d 14 05          	cmpl   $0x5,0x14(%ebp)
40005dd0:	0f 86 f6 03 00 00    	jbe    400061cc <_dtoa_r+0xa7c>
40005dd6:	89 d3                	mov    %edx,%ebx
40005dd8:	c7 85 60 ff ff ff ff 	movl   $0xffffffff,-0xa0(%ebp)
40005ddf:	ff ff ff 
40005de2:	c7 85 64 ff ff ff ff 	movl   $0xffffffff,-0x9c(%ebp)
40005de9:	ff ff ff 
40005dec:	c7 85 74 ff ff ff 01 	movl   $0x1,-0x8c(%ebp)
40005df3:	00 00 00 
40005df6:	8b 4d 08             	mov    0x8(%ebp),%ecx
40005df9:	83 fb 17             	cmp    $0x17,%ebx
40005dfc:	c7 41 44 00 00 00 00 	movl   $0x0,0x44(%ecx)
40005e03:	0f 86 6a 0c 00 00    	jbe    40006a73 <_dtoa_r+0x1323>
40005e09:	ba 04 00 00 00       	mov    $0x4,%edx
40005e0e:	31 c9                	xor    %ecx,%ecx
40005e10:	01 d2                	add    %edx,%edx
40005e12:	41                   	inc    %ecx
40005e13:	8d 42 14             	lea    0x14(%edx),%eax
40005e16:	39 d8                	cmp    %ebx,%eax
40005e18:	76 f6                	jbe    40005e10 <_dtoa_r+0x6c0>
40005e1a:	8b 55 08             	mov    0x8(%ebp),%edx
40005e1d:	83 bd 60 ff ff ff 0e 	cmpl   $0xe,-0xa0(%ebp)
40005e24:	89 4a 44             	mov    %ecx,0x44(%edx)
40005e27:	8a 4d 88             	mov    -0x78(%ebp),%cl
40005e2a:	0f 96 c3             	setbe  %bl
40005e2d:	88 4d af             	mov    %cl,-0x51(%ebp)
40005e30:	e9 76 fb ff ff       	jmp    400059ab <_dtoa_r+0x25b>
40005e35:	8b 9d 74 ff ff ff    	mov    -0x8c(%ebp),%ebx
40005e3b:	85 db                	test   %ebx,%ebx
40005e3d:	0f 84 d2 04 00 00    	je     40006315 <_dtoa_r+0xbc5>
40005e43:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
40005e47:	0f 8e 1c 0b 00 00    	jle    40006969 <_dtoa_r+0x1219>
40005e4d:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
40005e53:	48                   	dec    %eax
40005e54:	39 85 58 ff ff ff    	cmp    %eax,-0xa8(%ebp)
40005e5a:	0f 8c 8e 09 00 00    	jl     400067ee <_dtoa_r+0x109e>
40005e60:	8b 95 58 ff ff ff    	mov    -0xa8(%ebp),%edx
40005e66:	29 c2                	sub    %eax,%edx
40005e68:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
40005e6e:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
40005e74:	85 c0                	test   %eax,%eax
40005e76:	0f 88 30 0b 00 00    	js     400069ac <_dtoa_r+0x125c>
40005e7c:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
40005e82:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
40005e88:	89 8d 78 ff ff ff    	mov    %ecx,-0x88(%ebp)
40005e8e:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
40005e94:	8b 55 80             	mov    -0x80(%ebp),%edx
40005e97:	01 c1                	add    %eax,%ecx
40005e99:	01 c2                	add    %eax,%edx
40005e9b:	89 8d 54 ff ff ff    	mov    %ecx,-0xac(%ebp)
40005ea1:	89 55 80             	mov    %edx,-0x80(%ebp)
40005ea4:	50                   	push   %eax
40005ea5:	50                   	push   %eax
40005ea6:	6a 01                	push   $0x1
40005ea8:	8b 45 08             	mov    0x8(%ebp),%eax
40005eab:	50                   	push   %eax
40005eac:	e8 af 27 00 00       	call   40008660 <__i2b>
40005eb1:	83 c4 10             	add    $0x10,%esp
40005eb4:	89 45 98             	mov    %eax,-0x68(%ebp)
40005eb7:	8b 9d 78 ff ff ff    	mov    -0x88(%ebp),%ebx
40005ebd:	85 db                	test   %ebx,%ebx
40005ebf:	7e 3a                	jle    40005efb <_dtoa_r+0x7ab>
40005ec1:	8b 4d 80             	mov    -0x80(%ebp),%ecx
40005ec4:	85 c9                	test   %ecx,%ecx
40005ec6:	7e 33                	jle    40005efb <_dtoa_r+0x7ab>
40005ec8:	8b 45 80             	mov    -0x80(%ebp),%eax
40005ecb:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
40005ed1:	39 d0                	cmp    %edx,%eax
40005ed3:	7e 02                	jle    40005ed7 <_dtoa_r+0x787>
40005ed5:	89 d0                	mov    %edx,%eax
40005ed7:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
40005edd:	8b 9d 78 ff ff ff    	mov    -0x88(%ebp),%ebx
40005ee3:	8b 4d 80             	mov    -0x80(%ebp),%ecx
40005ee6:	29 c2                	sub    %eax,%edx
40005ee8:	29 c3                	sub    %eax,%ebx
40005eea:	29 c1                	sub    %eax,%ecx
40005eec:	89 95 54 ff ff ff    	mov    %edx,-0xac(%ebp)
40005ef2:	89 9d 78 ff ff ff    	mov    %ebx,-0x88(%ebp)
40005ef8:	89 4d 80             	mov    %ecx,-0x80(%ebp)
40005efb:	8b 95 58 ff ff ff    	mov    -0xa8(%ebp),%edx
40005f01:	85 d2                	test   %edx,%edx
40005f03:	7e 6a                	jle    40005f6f <_dtoa_r+0x81f>
40005f05:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
40005f0b:	85 c0                	test   %eax,%eax
40005f0d:	0f 84 89 07 00 00    	je     4000669c <_dtoa_r+0xf4c>
40005f13:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
40005f19:	85 c0                	test   %eax,%eax
40005f1b:	7e 40                	jle    40005f5d <_dtoa_r+0x80d>
40005f1d:	50                   	push   %eax
40005f1e:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
40005f24:	50                   	push   %eax
40005f25:	8b 45 98             	mov    -0x68(%ebp),%eax
40005f28:	50                   	push   %eax
40005f29:	8b 45 08             	mov    0x8(%ebp),%eax
40005f2c:	50                   	push   %eax
40005f2d:	e8 1e 28 00 00       	call   40008750 <__pow5mult>
40005f32:	83 c4 0c             	add    $0xc,%esp
40005f35:	8b 5d 90             	mov    -0x70(%ebp),%ebx
40005f38:	89 45 98             	mov    %eax,-0x68(%ebp)
40005f3b:	53                   	push   %ebx
40005f3c:	50                   	push   %eax
40005f3d:	8b 4d 08             	mov    0x8(%ebp),%ecx
40005f40:	51                   	push   %ecx
40005f41:	e8 2a 25 00 00       	call   40008470 <__multiply>
40005f46:	89 c3                	mov    %eax,%ebx
40005f48:	58                   	pop    %eax
40005f49:	8b 45 90             	mov    -0x70(%ebp),%eax
40005f4c:	5a                   	pop    %edx
40005f4d:	50                   	push   %eax
40005f4e:	8b 4d 08             	mov    0x8(%ebp),%ecx
40005f51:	51                   	push   %ecx
40005f52:	e8 d9 1b 00 00       	call   40007b30 <_Bfree>
40005f57:	89 5d 90             	mov    %ebx,-0x70(%ebp)
40005f5a:	83 c4 10             	add    $0x10,%esp
40005f5d:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
40005f63:	2b 85 7c ff ff ff    	sub    -0x84(%ebp),%eax
40005f69:	0f 85 ac 08 00 00    	jne    4000681b <_dtoa_r+0x10cb>
40005f6f:	50                   	push   %eax
40005f70:	50                   	push   %eax
40005f71:	6a 01                	push   $0x1
40005f73:	8b 45 08             	mov    0x8(%ebp),%eax
40005f76:	50                   	push   %eax
40005f77:	e8 e4 26 00 00       	call   40008660 <__i2b>
40005f7c:	8b 5d 84             	mov    -0x7c(%ebp),%ebx
40005f7f:	83 c4 10             	add    $0x10,%esp
40005f82:	89 45 9c             	mov    %eax,-0x64(%ebp)
40005f85:	85 db                	test   %ebx,%ebx
40005f87:	7e 15                	jle    40005f9e <_dtoa_r+0x84e>
40005f89:	51                   	push   %ecx
40005f8a:	8b 55 84             	mov    -0x7c(%ebp),%edx
40005f8d:	52                   	push   %edx
40005f8e:	50                   	push   %eax
40005f8f:	8b 45 08             	mov    0x8(%ebp),%eax
40005f92:	50                   	push   %eax
40005f93:	e8 b8 27 00 00       	call   40008750 <__pow5mult>
40005f98:	83 c4 10             	add    $0x10,%esp
40005f9b:	89 45 9c             	mov    %eax,-0x64(%ebp)
40005f9e:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
40005fa2:	0f 8e 91 03 00 00    	jle    40006339 <_dtoa_r+0xbe9>
40005fa8:	31 db                	xor    %ebx,%ebx
40005faa:	8b 45 84             	mov    -0x7c(%ebp),%eax
40005fad:	ba 01 00 00 00       	mov    $0x1,%edx
40005fb2:	85 c0                	test   %eax,%eax
40005fb4:	0f 85 26 06 00 00    	jne    400065e0 <_dtoa_r+0xe90>
40005fba:	8b 4d 80             	mov    -0x80(%ebp),%ecx
40005fbd:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
40005fc0:	ba 1c 00 00 00       	mov    $0x1c,%edx
40005fc5:	83 e0 1f             	and    $0x1f,%eax
40005fc8:	0f 84 69 04 00 00    	je     40006437 <_dtoa_r+0xce7>
40005fce:	b2 20                	mov    $0x20,%dl
40005fd0:	29 c2                	sub    %eax,%edx
40005fd2:	83 fa 04             	cmp    $0x4,%edx
40005fd5:	0f 8e 53 04 00 00    	jle    4000642e <_dtoa_r+0xcde>
40005fdb:	8d 42 fc             	lea    -0x4(%edx),%eax
40005fde:	8b bd 54 ff ff ff    	mov    -0xac(%ebp),%edi
40005fe4:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
40005fea:	01 c7                	add    %eax,%edi
40005fec:	01 c2                	add    %eax,%edx
40005fee:	01 c1                	add    %eax,%ecx
40005ff0:	89 bd 54 ff ff ff    	mov    %edi,-0xac(%ebp)
40005ff6:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
40005ffc:	89 4d 80             	mov    %ecx,-0x80(%ebp)
40005fff:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
40006005:	85 c0                	test   %eax,%eax
40006007:	7e 1b                	jle    40006024 <_dtoa_r+0x8d4>
40006009:	50                   	push   %eax
4000600a:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
40006010:	50                   	push   %eax
40006011:	8b 7d 90             	mov    -0x70(%ebp),%edi
40006014:	57                   	push   %edi
40006015:	8b 4d 08             	mov    0x8(%ebp),%ecx
40006018:	51                   	push   %ecx
40006019:	e8 32 23 00 00       	call   40008350 <__lshift>
4000601e:	83 c4 10             	add    $0x10,%esp
40006021:	89 45 90             	mov    %eax,-0x70(%ebp)
40006024:	8b 55 80             	mov    -0x80(%ebp),%edx
40006027:	85 d2                	test   %edx,%edx
40006029:	7e 18                	jle    40006043 <_dtoa_r+0x8f3>
4000602b:	50                   	push   %eax
4000602c:	8b 45 80             	mov    -0x80(%ebp),%eax
4000602f:	50                   	push   %eax
40006030:	8b 45 9c             	mov    -0x64(%ebp),%eax
40006033:	50                   	push   %eax
40006034:	8b 45 08             	mov    0x8(%ebp),%eax
40006037:	50                   	push   %eax
40006038:	e8 13 23 00 00       	call   40008350 <__lshift>
4000603d:	83 c4 10             	add    $0x10,%esp
40006040:	89 45 9c             	mov    %eax,-0x64(%ebp)
40006043:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
40006049:	85 c0                	test   %eax,%eax
4000604b:	0f 85 b1 05 00 00    	jne    40006602 <_dtoa_r+0xeb2>
40006051:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
40006057:	85 c0                	test   %eax,%eax
40006059:	0f 8e 3e 07 00 00    	jle    4000679d <_dtoa_r+0x104d>
4000605f:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
40006065:	85 c0                	test   %eax,%eax
40006067:	0f 84 4f 06 00 00    	je     400066bc <_dtoa_r+0xf6c>
4000606d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
40006073:	85 c0                	test   %eax,%eax
40006075:	7e 1b                	jle    40006092 <_dtoa_r+0x942>
40006077:	50                   	push   %eax
40006078:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
4000607e:	50                   	push   %eax
4000607f:	8b 7d 98             	mov    -0x68(%ebp),%edi
40006082:	57                   	push   %edi
40006083:	8b 4d 08             	mov    0x8(%ebp),%ecx
40006086:	51                   	push   %ecx
40006087:	e8 c4 22 00 00       	call   40008350 <__lshift>
4000608c:	83 c4 10             	add    $0x10,%esp
4000608f:	89 45 98             	mov    %eax,-0x68(%ebp)
40006092:	8b 45 98             	mov    -0x68(%ebp),%eax
40006095:	85 db                	test   %ebx,%ebx
40006097:	0f 85 7d 08 00 00    	jne    4000691a <_dtoa_r+0x11ca>
4000609d:	83 e6 01             	and    $0x1,%esi
400060a0:	8b 7d d4             	mov    -0x2c(%ebp),%edi
400060a3:	89 b5 50 ff ff ff    	mov    %esi,-0xb0(%ebp)
400060a9:	8b b5 60 ff ff ff    	mov    -0xa0(%ebp),%esi
400060af:	8b 4d 98             	mov    -0x68(%ebp),%ecx
400060b2:	01 fe                	add    %edi,%esi
400060b4:	89 4d 94             	mov    %ecx,-0x6c(%ebp)
400060b7:	89 45 98             	mov    %eax,-0x68(%ebp)
400060ba:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%ebp)
400060c0:	8b 55 9c             	mov    -0x64(%ebp),%edx
400060c3:	8b 45 90             	mov    -0x70(%ebp),%eax
400060c6:	e8 75 f4 ff ff       	call   40005540 <quorem>
400060cb:	83 c0 30             	add    $0x30,%eax
400060ce:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
400060d4:	56                   	push   %esi
400060d5:	56                   	push   %esi
400060d6:	8b 5d 94             	mov    -0x6c(%ebp),%ebx
400060d9:	53                   	push   %ebx
400060da:	8b 4d 90             	mov    -0x70(%ebp),%ecx
400060dd:	51                   	push   %ecx
400060de:	e8 5d 1b 00 00       	call   40007c40 <__mcmp>
400060e3:	83 c4 0c             	add    $0xc,%esp
400060e6:	8b 55 98             	mov    -0x68(%ebp),%edx
400060e9:	89 c6                	mov    %eax,%esi
400060eb:	52                   	push   %edx
400060ec:	8b 45 9c             	mov    -0x64(%ebp),%eax
400060ef:	50                   	push   %eax
400060f0:	8b 45 08             	mov    0x8(%ebp),%eax
400060f3:	50                   	push   %eax
400060f4:	e8 e7 20 00 00       	call   400081e0 <__mdiff>
400060f9:	89 c3                	mov    %eax,%ebx
400060fb:	83 c4 10             	add    $0x10,%esp
400060fe:	8b 40 0c             	mov    0xc(%eax),%eax
40006101:	c7 85 68 ff ff ff 01 	movl   $0x1,-0x98(%ebp)
40006108:	00 00 00 
4000610b:	85 c0                	test   %eax,%eax
4000610d:	0f 84 e5 02 00 00    	je     400063f8 <_dtoa_r+0xca8>
40006113:	50                   	push   %eax
40006114:	50                   	push   %eax
40006115:	53                   	push   %ebx
40006116:	8b 5d 08             	mov    0x8(%ebp),%ebx
40006119:	53                   	push   %ebx
4000611a:	e8 11 1a 00 00       	call   40007b30 <_Bfree>
4000611f:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
40006125:	83 c4 10             	add    $0x10,%esp
40006128:	0b 45 14             	or     0x14(%ebp),%eax
4000612b:	75 0e                	jne    4000613b <_dtoa_r+0x9eb>
4000612d:	8b 8d 50 ff ff ff    	mov    -0xb0(%ebp),%ecx
40006133:	85 c9                	test   %ecx,%ecx
40006135:	0f 84 c9 08 00 00    	je     40006a04 <_dtoa_r+0x12b4>
4000613b:	85 f6                	test   %esi,%esi
4000613d:	0f 88 47 07 00 00    	js     4000688a <_dtoa_r+0x113a>
40006143:	0b 75 14             	or     0x14(%ebp),%esi
40006146:	75 0e                	jne    40006156 <_dtoa_r+0xa06>
40006148:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
4000614e:	85 c0                	test   %eax,%eax
40006150:	0f 84 34 07 00 00    	je     4000688a <_dtoa_r+0x113a>
40006156:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
4000615c:	85 c0                	test   %eax,%eax
4000615e:	0f 8f 2e 08 00 00    	jg     40006992 <_dtoa_r+0x1242>
40006164:	8a 85 5c ff ff ff    	mov    -0xa4(%ebp),%al
4000616a:	88 07                	mov    %al,(%edi)
4000616c:	47                   	inc    %edi
4000616d:	3b bd 24 ff ff ff    	cmp    -0xdc(%ebp),%edi
40006173:	0f 84 8f 05 00 00    	je     40006708 <_dtoa_r+0xfb8>
40006179:	6a 00                	push   $0x0
4000617b:	6a 0a                	push   $0xa
4000617d:	8b 45 90             	mov    -0x70(%ebp),%eax
40006180:	50                   	push   %eax
40006181:	8b 75 08             	mov    0x8(%ebp),%esi
40006184:	56                   	push   %esi
40006185:	e8 f6 24 00 00       	call   40008680 <__multadd>
4000618a:	8b 55 98             	mov    -0x68(%ebp),%edx
4000618d:	83 c4 10             	add    $0x10,%esp
40006190:	89 45 90             	mov    %eax,-0x70(%ebp)
40006193:	39 55 94             	cmp    %edx,-0x6c(%ebp)
40006196:	0f 84 76 02 00 00    	je     40006412 <_dtoa_r+0xcc2>
4000619c:	6a 00                	push   $0x0
4000619e:	6a 0a                	push   $0xa
400061a0:	8b 4d 94             	mov    -0x6c(%ebp),%ecx
400061a3:	51                   	push   %ecx
400061a4:	8b 55 08             	mov    0x8(%ebp),%edx
400061a7:	52                   	push   %edx
400061a8:	e8 d3 24 00 00       	call   40008680 <__multadd>
400061ad:	89 45 94             	mov    %eax,-0x6c(%ebp)
400061b0:	6a 00                	push   $0x0
400061b2:	6a 0a                	push   $0xa
400061b4:	8b 45 98             	mov    -0x68(%ebp),%eax
400061b7:	50                   	push   %eax
400061b8:	8b 45 08             	mov    0x8(%ebp),%eax
400061bb:	50                   	push   %eax
400061bc:	e8 bf 24 00 00       	call   40008680 <__multadd>
400061c1:	83 c4 20             	add    $0x20,%esp
400061c4:	89 45 98             	mov    %eax,-0x68(%ebp)
400061c7:	e9 f4 fe ff ff       	jmp    400060c0 <_dtoa_r+0x970>
400061cc:	8b 45 14             	mov    0x14(%ebp),%eax
400061cf:	ff 24 85 70 c5 00 40 	jmp    *0x4000c570(,%eax,4)
400061d6:	b9 20 00 00 00       	mov    $0x20,%ecx
400061db:	8b 45 d0             	mov    -0x30(%ebp),%eax
400061de:	29 c1                	sub    %eax,%ecx
400061e0:	89 f2                	mov    %esi,%edx
400061e2:	d3 e2                	shl    %cl,%edx
400061e4:	e9 74 f6 ff ff       	jmp    4000585d <_dtoa_r+0x10d>
400061e9:	dd 45 a0             	fldl   -0x60(%ebp)
400061ec:	dc 35 20 c7 00 40    	fdivl  0x4000c720
400061f2:	83 e2 0f             	and    $0xf,%edx
400061f5:	b3 03                	mov    $0x3,%bl
400061f7:	dd 9d 18 ff ff ff    	fstpl  -0xe8(%ebp)
400061fd:	8b b5 18 ff ff ff    	mov    -0xe8(%ebp),%esi
40006203:	8b bd 1c ff ff ff    	mov    -0xe4(%ebp),%edi
40006209:	e9 ff f7 ff ff       	jmp    40005a0d <_dtoa_r+0x2bd>
4000620e:	dd d8                	fstp   %st(0)
40006210:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
40006216:	8b 8d 60 ff ff ff    	mov    -0xa0(%ebp),%ecx
4000621c:	89 55 cc             	mov    %edx,-0x34(%ebp)
4000621f:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
40006225:	85 c0                	test   %eax,%eax
40006227:	0f 84 9a 02 00 00    	je     400064c7 <_dtoa_r+0xd77>
4000622d:	d9 05 9c c5 00 40    	flds   0x4000c59c
40006233:	d9 7d de             	fnstcw -0x22(%ebp)
40006236:	dc 34 cd 18 c6 00 40 	fdivl  0x4000c618(,%ecx,8)
4000623d:	66 8b 45 de          	mov    -0x22(%ebp),%ax
40006241:	89 75 c0             	mov    %esi,-0x40(%ebp)
40006244:	89 7d c4             	mov    %edi,-0x3c(%ebp)
40006247:	b4 0c                	mov    $0xc,%ah
40006249:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
4000624d:	dc a5 40 ff ff ff    	fsubl  -0xc0(%ebp)
40006253:	dd 45 c0             	fldl   -0x40(%ebp)
40006256:	d9 6d dc             	fldcw  -0x24(%ebp)
40006259:	db 5d d8             	fistpl -0x28(%ebp)
4000625c:	d9 6d de             	fldcw  -0x22(%ebp)
4000625f:	8b 45 d8             	mov    -0x28(%ebp),%eax
40006262:	50                   	push   %eax
40006263:	83 c0 30             	add    $0x30,%eax
40006266:	db 04 24             	fildl  (%esp)
40006269:	dd 45 c0             	fldl   -0x40(%ebp)
4000626c:	de e1                	fsubp  %st,%st(1)
4000626e:	d9 c9                	fxch   %st(1)
40006270:	8b 55 d4             	mov    -0x2c(%ebp),%edx
40006273:	89 d3                	mov    %edx,%ebx
40006275:	83 c4 04             	add    $0x4,%esp
40006278:	88 02                	mov    %al,(%edx)
4000627a:	43                   	inc    %ebx
4000627b:	dd e1                	fucom  %st(1)
4000627d:	df e0                	fnstsw %ax
4000627f:	f6 c4 45             	test   $0x45,%ah
40006282:	74 7f                	je     40006303 <_dtoa_r+0xbb3>
40006284:	d9 c1                	fld    %st(1)
40006286:	d8 2d 8c c5 00 40    	fsubrs 0x4000c58c
4000628c:	d9 c9                	fxch   %st(1)
4000628e:	dd e1                	fucom  %st(1)
40006290:	df e0                	fnstsw %ax
40006292:	dd d9                	fstp   %st(1)
40006294:	f6 c4 45             	test   $0x45,%ah
40006297:	0f 84 1f 03 00 00    	je     400065bc <_dtoa_r+0xe6c>
4000629d:	83 f9 01             	cmp    $0x1,%ecx
400062a0:	0f 8e e4 f9 ff ff    	jle    40005c8a <_dtoa_r+0x53a>
400062a6:	8b 75 d4             	mov    -0x2c(%ebp),%esi
400062a9:	8d 14 31             	lea    (%ecx,%esi,1),%edx
400062ac:	eb 23                	jmp    400062d1 <_dtoa_r+0xb81>
400062ae:	66 90                	xchg   %ax,%ax
400062b0:	d9 c1                	fld    %st(1)
400062b2:	d8 2d 8c c5 00 40    	fsubrs 0x4000c58c
400062b8:	d9 c9                	fxch   %st(1)
400062ba:	dd e1                	fucom  %st(1)
400062bc:	df e0                	fnstsw %ax
400062be:	dd d9                	fstp   %st(1)
400062c0:	f6 c4 45             	test   $0x45,%ah
400062c3:	0f 84 f3 02 00 00    	je     400065bc <_dtoa_r+0xe6c>
400062c9:	39 d3                	cmp    %edx,%ebx
400062cb:	0f 84 14 05 00 00    	je     400067e5 <_dtoa_r+0x1095>
400062d1:	d9 05 90 c5 00 40    	flds   0x4000c590
400062d7:	dc c9                	fmul   %st,%st(1)
400062d9:	de ca                	fmulp  %st,%st(2)
400062db:	d9 c9                	fxch   %st(1)
400062dd:	d9 6d dc             	fldcw  -0x24(%ebp)
400062e0:	db 55 d8             	fistl  -0x28(%ebp)
400062e3:	d9 6d de             	fldcw  -0x22(%ebp)
400062e6:	8b 45 d8             	mov    -0x28(%ebp),%eax
400062e9:	50                   	push   %eax
400062ea:	83 c0 30             	add    $0x30,%eax
400062ed:	db 04 24             	fildl  (%esp)
400062f0:	de e9                	fsubrp %st,%st(1)
400062f2:	d9 c9                	fxch   %st(1)
400062f4:	88 03                	mov    %al,(%ebx)
400062f6:	83 c4 04             	add    $0x4,%esp
400062f9:	43                   	inc    %ebx
400062fa:	dd e1                	fucom  %st(1)
400062fc:	df e0                	fnstsw %ax
400062fe:	f6 c4 45             	test   $0x45,%ah
40006301:	75 ad                	jne    400062b0 <_dtoa_r+0xb60>
40006303:	dd d8                	fstp   %st(0)
40006305:	dd d8                	fstp   %st(0)
40006307:	8b 55 cc             	mov    -0x34(%ebp),%edx
4000630a:	89 95 6c ff ff ff    	mov    %edx,-0x94(%ebp)
40006310:	e9 39 f9 ff ff       	jmp    40005c4e <_dtoa_r+0x4fe>
40006315:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
4000631b:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
40006321:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
40006327:	89 8d 7c ff ff ff    	mov    %ecx,-0x84(%ebp)
4000632d:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
40006334:	e9 7e fb ff ff       	jmp    40005eb7 <_dtoa_r+0x767>
40006339:	85 f6                	test   %esi,%esi
4000633b:	0f 85 67 fc ff ff    	jne    40005fa8 <_dtoa_r+0x858>
40006341:	89 f8                	mov    %edi,%eax
40006343:	a9 ff ff 0f 00       	test   $0xfffff,%eax
40006348:	0f 85 5a fc ff ff    	jne    40005fa8 <_dtoa_r+0x858>
4000634e:	a9 00 00 f0 7f       	test   $0x7ff00000,%eax
40006353:	0f 84 4f fc ff ff    	je     40005fa8 <_dtoa_r+0x858>
40006359:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
4000635f:	bb 01 00 00 00       	mov    $0x1,%ebx
40006364:	40                   	inc    %eax
40006365:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
4000636b:	8b 45 80             	mov    -0x80(%ebp),%eax
4000636e:	40                   	inc    %eax
4000636f:	89 45 80             	mov    %eax,-0x80(%ebp)
40006372:	e9 33 fc ff ff       	jmp    40005faa <_dtoa_r+0x85a>
40006377:	c7 85 74 ff ff ff 00 	movl   $0x0,-0x8c(%ebp)
4000637e:	00 00 00 
40006381:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
40006387:	8b 4d 18             	mov    0x18(%ebp),%ecx
4000638a:	8d 44 0a 01          	lea    0x1(%edx,%ecx,1),%eax
4000638e:	85 c0                	test   %eax,%eax
40006390:	8d 50 ff             	lea    -0x1(%eax),%edx
40006393:	89 95 64 ff ff ff    	mov    %edx,-0x9c(%ebp)
40006399:	0f 8e 64 05 00 00    	jle    40006903 <_dtoa_r+0x11b3>
4000639f:	89 c3                	mov    %eax,%ebx
400063a1:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
400063a7:	e9 4a fa ff ff       	jmp    40005df6 <_dtoa_r+0x6a6>
400063ac:	c7 85 74 ff ff ff 00 	movl   $0x0,-0x8c(%ebp)
400063b3:	00 00 00 
400063b6:	8b 5d 18             	mov    0x18(%ebp),%ebx
400063b9:	85 db                	test   %ebx,%ebx
400063bb:	0f 8e 31 05 00 00    	jle    400068f2 <_dtoa_r+0x11a2>
400063c1:	8b 4d 18             	mov    0x18(%ebp),%ecx
400063c4:	89 8d 60 ff ff ff    	mov    %ecx,-0xa0(%ebp)
400063ca:	89 8d 64 ff ff ff    	mov    %ecx,-0x9c(%ebp)
400063d0:	e9 21 fa ff ff       	jmp    40005df6 <_dtoa_r+0x6a6>
400063d5:	c7 85 74 ff ff ff 01 	movl   $0x1,-0x8c(%ebp)
400063dc:	00 00 00 
400063df:	eb a0                	jmp    40006381 <_dtoa_r+0xc31>
400063e1:	8a 55 88             	mov    -0x78(%ebp),%dl
400063e4:	88 55 af             	mov    %dl,-0x51(%ebp)
400063e7:	e9 8e f5 ff ff       	jmp    4000597a <_dtoa_r+0x22a>
400063ec:	c7 85 74 ff ff ff 01 	movl   $0x1,-0x8c(%ebp)
400063f3:	00 00 00 
400063f6:	eb be                	jmp    400063b6 <_dtoa_r+0xc66>
400063f8:	50                   	push   %eax
400063f9:	50                   	push   %eax
400063fa:	53                   	push   %ebx
400063fb:	8b 45 90             	mov    -0x70(%ebp),%eax
400063fe:	50                   	push   %eax
400063ff:	e8 3c 18 00 00       	call   40007c40 <__mcmp>
40006404:	83 c4 10             	add    $0x10,%esp
40006407:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
4000640d:	e9 01 fd ff ff       	jmp    40006113 <_dtoa_r+0x9c3>
40006412:	6a 00                	push   $0x0
40006414:	6a 0a                	push   $0xa
40006416:	52                   	push   %edx
40006417:	8b 5d 08             	mov    0x8(%ebp),%ebx
4000641a:	53                   	push   %ebx
4000641b:	e8 60 22 00 00       	call   40008680 <__multadd>
40006420:	83 c4 10             	add    $0x10,%esp
40006423:	89 45 98             	mov    %eax,-0x68(%ebp)
40006426:	89 45 94             	mov    %eax,-0x6c(%ebp)
40006429:	e9 92 fc ff ff       	jmp    400060c0 <_dtoa_r+0x970>
4000642e:	0f 84 cb fb ff ff    	je     40005fff <_dtoa_r+0x8af>
40006434:	83 c2 1c             	add    $0x1c,%edx
40006437:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
4000643d:	01 d0                	add    %edx,%eax
4000643f:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
40006445:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
4000644b:	01 d0                	add    %edx,%eax
4000644d:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
40006453:	8b 45 80             	mov    -0x80(%ebp),%eax
40006456:	01 d0                	add    %edx,%eax
40006458:	89 45 80             	mov    %eax,-0x80(%ebp)
4000645b:	e9 9f fb ff ff       	jmp    40005fff <_dtoa_r+0x8af>
40006460:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
40006466:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
4000646c:	29 c8                	sub    %ecx,%eax
4000646e:	c7 45 84 00 00 00 00 	movl   $0x0,-0x7c(%ebp)
40006475:	f7 d9                	neg    %ecx
40006477:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
4000647d:	89 8d 58 ff ff ff    	mov    %ecx,-0xa8(%ebp)
40006483:	e9 dd f4 ff ff       	jmp    40005965 <_dtoa_r+0x215>
40006488:	f7 d8                	neg    %eax
4000648a:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
40006490:	c7 45 80 00 00 00 00 	movl   $0x0,-0x80(%ebp)
40006497:	e9 a0 f4 ff ff       	jmp    4000593c <_dtoa_r+0x1ec>
4000649c:	db 85 6c ff ff ff    	fildl  -0x94(%ebp)
400064a2:	da e9                	fucompp 
400064a4:	df e0                	fnstsw %ax
400064a6:	80 e4 45             	and    $0x45,%ah
400064a9:	80 f4 40             	xor    $0x40,%ah
400064ac:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
400064b2:	0f 95 c0             	setne  %al
400064b5:	25 ff 00 00 00       	and    $0xff,%eax
400064ba:	29 c1                	sub    %eax,%ecx
400064bc:	89 8d 6c ff ff ff    	mov    %ecx,-0x94(%ebp)
400064c2:	e9 1b f4 ff ff       	jmp    400058e2 <_dtoa_r+0x192>
400064c7:	dd 85 40 ff ff ff    	fldl   -0xc0(%ebp)
400064cd:	d9 7d de             	fnstcw -0x22(%ebp)
400064d0:	dc 0c cd 18 c6 00 40 	fmull  0x4000c618(,%ecx,8)
400064d7:	66 8b 45 de          	mov    -0x22(%ebp),%ax
400064db:	89 75 b8             	mov    %esi,-0x48(%ebp)
400064de:	89 7d bc             	mov    %edi,-0x44(%ebp)
400064e1:	b4 0c                	mov    $0xc,%ah
400064e3:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
400064e7:	dd 45 b8             	fldl   -0x48(%ebp)
400064ea:	d9 6d dc             	fldcw  -0x24(%ebp)
400064ed:	db 5d d8             	fistpl -0x28(%ebp)
400064f0:	d9 6d de             	fldcw  -0x22(%ebp)
400064f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
400064f6:	50                   	push   %eax
400064f7:	83 c0 30             	add    $0x30,%eax
400064fa:	db 04 24             	fildl  (%esp)
400064fd:	dc 6d b8             	fsubrl -0x48(%ebp)
40006500:	8b 55 d4             	mov    -0x2c(%ebp),%edx
40006503:	89 d3                	mov    %edx,%ebx
40006505:	83 c4 04             	add    $0x4,%esp
40006508:	43                   	inc    %ebx
40006509:	83 f9 01             	cmp    $0x1,%ecx
4000650c:	dd 9d 28 ff ff ff    	fstpl  -0xd8(%ebp)
40006512:	8b b5 28 ff ff ff    	mov    -0xd8(%ebp),%esi
40006518:	8b bd 2c ff ff ff    	mov    -0xd4(%ebp),%edi
4000651e:	88 02                	mov    %al,(%edx)
40006520:	74 52                	je     40006574 <_dtoa_r+0xe24>
40006522:	dd 85 28 ff ff ff    	fldl   -0xd8(%ebp)
40006528:	ba 01 00 00 00       	mov    $0x1,%edx
4000652d:	8d 76 00             	lea    0x0(%esi),%esi
40006530:	d8 0d 90 c5 00 40    	fmuls  0x4000c590
40006536:	42                   	inc    %edx
40006537:	d9 6d dc             	fldcw  -0x24(%ebp)
4000653a:	db 55 d8             	fistl  -0x28(%ebp)
4000653d:	d9 6d de             	fldcw  -0x22(%ebp)
40006540:	8b 45 d8             	mov    -0x28(%ebp),%eax
40006543:	50                   	push   %eax
40006544:	83 c0 30             	add    $0x30,%eax
40006547:	8b 75 d4             	mov    -0x2c(%ebp),%esi
4000654a:	db 04 24             	fildl  (%esp)
4000654d:	de e9                	fsubrp %st,%st(1)
4000654f:	83 c4 04             	add    $0x4,%esp
40006552:	88 44 32 ff          	mov    %al,-0x1(%edx,%esi,1)
40006556:	39 ca                	cmp    %ecx,%edx
40006558:	75 d6                	jne    40006530 <_dtoa_r+0xde0>
4000655a:	dd 9d 18 ff ff ff    	fstpl  -0xe8(%ebp)
40006560:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
40006566:	8b 95 1c ff ff ff    	mov    -0xe4(%ebp),%edx
4000656c:	8d 5c 19 ff          	lea    -0x1(%ecx,%ebx,1),%ebx
40006570:	89 c6                	mov    %eax,%esi
40006572:	89 d7                	mov    %edx,%edi
40006574:	d9 05 9c c5 00 40    	flds   0x4000c59c
4000657a:	d9 c1                	fld    %st(1)
4000657c:	d8 c1                	fadd   %st(1),%st
4000657e:	89 75 b0             	mov    %esi,-0x50(%ebp)
40006581:	89 7d b4             	mov    %edi,-0x4c(%ebp)
40006584:	dd 45 b0             	fldl   -0x50(%ebp)
40006587:	dd e1                	fucom  %st(1)
40006589:	df e0                	fnstsw %ax
4000658b:	dd d9                	fstp   %st(1)
4000658d:	f6 c4 45             	test   $0x45,%ah
40006590:	74 28                	je     400065ba <_dtoa_r+0xe6a>
40006592:	d9 c9                	fxch   %st(1)
40006594:	de e2                	fsubp  %st,%st(2)
40006596:	d9 c9                	fxch   %st(1)
40006598:	da e9                	fucompp 
4000659a:	df e0                	fnstsw %ax
4000659c:	f6 c4 45             	test   $0x45,%ah
4000659f:	0f 85 e9 f6 ff ff    	jne    40005c8e <_dtoa_r+0x53e>
400065a5:	4b                   	dec    %ebx
400065a6:	80 3b 30             	cmpb   $0x30,(%ebx)
400065a9:	74 fa                	je     400065a5 <_dtoa_r+0xe55>
400065ab:	8b 55 cc             	mov    -0x34(%ebp),%edx
400065ae:	43                   	inc    %ebx
400065af:	89 95 6c ff ff ff    	mov    %edx,-0x94(%ebp)
400065b5:	e9 94 f6 ff ff       	jmp    40005c4e <_dtoa_r+0x4fe>
400065ba:	dd d8                	fstp   %st(0)
400065bc:	dd d8                	fstp   %st(0)
400065be:	dd d8                	fstp   %st(0)
400065c0:	e9 bb f7 ff ff       	jmp    40005d80 <_dtoa_r+0x630>
400065c5:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
400065cb:	f7 da                	neg    %edx
400065cd:	0f 85 4f 02 00 00    	jne    40006822 <_dtoa_r+0x10d2>
400065d3:	dd 45 a0             	fldl   -0x60(%ebp)
400065d6:	bb 02 00 00 00       	mov    $0x2,%ebx
400065db:	e9 78 f4 ff ff       	jmp    40005a58 <_dtoa_r+0x308>
400065e0:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
400065e3:	83 ec 0c             	sub    $0xc,%esp
400065e6:	8b 41 10             	mov    0x10(%ecx),%eax
400065e9:	8b 44 81 10          	mov    0x10(%ecx,%eax,4),%eax
400065ed:	50                   	push   %eax
400065ee:	e8 5d 15 00 00       	call   40007b50 <__hi0bits>
400065f3:	ba 20 00 00 00       	mov    $0x20,%edx
400065f8:	83 c4 10             	add    $0x10,%esp
400065fb:	29 c2                	sub    %eax,%edx
400065fd:	e9 b8 f9 ff ff       	jmp    40005fba <_dtoa_r+0x86a>
40006602:	50                   	push   %eax
40006603:	50                   	push   %eax
40006604:	8b 7d 9c             	mov    -0x64(%ebp),%edi
40006607:	57                   	push   %edi
40006608:	8b 4d 90             	mov    -0x70(%ebp),%ecx
4000660b:	51                   	push   %ecx
4000660c:	e8 2f 16 00 00       	call   40007c40 <__mcmp>
40006611:	83 c4 10             	add    $0x10,%esp
40006614:	85 c0                	test   %eax,%eax
40006616:	0f 89 35 fa ff ff    	jns    40006051 <_dtoa_r+0x901>
4000661c:	6a 00                	push   $0x0
4000661e:	6a 0a                	push   $0xa
40006620:	8b 55 90             	mov    -0x70(%ebp),%edx
40006623:	52                   	push   %edx
40006624:	8b 45 08             	mov    0x8(%ebp),%eax
40006627:	50                   	push   %eax
40006628:	e8 53 20 00 00       	call   40008680 <__multadd>
4000662d:	89 45 90             	mov    %eax,-0x70(%ebp)
40006630:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
40006636:	83 c4 10             	add    $0x10,%esp
40006639:	85 c0                	test   %eax,%eax
4000663b:	0f 85 16 04 00 00    	jne    40006a57 <_dtoa_r+0x1307>
40006641:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
40006647:	48                   	dec    %eax
40006648:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
4000664e:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
40006654:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
4000665a:	e9 f2 f9 ff ff       	jmp    40006051 <_dtoa_r+0x901>
4000665f:	dd d8                	fstp   %st(0)
40006661:	dd d8                	fstp   %st(0)
40006663:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
4000666a:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
40006671:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
40006674:	89 cb                	mov    %ecx,%ebx
40006676:	c6 01 31             	movb   $0x31,(%ecx)
40006679:	43                   	inc    %ebx
4000667a:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
40006680:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
40006687:	40                   	inc    %eax
40006688:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
4000668e:	e9 6f f5 ff ff       	jmp    40005c02 <_dtoa_r+0x4b2>
40006693:	dd d8                	fstp   %st(0)
40006695:	dd d8                	fstp   %st(0)
40006697:	e9 b2 f5 ff ff       	jmp    40005c4e <_dtoa_r+0x4fe>
4000669c:	50                   	push   %eax
4000669d:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
400066a3:	50                   	push   %eax
400066a4:	8b 45 90             	mov    -0x70(%ebp),%eax
400066a7:	50                   	push   %eax
400066a8:	8b 45 08             	mov    0x8(%ebp),%eax
400066ab:	50                   	push   %eax
400066ac:	e8 9f 20 00 00       	call   40008750 <__pow5mult>
400066b1:	83 c4 10             	add    $0x10,%esp
400066b4:	89 45 90             	mov    %eax,-0x70(%ebp)
400066b7:	e9 b3 f8 ff ff       	jmp    40005f6f <_dtoa_r+0x81f>
400066bc:	bb 01 00 00 00       	mov    $0x1,%ebx
400066c1:	eb 18                	jmp    400066db <_dtoa_r+0xf8b>
400066c3:	6a 00                	push   $0x0
400066c5:	6a 0a                	push   $0xa
400066c7:	8b 45 90             	mov    -0x70(%ebp),%eax
400066ca:	43                   	inc    %ebx
400066cb:	50                   	push   %eax
400066cc:	8b 45 08             	mov    0x8(%ebp),%eax
400066cf:	50                   	push   %eax
400066d0:	e8 ab 1f 00 00       	call   40008680 <__multadd>
400066d5:	83 c4 10             	add    $0x10,%esp
400066d8:	89 45 90             	mov    %eax,-0x70(%ebp)
400066db:	8b 55 9c             	mov    -0x64(%ebp),%edx
400066de:	8b 45 90             	mov    -0x70(%ebp),%eax
400066e1:	e8 5a ee ff ff       	call   40005540 <quorem>
400066e6:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
400066e9:	83 c0 30             	add    $0x30,%eax
400066ec:	8d 3c 0b             	lea    (%ebx,%ecx,1),%edi
400066ef:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
400066f5:	88 44 0b ff          	mov    %al,-0x1(%ebx,%ecx,1)
400066f9:	3b 9d 60 ff ff ff    	cmp    -0xa0(%ebp),%ebx
400066ff:	7c c2                	jl     400066c3 <_dtoa_r+0xf73>
40006701:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
40006708:	50                   	push   %eax
40006709:	6a 01                	push   $0x1
4000670b:	8b 45 90             	mov    -0x70(%ebp),%eax
4000670e:	50                   	push   %eax
4000670f:	8b 75 08             	mov    0x8(%ebp),%esi
40006712:	56                   	push   %esi
40006713:	e8 38 1c 00 00       	call   40008350 <__lshift>
40006718:	89 45 90             	mov    %eax,-0x70(%ebp)
4000671b:	8b 55 9c             	mov    -0x64(%ebp),%edx
4000671e:	59                   	pop    %ecx
4000671f:	5b                   	pop    %ebx
40006720:	52                   	push   %edx
40006721:	50                   	push   %eax
40006722:	e8 19 15 00 00       	call   40007c40 <__mcmp>
40006727:	83 c4 10             	add    $0x10,%esp
4000672a:	83 f8 00             	cmp    $0x0,%eax
4000672d:	0f 8e b4 02 00 00    	jle    400069e7 <_dtoa_r+0x1297>
40006733:	4f                   	dec    %edi
40006734:	8a 07                	mov    (%edi),%al
40006736:	3c 39                	cmp    $0x39,%al
40006738:	0f 85 89 02 00 00    	jne    400069c7 <_dtoa_r+0x1277>
4000673e:	39 7d d4             	cmp    %edi,-0x2c(%ebp)
40006741:	75 f0                	jne    40006733 <_dtoa_r+0xfe3>
40006743:	8b 75 d4             	mov    -0x2c(%ebp),%esi
40006746:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
4000674c:	89 f3                	mov    %esi,%ebx
4000674e:	40                   	inc    %eax
4000674f:	43                   	inc    %ebx
40006750:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
40006756:	c6 06 31             	movb   $0x31,(%esi)
40006759:	e9 a4 f4 ff ff       	jmp    40005c02 <_dtoa_r+0x4b2>
4000675e:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
40006765:	0f 8f 59 f5 ff ff    	jg     40005cc4 <_dtoa_r+0x574>
4000676b:	0f 8c f1 01 00 00    	jl     40006962 <_dtoa_r+0x1212>
40006771:	d8 0d 98 c5 00 40    	fmuls  0x4000c598
40006777:	89 b5 18 ff ff ff    	mov    %esi,-0xe8(%ebp)
4000677d:	89 bd 1c ff ff ff    	mov    %edi,-0xe4(%ebp)
40006783:	dd 85 18 ff ff ff    	fldl   -0xe8(%ebp)
40006789:	d9 c9                	fxch   %st(1)
4000678b:	da e9                	fucompp 
4000678d:	df e0                	fnstsw %ax
4000678f:	f6 c4 05             	test   $0x5,%ah
40006792:	0f 84 46 f4 ff ff    	je     40005bde <_dtoa_r+0x48e>
40006798:	e9 c6 fe ff ff       	jmp    40006663 <_dtoa_r+0xf13>
4000679d:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
400067a1:	0f 8e b8 f8 ff ff    	jle    4000605f <_dtoa_r+0x90f>
400067a7:	8b bd 60 ff ff ff    	mov    -0xa0(%ebp),%edi
400067ad:	85 ff                	test   %edi,%edi
400067af:	0f 88 37 f4 ff ff    	js     40005bec <_dtoa_r+0x49c>
400067b5:	6a 00                	push   $0x0
400067b7:	6a 05                	push   $0x5
400067b9:	8b 75 9c             	mov    -0x64(%ebp),%esi
400067bc:	56                   	push   %esi
400067bd:	8b 5d 08             	mov    0x8(%ebp),%ebx
400067c0:	53                   	push   %ebx
400067c1:	e8 ba 1e 00 00       	call   40008680 <__multadd>
400067c6:	89 45 9c             	mov    %eax,-0x64(%ebp)
400067c9:	5a                   	pop    %edx
400067ca:	59                   	pop    %ecx
400067cb:	50                   	push   %eax
400067cc:	8b 45 90             	mov    -0x70(%ebp),%eax
400067cf:	50                   	push   %eax
400067d0:	e8 6b 14 00 00       	call   40007c40 <__mcmp>
400067d5:	83 c4 10             	add    $0x10,%esp
400067d8:	85 c0                	test   %eax,%eax
400067da:	0f 8f 91 fe ff ff    	jg     40006671 <_dtoa_r+0xf21>
400067e0:	e9 07 f4 ff ff       	jmp    40005bec <_dtoa_r+0x49c>
400067e5:	dd d8                	fstp   %st(0)
400067e7:	dd d8                	fstp   %st(0)
400067e9:	e9 a0 f4 ff ff       	jmp    40005c8e <_dtoa_r+0x53e>
400067ee:	8b 9d 58 ff ff ff    	mov    -0xa8(%ebp),%ebx
400067f4:	8b 4d 84             	mov    -0x7c(%ebp),%ecx
400067f7:	29 d8                	sub    %ebx,%eax
400067f9:	8b 95 58 ff ff ff    	mov    -0xa8(%ebp),%edx
400067ff:	01 c1                	add    %eax,%ecx
40006801:	01 c2                	add    %eax,%edx
40006803:	89 4d 84             	mov    %ecx,-0x7c(%ebp)
40006806:	89 95 58 ff ff ff    	mov    %edx,-0xa8(%ebp)
4000680c:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
40006813:	00 00 00 
40006816:	e9 53 f6 ff ff       	jmp    40005e6e <_dtoa_r+0x71e>
4000681b:	52                   	push   %edx
4000681c:	50                   	push   %eax
4000681d:	e9 82 fe ff ff       	jmp    400066a4 <_dtoa_r+0xf54>
40006822:	89 d0                	mov    %edx,%eax
40006824:	83 e0 0f             	and    $0xf,%eax
40006827:	dd 45 a0             	fldl   -0x60(%ebp)
4000682a:	c1 fa 04             	sar    $0x4,%edx
4000682d:	dc 0c c5 20 c6 00 40 	fmull  0x4000c620(,%eax,8)
40006834:	dd 95 30 ff ff ff    	fstl   -0xd0(%ebp)
4000683a:	8b b5 30 ff ff ff    	mov    -0xd0(%ebp),%esi
40006840:	8b bd 34 ff ff ff    	mov    -0xcc(%ebp),%edi
40006846:	0f 84 01 02 00 00    	je     40006a4d <_dtoa_r+0x12fd>
4000684c:	dd d8                	fstp   %st(0)
4000684e:	dd 85 30 ff ff ff    	fldl   -0xd0(%ebp)
40006854:	31 c9                	xor    %ecx,%ecx
40006856:	bb 02 00 00 00       	mov    $0x2,%ebx
4000685b:	eb 01                	jmp    4000685e <_dtoa_r+0x110e>
4000685d:	41                   	inc    %ecx
4000685e:	f6 c2 01             	test   $0x1,%dl
40006861:	74 08                	je     4000686b <_dtoa_r+0x111b>
40006863:	dc 0c cd 00 c7 00 40 	fmull  0x4000c700(,%ecx,8)
4000686a:	43                   	inc    %ebx
4000686b:	d1 fa                	sar    %edx
4000686d:	75 ee                	jne    4000685d <_dtoa_r+0x110d>
4000686f:	dd 95 18 ff ff ff    	fstl   -0xe8(%ebp)
40006875:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
4000687b:	8b 95 1c ff ff ff    	mov    -0xe4(%ebp),%edx
40006881:	89 c6                	mov    %eax,%esi
40006883:	89 d7                	mov    %edx,%edi
40006885:	e9 ce f1 ff ff       	jmp    40005a58 <_dtoa_r+0x308>
4000688a:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
40006890:	85 c0                	test   %eax,%eax
40006892:	7e 45                	jle    400068d9 <_dtoa_r+0x1189>
40006894:	50                   	push   %eax
40006895:	6a 01                	push   $0x1
40006897:	8b 45 90             	mov    -0x70(%ebp),%eax
4000689a:	50                   	push   %eax
4000689b:	8b 75 08             	mov    0x8(%ebp),%esi
4000689e:	56                   	push   %esi
4000689f:	e8 ac 1a 00 00       	call   40008350 <__lshift>
400068a4:	89 45 90             	mov    %eax,-0x70(%ebp)
400068a7:	8b 55 9c             	mov    -0x64(%ebp),%edx
400068aa:	59                   	pop    %ecx
400068ab:	5b                   	pop    %ebx
400068ac:	52                   	push   %edx
400068ad:	50                   	push   %eax
400068ae:	e8 8d 13 00 00       	call   40007c40 <__mcmp>
400068b3:	83 c4 10             	add    $0x10,%esp
400068b6:	83 f8 00             	cmp    $0x0,%eax
400068b9:	0f 8e 76 01 00 00    	jle    40006a35 <_dtoa_r+0x12e5>
400068bf:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
400068c5:	40                   	inc    %eax
400068c6:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
400068cc:	83 bd 5c ff ff ff 3a 	cmpl   $0x3a,-0xa4(%ebp)
400068d3:	0f 84 f9 00 00 00    	je     400069d2 <_dtoa_r+0x1282>
400068d9:	8a 8d 5c ff ff ff    	mov    -0xa4(%ebp),%cl
400068df:	8d 5f 01             	lea    0x1(%edi),%ebx
400068e2:	88 0f                	mov    %cl,(%edi)
400068e4:	e9 19 f3 ff ff       	jmp    40005c02 <_dtoa_r+0x4b2>
400068e9:	dd d8                	fstp   %st(0)
400068eb:	dd d8                	fstp   %st(0)
400068ed:	e9 79 f4 ff ff       	jmp    40005d6b <_dtoa_r+0x61b>
400068f2:	bb 01 00 00 00       	mov    $0x1,%ebx
400068f7:	c7 45 18 01 00 00 00 	movl   $0x1,0x18(%ebp)
400068fe:	e9 be fa ff ff       	jmp    400063c1 <_dtoa_r+0xc71>
40006903:	83 f8 0e             	cmp    $0xe,%eax
40006906:	8a 55 88             	mov    -0x78(%ebp),%dl
40006909:	0f 96 c3             	setbe  %bl
4000690c:	88 55 af             	mov    %dl,-0x51(%ebp)
4000690f:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
40006915:	e9 87 f0 ff ff       	jmp    400059a1 <_dtoa_r+0x251>
4000691a:	52                   	push   %edx
4000691b:	52                   	push   %edx
4000691c:	8b 40 04             	mov    0x4(%eax),%eax
4000691f:	50                   	push   %eax
40006920:	8b 45 08             	mov    0x8(%ebp),%eax
40006923:	50                   	push   %eax
40006924:	e8 f7 16 00 00       	call   40008020 <_Balloc>
40006929:	8b 55 98             	mov    -0x68(%ebp),%edx
4000692c:	89 c3                	mov    %eax,%ebx
4000692e:	83 c4 0c             	add    $0xc,%esp
40006931:	8b 42 10             	mov    0x10(%edx),%eax
40006934:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
4000693b:	50                   	push   %eax
4000693c:	89 d0                	mov    %edx,%eax
4000693e:	83 c0 0c             	add    $0xc,%eax
40006941:	50                   	push   %eax
40006942:	8d 43 0c             	lea    0xc(%ebx),%eax
40006945:	50                   	push   %eax
40006946:	e8 05 11 00 00       	call   40007a50 <memcpy>
4000694b:	83 c4 0c             	add    $0xc,%esp
4000694e:	6a 01                	push   $0x1
40006950:	53                   	push   %ebx
40006951:	8b 7d 08             	mov    0x8(%ebp),%edi
40006954:	57                   	push   %edi
40006955:	e8 f6 19 00 00       	call   40008350 <__lshift>
4000695a:	83 c4 10             	add    $0x10,%esp
4000695d:	e9 3b f7 ff ff       	jmp    4000609d <_dtoa_r+0x94d>
40006962:	dd d8                	fstp   %st(0)
40006964:	e9 75 f2 ff ff       	jmp    40005bde <_dtoa_r+0x48e>
40006969:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
4000696c:	85 c9                	test   %ecx,%ecx
4000696e:	74 6b                	je     400069db <_dtoa_r+0x128b>
40006970:	05 33 04 00 00       	add    $0x433,%eax
40006975:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
4000697b:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
40006981:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
40006987:	89 8d 7c ff ff ff    	mov    %ecx,-0x84(%ebp)
4000698d:	e9 fc f4 ff ff       	jmp    40005e8e <_dtoa_r+0x73e>
40006992:	83 bd 5c ff ff ff 39 	cmpl   $0x39,-0xa4(%ebp)
40006999:	74 37                	je     400069d2 <_dtoa_r+0x1282>
4000699b:	8a 85 5c ff ff ff    	mov    -0xa4(%ebp),%al
400069a1:	8d 5f 01             	lea    0x1(%edi),%ebx
400069a4:	40                   	inc    %eax
400069a5:	88 07                	mov    %al,(%edi)
400069a7:	e9 56 f2 ff ff       	jmp    40005c02 <_dtoa_r+0x4b2>
400069ac:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
400069b2:	8b 9d 60 ff ff ff    	mov    -0xa0(%ebp),%ebx
400069b8:	29 d8                	sub    %ebx,%eax
400069ba:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
400069c0:	31 c0                	xor    %eax,%eax
400069c2:	e9 c7 f4 ff ff       	jmp    40005e8e <_dtoa_r+0x73e>
400069c7:	40                   	inc    %eax
400069c8:	8d 5f 01             	lea    0x1(%edi),%ebx
400069cb:	88 07                	mov    %al,(%edi)
400069cd:	e9 30 f2 ff ff       	jmp    40005c02 <_dtoa_r+0x4b2>
400069d2:	c6 07 39             	movb   $0x39,(%edi)
400069d5:	47                   	inc    %edi
400069d6:	e9 58 fd ff ff       	jmp    40006733 <_dtoa_r+0xfe3>
400069db:	b8 36 00 00 00       	mov    $0x36,%eax
400069e0:	8b 55 ec             	mov    -0x14(%ebp),%edx
400069e3:	29 d0                	sub    %edx,%eax
400069e5:	eb 8e                	jmp    40006975 <_dtoa_r+0x1225>
400069e7:	75 0d                	jne    400069f6 <_dtoa_r+0x12a6>
400069e9:	f6 85 5c ff ff ff 01 	testb  $0x1,-0xa4(%ebp)
400069f0:	0f 85 3d fd ff ff    	jne    40006733 <_dtoa_r+0xfe3>
400069f6:	4f                   	dec    %edi
400069f7:	80 3f 30             	cmpb   $0x30,(%edi)
400069fa:	74 fa                	je     400069f6 <_dtoa_r+0x12a6>
400069fc:	8d 5f 01             	lea    0x1(%edi),%ebx
400069ff:	e9 fe f1 ff ff       	jmp    40005c02 <_dtoa_r+0x4b2>
40006a04:	83 bd 5c ff ff ff 39 	cmpl   $0x39,-0xa4(%ebp)
40006a0b:	74 c5                	je     400069d2 <_dtoa_r+0x1282>
40006a0d:	85 f6                	test   %esi,%esi
40006a0f:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
40006a15:	0f 9f c0             	setg   %al
40006a18:	25 ff 00 00 00       	and    $0xff,%eax
40006a1d:	8d 5f 01             	lea    0x1(%edi),%ebx
40006a20:	01 c2                	add    %eax,%edx
40006a22:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%ebp)
40006a28:	8a 95 5c ff ff ff    	mov    -0xa4(%ebp),%dl
40006a2e:	88 17                	mov    %dl,(%edi)
40006a30:	e9 cd f1 ff ff       	jmp    40005c02 <_dtoa_r+0x4b2>
40006a35:	0f 85 9e fe ff ff    	jne    400068d9 <_dtoa_r+0x1189>
40006a3b:	f6 85 5c ff ff ff 01 	testb  $0x1,-0xa4(%ebp)
40006a42:	0f 84 91 fe ff ff    	je     400068d9 <_dtoa_r+0x1189>
40006a48:	e9 72 fe ff ff       	jmp    400068bf <_dtoa_r+0x116f>
40006a4d:	bb 02 00 00 00       	mov    $0x2,%ebx
40006a52:	e9 01 f0 ff ff       	jmp    40005a58 <_dtoa_r+0x308>
40006a57:	6a 00                	push   $0x0
40006a59:	6a 0a                	push   $0xa
40006a5b:	8b 45 98             	mov    -0x68(%ebp),%eax
40006a5e:	50                   	push   %eax
40006a5f:	8b 45 08             	mov    0x8(%ebp),%eax
40006a62:	50                   	push   %eax
40006a63:	e8 18 1c 00 00       	call   40008680 <__multadd>
40006a68:	83 c4 10             	add    $0x10,%esp
40006a6b:	89 45 98             	mov    %eax,-0x68(%ebp)
40006a6e:	e9 ce fb ff ff       	jmp    40006641 <_dtoa_r+0xef1>
40006a73:	83 bd 60 ff ff ff 0e 	cmpl   $0xe,-0xa0(%ebp)
40006a7a:	8a 45 88             	mov    -0x78(%ebp),%al
40006a7d:	0f 96 c3             	setbe  %bl
40006a80:	88 45 af             	mov    %al,-0x51(%ebp)
40006a83:	e9 23 ef ff ff       	jmp    400059ab <_dtoa_r+0x25b>
40006a88:	90                   	nop    
40006a89:	90                   	nop    
40006a8a:	90                   	nop    
40006a8b:	90                   	nop    
40006a8c:	90                   	nop    
40006a8d:	90                   	nop    
40006a8e:	90                   	nop    
40006a8f:	90                   	nop    

40006a90 <exit>:
#include <stdio.h>
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */

int
40006a90:	55                   	push   %ebp
40006a91:	89 e5                	mov    %esp,%ebp
40006a93:	53                   	push   %ebx
40006a94:	83 ec 0c             	sub    $0xc,%esp
40006a97:	8b 5d 08             	mov    0x8(%ebp),%ebx
_DEFUN(fflush, (fp),
40006a9a:	6a 00                	push   $0x0
40006a9c:	53                   	push   %ebx
40006a9d:	e8 4e 43 00 00       	call   4000adf0 <__call_exitprocs>
       register FILE * fp)
{
40006aa2:	8b 15 34 bc 00 40    	mov    0x4000bc34,%edx
40006aa8:	8b 42 3c             	mov    0x3c(%edx),%eax
40006aab:	83 c4 10             	add    $0x10,%esp
40006aae:	85 c0                	test   %eax,%eax
40006ab0:	74 09                	je     40006abb <exit+0x2b>
  register unsigned char *p;
40006ab2:	83 ec 0c             	sub    $0xc,%esp
40006ab5:	52                   	push   %edx
40006ab6:	ff d0                	call   *%eax
40006ab8:	83 c4 10             	add    $0x10,%esp
  register int n, t;
40006abb:	83 ec 0c             	sub    $0xc,%esp
40006abe:	53                   	push   %ebx
40006abf:	e8 5c a8 ff ff       	call   40001320 <_exit>
40006ac4:	90                   	nop    
40006ac5:	90                   	nop    
40006ac6:	90                   	nop    
40006ac7:	90                   	nop    
40006ac8:	90                   	nop    
40006ac9:	90                   	nop    
40006aca:	90                   	nop    
40006acb:	90                   	nop    
40006acc:	90                   	nop    
40006acd:	90                   	nop    
40006ace:	90                   	nop    
40006acf:	90                   	nop    

40006ad0 <_fclose_r>:

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);

40006ad0:	55                   	push   %ebp
40006ad1:	89 e5                	mov    %esp,%ebp
40006ad3:	57                   	push   %edi
40006ad4:	56                   	push   %esi
40006ad5:	53                   	push   %ebx
40006ad6:	83 ec 0c             	sub    $0xc,%esp
  _flockfile (fp);

  t = fp->_flags;
40006ad9:	31 ff                	xor    %edi,%edi

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);

40006adb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
40006ade:	8b 75 08             	mov    0x8(%ebp),%esi
  _flockfile (fp);

  t = fp->_flags;
40006ae1:	85 db                	test   %ebx,%ebx
40006ae3:	0f 84 a3 00 00 00    	je     40006b8c <_fclose_r+0xbc>
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));
40006ae9:	e8 d2 98 ff ff       	call   400003c0 <__sfp_lock_acquire>

      /* For a read stream, an fflush causes the next seek to be
40006aee:	85 f6                	test   %esi,%esi
40006af0:	74 0b                	je     40006afd <_fclose_r+0x2d>
40006af2:	8b 4e 38             	mov    0x38(%esi),%ecx
40006af5:	85 c9                	test   %ecx,%ecx
40006af7:	0f 84 c3 00 00 00    	je     40006bc0 <_fclose_r+0xf0>
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;

40006afd:	66 83 7b 0c 00       	cmpw   $0x0,0xc(%ebx)
40006b02:	0f 84 98 00 00 00    	je     40006ba0 <_fclose_r+0xd0>
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
40006b08:	83 ec 0c             	sub    $0xc,%esp
40006b0b:	53                   	push   %ebx
40006b0c:	e8 df 96 ff ff       	call   400001f0 <fflush>
40006b11:	89 c7                	mov    %eax,%edi
          _fpos_t curoff;
40006b13:	8b 43 2c             	mov    0x2c(%ebx),%eax
40006b16:	83 c4 10             	add    $0x10,%esp
40006b19:	85 c0                	test   %eax,%eax
40006b1b:	74 14                	je     40006b31 <_fclose_r+0x61>
40006b1d:	83 ec 0c             	sub    $0xc,%esp
40006b20:	8b 53 1c             	mov    0x1c(%ebx),%edx
40006b23:	52                   	push   %edx
40006b24:	ff d0                	call   *%eax
40006b26:	83 c4 10             	add    $0x10,%esp
40006b29:	85 c0                	test   %eax,%eax
40006b2b:	0f 88 c3 00 00 00    	js     40006bf4 <_fclose_r+0x124>

          /* Get the physical position we are at in the file.  */
40006b31:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
40006b35:	0f 88 a5 00 00 00    	js     40006be0 <_fclose_r+0x110>
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
40006b3b:	8b 53 30             	mov    0x30(%ebx),%edx
40006b3e:	85 d2                	test   %edx,%edx
40006b40:	74 20                	je     40006b62 <_fclose_r+0x92>
          else
40006b42:	8d 43 40             	lea    0x40(%ebx),%eax
40006b45:	39 c2                	cmp    %eax,%edx
40006b47:	74 12                	je     40006b5b <_fclose_r+0x8b>
40006b49:	56                   	push   %esi
40006b4a:	56                   	push   %esi
40006b4b:	52                   	push   %edx
40006b4c:	8b 0d 60 d0 00 40    	mov    0x4000d060,%ecx
40006b52:	51                   	push   %ecx
40006b53:	e8 08 04 00 00       	call   40006f60 <_free_r>
40006b58:	83 c4 10             	add    $0x10,%esp
40006b5b:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
            {
40006b62:	8b 43 44             	mov    0x44(%ebx),%eax
40006b65:	85 c0                	test   %eax,%eax
40006b67:	74 18                	je     40006b81 <_fclose_r+0xb1>
              /* We don't know current physical offset, so ask for it.  */
40006b69:	52                   	push   %edx
40006b6a:	52                   	push   %edx
40006b6b:	50                   	push   %eax
40006b6c:	a1 60 d0 00 40       	mov    0x4000d060,%eax
40006b71:	50                   	push   %eax
40006b72:	e8 e9 03 00 00       	call   40006f60 <_free_r>
40006b77:	c7 43 44 00 00 00 00 	movl   $0x0,0x44(%ebx)
40006b7e:	83 c4 10             	add    $0x10,%esp
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
40006b81:	66 c7 43 0c 00 00    	movw   $0x0,0xc(%ebx)
              if (curoff == -1L)
                {
                  _funlockfile (fp);
                  return 0;
                }
            }
40006b87:	e8 44 98 ff ff       	call   400003d0 <__sfp_lock_release>
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
40006b8c:	8d 65 f4             	lea    -0xc(%ebp),%esp
40006b8f:	89 f8                	mov    %edi,%eax
40006b91:	5b                   	pop    %ebx
40006b92:	5e                   	pop    %esi
40006b93:	5f                   	pop    %edi
40006b94:	5d                   	pop    %ebp
40006b95:	c3                   	ret    
40006b96:	8d 76 00             	lea    0x0(%esi),%esi
40006b99:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;

      /* For a seekable stream with buffered read characters, we will attempt
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
40006ba0:	e8 2b 98 ff ff       	call   400003d0 <__sfp_lock_release>
40006ba5:	31 ff                	xor    %edi,%edi
                  return 0;
                }
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
40006ba7:	8d 65 f4             	lea    -0xc(%ebp),%esp
40006baa:	89 f8                	mov    %edi,%eax
40006bac:	5b                   	pop    %ebx
40006bad:	5e                   	pop    %esi
40006bae:	5f                   	pop    %edi
40006baf:	5d                   	pop    %ebp
40006bb0:	c3                   	ret    
40006bb1:	eb 0d                	jmp    40006bc0 <_fclose_r+0xf0>
40006bb3:	90                   	nop    
40006bb4:	90                   	nop    
40006bb5:	90                   	nop    
40006bb6:	90                   	nop    
40006bb7:	90                   	nop    
40006bb8:	90                   	nop    
40006bb9:	90                   	nop    
40006bba:	90                   	nop    
40006bbb:	90                   	nop    
40006bbc:	90                   	nop    
40006bbd:	90                   	nop    
40006bbe:	90                   	nop    
40006bbf:	90                   	nop    
  t = fp->_flags;
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

      /* For a read stream, an fflush causes the next seek to be
40006bc0:	83 ec 0c             	sub    $0xc,%esp
40006bc3:	56                   	push   %esi
40006bc4:	e8 37 98 ff ff       	call   40000400 <__sinit>
40006bc9:	83 c4 10             	add    $0x10,%esp
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;

40006bcc:	66 83 7b 0c 00       	cmpw   $0x0,0xc(%ebx)
40006bd1:	0f 85 31 ff ff ff    	jne    40006b08 <_fclose_r+0x38>
40006bd7:	eb c7                	jmp    40006ba0 <_fclose_r+0xd0>
40006bd9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
40006be0:	50                   	push   %eax
40006be1:	50                   	push   %eax
40006be2:	8b 43 10             	mov    0x10(%ebx),%eax
40006be5:	50                   	push   %eax
40006be6:	56                   	push   %esi
40006be7:	e8 74 03 00 00       	call   40006f60 <_free_r>
40006bec:	83 c4 10             	add    $0x10,%esp
40006bef:	e9 47 ff ff ff       	jmp    40006b3b <_fclose_r+0x6b>
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;
40006bf4:	83 cf ff             	or     $0xffffffff,%edi
40006bf7:	e9 35 ff ff ff       	jmp    40006b31 <_fclose_r+0x61>
40006bfc:	8d 74 26 00          	lea    0x0(%esi),%esi

40006c00 <fclose>:
              curoff -= fp->_r;
              if (HASUB (fp))
                curoff -= fp->_ur;
            }
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
40006c00:	55                   	push   %ebp
40006c01:	89 e5                	mov    %esp,%ebp
40006c03:	83 ec 10             	sub    $0x10,%esp
            {
40006c06:	8b 45 08             	mov    0x8(%ebp),%eax
40006c09:	50                   	push   %eax
40006c0a:	a1 60 d0 00 40       	mov    0x4000d060,%eax
40006c0f:	50                   	push   %eax
40006c10:	e8 bb fe ff ff       	call   40006ad0 <_fclose_r>
              /* Seek successful.  We can clear read buffer now.  */
40006c15:	c9                   	leave  
40006c16:	c3                   	ret    
40006c17:	90                   	nop    
40006c18:	90                   	nop    
40006c19:	90                   	nop    
40006c1a:	90                   	nop    
40006c1b:	90                   	nop    
40006c1c:	90                   	nop    
40006c1d:	90                   	nop    
40006c1e:	90                   	nop    
40006c1f:	90                   	nop    

40006c20 <_fread_r>:
      return 0;
    }
  n = fp->_p - p;		/* write this much */

  /*
   * Set these immediately to avoid problems with longjmp
40006c20:	55                   	push   %ebp
40006c21:	89 e5                	mov    %esp,%ebp
40006c23:	57                   	push   %edi
40006c24:	56                   	push   %esi
40006c25:	53                   	push   %ebx
40006c26:	83 ec 1c             	sub    $0x1c,%esp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

40006c29:	8b 45 14             	mov    0x14(%ebp),%eax
40006c2c:	8b 55 10             	mov    0x10(%ebp),%edx
40006c2f:	0f af c2             	imul   %edx,%eax
      return 0;
    }
  n = fp->_p - p;		/* write this much */

  /*
   * Set these immediately to avoid problems with longjmp
40006c32:	8b 7d 18             	mov    0x18(%ebp),%edi
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

40006c35:	89 45 e0             	mov    %eax,-0x20(%ebp)
40006c38:	85 c0                	test   %eax,%eax
40006c3a:	0f 84 70 01 00 00    	je     40006db0 <_fread_r+0x190>
  while (n > 0)
    {
      t = (*fp->_write) (fp->_cookie, (char *) p, n);
40006c40:	8b 45 08             	mov    0x8(%ebp),%eax
40006c43:	85 c0                	test   %eax,%eax
40006c45:	74 0e                	je     40006c55 <_fread_r+0x35>
40006c47:	8b 55 08             	mov    0x8(%ebp),%edx
40006c4a:	8b 42 38             	mov    0x38(%edx),%eax
40006c4d:	85 c0                	test   %eax,%eax
40006c4f:	0f 84 6d 01 00 00    	je     40006dc2 <_fread_r+0x1a2>
      if (t <= 0)
	{
          fp->_flags |= __SERR;
40006c55:	8b 47 04             	mov    0x4(%edi),%eax
40006c58:	85 c0                	test   %eax,%eax
40006c5a:	0f 88 79 01 00 00    	js     40006dd9 <_fread_r+0x1b9>
          _funlockfile (fp);
          return EOF;
	}
40006c60:	8b 45 0c             	mov    0xc(%ebp),%eax
40006c63:	8b 75 e0             	mov    -0x20(%ebp),%esi
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
	}
40006c66:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      p += t;
      n -= t;
    }
  _funlockfile (fp);
  return 0;
40006c69:	f6 47 0c 02          	testb  $0x2,0xc(%edi)
40006c6d:	0f 84 e5 00 00 00    	je     40006d58 <_fread_r+0x138>
}
40006c73:	8b 47 04             	mov    0x4(%edi),%eax
40006c76:	89 f3                	mov    %esi,%ebx
40006c78:	39 c6                	cmp    %eax,%esi
40006c7a:	0f 87 65 01 00 00    	ja     40006de5 <_fread_r+0x1c5>
40006c80:	50                   	push   %eax
40006c81:	53                   	push   %ebx
40006c82:	8b 37                	mov    (%edi),%esi
40006c84:	56                   	push   %esi
40006c85:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40006c88:	51                   	push   %ecx
40006c89:	e8 c2 0d 00 00       	call   40007a50 <memcpy>
40006c8e:	8b 47 04             	mov    0x4(%edi),%eax
  return 0;
}
40006c91:	8b 17                	mov    (%edi),%edx
40006c93:	29 d8                	sub    %ebx,%eax
  return 0;
}
40006c95:	01 da                	add    %ebx,%edx
40006c97:	89 47 04             	mov    %eax,0x4(%edi)
40006c9a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  return 0;
}
40006c9d:	89 17                	mov    %edx,(%edi)
40006c9f:	83 c4 10             	add    $0x10,%esp
40006ca2:	8b 57 30             	mov    0x30(%edi),%edx
40006ca5:	29 d8                	sub    %ebx,%eax
40006ca7:	0f 95 45 df          	setne  -0x21(%ebp)
40006cab:	89 45 ec             	mov    %eax,-0x14(%ebp)
40006cae:	85 d2                	test   %edx,%edx
40006cb0:	0f 85 36 01 00 00    	jne    40006dec <_fread_r+0x1cc>
40006cb6:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
40006cba:	0f 84 df 00 00 00    	je     40006d9f <_fread_r+0x17f>
40006cc0:	8b 45 0c             	mov    0xc(%ebp),%eax
40006cc3:	01 c3                	add    %eax,%ebx
40006cc5:	89 5d f0             	mov    %ebx,-0x10(%ebp)
40006cc8:	eb 11                	jmp    40006cdb <_fread_r+0xbb>
40006cca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40006cd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006cd3:	85 c0                	test   %eax,%eax
40006cd5:	0f 84 c4 00 00 00    	je     40006d9f <_fread_r+0x17f>
40006cdb:	8b 17                	mov    (%edi),%edx
40006cdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
40006ce0:	89 55 e8             	mov    %edx,-0x18(%ebp)
40006ce3:	8b 55 ec             	mov    -0x14(%ebp),%edx
40006ce6:	8b 5f 14             	mov    0x14(%edi),%ebx
40006ce9:	8b 77 10             	mov    0x10(%edi),%esi
40006cec:	89 07                	mov    %eax,(%edi)
40006cee:	89 47 10             	mov    %eax,0x10(%edi)
40006cf1:	89 57 14             	mov    %edx,0x14(%edi)
40006cf4:	50                   	push   %eax
40006cf5:	50                   	push   %eax
40006cf6:	57                   	push   %edi
40006cf7:	8b 45 08             	mov    0x8(%ebp),%eax
40006cfa:	50                   	push   %eax
40006cfb:	e8 20 24 00 00       	call   40009120 <__srefill_r>
40006d00:	8b 55 e8             	mov    -0x18(%ebp),%edx
40006d03:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40006d06:	89 5f 14             	mov    %ebx,0x14(%edi)
40006d09:	89 17                	mov    %edx,(%edi)
40006d0b:	8b 5d ec             	mov    -0x14(%ebp),%ebx
40006d0e:	8b 57 04             	mov    0x4(%edi),%edx
40006d11:	29 d3                	sub    %edx,%ebx
40006d13:	01 d1                	add    %edx,%ecx
40006d15:	83 c4 10             	add    $0x10,%esp
40006d18:	89 77 10             	mov    %esi,0x10(%edi)
40006d1b:	89 5d ec             	mov    %ebx,-0x14(%ebp)
40006d1e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40006d21:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
40006d28:	85 c0                	test   %eax,%eax
40006d2a:	74 a4                	je     40006cd0 <_fread_r+0xb0>
40006d2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
40006d2f:	8b 55 e0             	mov    -0x20(%ebp),%edx
40006d32:	29 c2                	sub    %eax,%edx
40006d34:	89 55 e0             	mov    %edx,-0x20(%ebp)
40006d37:	31 d2                	xor    %edx,%edx
40006d39:	8b 45 e0             	mov    -0x20(%ebp),%eax
40006d3c:	f7 75 10             	divl   0x10(%ebp)
40006d3f:	89 45 14             	mov    %eax,0x14(%ebp)
40006d42:	8b 45 14             	mov    0x14(%ebp),%eax
40006d45:	8d 65 f4             	lea    -0xc(%ebp),%esp
40006d48:	5b                   	pop    %ebx
40006d49:	5e                   	pop    %esi
40006d4a:	5f                   	pop    %edi
40006d4b:	5d                   	pop    %ebp
40006d4c:	c3                   	ret    
40006d4d:	8d 76 00             	lea    0x0(%esi),%esi
40006d50:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40006d53:	01 d8                	add    %ebx,%eax
40006d55:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40006d58:	8b 5f 04             	mov    0x4(%edi),%ebx
40006d5b:	39 de                	cmp    %ebx,%esi
40006d5d:	0f 86 b3 00 00 00    	jbe    40006e16 <_fread_r+0x1f6>
40006d63:	50                   	push   %eax
40006d64:	53                   	push   %ebx
40006d65:	8b 07                	mov    (%edi),%eax
40006d67:	29 de                	sub    %ebx,%esi
40006d69:	50                   	push   %eax
40006d6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40006d6d:	50                   	push   %eax
40006d6e:	e8 dd 0c 00 00       	call   40007a50 <memcpy>
40006d73:	8b 0f                	mov    (%edi),%ecx
40006d75:	01 d9                	add    %ebx,%ecx
40006d77:	89 0f                	mov    %ecx,(%edi)
40006d79:	58                   	pop    %eax
40006d7a:	5a                   	pop    %edx
40006d7b:	57                   	push   %edi
40006d7c:	8b 45 08             	mov    0x8(%ebp),%eax
40006d7f:	50                   	push   %eax
40006d80:	e8 9b 23 00 00       	call   40009120 <__srefill_r>
40006d85:	83 c4 10             	add    $0x10,%esp
40006d88:	85 c0                	test   %eax,%eax
40006d8a:	74 c4                	je     40006d50 <_fread_r+0x130>
40006d8c:	8b 45 e0             	mov    -0x20(%ebp),%eax
40006d8f:	31 d2                	xor    %edx,%edx
40006d91:	29 f0                	sub    %esi,%eax
40006d93:	89 45 e0             	mov    %eax,-0x20(%ebp)
40006d96:	8b 45 e0             	mov    -0x20(%ebp),%eax
40006d99:	f7 75 10             	divl   0x10(%ebp)
40006d9c:	89 45 14             	mov    %eax,0x14(%ebp)
40006d9f:	8b 45 14             	mov    0x14(%ebp),%eax
40006da2:	8d 65 f4             	lea    -0xc(%ebp),%esp
40006da5:	5b                   	pop    %ebx
40006da6:	5e                   	pop    %esi
40006da7:	5f                   	pop    %edi
40006da8:	5d                   	pop    %ebp
40006da9:	c3                   	ret    
40006daa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

40006db0:	c7 45 14 00 00 00 00 	movl   $0x0,0x14(%ebp)
40006db7:	8b 45 14             	mov    0x14(%ebp),%eax
40006dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
40006dbd:	5b                   	pop    %ebx
40006dbe:	5e                   	pop    %esi
40006dbf:	5f                   	pop    %edi
40006dc0:	5d                   	pop    %ebp
40006dc1:	c3                   	ret    
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
    {
      t = (*fp->_write) (fp->_cookie, (char *) p, n);
40006dc2:	83 ec 0c             	sub    $0xc,%esp
40006dc5:	52                   	push   %edx
40006dc6:	e8 35 96 ff ff       	call   40000400 <__sinit>
      if (t <= 0)
	{
          fp->_flags |= __SERR;
40006dcb:	8b 47 04             	mov    0x4(%edi),%eax
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
    {
      t = (*fp->_write) (fp->_cookie, (char *) p, n);
40006dce:	83 c4 10             	add    $0x10,%esp
      if (t <= 0)
	{
          fp->_flags |= __SERR;
40006dd1:	85 c0                	test   %eax,%eax
40006dd3:	0f 89 87 fe ff ff    	jns    40006c60 <_fread_r+0x40>
          _funlockfile (fp);
40006dd9:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
40006de0:	e9 7b fe ff ff       	jmp    40006c60 <_fread_r+0x40>
    }
  _funlockfile (fp);
  return 0;
}
40006de5:	89 c3                	mov    %eax,%ebx
40006de7:	e9 94 fe ff ff       	jmp    40006c80 <_fread_r+0x60>
40006dec:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
40006df0:	74 ad                	je     40006d9f <_fread_r+0x17f>
40006df2:	8d 47 40             	lea    0x40(%edi),%eax
40006df5:	39 c2                	cmp    %eax,%edx
40006df7:	74 11                	je     40006e0a <_fread_r+0x1ea>
40006df9:	50                   	push   %eax
40006dfa:	50                   	push   %eax
40006dfb:	52                   	push   %edx
40006dfc:	a1 60 d0 00 40       	mov    0x4000d060,%eax
40006e01:	50                   	push   %eax
40006e02:	e8 59 01 00 00       	call   40006f60 <_free_r>
40006e07:	83 c4 10             	add    $0x10,%esp
40006e0a:	c7 47 30 00 00 00 00 	movl   $0x0,0x30(%edi)
40006e11:	e9 a0 fe ff ff       	jmp    40006cb6 <_fread_r+0x96>
40006e16:	50                   	push   %eax
40006e17:	56                   	push   %esi
40006e18:	8b 1f                	mov    (%edi),%ebx
40006e1a:	53                   	push   %ebx
40006e1b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40006e1e:	51                   	push   %ecx
40006e1f:	e8 2c 0c 00 00       	call   40007a50 <memcpy>
40006e24:	8b 57 04             	mov    0x4(%edi),%edx
40006e27:	8b 07                	mov    (%edi),%eax
40006e29:	01 f0                	add    %esi,%eax
40006e2b:	29 f2                	sub    %esi,%edx
40006e2d:	89 07                	mov    %eax,(%edi)
40006e2f:	89 57 04             	mov    %edx,0x4(%edi)
40006e32:	8b 45 14             	mov    0x14(%ebp),%eax
40006e35:	83 c4 10             	add    $0x10,%esp
40006e38:	8d 65 f4             	lea    -0xc(%ebp),%esp
40006e3b:	5b                   	pop    %ebx
40006e3c:	5e                   	pop    %esi
40006e3d:	5f                   	pop    %edi
40006e3e:	5d                   	pop    %ebp
40006e3f:	c3                   	ret    

40006e40 <fread>:
40006e40:	55                   	push   %ebp
40006e41:	89 e5                	mov    %esp,%ebp
40006e43:	83 ec 14             	sub    $0x14,%esp
40006e46:	8b 0d 60 d0 00 40    	mov    0x4000d060,%ecx
40006e4c:	8b 45 14             	mov    0x14(%ebp),%eax
40006e4f:	50                   	push   %eax
40006e50:	8b 45 10             	mov    0x10(%ebp),%eax
40006e53:	50                   	push   %eax
40006e54:	8b 45 0c             	mov    0xc(%ebp),%eax
40006e57:	50                   	push   %eax
40006e58:	8b 45 08             	mov    0x8(%ebp),%eax
40006e5b:	50                   	push   %eax
40006e5c:	51                   	push   %ecx
40006e5d:	e8 be fd ff ff       	call   40006c20 <_fread_r>
40006e62:	c9                   	leave  
40006e63:	c3                   	ret    
40006e64:	90                   	nop    
40006e65:	90                   	nop    
40006e66:	90                   	nop    
40006e67:	90                   	nop    
40006e68:	90                   	nop    
40006e69:	90                   	nop    
40006e6a:	90                   	nop    
40006e6b:	90                   	nop    
40006e6c:	90                   	nop    
40006e6d:	90                   	nop    
40006e6e:	90                   	nop    
40006e6f:	90                   	nop    

40006e70 <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
40006e70:	55                   	push   %ebp
40006e71:	89 e5                	mov    %esp,%ebp
40006e73:	57                   	push   %edi
40006e74:	56                   	push   %esi
40006e75:	53                   	push   %ebx
40006e76:	83 ec 18             	sub    $0x18,%esp
40006e79:	8b 7d 08             	mov    0x8(%ebp),%edi
40006e7c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;
40006e7f:	57                   	push   %edi
40006e80:	e8 ab a1 ff ff       	call   40001030 <__malloc_lock>

  top_size = chunksize(top);
40006e85:	a1 88 d4 00 40       	mov    0x4000d488,%eax
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;

  if (extra < (long)pagesz)  /* Not enough memory to release */
40006e8a:	83 c4 10             	add    $0x10,%esp
  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
40006e8d:	f7 db                	neg    %ebx

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
40006e8f:	8b 70 04             	mov    0x4(%eax),%esi
40006e92:	83 e6 fc             	and    $0xfffffffc,%esi
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
40006e95:	8d 84 1e ef 0f 00 00 	lea    0xfef(%esi,%ebx,1),%eax
40006e9c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
40006ea1:	8d 98 00 f0 ff ff    	lea    -0x1000(%eax),%ebx

  if (extra < (long)pagesz)  /* Not enough memory to release */
40006ea7:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
40006ead:	7e 1b                	jle    40006eca <_malloc_trim_r+0x5a>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
40006eaf:	50                   	push   %eax
40006eb0:	50                   	push   %eax
40006eb1:	6a 00                	push   $0x0
40006eb3:	57                   	push   %edi
40006eb4:	e8 67 a2 ff ff       	call   40001120 <_sbrk_r>
    if (current_brk != (char*)(top) + top_size)
40006eb9:	89 f2                	mov    %esi,%edx
40006ebb:	8b 0d 88 d4 00 40    	mov    0x4000d488,%ecx
40006ec1:	83 c4 10             	add    $0x10,%esp
40006ec4:	01 ca                	add    %ecx,%edx
40006ec6:	39 c2                	cmp    %eax,%edx
40006ec8:	74 16                	je     40006ee0 <_malloc_trim_r+0x70>
        {
          sbrked_mem = current_brk - sbrk_base;
          set_head(top, top_size | PREV_INUSE);
        }
        check_chunk(top);
	MALLOC_UNLOCK;
40006eca:	83 ec 0c             	sub    $0xc,%esp
40006ecd:	57                   	push   %edi
40006ece:	e8 6d a1 ff ff       	call   40001040 <__malloc_unlock>
40006ed3:	31 c0                	xor    %eax,%eax
        return 0; 
40006ed5:	83 c4 10             	add    $0x10,%esp
	MALLOC_UNLOCK;
        return 1;
      }
    }
  }
}
40006ed8:	8d 65 f4             	lea    -0xc(%ebp),%esp
40006edb:	5b                   	pop    %ebx
40006edc:	5e                   	pop    %esi
40006edd:	5f                   	pop    %edi
40006ede:	5d                   	pop    %ebp
40006edf:	c3                   	ret    
      return 0;     /* Apparently we don't own memory; must fail */
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
40006ee0:	50                   	push   %eax
40006ee1:	50                   	push   %eax
40006ee2:	89 d8                	mov    %ebx,%eax
40006ee4:	f7 d8                	neg    %eax
40006ee6:	50                   	push   %eax
40006ee7:	57                   	push   %edi
40006ee8:	e8 33 a2 ff ff       	call   40001120 <_sbrk_r>
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
40006eed:	83 c4 10             	add    $0x10,%esp
40006ef0:	40                   	inc    %eax
40006ef1:	74 2c                	je     40006f1f <_malloc_trim_r+0xaf>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
40006ef3:	a1 88 d4 00 40       	mov    0x4000d488,%eax
40006ef8:	29 de                	sub    %ebx,%esi
40006efa:	83 ce 01             	or     $0x1,%esi
        sbrked_mem -= extra;
        check_chunk(top);
	MALLOC_UNLOCK;
40006efd:	83 ec 0c             	sub    $0xc,%esp
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
40006f00:	89 70 04             	mov    %esi,0x4(%eax)
        sbrked_mem -= extra;
40006f03:	a1 20 d9 00 40       	mov    0x4000d920,%eax
40006f08:	29 d8                	sub    %ebx,%eax
        check_chunk(top);
	MALLOC_UNLOCK;
40006f0a:	57                   	push   %edi

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
        sbrked_mem -= extra;
40006f0b:	a3 20 d9 00 40       	mov    %eax,0x4000d920
        check_chunk(top);
	MALLOC_UNLOCK;
40006f10:	e8 2b a1 ff ff       	call   40001040 <__malloc_unlock>
40006f15:	b8 01 00 00 00       	mov    $0x1,%eax
40006f1a:	83 c4 10             	add    $0x10,%esp
40006f1d:	eb b9                	jmp    40006ed8 <_malloc_trim_r+0x68>
      new_brk = (char*)(MORECORE (-extra));
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
40006f1f:	56                   	push   %esi
40006f20:	56                   	push   %esi
40006f21:	6a 00                	push   $0x0
40006f23:	57                   	push   %edi
40006f24:	e8 f7 a1 ff ff       	call   40001120 <_sbrk_r>
        top_size = current_brk - (char*)top;
40006f29:	8b 0d 88 d4 00 40    	mov    0x4000d488,%ecx
40006f2f:	89 c2                	mov    %eax,%edx
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
40006f31:	83 c4 10             	add    $0x10,%esp
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
40006f34:	29 ca                	sub    %ecx,%edx
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
40006f36:	83 fa 0f             	cmp    $0xf,%edx
40006f39:	7e 8f                	jle    40006eca <_malloc_trim_r+0x5a>
        {
          sbrked_mem = current_brk - sbrk_base;
40006f3b:	8b 1d 8c d8 00 40    	mov    0x4000d88c,%ebx
          set_head(top, top_size | PREV_INUSE);
40006f41:	83 ca 01             	or     $0x1,%edx
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
        {
          sbrked_mem = current_brk - sbrk_base;
40006f44:	29 d8                	sub    %ebx,%eax
          set_head(top, top_size | PREV_INUSE);
40006f46:	89 51 04             	mov    %edx,0x4(%ecx)
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
        {
          sbrked_mem = current_brk - sbrk_base;
40006f49:	a3 20 d9 00 40       	mov    %eax,0x4000d920
40006f4e:	e9 77 ff ff ff       	jmp    40006eca <_malloc_trim_r+0x5a>
40006f53:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40006f59:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40006f60 <_free_r>:
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
40006f60:	55                   	push   %ebp
40006f61:	89 e5                	mov    %esp,%ebp
40006f63:	57                   	push   %edi
40006f64:	56                   	push   %esi
40006f65:	53                   	push   %ebx
40006f66:	83 ec 0c             	sub    $0xc,%esp
40006f69:	8b 45 08             	mov    0x8(%ebp),%eax
40006f6c:	8b 75 0c             	mov    0xc(%ebp),%esi
40006f6f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
40006f72:	85 f6                	test   %esi,%esi
40006f74:	0f 84 26 01 00 00    	je     400070a0 <_free_r+0x140>
    return;

  MALLOC_LOCK;
40006f7a:	83 ec 0c             	sub    $0xc,%esp
40006f7d:	50                   	push   %eax
40006f7e:	e8 ad a0 ff ff       	call   40001030 <__malloc_lock>

  p = mem2chunk(mem);
40006f83:	8d 56 f8             	lea    -0x8(%esi),%edx
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
40006f86:	83 c4 10             	add    $0x10,%esp
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
40006f89:	89 d1                	mov    %edx,%ecx
  if (mem == 0)                              /* free(0) has no effect */
    return;

  MALLOC_LOCK;

  p = mem2chunk(mem);
40006f8b:	89 55 ec             	mov    %edx,-0x14(%ebp)
  hd = p->size;
40006f8e:	8b 42 04             	mov    0x4(%edx),%eax
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
40006f91:	89 c3                	mov    %eax,%ebx
40006f93:	83 e3 fe             	and    $0xfffffffe,%ebx
  next = chunk_at_offset(p, sz);
40006f96:	01 d9                	add    %ebx,%ecx
  nextsz = chunksize(next);
40006f98:	8b 79 04             	mov    0x4(%ecx),%edi
40006f9b:	83 e7 fc             	and    $0xfffffffc,%edi
  
  if (next == top)                            /* merge with top */
40006f9e:	39 0d 88 d4 00 40    	cmp    %ecx,0x4000d488
40006fa4:	0f 84 56 01 00 00    	je     40007100 <_free_r+0x1a0>
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
    return;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
40006faa:	89 79 04             	mov    %edi,0x4(%ecx)

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
40006fad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40006fb4:	a8 01                	test   $0x1,%al
40006fb6:	75 32                	jne    40006fea <_free_r+0x8a>
  {
    prevsz = p->prev_size;
40006fb8:	8b 46 f8             	mov    -0x8(%esi),%eax
    p = chunk_at_offset(p, -prevsz);
40006fbb:	8b 55 ec             	mov    -0x14(%ebp),%edx
40006fbe:	29 c2                	sub    %eax,%edx
    sz += prevsz;
40006fc0:	01 c3                	add    %eax,%ebx
  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -prevsz);
40006fc2:	89 55 ec             	mov    %edx,-0x14(%ebp)
    sz += prevsz;
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
40006fc5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
40006fcc:	8b 75 ec             	mov    -0x14(%ebp),%esi
40006fcf:	8b 56 08             	mov    0x8(%esi),%edx
40006fd2:	81 fa 88 d4 00 40    	cmp    $0x4000d488,%edx
40006fd8:	74 10                	je     40006fea <_free_r+0x8a>
      islr = 1;
    else
      unlink(p, bck, fwd);
40006fda:	8b 46 0c             	mov    0xc(%esi),%eax
40006fdd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40006fe4:	89 42 0c             	mov    %eax,0xc(%edx)
40006fe7:	89 50 08             	mov    %edx,0x8(%eax)
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
40006fea:	f6 44 0f 04 01       	testb  $0x1,0x4(%edi,%ecx,1)
40006fef:	75 25                	jne    40007016 <_free_r+0xb6>
  {
    sz += nextsz;
40006ff1:	01 fb                	add    %edi,%ebx
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
40006ff3:	8b 7d f0             	mov    -0x10(%ebp),%edi
40006ff6:	85 ff                	test   %edi,%edi
40006ff8:	0f 85 b2 00 00 00    	jne    400070b0 <_free_r+0x150>
40006ffe:	8b 51 08             	mov    0x8(%ecx),%edx
40007001:	81 fa 88 d4 00 40    	cmp    $0x4000d488,%edx
40007007:	0f 84 85 01 00 00    	je     40007192 <_free_r+0x232>
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
4000700d:	8b 41 0c             	mov    0xc(%ecx),%eax
40007010:	89 42 0c             	mov    %eax,0xc(%edx)
40007013:	89 50 08             	mov    %edx,0x8(%eax)
  }


  set_head(p, sz | PREV_INUSE);
40007016:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40007019:	89 d8                	mov    %ebx,%eax
4000701b:	83 c8 01             	or     $0x1,%eax
  set_foot(p, sz);
  if (!islr)
4000701e:	8b 75 f0             	mov    -0x10(%ebp),%esi
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
40007021:	89 41 04             	mov    %eax,0x4(%ecx)
  set_foot(p, sz);
40007024:	89 1c 19             	mov    %ebx,(%ecx,%ebx,1)
  if (!islr)
40007027:	85 f6                	test   %esi,%esi
40007029:	74 15                	je     40007040 <_free_r+0xe0>
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;
4000702b:	8b 75 e8             	mov    -0x18(%ebp),%esi
4000702e:	89 75 08             	mov    %esi,0x8(%ebp)

#endif /* MALLOC_PROVIDED */
}
40007031:	8d 65 f4             	lea    -0xc(%ebp),%esp
40007034:	5b                   	pop    %ebx
40007035:	5e                   	pop    %esi
40007036:	5f                   	pop    %edi
40007037:	5d                   	pop    %ebp
  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;
40007038:	e9 03 a0 ff ff       	jmp    40001040 <__malloc_unlock>
4000703d:	8d 76 00             	lea    0x0(%esi),%esi


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
40007040:	81 fb ff 01 00 00    	cmp    $0x1ff,%ebx
40007046:	76 78                	jbe    400070c0 <_free_r+0x160>
40007048:	89 d8                	mov    %ebx,%eax
4000704a:	c1 e8 09             	shr    $0x9,%eax
4000704d:	0f 85 f7 00 00 00    	jne    4000714a <_free_r+0x1ea>
40007053:	89 de                	mov    %ebx,%esi
40007055:	c1 ee 03             	shr    $0x3,%esi
40007058:	8d 04 f5 08 00 00 00 	lea    0x8(,%esi,8),%eax
4000705f:	8d 90 78 d4 00 40    	lea    0x4000d478(%eax),%edx
40007065:	8b 7a 08             	mov    0x8(%edx),%edi
40007068:	39 d7                	cmp    %edx,%edi
4000706a:	0f 84 50 01 00 00    	je     400071c0 <_free_r+0x260>
40007070:	8b 47 04             	mov    0x4(%edi),%eax
40007073:	83 e0 fc             	and    $0xfffffffc,%eax
40007076:	39 c3                	cmp    %eax,%ebx
40007078:	73 07                	jae    40007081 <_free_r+0x121>
4000707a:	8b 7f 08             	mov    0x8(%edi),%edi
4000707d:	39 fa                	cmp    %edi,%edx
4000707f:	75 ef                	jne    40007070 <_free_r+0x110>
40007081:	8b 47 0c             	mov    0xc(%edi),%eax
40007084:	8b 5d ec             	mov    -0x14(%ebp),%ebx
40007087:	89 43 0c             	mov    %eax,0xc(%ebx)
4000708a:	89 7b 08             	mov    %edi,0x8(%ebx)
4000708d:	89 5f 0c             	mov    %ebx,0xc(%edi)
40007090:	89 58 08             	mov    %ebx,0x8(%eax)
40007093:	eb 96                	jmp    4000702b <_free_r+0xcb>
40007095:	8d 74 26 00          	lea    0x0(%esi),%esi
40007099:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
400070a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
400070a3:	5b                   	pop    %ebx
400070a4:	5e                   	pop    %esi
400070a5:	5f                   	pop    %edi
400070a6:	5d                   	pop    %ebp
400070a7:	c3                   	ret    
400070a8:	90                   	nop    
400070a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
400070b0:	8b 51 08             	mov    0x8(%ecx),%edx
400070b3:	e9 55 ff ff ff       	jmp    4000700d <_free_r+0xad>
400070b8:	90                   	nop    
400070b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
400070c0:	89 da                	mov    %ebx,%edx
400070c2:	b8 01 00 00 00       	mov    $0x1,%eax
400070c7:	c1 ea 03             	shr    $0x3,%edx
400070ca:	8b 5d ec             	mov    -0x14(%ebp),%ebx
400070cd:	89 d1                	mov    %edx,%ecx
400070cf:	c1 e9 02             	shr    $0x2,%ecx
400070d2:	8d 14 d5 80 d4 00 40 	lea    0x4000d480(,%edx,8),%edx
400070d9:	d3 e0                	shl    %cl,%eax
400070db:	8b 0d 84 d4 00 40    	mov    0x4000d484,%ecx
400070e1:	89 53 0c             	mov    %edx,0xc(%ebx)
400070e4:	09 c1                	or     %eax,%ecx
400070e6:	8b 42 08             	mov    0x8(%edx),%eax
400070e9:	89 43 08             	mov    %eax,0x8(%ebx)
400070ec:	89 0d 84 d4 00 40    	mov    %ecx,0x4000d484
400070f2:	89 5a 08             	mov    %ebx,0x8(%edx)
400070f5:	89 58 0c             	mov    %ebx,0xc(%eax)
400070f8:	e9 2e ff ff ff       	jmp    4000702b <_free_r+0xcb>
400070fd:	8d 76 00             	lea    0x0(%esi),%esi
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
  {
    sz += nextsz;
40007100:	8d 0c 1f             	lea    (%edi,%ebx,1),%ecx

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
40007103:	a8 01                	test   $0x1,%al
40007105:	75 18                	jne    4000711f <_free_r+0x1bf>
    {
      prevsz = p->prev_size;
40007107:	8b 46 f8             	mov    -0x8(%esi),%eax
      p = chunk_at_offset(p, -prevsz);
4000710a:	29 c2                	sub    %eax,%edx
      sz += prevsz;
4000710c:	01 c1                	add    %eax,%ecx
      unlink(p, bck, fwd);
4000710e:	89 d3                	mov    %edx,%ebx
    sz += nextsz;

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
    {
      prevsz = p->prev_size;
      p = chunk_at_offset(p, -prevsz);
40007110:	89 55 ec             	mov    %edx,-0x14(%ebp)
      sz += prevsz;
      unlink(p, bck, fwd);
40007113:	8b 52 0c             	mov    0xc(%edx),%edx
40007116:	8b 43 08             	mov    0x8(%ebx),%eax
40007119:	89 42 08             	mov    %eax,0x8(%edx)
4000711c:	89 50 0c             	mov    %edx,0xc(%eax)
    }

    set_head(p, sz | PREV_INUSE);
4000711f:	8b 75 ec             	mov    -0x14(%ebp),%esi
40007122:	89 c8                	mov    %ecx,%eax
40007124:	83 c8 01             	or     $0x1,%eax
    top = p;
40007127:	89 35 88 d4 00 40    	mov    %esi,0x4000d488
      p = chunk_at_offset(p, -prevsz);
      sz += prevsz;
      unlink(p, bck, fwd);
    }

    set_head(p, sz | PREV_INUSE);
4000712d:	89 46 04             	mov    %eax,0x4(%esi)
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
40007130:	3b 0d 88 d8 00 40    	cmp    0x4000d888,%ecx
40007136:	73 43                	jae    4000717b <_free_r+0x21b>
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
40007138:	8b 45 e8             	mov    -0x18(%ebp),%eax
4000713b:	89 45 08             	mov    %eax,0x8(%ebp)
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
4000713e:	8d 65 f4             	lea    -0xc(%ebp),%esp
40007141:	5b                   	pop    %ebx
40007142:	5e                   	pop    %esi
40007143:	5f                   	pop    %edi
40007144:	5d                   	pop    %ebp
  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;
40007145:	e9 f6 9e ff ff       	jmp    40001040 <__malloc_unlock>


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
4000714a:	83 f8 04             	cmp    $0x4,%eax
4000714d:	76 18                	jbe    40007167 <_free_r+0x207>
4000714f:	83 f8 14             	cmp    $0x14,%eax
40007152:	0f 87 89 00 00 00    	ja     400071e1 <_free_r+0x281>
40007158:	8d 70 5b             	lea    0x5b(%eax),%esi
4000715b:	8d 04 c5 e0 02 00 00 	lea    0x2e0(,%eax,8),%eax
40007162:	e9 f8 fe ff ff       	jmp    4000705f <_free_r+0xff>
40007167:	89 d8                	mov    %ebx,%eax
40007169:	c1 e8 06             	shr    $0x6,%eax
4000716c:	8d 70 38             	lea    0x38(%eax),%esi
4000716f:	8d 04 c5 c8 01 00 00 	lea    0x1c8(,%eax,8),%eax
40007176:	e9 e4 fe ff ff       	jmp    4000705f <_free_r+0xff>
    }

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
4000717b:	56                   	push   %esi
4000717c:	56                   	push   %esi
4000717d:	8b 1d 00 d9 00 40    	mov    0x4000d900,%ebx
40007183:	53                   	push   %ebx
40007184:	8b 4d e8             	mov    -0x18(%ebp),%ecx
40007187:	51                   	push   %ecx
40007188:	e8 e3 fc ff ff       	call   40006e70 <_malloc_trim_r>
4000718d:	83 c4 10             	add    $0x10,%esp
40007190:	eb a6                	jmp    40007138 <_free_r+0x1d8>
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
      link_last_remainder(p);   
40007192:	8b 45 ec             	mov    -0x14(%ebp),%eax
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
40007195:	8b 55 ec             	mov    -0x14(%ebp),%edx
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
      link_last_remainder(p);   
40007198:	a3 94 d4 00 40       	mov    %eax,0x4000d494
4000719d:	a3 90 d4 00 40       	mov    %eax,0x4000d490
400071a2:	c7 40 0c 88 d4 00 40 	movl   $0x4000d488,0xc(%eax)
400071a9:	c7 40 08 88 d4 00 40 	movl   $0x4000d488,0x8(%eax)
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
400071b0:	89 d8                	mov    %ebx,%eax
  set_foot(p, sz);
400071b2:	89 1c 1a             	mov    %ebx,(%edx,%ebx,1)
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
400071b5:	83 c8 01             	or     $0x1,%eax
400071b8:	89 42 04             	mov    %eax,0x4(%edx)
400071bb:	e9 6b fe ff ff       	jmp    4000702b <_free_r+0xcb>
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
400071c0:	c1 ee 02             	shr    $0x2,%esi
400071c3:	b8 01 00 00 00       	mov    $0x1,%eax
400071c8:	89 f1                	mov    %esi,%ecx
400071ca:	8b 15 84 d4 00 40    	mov    0x4000d484,%edx
400071d0:	d3 e0                	shl    %cl,%eax
400071d2:	09 c2                	or     %eax,%edx
400071d4:	89 f8                	mov    %edi,%eax
400071d6:	89 15 84 d4 00 40    	mov    %edx,0x4000d484
400071dc:	e9 a3 fe ff ff       	jmp    40007084 <_free_r+0x124>
400071e1:	83 f8 54             	cmp    $0x54,%eax
400071e4:	77 14                	ja     400071fa <_free_r+0x29a>
400071e6:	89 d8                	mov    %ebx,%eax
400071e8:	c1 e8 0c             	shr    $0xc,%eax
400071eb:	8d 70 6e             	lea    0x6e(%eax),%esi
400071ee:	8d 04 c5 78 03 00 00 	lea    0x378(,%eax,8),%eax
400071f5:	e9 65 fe ff ff       	jmp    4000705f <_free_r+0xff>
400071fa:	3d 54 01 00 00       	cmp    $0x154,%eax
400071ff:	77 14                	ja     40007215 <_free_r+0x2b5>
40007201:	89 d8                	mov    %ebx,%eax
40007203:	c1 e8 0f             	shr    $0xf,%eax
40007206:	8d 70 77             	lea    0x77(%eax),%esi
40007209:	8d 04 c5 c0 03 00 00 	lea    0x3c0(,%eax,8),%eax
40007210:	e9 4a fe ff ff       	jmp    4000705f <_free_r+0xff>
40007215:	3d 54 05 00 00       	cmp    $0x554,%eax
4000721a:	76 0f                	jbe    4000722b <_free_r+0x2cb>
4000721c:	be 7e 00 00 00       	mov    $0x7e,%esi
40007221:	b8 f8 03 00 00       	mov    $0x3f8,%eax
40007226:	e9 34 fe ff ff       	jmp    4000705f <_free_r+0xff>
4000722b:	89 d8                	mov    %ebx,%eax
4000722d:	c1 e8 12             	shr    $0x12,%eax
40007230:	8d 70 7c             	lea    0x7c(%eax),%esi
40007233:	8d 04 c5 e8 03 00 00 	lea    0x3e8(,%eax,8),%eax
4000723a:	e9 20 fe ff ff       	jmp    4000705f <_free_r+0xff>
4000723f:	90                   	nop    

40007240 <__sfvwrite_r>:
situation, it returns <<EOF>>.

PORTABILITY
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
40007240:	55                   	push   %ebp
40007241:	89 e5                	mov    %esp,%ebp
40007243:	57                   	push   %edi
40007244:	56                   	push   %esi
40007245:	53                   	push   %ebx
40007246:	83 ec 1c             	sub    $0x1c,%esp
#include <_ansi.h>
#include <stdio.h>
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */

40007249:	8b 45 10             	mov    0x10(%ebp),%eax
4000724c:	8b 48 08             	mov    0x8(%eax),%ecx
4000724f:	85 c9                	test   %ecx,%ecx
40007251:	0f 84 8d 00 00 00    	je     400072e4 <__sfvwrite_r+0xa4>
int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
40007257:	8b 55 0c             	mov    0xc(%ebp),%edx
4000725a:	0f bf 42 0c          	movswl 0xc(%edx),%eax
4000725e:	a8 08                	test   $0x8,%al
40007260:	0f 84 88 00 00 00    	je     400072ee <__sfvwrite_r+0xae>
40007266:	8b 52 10             	mov    0x10(%edx),%edx
40007269:	85 d2                	test   %edx,%edx
4000726b:	0f 84 7d 00 00 00    	je     400072ee <__sfvwrite_r+0xae>
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);
40007271:	8b 55 10             	mov    0x10(%ebp),%edx
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;
40007274:	a8 02                	test   $0x2,%al
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);
40007276:	8b 12                	mov    (%edx),%edx
40007278:	89 55 dc             	mov    %edx,-0x24(%ebp)
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;
4000727b:	0f 84 9b 00 00 00    	je     4000731c <__sfvwrite_r+0xdc>
40007281:	31 db                	xor    %ebx,%ebx
40007283:	31 f6                	xor    %esi,%esi
40007285:	8d 74 26 00          	lea    0x0(%esi),%esi
40007289:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
            {
              /* We don't know current physical offset, so ask for it.  */
40007290:	85 db                	test   %ebx,%ebx
40007292:	74 40                	je     400072d4 <__sfvwrite_r+0x94>
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
40007294:	89 d8                	mov    %ebx,%eax
40007296:	57                   	push   %edi
40007297:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
4000729d:	76 05                	jbe    400072a4 <__sfvwrite_r+0x64>
4000729f:	b8 00 04 00 00       	mov    $0x400,%eax
400072a4:	50                   	push   %eax
400072a5:	56                   	push   %esi
400072a6:	8b 45 0c             	mov    0xc(%ebp),%eax
400072a9:	8b 48 1c             	mov    0x1c(%eax),%ecx
400072ac:	51                   	push   %ecx
400072ad:	ff 50 24             	call   *0x24(%eax)
              if (curoff == -1L)
400072b0:	83 c4 10             	add    $0x10,%esp
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
            {
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
400072b3:	89 c2                	mov    %eax,%edx
              if (curoff == -1L)
400072b5:	85 c0                	test   %eax,%eax
400072b7:	0f 8e 4a 01 00 00    	jle    40007407 <__sfvwrite_r+0x1c7>
                {
                  _funlockfile (fp);
                  return 0;
                }
            }
400072bd:	8b 4d 10             	mov    0x10(%ebp),%ecx
400072c0:	8b 41 08             	mov    0x8(%ecx),%eax
400072c3:	29 d0                	sub    %edx,%eax
400072c5:	89 41 08             	mov    %eax,0x8(%ecx)
400072c8:	85 c0                	test   %eax,%eax
400072ca:	74 18                	je     400072e4 <__sfvwrite_r+0xa4>
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
                  _funlockfile (fp);
                  return 0;
400072cc:	29 d3                	sub    %edx,%ebx
            {
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
                  _funlockfile (fp);
400072ce:	01 d6                	add    %edx,%esi
          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
            {
              /* We don't know current physical offset, so ask for it.  */
400072d0:	85 db                	test   %ebx,%ebx
400072d2:	75 c0                	jne    40007294 <__sfvwrite_r+0x54>
400072d4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
400072d7:	8b 31                	mov    (%ecx),%esi
400072d9:	8b 59 04             	mov    0x4(%ecx),%ebx
400072dc:	83 c1 08             	add    $0x8,%ecx
400072df:	89 4d dc             	mov    %ecx,-0x24(%ebp)
400072e2:	eb ac                	jmp    40007290 <__sfvwrite_r+0x50>
400072e4:	31 c0                	xor    %eax,%eax
400072e6:	8d 65 f4             	lea    -0xc(%ebp),%esp
400072e9:	5b                   	pop    %ebx
400072ea:	5e                   	pop    %esi
400072eb:	5f                   	pop    %edi
400072ec:	5d                   	pop    %ebp
400072ed:	c3                   	ret    
/* Flush a single file, or (if fp is NULL) all files.  */

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
400072ee:	83 ec 0c             	sub    $0xc,%esp
400072f1:	8b 45 0c             	mov    0xc(%ebp),%eax
400072f4:	50                   	push   %eax
400072f5:	e8 f6 e0 ff ff       	call   400053f0 <__swsetup>
400072fa:	83 c4 10             	add    $0x10,%esp
400072fd:	85 c0                	test   %eax,%eax
400072ff:	0f 85 c4 03 00 00    	jne    400076c9 <__sfvwrite_r+0x489>
40007305:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);
40007308:	8b 55 10             	mov    0x10(%ebp),%edx
/* Flush a single file, or (if fp is NULL) all files.  */

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
4000730b:	0f bf 41 0c          	movswl 0xc(%ecx),%eax
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);
4000730f:	8b 12                	mov    (%edx),%edx
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;
40007311:	a8 02                	test   $0x2,%al
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);
40007313:	89 55 dc             	mov    %edx,-0x24(%ebp)
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;
40007316:	0f 85 65 ff ff ff    	jne    40007281 <__sfvwrite_r+0x41>
                  _funlockfile (fp);
                  return 0;
                }
            }
          if (fp->_flags & __SRD)
            {
4000731c:	a8 01                	test   $0x1,%al
4000731e:	0f 84 f6 00 00 00    	je     4000741a <__sfvwrite_r+0x1da>
40007324:	31 ff                	xor    %edi,%edi
40007326:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000732d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
40007334:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
4000733b:	90                   	nop    
4000733c:	8d 74 26 00          	lea    0x0(%esi),%esi
40007340:	85 ff                	test   %edi,%edi
40007342:	0f 84 88 00 00 00    	je     400073d0 <__sfvwrite_r+0x190>
40007348:	8b 45 e0             	mov    -0x20(%ebp),%eax
4000734b:	85 c0                	test   %eax,%eax
4000734d:	0f 84 ad 02 00 00    	je     40007600 <__sfvwrite_r+0x3c0>
40007353:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
40007356:	39 fb                	cmp    %edi,%ebx
40007358:	76 02                	jbe    4000735c <__sfvwrite_r+0x11c>
4000735a:	89 fb                	mov    %edi,%ebx
4000735c:	8b 55 0c             	mov    0xc(%ebp),%edx
4000735f:	8b 42 14             	mov    0x14(%edx),%eax
40007362:	8b 4a 08             	mov    0x8(%edx),%ecx
40007365:	89 c6                	mov    %eax,%esi
40007367:	01 ce                	add    %ecx,%esi
40007369:	89 d1                	mov    %edx,%ecx
4000736b:	8b 12                	mov    (%edx),%edx
4000736d:	3b 51 10             	cmp    0x10(%ecx),%edx
40007370:	0f 86 6a 01 00 00    	jbe    400074e0 <__sfvwrite_r+0x2a0>
40007376:	39 f3                	cmp    %esi,%ebx
40007378:	0f 8e 62 01 00 00    	jle    400074e0 <__sfvwrite_r+0x2a0>
4000737e:	50                   	push   %eax
4000737f:	56                   	push   %esi
40007380:	8b 5d f0             	mov    -0x10(%ebp),%ebx
40007383:	53                   	push   %ebx
40007384:	52                   	push   %edx
40007385:	e8 16 07 00 00       	call   40007aa0 <memmove>
4000738a:	8b 45 0c             	mov    0xc(%ebp),%eax
4000738d:	8b 08                	mov    (%eax),%ecx
4000738f:	01 f1                	add    %esi,%ecx
40007391:	89 08                	mov    %ecx,(%eax)
40007393:	89 04 24             	mov    %eax,(%esp)
40007396:	e8 55 8e ff ff       	call   400001f0 <fflush>
4000739b:	83 c4 10             	add    $0x10,%esp
4000739e:	85 c0                	test   %eax,%eax
400073a0:	75 65                	jne    40007407 <__sfvwrite_r+0x1c7>
400073a2:	29 75 e4             	sub    %esi,-0x1c(%ebp)
400073a5:	0f 84 63 01 00 00    	je     4000750e <__sfvwrite_r+0x2ce>
400073ab:	8b 55 10             	mov    0x10(%ebp),%edx
400073ae:	8b 42 08             	mov    0x8(%edx),%eax
400073b1:	29 f0                	sub    %esi,%eax
400073b3:	89 42 08             	mov    %eax,0x8(%edx)
400073b6:	85 c0                	test   %eax,%eax
400073b8:	0f 84 26 ff ff ff    	je     400072e4 <__sfvwrite_r+0xa4>
400073be:	8b 45 f0             	mov    -0x10(%ebp),%eax
400073c1:	29 f7                	sub    %esi,%edi
400073c3:	01 f0                	add    %esi,%eax
400073c5:	85 ff                	test   %edi,%edi
400073c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
400073ca:	0f 85 78 ff ff ff    	jne    40007348 <__sfvwrite_r+0x108>
400073d0:	8b 55 dc             	mov    -0x24(%ebp),%edx
400073d3:	8b 45 dc             	mov    -0x24(%ebp),%eax
400073d6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
400073dd:	8b 00                	mov    (%eax),%eax
400073df:	8b 7a 04             	mov    0x4(%edx),%edi
400073e2:	83 c2 08             	add    $0x8,%edx
400073e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
400073e8:	89 55 dc             	mov    %edx,-0x24(%ebp)
400073eb:	e9 50 ff ff ff       	jmp    40007340 <__sfvwrite_r+0x100>

  while (n > 0)
    {
      t = (*fp->_write) (fp->_cookie, (char *) p, n);
      if (t <= 0)
	{
400073f0:	50                   	push   %eax
400073f1:	50                   	push   %eax
400073f2:	8b 45 0c             	mov    0xc(%ebp),%eax
400073f5:	8b 40 10             	mov    0x10(%eax),%eax
400073f8:	50                   	push   %eax
400073f9:	a1 60 d0 00 40       	mov    0x4000d060,%eax
400073fe:	50                   	push   %eax
400073ff:	e8 5c fb ff ff       	call   40006f60 <_free_r>
          fp->_flags |= __SERR;
40007404:	83 c4 10             	add    $0x10,%esp
40007407:	8b 4d 0c             	mov    0xc(%ebp),%ecx
4000740a:	83 c8 ff             	or     $0xffffffff,%eax
4000740d:	66 83 49 0c 40       	orw    $0x40,0xc(%ecx)
40007412:	8d 65 f4             	lea    -0xc(%ebp),%esp
40007415:	5b                   	pop    %ebx
40007416:	5e                   	pop    %esi
40007417:	5f                   	pop    %edi
40007418:	5d                   	pop    %ebp
40007419:	c3                   	ret    
                  _funlockfile (fp);
                  return 0;
                }
            }
          if (fp->_flags & __SRD)
            {
4000741a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40007421:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007428:	90                   	nop    
40007429:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
              fp->_r = 0;
              fp->_p = fp->_bf._base;
              if (fp->_flags & __SOFF)
                fp->_offset = curoff;
            }
        } 
40007430:	8b 7d e8             	mov    -0x18(%ebp),%edi
40007433:	85 ff                	test   %edi,%edi
40007435:	74 7c                	je     400074b3 <__sfvwrite_r+0x273>
      _funlockfile (fp);
40007437:	8b 4d 0c             	mov    0xc(%ebp),%ecx
      return 0;
4000743a:	f6 c4 02             	test   $0x2,%ah
              fp->_p = fp->_bf._base;
              if (fp->_flags & __SOFF)
                fp->_offset = curoff;
            }
        } 
      _funlockfile (fp);
4000743d:	8b 71 08             	mov    0x8(%ecx),%esi
      return 0;
40007440:	0f 84 fa 00 00 00    	je     40007540 <__sfvwrite_r+0x300>
    }
  if ((p = fp->_bf._base) == NULL)
40007446:	89 f2                	mov    %esi,%edx
40007448:	39 75 e8             	cmp    %esi,-0x18(%ebp)
4000744b:	0f 83 9f 01 00 00    	jae    400075f0 <__sfvwrite_r+0x3b0>
40007451:	8b 5d e8             	mov    -0x18(%ebp),%ebx
40007454:	89 da                	mov    %ebx,%edx
40007456:	89 de                	mov    %ebx,%esi
      n -= t;
    }
  _funlockfile (fp);
  return 0;
}
40007458:	50                   	push   %eax
40007459:	52                   	push   %edx
4000745a:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000745d:	50                   	push   %eax
4000745e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40007461:	8b 39                	mov    (%ecx),%edi
40007463:	57                   	push   %edi
40007464:	e8 37 06 00 00       	call   40007aa0 <memmove>
40007469:	8b 45 0c             	mov    0xc(%ebp),%eax
4000746c:	83 c4 10             	add    $0x10,%esp
    }
  _funlockfile (fp);
  return 0;
}
4000746f:	8b 48 08             	mov    0x8(%eax),%ecx
40007472:	8b 10                	mov    (%eax),%edx
    }
  _funlockfile (fp);
  return 0;
}
40007474:	29 d9                	sub    %ebx,%ecx
40007476:	01 da                	add    %ebx,%edx
40007478:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    }
  _funlockfile (fp);
  return 0;
}
4000747b:	89 48 08             	mov    %ecx,0x8(%eax)
4000747e:	89 10                	mov    %edx,(%eax)
40007480:	89 df                	mov    %ebx,%edi
40007482:	8b 4d 10             	mov    0x10(%ebp),%ecx
40007485:	8b 41 08             	mov    0x8(%ecx),%eax
40007488:	29 f0                	sub    %esi,%eax
4000748a:	89 41 08             	mov    %eax,0x8(%ecx)
4000748d:	85 c0                	test   %eax,%eax
4000748f:	0f 84 4f fe ff ff    	je     400072e4 <__sfvwrite_r+0xa4>
40007495:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007498:	8b 75 0c             	mov    0xc(%ebp),%esi
4000749b:	01 f8                	add    %edi,%eax
4000749d:	89 45 ec             	mov    %eax,-0x14(%ebp)
400074a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
400074a3:	29 d8                	sub    %ebx,%eax
400074a5:	89 45 e8             	mov    %eax,-0x18(%ebp)
              fp->_r = 0;
              fp->_p = fp->_bf._base;
              if (fp->_flags & __SOFF)
                fp->_offset = curoff;
            }
        } 
400074a8:	8b 7d e8             	mov    -0x18(%ebp),%edi
400074ab:	0f bf 46 0c          	movswl 0xc(%esi),%eax
400074af:	85 ff                	test   %edi,%edi
400074b1:	75 84                	jne    40007437 <__sfvwrite_r+0x1f7>
400074b3:	8b 55 dc             	mov    -0x24(%ebp),%edx
400074b6:	8b 75 dc             	mov    -0x24(%ebp),%esi
400074b9:	8b 52 04             	mov    0x4(%edx),%edx
400074bc:	8b 36                	mov    (%esi),%esi
400074be:	89 55 e8             	mov    %edx,-0x18(%ebp)
400074c1:	8b 55 dc             	mov    -0x24(%ebp),%edx
400074c4:	83 c2 08             	add    $0x8,%edx
400074c7:	89 75 ec             	mov    %esi,-0x14(%ebp)
400074ca:	89 55 dc             	mov    %edx,-0x24(%ebp)
400074cd:	e9 5e ff ff ff       	jmp    40007430 <__sfvwrite_r+0x1f0>
400074d2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
400074d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
400074e0:	39 c3                	cmp    %eax,%ebx
400074e2:	0f 8c d8 00 00 00    	jl     400075c0 <__sfvwrite_r+0x380>
400074e8:	52                   	push   %edx
400074e9:	50                   	push   %eax
400074ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
400074ed:	50                   	push   %eax
400074ee:	8b 55 0c             	mov    0xc(%ebp),%edx
400074f1:	8b 42 1c             	mov    0x1c(%edx),%eax
400074f4:	50                   	push   %eax
400074f5:	ff 52 24             	call   *0x24(%edx)
400074f8:	83 c4 10             	add    $0x10,%esp
400074fb:	89 c6                	mov    %eax,%esi
400074fd:	85 c0                	test   %eax,%eax
400074ff:	0f 8e 02 ff ff ff    	jle    40007407 <__sfvwrite_r+0x1c7>
40007505:	29 75 e4             	sub    %esi,-0x1c(%ebp)
40007508:	0f 85 9d fe ff ff    	jne    400073ab <__sfvwrite_r+0x16b>
4000750e:	83 ec 0c             	sub    $0xc,%esp
40007511:	8b 55 0c             	mov    0xc(%ebp),%edx
40007514:	52                   	push   %edx
40007515:	e8 d6 8c ff ff       	call   400001f0 <fflush>
4000751a:	83 c4 10             	add    $0x10,%esp
4000751d:	85 c0                	test   %eax,%eax
4000751f:	0f 85 e2 fe ff ff    	jne    40007407 <__sfvwrite_r+0x1c7>
40007525:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
4000752c:	e9 7a fe ff ff       	jmp    400073ab <__sfvwrite_r+0x16b>
40007531:	eb 0d                	jmp    40007540 <__sfvwrite_r+0x300>
40007533:	90                   	nop    
40007534:	90                   	nop    
40007535:	90                   	nop    
40007536:	90                   	nop    
40007537:	90                   	nop    
40007538:	90                   	nop    
40007539:	90                   	nop    
4000753a:	90                   	nop    
4000753b:	90                   	nop    
4000753c:	90                   	nop    
4000753d:	90                   	nop    
4000753e:	90                   	nop    
4000753f:	90                   	nop    
40007540:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40007543:	89 f3                	mov    %esi,%ebx
40007545:	8b 11                	mov    (%ecx),%edx
40007547:	3b 51 10             	cmp    0x10(%ecx),%edx
4000754a:	76 34                	jbe    40007580 <__sfvwrite_r+0x340>
4000754c:	3b 75 e8             	cmp    -0x18(%ebp),%esi
4000754f:	73 2f                	jae    40007580 <__sfvwrite_r+0x340>
40007551:	50                   	push   %eax
40007552:	56                   	push   %esi
40007553:	8b 7d ec             	mov    -0x14(%ebp),%edi
40007556:	57                   	push   %edi
40007557:	52                   	push   %edx
40007558:	e8 43 05 00 00       	call   40007aa0 <memmove>
4000755d:	8b 45 0c             	mov    0xc(%ebp),%eax
40007560:	8b 08                	mov    (%eax),%ecx
40007562:	89 f7                	mov    %esi,%edi
40007564:	01 f1                	add    %esi,%ecx
40007566:	89 08                	mov    %ecx,(%eax)
40007568:	89 04 24             	mov    %eax,(%esp)
4000756b:	e8 80 8c ff ff       	call   400001f0 <fflush>
40007570:	83 c4 10             	add    $0x10,%esp
40007573:	85 c0                	test   %eax,%eax
40007575:	0f 84 07 ff ff ff    	je     40007482 <__sfvwrite_r+0x242>
4000757b:	e9 87 fe ff ff       	jmp    40007407 <__sfvwrite_r+0x1c7>
40007580:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40007583:	8b 41 14             	mov    0x14(%ecx),%eax
40007586:	39 45 e8             	cmp    %eax,-0x18(%ebp)
40007589:	0f 82 9e 00 00 00    	jb     4000762d <__sfvwrite_r+0x3ed>
4000758f:	52                   	push   %edx
40007590:	50                   	push   %eax
40007591:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007594:	50                   	push   %eax
40007595:	8b 41 1c             	mov    0x1c(%ecx),%eax
40007598:	50                   	push   %eax
40007599:	ff 51 24             	call   *0x24(%ecx)
4000759c:	83 c4 10             	add    $0x10,%esp
4000759f:	89 c6                	mov    %eax,%esi
400075a1:	85 c0                	test   %eax,%eax
400075a3:	0f 8e 5e fe ff ff    	jle    40007407 <__sfvwrite_r+0x1c7>
400075a9:	89 c3                	mov    %eax,%ebx
400075ab:	89 c7                	mov    %eax,%edi
400075ad:	e9 d0 fe ff ff       	jmp    40007482 <__sfvwrite_r+0x242>
400075b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
400075b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
400075c0:	50                   	push   %eax
400075c1:	53                   	push   %ebx
400075c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
400075c5:	50                   	push   %eax
400075c6:	52                   	push   %edx
400075c7:	e8 d4 04 00 00       	call   40007aa0 <memmove>
400075cc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
400075cf:	8b 31                	mov    (%ecx),%esi
400075d1:	8b 41 08             	mov    0x8(%ecx),%eax
400075d4:	01 de                	add    %ebx,%esi
400075d6:	29 d8                	sub    %ebx,%eax
400075d8:	89 31                	mov    %esi,(%ecx)
400075da:	83 c4 10             	add    $0x10,%esp
400075dd:	89 de                	mov    %ebx,%esi
400075df:	89 41 08             	mov    %eax,0x8(%ecx)
400075e2:	e9 bb fd ff ff       	jmp    400073a2 <__sfvwrite_r+0x162>
400075e7:	89 f6                	mov    %esi,%esi
400075e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
            }
        } 
      _funlockfile (fp);
      return 0;
    }
  if ((p = fp->_bf._base) == NULL)
400075f0:	84 c0                	test   %al,%al
400075f2:	78 68                	js     4000765c <__sfvwrite_r+0x41c>
400075f4:	89 f3                	mov    %esi,%ebx
400075f6:	8b 75 e8             	mov    -0x18(%ebp),%esi
400075f9:	e9 5a fe ff ff       	jmp    40007458 <__sfvwrite_r+0x218>
400075fe:	66 90                	xchg   %ax,%ax
40007600:	56                   	push   %esi
40007601:	57                   	push   %edi
40007602:	6a 0a                	push   $0xa
40007604:	8b 5d f0             	mov    -0x10(%ebp),%ebx
40007607:	53                   	push   %ebx
40007608:	e8 1b 04 00 00       	call   40007a28 <memchr>
4000760d:	83 c4 10             	add    $0x10,%esp
40007610:	85 c0                	test   %eax,%eax
40007612:	0f 84 a6 00 00 00    	je     400076be <__sfvwrite_r+0x47e>
40007618:	40                   	inc    %eax
40007619:	8b 4d f0             	mov    -0x10(%ebp),%ecx
4000761c:	29 c8                	sub    %ecx,%eax
4000761e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40007621:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
40007628:	e9 26 fd ff ff       	jmp    40007353 <__sfvwrite_r+0x113>
4000762d:	8b 75 e8             	mov    -0x18(%ebp),%esi
40007630:	50                   	push   %eax
40007631:	56                   	push   %esi
40007632:	8b 7d ec             	mov    -0x14(%ebp),%edi
40007635:	57                   	push   %edi
40007636:	52                   	push   %edx
40007637:	e8 64 04 00 00       	call   40007aa0 <memmove>
4000763c:	8b 55 0c             	mov    0xc(%ebp),%edx
4000763f:	8b 45 e8             	mov    -0x18(%ebp),%eax
40007642:	8b 5a 08             	mov    0x8(%edx),%ebx
40007645:	29 c3                	sub    %eax,%ebx
40007647:	8b 0a                	mov    (%edx),%ecx
40007649:	89 5a 08             	mov    %ebx,0x8(%edx)
4000764c:	01 c1                	add    %eax,%ecx
4000764e:	89 c7                	mov    %eax,%edi
40007650:	89 c3                	mov    %eax,%ebx
40007652:	83 c4 10             	add    $0x10,%esp
40007655:	89 0a                	mov    %ecx,(%edx)
40007657:	e9 26 fe ff ff       	jmp    40007482 <__sfvwrite_r+0x242>
      return 0;
    }
  if ((p = fp->_bf._base) == NULL)
    {
      /* Nothing to flush.  */
      _funlockfile (fp);
4000765c:	8b 75 0c             	mov    0xc(%ebp),%esi
  n = fp->_p - p;		/* write this much */

  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
4000765f:	8b 46 14             	mov    0x14(%esi),%eax
      return 0;
    }
  if ((p = fp->_bf._base) == NULL)
    {
      /* Nothing to flush.  */
      _funlockfile (fp);
40007662:	8b 4e 10             	mov    0x10(%esi),%ecx
40007665:	8b 3e                	mov    (%esi),%edi

  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
40007667:	8b 75 e8             	mov    -0x18(%ebp),%esi
  n = fp->_p - p;		/* write this much */

  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
4000766a:	8d 04 40             	lea    (%eax,%eax,2),%eax
      return 0;
    }
  if ((p = fp->_bf._base) == NULL)
    {
      /* Nothing to flush.  */
      _funlockfile (fp);
4000766d:	29 cf                	sub    %ecx,%edi
  n = fp->_p - p;		/* write this much */

  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
4000766f:	89 c2                	mov    %eax,%edx
40007671:	c1 ea 1f             	shr    $0x1f,%edx
40007674:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   */
40007677:	8d 44 3e 01          	lea    0x1(%esi,%edi,1),%eax
  n = fp->_p - p;		/* write this much */

  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
4000767b:	d1 fb                	sar    %ebx
   */
4000767d:	89 da                	mov    %ebx,%edx
4000767f:	39 c3                	cmp    %eax,%ebx
40007681:	73 04                	jae    40007687 <__sfvwrite_r+0x447>
  fp->_p = p;
40007683:	89 c3                	mov    %eax,%ebx
40007685:	89 c2                	mov    %eax,%edx
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
40007687:	56                   	push   %esi
40007688:	52                   	push   %edx
40007689:	51                   	push   %ecx
4000768a:	a1 60 d0 00 40       	mov    0x4000d060,%eax
4000768f:	50                   	push   %eax
40007690:	e8 db 12 00 00       	call   40008970 <_realloc_r>

  while (n > 0)
    {
40007695:	83 c4 10             	add    $0x10,%esp
40007698:	85 c0                	test   %eax,%eax
4000769a:	0f 84 50 fd ff ff    	je     400073f0 <__sfvwrite_r+0x1b0>
      t = (*fp->_write) (fp->_cookie, (char *) p, n);
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
400076a0:	8b 55 0c             	mov    0xc(%ebp),%edx
	}
      p += t;
      n -= t;
400076a3:	8b 75 e8             	mov    -0x18(%ebp),%esi
      t = (*fp->_write) (fp->_cookie, (char *) p, n);
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
400076a6:	89 42 10             	mov    %eax,0x10(%edx)
	}
      p += t;
400076a9:	89 5a 14             	mov    %ebx,0x14(%edx)
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
	}
400076ac:	01 f8                	add    %edi,%eax
      p += t;
      n -= t;
    }
400076ae:	29 fb                	sub    %edi,%ebx
400076b0:	89 5a 08             	mov    %ebx,0x8(%edx)
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
	}
400076b3:	89 02                	mov    %eax,(%edx)
      p += t;
      n -= t;
    }
400076b5:	89 f3                	mov    %esi,%ebx
400076b7:	89 f2                	mov    %esi,%edx
400076b9:	e9 9a fd ff ff       	jmp    40007458 <__sfvwrite_r+0x218>
400076be:	8d 77 01             	lea    0x1(%edi),%esi
400076c1:	89 75 e4             	mov    %esi,-0x1c(%ebp)
400076c4:	e9 58 ff ff ff       	jmp    40007621 <__sfvwrite_r+0x3e1>
int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  register unsigned char *p;
  register int n, t;
400076c9:	8b 75 0c             	mov    0xc(%ebp),%esi

400076cc:	8b 45 08             	mov    0x8(%ebp),%eax
int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  register unsigned char *p;
  register int n, t;
400076cf:	66 83 4e 0c 40       	orw    $0x40,0xc(%esi)

400076d4:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
400076da:	83 c8 ff             	or     $0xffffffff,%eax
400076dd:	e9 04 fc ff ff       	jmp    400072e6 <__sfvwrite_r+0xa6>
400076e2:	90                   	nop    
400076e3:	90                   	nop    
400076e4:	90                   	nop    
400076e5:	90                   	nop    
400076e6:	90                   	nop    
400076e7:	90                   	nop    
400076e8:	90                   	nop    
400076e9:	90                   	nop    
400076ea:	90                   	nop    
400076eb:	90                   	nop    
400076ec:	90                   	nop    
400076ed:	90                   	nop    
400076ee:	90                   	nop    
400076ef:	90                   	nop    

400076f0 <iswspace>:
  if (fp == NULL)
400076f0:	55                   	push   %ebp
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
                  _funlockfile (fp);
                  return 0;
400076f1:	31 c0                	xor    %eax,%eax
       register FILE * fp)
{
  register unsigned char *p;
  register int n, t;

  if (fp == NULL)
400076f3:	89 e5                	mov    %esp,%ebp
400076f5:	8b 55 08             	mov    0x8(%ebp),%edx
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
                  _funlockfile (fp);
                  return 0;
400076f8:	81 fa ff 00 00 00    	cmp    $0xff,%edx
400076fe:	77 0c                	ja     4000770c <iswspace+0x1c>
40007700:	a1 90 d8 00 40       	mov    0x4000d890,%eax
40007705:	0f be 04 10          	movsbl (%eax,%edx,1),%eax
40007709:	83 e0 08             	and    $0x8,%eax
                }
4000770c:	5d                   	pop    %ebp
4000770d:	c3                   	ret    
4000770e:	90                   	nop    
4000770f:	90                   	nop    

40007710 <__locale_charset>:
40007710:	55                   	push   %ebp
40007711:	a1 10 c6 00 40       	mov    0x4000c610,%eax
40007716:	89 e5                	mov    %esp,%ebp
40007718:	5d                   	pop    %ebp
40007719:	c3                   	ret    
4000771a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

40007720 <_localeconv_r>:
40007720:	55                   	push   %ebp
40007721:	b8 e0 c5 00 40       	mov    $0x4000c5e0,%eax
40007726:	89 e5                	mov    %esp,%ebp
40007728:	5d                   	pop    %ebp
40007729:	c3                   	ret    
4000772a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

40007730 <localeconv>:
40007730:	55                   	push   %ebp
40007731:	8b 0d 60 d0 00 40    	mov    0x4000d060,%ecx
40007737:	89 e5                	mov    %esp,%ebp
40007739:	51                   	push   %ecx
4000773a:	e8 e1 ff ff ff       	call   40007720 <_localeconv_r>
4000773f:	5a                   	pop    %edx
40007740:	c9                   	leave  
40007741:	c3                   	ret    
40007742:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40007749:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40007750 <_setlocale_r>:
            {
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
              fp->_p = fp->_bf._base;
              if (fp->_flags & __SOFF)
40007750:	55                   	push   %ebp
                fp->_offset = curoff;
            }
40007751:	ba 38 bc 00 40       	mov    $0x4000bc38,%edx
            {
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
              fp->_p = fp->_bf._base;
              if (fp->_flags & __SOFF)
40007756:	89 e5                	mov    %esp,%ebp
40007758:	56                   	push   %esi
40007759:	53                   	push   %ebx
4000775a:	8b 5d 10             	mov    0x10(%ebp),%ebx
4000775d:	8b 75 08             	mov    0x8(%ebp),%esi
                fp->_offset = curoff;
            }
40007760:	85 db                	test   %ebx,%ebx
40007762:	74 1e                	je     40007782 <_setlocale_r+0x32>
        } 
      _funlockfile (fp);
40007764:	50                   	push   %eax
40007765:	50                   	push   %eax
40007766:	52                   	push   %edx
40007767:	53                   	push   %ebx
40007768:	e8 63 1d 00 00       	call   400094d0 <strcmp>
4000776d:	83 c4 10             	add    $0x10,%esp
40007770:	85 c0                	test   %eax,%eax
40007772:	75 17                	jne    4000778b <_setlocale_r+0x3b>
      return 0;
    }
40007774:	8b 45 0c             	mov    0xc(%ebp),%eax
  if ((p = fp->_bf._base) == NULL)
40007777:	89 5e 34             	mov    %ebx,0x34(%esi)
                fp->_offset = curoff;
            }
        } 
      _funlockfile (fp);
      return 0;
    }
4000777a:	89 46 30             	mov    %eax,0x30(%esi)
  if ((p = fp->_bf._base) == NULL)
4000777d:	ba 38 bc 00 40       	mov    $0x4000bc38,%edx
40007782:	8d 65 f8             	lea    -0x8(%ebp),%esp
40007785:	89 d0                	mov    %edx,%eax
40007787:	5b                   	pop    %ebx
40007788:	5e                   	pop    %esi
40007789:	5d                   	pop    %ebp
4000778a:	c3                   	ret    
              fp->_p = fp->_bf._base;
              if (fp->_flags & __SOFF)
                fp->_offset = curoff;
            }
        } 
      _funlockfile (fp);
4000778b:	50                   	push   %eax
4000778c:	50                   	push   %eax
4000778d:	68 3b bc 00 40       	push   $0x4000bc3b
40007792:	53                   	push   %ebx
40007793:	e8 38 1d 00 00       	call   400094d0 <strcmp>
40007798:	83 c4 10             	add    $0x10,%esp
4000779b:	31 d2                	xor    %edx,%edx
4000779d:	85 c0                	test   %eax,%eax
4000779f:	74 d3                	je     40007774 <_setlocale_r+0x24>
400077a1:	eb df                	jmp    40007782 <_setlocale_r+0x32>
400077a3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
400077a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

400077b0 <setlocale>:
400077b0:	55                   	push   %ebp
400077b1:	89 e5                	mov    %esp,%ebp
400077b3:	83 ec 0c             	sub    $0xc,%esp
400077b6:	8b 45 0c             	mov    0xc(%ebp),%eax
400077b9:	50                   	push   %eax
400077ba:	8b 45 08             	mov    0x8(%ebp),%eax
400077bd:	50                   	push   %eax
400077be:	a1 60 d0 00 40       	mov    0x4000d060,%eax
400077c3:	50                   	push   %eax
400077c4:	e8 87 ff ff ff       	call   40007750 <_setlocale_r>
400077c9:	c9                   	leave  
400077ca:	c3                   	ret    
400077cb:	90                   	nop    
400077cc:	90                   	nop    
400077cd:	90                   	nop    
400077ce:	90                   	nop    
400077cf:	90                   	nop    

400077d0 <_lseek_r>:
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
*/

#include <_ansi.h>
400077d0:	55                   	push   %ebp
400077d1:	89 e5                	mov    %esp,%ebp
400077d3:	83 ec 0c             	sub    $0xc,%esp
#include <stdio.h>
#include "local.h"

400077d6:	c7 05 60 d9 00 40 00 	movl   $0x0,0x4000d960
400077dd:	00 00 00 
/* Flush a single file, or (if fp is NULL) all files.  */
400077e0:	8b 4d 14             	mov    0x14(%ebp),%ecx
400077e3:	51                   	push   %ecx
400077e4:	8b 55 10             	mov    0x10(%ebp),%edx
400077e7:	52                   	push   %edx
400077e8:	8b 45 0c             	mov    0xc(%ebp),%eax
400077eb:	50                   	push   %eax
400077ec:	e8 3f 9c ff ff       	call   40001430 <lseek>
400077f1:	83 c4 10             	add    $0x10,%esp
400077f4:	83 f8 ff             	cmp    $0xffffffff,%eax
400077f7:	74 07                	je     40007800 <_lseek_r+0x30>

int
_DEFUN(fflush, (fp),
400077f9:	c9                   	leave  
400077fa:	c3                   	ret    
400077fb:	90                   	nop    
400077fc:	8d 74 26 00          	lea    0x0(%esi),%esi

#include <_ansi.h>
#include <stdio.h>
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */
40007800:	8b 15 60 d9 00 40    	mov    0x4000d960,%edx
40007806:	85 d2                	test   %edx,%edx
40007808:	74 ef                	je     400077f9 <_lseek_r+0x29>

4000780a:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000780d:	89 11                	mov    %edx,(%ecx)
int
_DEFUN(fflush, (fp),
4000780f:	c9                   	leave  
40007810:	c3                   	ret    
40007811:	90                   	nop    
40007812:	90                   	nop    
40007813:	90                   	nop    
40007814:	90                   	nop    
40007815:	90                   	nop    
40007816:	90                   	nop    
40007817:	90                   	nop    
40007818:	90                   	nop    
40007819:	90                   	nop    
4000781a:	90                   	nop    
4000781b:	90                   	nop    
4000781c:	90                   	nop    
4000781d:	90                   	nop    
4000781e:	90                   	nop    
4000781f:	90                   	nop    

40007820 <__smakebuf>:
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

Use <<fflush>> to deliver any such pending output (for the file
or stream identified by <[fp]>) to the host system.

40007820:	55                   	push   %ebp
40007821:	89 e5                	mov    %esp,%ebp
40007823:	57                   	push   %edi
40007824:	56                   	push   %esi
40007825:	53                   	push   %ebx
40007826:	83 ec 4c             	sub    $0x4c,%esp
40007829:	8b 75 08             	mov    0x8(%ebp),%esi
If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
open files.

RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
4000782c:	8b 56 0c             	mov    0xc(%esi),%edx
4000782f:	0f bf c2             	movswl %dx,%eax
40007832:	a8 02                	test   $0x2,%al
40007834:	75 6a                	jne    400078a0 <__smakebuf+0x80>
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
*/

#include <_ansi.h>
40007836:	66 8b 4e 0e          	mov    0xe(%esi),%cx
4000783a:	66 85 c9             	test   %cx,%cx
4000783d:	0f 88 7d 00 00 00    	js     400078c0 <__smakebuf+0xa0>
40007843:	8d 45 b8             	lea    -0x48(%ebp),%eax
40007846:	53                   	push   %ebx
40007847:	50                   	push   %eax
40007848:	0f bf c1             	movswl %cx,%eax
4000784b:	50                   	push   %eax
4000784c:	8b 0d 60 d0 00 40    	mov    0x4000d060,%ecx
40007852:	51                   	push   %ecx
40007853:	e8 58 37 00 00       	call   4000afb0 <_fstat_r>
40007858:	83 c4 10             	add    $0x10,%esp
4000785b:	85 c0                	test   %eax,%eax
4000785d:	78 58                	js     400078b7 <__smakebuf+0x97>
{
  register unsigned char *p;
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);
4000785f:	8b 55 bc             	mov    -0x44(%ebp),%edx
40007862:	81 e2 00 f0 00 00    	and    $0xf000,%edx
40007868:	81 fa 00 20 00 00    	cmp    $0x2000,%edx
4000786e:	0f 94 c0             	sete   %al
40007871:	25 ff 00 00 00       	and    $0xff,%eax

  t = fp->_flags;
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

40007876:	81 fa 00 80 00 00    	cmp    $0x8000,%edx
{
  register unsigned char *p;
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);
4000787c:	89 c7                	mov    %eax,%edi

  t = fp->_flags;
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

4000787e:	0f 84 ab 00 00 00    	je     4000792f <__smakebuf+0x10f>

      /* For a seekable stream with buffered read characters, we will attempt
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
40007884:	66 81 4e 0c 00 08    	orw    $0x800,0xc(%esi)
4000788a:	bb 00 04 00 00       	mov    $0x400,%ebx
4000788f:	eb 48                	jmp    400078d9 <__smakebuf+0xb9>
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
40007891:	66 83 4e 0c 02       	orw    $0x2,0xc(%esi)
40007896:	8d 76 00             	lea    0x0(%esi),%esi
40007899:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
          _fpos_t curoff;
400078a0:	8d 46 43             	lea    0x43(%esi),%eax

400078a3:	c7 46 14 01 00 00 00 	movl   $0x1,0x14(%esi)
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;
400078aa:	89 06                	mov    %eax,(%esi)
400078ac:	89 46 10             	mov    %eax,0x10(%esi)
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
                  _funlockfile (fp);
                  return 0;
400078af:	8d 65 f4             	lea    -0xc(%ebp),%esp
400078b2:	5b                   	pop    %ebx
400078b3:	5e                   	pop    %esi
400078b4:	5f                   	pop    %edi
400078b5:	5d                   	pop    %ebp
400078b6:	c3                   	ret    
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
*/

#include <_ansi.h>
400078b7:	8b 56 0c             	mov    0xc(%esi),%edx
400078ba:	0f bf c2             	movswl %dx,%eax
400078bd:	8d 76 00             	lea    0x0(%esi),%esi
#include <stdio.h>
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */

400078c0:	83 e0 80             	and    $0xffffff80,%eax
400078c3:	3c 01                	cmp    $0x1,%al
400078c5:	19 db                	sbb    %ebx,%ebx
int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  register unsigned char *p;
400078c7:	80 ce 08             	or     $0x8,%dh
#include <_ansi.h>
#include <stdio.h>
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */

400078ca:	81 e3 c0 03 00 00    	and    $0x3c0,%ebx
int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  register unsigned char *p;
400078d0:	66 89 56 0c          	mov    %dx,0xc(%esi)
#include <_ansi.h>
#include <stdio.h>
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */

400078d4:	83 c3 40             	add    $0x40,%ebx
int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  register unsigned char *p;
400078d7:	31 ff                	xor    %edi,%edi
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
400078d9:	52                   	push   %edx
400078da:	52                   	push   %edx
400078db:	53                   	push   %ebx
400078dc:	a1 60 d0 00 40       	mov    0x4000d060,%eax
400078e1:	50                   	push   %eax
400078e2:	e8 f9 8e ff ff       	call   400007e0 <_malloc_r>
400078e7:	83 c4 10             	add    $0x10,%esp
400078ea:	89 c2                	mov    %eax,%edx
400078ec:	85 c0                	test   %eax,%eax
400078ee:	74 a1                	je     40007891 <__smakebuf+0x71>
          _fpos_t curoff;

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
400078f0:	a1 60 d0 00 40       	mov    0x4000d060,%eax
            {
              /* We don't know current physical offset, so ask for it.  */
400078f5:	89 16                	mov    %edx,(%esi)

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
            {
400078f7:	66 81 4e 0c 80 00    	orw    $0x80,0xc(%esi)
          _fpos_t curoff;

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
400078fd:	c7 40 3c f0 04 00 40 	movl   $0x400004f0,0x3c(%eax)
            {
              /* We don't know current physical offset, so ask for it.  */
40007904:	89 56 10             	mov    %edx,0x10(%esi)
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
40007907:	89 5e 14             	mov    %ebx,0x14(%esi)
              if (curoff == -1L)
4000790a:	85 ff                	test   %edi,%edi
4000790c:	74 a1                	je     400078af <__smakebuf+0x8f>
4000790e:	83 ec 0c             	sub    $0xc,%esp
40007911:	0f bf 46 0e          	movswl 0xe(%esi),%eax
40007915:	50                   	push   %eax
40007916:	e8 c5 9a ff ff       	call   400013e0 <isatty>
4000791b:	83 c4 10             	add    $0x10,%esp
4000791e:	85 c0                	test   %eax,%eax
40007920:	74 8d                	je     400078af <__smakebuf+0x8f>
                {
40007922:	66 83 4e 0c 01       	orw    $0x1,0xc(%esi)
                  _funlockfile (fp);
                  return 0;
40007927:	8d 65 f4             	lea    -0xc(%ebp),%esp
4000792a:	5b                   	pop    %ebx
4000792b:	5e                   	pop    %esi
4000792c:	5f                   	pop    %edi
4000792d:	5d                   	pop    %ebp
4000792e:	c3                   	ret    

  t = fp->_flags;
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

4000792f:	81 7e 28 e0 11 00 40 	cmpl   $0x400011e0,0x28(%esi)
40007936:	0f 85 48 ff ff ff    	jne    40007884 <__smakebuf+0x64>
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
4000793c:	66 81 4e 0c 00 04    	orw    $0x400,0xc(%esi)
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;

      /* For a seekable stream with buffered read characters, we will attempt
40007942:	bb 00 04 00 00       	mov    $0x400,%ebx
40007947:	c7 46 4c 00 04 00 00 	movl   $0x400,0x4c(%esi)
4000794e:	eb 89                	jmp    400078d9 <__smakebuf+0xb9>

40007950 <_mbrtowc_r>:
* VERSION 2.6.4  Thu Nov 28 07:54:55 1996  Doug Lea  (dl at gee)
  
   Note: There may be an updated version of this malloc obtainable at
           ftp://g.oswego.edu/pub/misc/malloc.c
         Check before installing!

40007950:	55                   	push   %ebp
40007951:	89 e5                	mov    %esp,%ebp
40007953:	56                   	push   %esi
40007954:	53                   	push   %ebx
40007955:	8b 45 10             	mov    0x10(%ebp),%eax
40007958:	8b 75 08             	mov    0x8(%ebp),%esi
4000795b:	8b 5d 18             	mov    0x18(%ebp),%ebx
  Consistent balance across these factors results in a good general-purpose 
  allocator. For a high-level description, see 
     http://g.oswego.edu/dl/html/malloc.html

* Synopsis of public routines

4000795e:	85 c0                	test   %eax,%eax
40007960:	74 2e                	je     40007990 <_mbrtowc_r+0x40>
  (Much fuller descriptions are contained in the program documentation below.)

  malloc(size_t n);
40007962:	83 ec 0c             	sub    $0xc,%esp
40007965:	8b 55 14             	mov    0x14(%ebp),%edx
40007968:	53                   	push   %ebx
40007969:	52                   	push   %edx
4000796a:	50                   	push   %eax
4000796b:	8b 45 0c             	mov    0xc(%ebp),%eax
4000796e:	50                   	push   %eax
4000796f:	56                   	push   %esi
40007970:	e8 6b 00 00 00       	call   400079e0 <_mbtowc_r>
40007975:	83 c4 20             	add    $0x20,%esp
     Return a pointer to a newly allocated chunk of at least n bytes, or null
     if no space is available.
40007978:	83 f8 ff             	cmp    $0xffffffff,%eax
4000797b:	75 0c                	jne    40007989 <_mbrtowc_r+0x39>
  free(Void_t* p);
     Release the chunk of memory pointed to by p, or no effect if p is null.
4000797d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  realloc(Void_t* p, size_t n);
40007983:	c7 06 8a 00 00 00    	movl   $0x8a,(%esi)
     Return a pointer to a chunk of size n that contains the same data
     as does chunk p up to the minimum of (n, p's size) bytes, or null
     if no space is available. The returned pointer may or may not be
     the same as p. If p is null, equivalent to malloc.  Unless the
     #define REALLOC_ZERO_BYTES_FREES below is set, realloc with a
40007989:	8d 65 f8             	lea    -0x8(%ebp),%esp
4000798c:	5b                   	pop    %ebx
4000798d:	5e                   	pop    %esi
4000798e:	5d                   	pop    %ebp
4000798f:	c3                   	ret    
  allocator. For a high-level description, see 
     http://g.oswego.edu/dl/html/malloc.html

* Synopsis of public routines

  (Much fuller descriptions are contained in the program documentation below.)
40007990:	83 ec 0c             	sub    $0xc,%esp
40007993:	53                   	push   %ebx
40007994:	6a 01                	push   $0x1
40007996:	68 3b bc 00 40       	push   $0x4000bc3b
4000799b:	6a 00                	push   $0x0
4000799d:	56                   	push   %esi
4000799e:	e8 3d 00 00 00       	call   400079e0 <_mbtowc_r>
400079a3:	83 c4 20             	add    $0x20,%esp
400079a6:	eb d0                	jmp    40007978 <_mbrtowc_r+0x28>
400079a8:	90                   	nop    
400079a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

400079b0 <mbrtowc>:
     in accord with the alignment argument, which must be a power of
     two.
  valloc(size_t n);
     Equivalent to memalign(pagesize, n), where pagesize is the page
     size of the system (or as near to this as can be figured out from
     all the includes/defines below.)
400079b0:	55                   	push   %ebp
400079b1:	89 e5                	mov    %esp,%ebp
400079b3:	83 ec 14             	sub    $0x14,%esp
  pvalloc(size_t n);
400079b6:	8b 0d 60 d0 00 40    	mov    0x4000d060,%ecx
400079bc:	8b 45 14             	mov    0x14(%ebp),%eax
400079bf:	50                   	push   %eax
400079c0:	8b 45 10             	mov    0x10(%ebp),%eax
400079c3:	50                   	push   %eax
400079c4:	8b 45 0c             	mov    0xc(%ebp),%eax
400079c7:	50                   	push   %eax
400079c8:	8b 45 08             	mov    0x8(%ebp),%eax
400079cb:	50                   	push   %eax
400079cc:	51                   	push   %ecx
400079cd:	e8 7e ff ff ff       	call   40007950 <_mbrtowc_r>
     Equivalent to valloc(minimum-page-that-holds(n)), that is,
400079d2:	c9                   	leave  
400079d3:	c3                   	ret    
400079d4:	90                   	nop    
400079d5:	90                   	nop    
400079d6:	90                   	nop    
400079d7:	90                   	nop    
400079d8:	90                   	nop    
400079d9:	90                   	nop    
400079da:	90                   	nop    
400079db:	90                   	nop    
400079dc:	90                   	nop    
400079dd:	90                   	nop    
400079de:	90                   	nop    
400079df:	90                   	nop    

400079e0 <_mbtowc_r>:
     round up n to nearest pagesize.
  calloc(size_t unit, size_t quantity);
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
  cfree(Void_t* p);
     Equivalent to free(p).
400079e0:	55                   	push   %ebp
400079e1:	89 e5                	mov    %esp,%ebp
400079e3:	83 ec 10             	sub    $0x10,%esp
400079e6:	8b 55 0c             	mov    0xc(%ebp),%edx
400079e9:	8b 4d 10             	mov    0x10(%ebp),%ecx
  malloc_trim(size_t pad);
     Release all but pad bytes of freed top-most memory back 
     to the system. Return 1 if successful, else 0.
  malloc_usable_size(Void_t* p);
400079ec:	85 d2                	test   %edx,%edx
400079ee:	74 30                	je     40007a20 <_mbtowc_r+0x40>
  realloc with zero bytes should be the same as a call to free.
  Some people think it should. Otherwise, since this malloc
  returns a unique pointer for malloc(0), so does realloc(p, 0). 
*/


400079f0:	31 c0                	xor    %eax,%eax
     Release all but pad bytes of freed top-most memory back 
     to the system. Return 1 if successful, else 0.
  malloc_usable_size(Void_t* p);
     Report the number usable allocated bytes associated with allocated
     chunk p. This may or may not report more bytes than were requested,
     due to alignment and minimum size constraints.
400079f2:	85 c9                	test   %ecx,%ecx
400079f4:	74 1c                	je     40007a12 <_mbtowc_r+0x32>
400079f6:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
400079fb:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
400079ff:	74 11                	je     40007a12 <_mbtowc_r+0x32>
*/


/*   #define REALLOC_ZERO_BYTES_FREES */


40007a01:	31 c0                	xor    %eax,%eax
40007a03:	8a 01                	mov    (%ecx),%al
40007a05:	89 02                	mov    %eax,(%edx)
40007a07:	80 39 00             	cmpb   $0x0,(%ecx)
40007a0a:	0f 95 c0             	setne  %al
40007a0d:	25 ff 00 00 00       	and    $0xff,%eax
/* 
  WIN32 causes an emulation of sbrk to be compiled in
  mmap-based options are not currently supported in WIN32.
*/

/* #define WIN32 */
40007a12:	c9                   	leave  
40007a13:	c3                   	ret    
40007a14:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40007a1a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
  cfree(Void_t* p);
     Equivalent to free(p).
  malloc_trim(size_t pad);
     Release all but pad bytes of freed top-most memory back 
     to the system. Return 1 if successful, else 0.
  malloc_usable_size(Void_t* p);
40007a20:	8d 55 fc             	lea    -0x4(%ebp),%edx
40007a23:	eb cb                	jmp    400079f0 <_mbtowc_r+0x10>
40007a25:	90                   	nop    
40007a26:	90                   	nop    
40007a27:	90                   	nop    

40007a28 <memchr>:
40007a28:	55                   	push   %ebp
40007a29:	89 e5                	mov    %esp,%ebp
40007a2b:	57                   	push   %edi
40007a2c:	8b 45 0c             	mov    0xc(%ebp),%eax
40007a2f:	8b 4d 10             	mov    0x10(%ebp),%ecx
40007a32:	8b 7d 08             	mov    0x8(%ebp),%edi
40007a35:	31 d2                	xor    %edx,%edx
40007a37:	85 c9                	test   %ecx,%ecx
40007a39:	74 0a                	je     40007a45 <L1>
40007a3b:	fc                   	cld    
40007a3c:	f2 ae                	repnz scas %es:(%edi),%al
40007a3e:	0f 95 c2             	setne  %dl
40007a41:	4f                   	dec    %edi
40007a42:	4a                   	dec    %edx
40007a43:	21 fa                	and    %edi,%edx

40007a45 <L1>:
40007a45:	89 d0                	mov    %edx,%eax
40007a47:	8d 65 fc             	lea    -0x4(%ebp),%esp
40007a4a:	5f                   	pop    %edi
40007a4b:	c9                   	leave  
40007a4c:	c3                   	ret    
40007a4d:	90                   	nop    
40007a4e:	90                   	nop    
40007a4f:	90                   	nop    

40007a50 <memcpy>:
40007a50:	55                   	push   %ebp
40007a51:	89 e5                	mov    %esp,%ebp
40007a53:	56                   	push   %esi
40007a54:	57                   	push   %edi
40007a55:	53                   	push   %ebx
40007a56:	8b 7d 08             	mov    0x8(%ebp),%edi
40007a59:	8b 4d 10             	mov    0x10(%ebp),%ecx
40007a5c:	8b 75 0c             	mov    0xc(%ebp),%esi
40007a5f:	fc                   	cld    
40007a60:	83 f9 08             	cmp    $0x8,%ecx
40007a63:	76 26                	jbe    40007a8b <memcpy+0x3b>
40007a65:	89 fa                	mov    %edi,%edx
40007a67:	89 cb                	mov    %ecx,%ebx
40007a69:	83 e2 03             	and    $0x3,%edx
40007a6c:	74 10                	je     40007a7e <memcpy+0x2e>
40007a6e:	b9 04 00 00 00       	mov    $0x4,%ecx
40007a73:	29 d1                	sub    %edx,%ecx
40007a75:	83 e1 03             	and    $0x3,%ecx
40007a78:	29 cb                	sub    %ecx,%ebx
40007a7a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
40007a7c:	89 d9                	mov    %ebx,%ecx
40007a7e:	c1 e9 02             	shr    $0x2,%ecx
40007a81:	8d 76 00             	lea    0x0(%esi),%esi
40007a84:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
40007a86:	89 d9                	mov    %ebx,%ecx
40007a88:	83 e1 03             	and    $0x3,%ecx
40007a8b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
40007a8d:	8b 45 08             	mov    0x8(%ebp),%eax
40007a90:	8d 65 f4             	lea    -0xc(%ebp),%esp
40007a93:	5b                   	pop    %ebx
40007a94:	5f                   	pop    %edi
40007a95:	5e                   	pop    %esi
40007a96:	c9                   	leave  
40007a97:	c3                   	ret    
40007a98:	90                   	nop    
40007a99:	90                   	nop    
40007a9a:	90                   	nop    
40007a9b:	90                   	nop    
40007a9c:	90                   	nop    
40007a9d:	90                   	nop    
40007a9e:	90                   	nop    
40007a9f:	90                   	nop    

40007aa0 <memmove>:
40007aa0:	55                   	push   %ebp
40007aa1:	89 e5                	mov    %esp,%ebp
40007aa3:	56                   	push   %esi
40007aa4:	57                   	push   %edi
40007aa5:	53                   	push   %ebx
40007aa6:	8b 7d 08             	mov    0x8(%ebp),%edi
40007aa9:	8b 4d 10             	mov    0x10(%ebp),%ecx
40007aac:	8b 75 0c             	mov    0xc(%ebp),%esi
40007aaf:	fc                   	cld    
40007ab0:	39 fe                	cmp    %edi,%esi
40007ab2:	73 43                	jae    40007af7 <memmove+0x57>
40007ab4:	8d 5c 31 ff          	lea    -0x1(%ecx,%esi,1),%ebx
40007ab8:	39 df                	cmp    %ebx,%edi
40007aba:	77 3b                	ja     40007af7 <memmove+0x57>
40007abc:	01 ce                	add    %ecx,%esi
40007abe:	01 cf                	add    %ecx,%edi
40007ac0:	fd                   	std    
40007ac1:	83 f9 08             	cmp    $0x8,%ecx
40007ac4:	76 2b                	jbe    40007af1 <memmove+0x51>
40007ac6:	89 fa                	mov    %edi,%edx
40007ac8:	89 cb                	mov    %ecx,%ebx
40007aca:	83 e2 03             	and    $0x3,%edx
40007acd:	74 0c                	je     40007adb <memmove+0x3b>
40007acf:	89 d1                	mov    %edx,%ecx
40007ad1:	4e                   	dec    %esi
40007ad2:	4f                   	dec    %edi
40007ad3:	29 cb                	sub    %ecx,%ebx
40007ad5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
40007ad7:	89 d9                	mov    %ebx,%ecx
40007ad9:	46                   	inc    %esi
40007ada:	47                   	inc    %edi
40007adb:	c1 e9 02             	shr    $0x2,%ecx
40007ade:	83 ee 04             	sub    $0x4,%esi
40007ae1:	83 ef 04             	sub    $0x4,%edi
40007ae4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
40007ae6:	83 c6 04             	add    $0x4,%esi
40007ae9:	83 c7 04             	add    $0x4,%edi
40007aec:	89 d9                	mov    %ebx,%ecx
40007aee:	83 e1 03             	and    $0x3,%ecx
40007af1:	4e                   	dec    %esi
40007af2:	4f                   	dec    %edi
40007af3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
40007af5:	eb 2a                	jmp    40007b21 <memmove+0x81>
40007af7:	83 f9 08             	cmp    $0x8,%ecx
40007afa:	76 23                	jbe    40007b1f <memmove+0x7f>
40007afc:	89 fa                	mov    %edi,%edx
40007afe:	89 cb                	mov    %ecx,%ebx
40007b00:	83 e2 03             	and    $0x3,%edx
40007b03:	74 10                	je     40007b15 <memmove+0x75>
40007b05:	b9 04 00 00 00       	mov    $0x4,%ecx
40007b0a:	29 d1                	sub    %edx,%ecx
40007b0c:	83 e1 03             	and    $0x3,%ecx
40007b0f:	29 cb                	sub    %ecx,%ebx
40007b11:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
40007b13:	89 d9                	mov    %ebx,%ecx
40007b15:	c1 e9 02             	shr    $0x2,%ecx
40007b18:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
40007b1a:	89 d9                	mov    %ebx,%ecx
40007b1c:	83 e1 03             	and    $0x3,%ecx
40007b1f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
40007b21:	8b 45 08             	mov    0x8(%ebp),%eax
40007b24:	fc                   	cld    
40007b25:	8d 65 f4             	lea    -0xc(%ebp),%esp
40007b28:	5b                   	pop    %ebx
40007b29:	5f                   	pop    %edi
40007b2a:	5e                   	pop    %esi
40007b2b:	c9                   	leave  
40007b2c:	c3                   	ret    
40007b2d:	90                   	nop    
40007b2e:	90                   	nop    
40007b2f:	90                   	nop    

40007b30 <_Bfree>:
      return 0;
    }
  if ((p = fp->_bf._base) == NULL)
    {
      /* Nothing to flush.  */
      _funlockfile (fp);
40007b30:	55                   	push   %ebp
40007b31:	89 e5                	mov    %esp,%ebp
40007b33:	53                   	push   %ebx
40007b34:	8b 5d 0c             	mov    0xc(%ebp),%ebx
      return 0;
    }
40007b37:	85 db                	test   %ebx,%ebx
40007b39:	74 11                	je     40007b4c <_Bfree+0x1c>
  n = fp->_p - p;		/* write this much */

40007b3b:	8b 45 08             	mov    0x8(%ebp),%eax
40007b3e:	8b 53 04             	mov    0x4(%ebx),%edx
40007b41:	8b 48 4c             	mov    0x4c(%eax),%ecx
40007b44:	8b 04 91             	mov    (%ecx,%edx,4),%eax
40007b47:	89 03                	mov    %eax,(%ebx)
  /*
40007b49:	89 1c 91             	mov    %ebx,(%ecx,%edx,4)
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
40007b4c:	5b                   	pop    %ebx
40007b4d:	5d                   	pop    %ebp
40007b4e:	c3                   	ret    
40007b4f:	90                   	nop    

40007b50 <__hi0bits>:
40007b50:	55                   	push   %ebp
40007b51:	31 c0                	xor    %eax,%eax
40007b53:	89 e5                	mov    %esp,%ebp
40007b55:	8b 55 08             	mov    0x8(%ebp),%edx
40007b58:	f7 c2 00 00 ff ff    	test   $0xffff0000,%edx
40007b5e:	75 05                	jne    40007b65 <__hi0bits+0x15>
40007b60:	c1 e2 10             	shl    $0x10,%edx
40007b63:	b0 10                	mov    $0x10,%al
40007b65:	f7 c2 00 00 00 ff    	test   $0xff000000,%edx
40007b6b:	75 06                	jne    40007b73 <__hi0bits+0x23>
40007b6d:	c1 e2 08             	shl    $0x8,%edx
40007b70:	83 c0 08             	add    $0x8,%eax
40007b73:	f7 c2 00 00 00 f0    	test   $0xf0000000,%edx
40007b79:	75 06                	jne    40007b81 <__hi0bits+0x31>
40007b7b:	c1 e2 04             	shl    $0x4,%edx
40007b7e:	83 c0 04             	add    $0x4,%eax
40007b81:	f7 c2 00 00 00 c0    	test   $0xc0000000,%edx
40007b87:	75 06                	jne    40007b8f <__hi0bits+0x3f>
40007b89:	c1 e2 02             	shl    $0x2,%edx
40007b8c:	83 c0 02             	add    $0x2,%eax
40007b8f:	85 d2                	test   %edx,%edx
40007b91:	78 09                	js     40007b9c <__hi0bits+0x4c>
40007b93:	81 e2 00 00 00 40    	and    $0x40000000,%edx
40007b99:	74 05                	je     40007ba0 <__hi0bits+0x50>
40007b9b:	40                   	inc    %eax
40007b9c:	5d                   	pop    %ebp
40007b9d:	c3                   	ret    
40007b9e:	66 90                	xchg   %ax,%ax
40007ba0:	b8 20 00 00 00       	mov    $0x20,%eax
40007ba5:	5d                   	pop    %ebp
40007ba6:	c3                   	ret    
40007ba7:	89 f6                	mov    %esi,%esi
40007ba9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40007bb0 <__lo0bits>:
40007bb0:	55                   	push   %ebp
40007bb1:	89 e5                	mov    %esp,%ebp
40007bb3:	8b 4d 08             	mov    0x8(%ebp),%ecx
40007bb6:	8b 11                	mov    (%ecx),%edx
40007bb8:	f6 c2 07             	test   $0x7,%dl
40007bbb:	74 23                	je     40007be0 <__lo0bits+0x30>
40007bbd:	31 c0                	xor    %eax,%eax
40007bbf:	f6 c2 01             	test   $0x1,%dl
40007bc2:	75 0f                	jne    40007bd3 <__lo0bits+0x23>
40007bc4:	f6 c2 02             	test   $0x2,%dl
40007bc7:	75 6e                	jne    40007c37 <__lo0bits+0x87>
40007bc9:	c1 ea 02             	shr    $0x2,%edx
40007bcc:	b8 02 00 00 00       	mov    $0x2,%eax
40007bd1:	89 11                	mov    %edx,(%ecx)
40007bd3:	5d                   	pop    %ebp
40007bd4:	c3                   	ret    
40007bd5:	8d 74 26 00          	lea    0x0(%esi),%esi
40007bd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40007be0:	31 c0                	xor    %eax,%eax
40007be2:	66 85 d2             	test   %dx,%dx
40007be5:	74 39                	je     40007c20 <__lo0bits+0x70>
40007be7:	84 d2                	test   %dl,%dl
40007be9:	75 06                	jne    40007bf1 <__lo0bits+0x41>
40007beb:	c1 ea 08             	shr    $0x8,%edx
40007bee:	83 c0 08             	add    $0x8,%eax
40007bf1:	f6 c2 0f             	test   $0xf,%dl
40007bf4:	75 06                	jne    40007bfc <__lo0bits+0x4c>
40007bf6:	c1 ea 04             	shr    $0x4,%edx
40007bf9:	83 c0 04             	add    $0x4,%eax
40007bfc:	f6 c2 03             	test   $0x3,%dl
40007bff:	75 06                	jne    40007c07 <__lo0bits+0x57>
40007c01:	c1 ea 02             	shr    $0x2,%edx
40007c04:	83 c0 02             	add    $0x2,%eax
40007c07:	f6 c2 01             	test   $0x1,%dl
40007c0a:	75 05                	jne    40007c11 <__lo0bits+0x61>
40007c0c:	d1 ea                	shr    %edx
40007c0e:	74 20                	je     40007c30 <__lo0bits+0x80>
40007c10:	40                   	inc    %eax
40007c11:	89 11                	mov    %edx,(%ecx)
40007c13:	5d                   	pop    %ebp
40007c14:	c3                   	ret    
40007c15:	8d 74 26 00          	lea    0x0(%esi),%esi
40007c19:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40007c20:	c1 ea 10             	shr    $0x10,%edx
40007c23:	b0 10                	mov    $0x10,%al
40007c25:	84 d2                	test   %dl,%dl
40007c27:	75 c8                	jne    40007bf1 <__lo0bits+0x41>
40007c29:	eb c0                	jmp    40007beb <__lo0bits+0x3b>
40007c2b:	90                   	nop    
40007c2c:	8d 74 26 00          	lea    0x0(%esi),%esi
40007c30:	b8 20 00 00 00       	mov    $0x20,%eax
40007c35:	5d                   	pop    %ebp
40007c36:	c3                   	ret    
40007c37:	d1 ea                	shr    %edx
40007c39:	b0 01                	mov    $0x1,%al
40007c3b:	89 11                	mov    %edx,(%ecx)
40007c3d:	5d                   	pop    %ebp
40007c3e:	c3                   	ret    
40007c3f:	90                   	nop    

40007c40 <__mcmp>:
40007c40:	55                   	push   %ebp
40007c41:	89 e5                	mov    %esp,%ebp
40007c43:	57                   	push   %edi
40007c44:	56                   	push   %esi
40007c45:	53                   	push   %ebx
40007c46:	8b 4d 08             	mov    0x8(%ebp),%ecx
40007c49:	8b 7d 0c             	mov    0xc(%ebp),%edi
40007c4c:	8b 41 10             	mov    0x10(%ecx),%eax
40007c4f:	8b 57 10             	mov    0x10(%edi),%edx
40007c52:	89 c6                	mov    %eax,%esi
40007c54:	29 d6                	sub    %edx,%esi
40007c56:	75 2a                	jne    40007c82 <__mcmp+0x42>
40007c58:	8d 04 95 10 00 00 00 	lea    0x10(,%edx,4),%eax
40007c5f:	8d 59 14             	lea    0x14(%ecx),%ebx
40007c62:	8d 54 01 04          	lea    0x4(%ecx,%eax,1),%edx
40007c66:	8d 4c 07 04          	lea    0x4(%edi,%eax,1),%ecx
40007c6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40007c70:	8b 41 fc             	mov    -0x4(%ecx),%eax
40007c73:	39 42 fc             	cmp    %eax,-0x4(%edx)
40007c76:	75 11                	jne    40007c89 <__mcmp+0x49>
40007c78:	83 ea 04             	sub    $0x4,%edx
40007c7b:	83 e9 04             	sub    $0x4,%ecx
40007c7e:	39 d3                	cmp    %edx,%ebx
40007c80:	72 ee                	jb     40007c70 <__mcmp+0x30>
40007c82:	89 f0                	mov    %esi,%eax
40007c84:	5b                   	pop    %ebx
40007c85:	5e                   	pop    %esi
40007c86:	5f                   	pop    %edi
40007c87:	5d                   	pop    %ebp
40007c88:	c3                   	ret    
40007c89:	19 f6                	sbb    %esi,%esi
40007c8b:	5b                   	pop    %ebx
40007c8c:	83 ce 01             	or     $0x1,%esi
40007c8f:	89 f0                	mov    %esi,%eax
40007c91:	5e                   	pop    %esi
40007c92:	5f                   	pop    %edi
40007c93:	5d                   	pop    %ebp
40007c94:	c3                   	ret    
40007c95:	8d 74 26 00          	lea    0x0(%esi),%esi
40007c99:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40007ca0 <__ulp>:
40007ca0:	55                   	push   %ebp
40007ca1:	89 e5                	mov    %esp,%ebp
40007ca3:	83 ec 08             	sub    $0x8,%esp
40007ca6:	8b 55 0c             	mov    0xc(%ebp),%edx
40007ca9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40007cb0:	89 d0                	mov    %edx,%eax
40007cb2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40007cb9:	25 00 00 f0 7f       	and    $0x7ff00000,%eax
40007cbe:	2d 00 00 40 03       	sub    $0x3400000,%eax
40007cc3:	85 c0                	test   %eax,%eax
40007cc5:	7e 19                	jle    40007ce0 <__ulp+0x40>
40007cc7:	89 45 fc             	mov    %eax,-0x4(%ebp)
40007cca:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
40007cd1:	dd 45 f8             	fldl   -0x8(%ebp)
40007cd4:	c9                   	leave  
40007cd5:	c3                   	ret    
40007cd6:	8d 76 00             	lea    0x0(%esi),%esi
40007cd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40007ce0:	89 c1                	mov    %eax,%ecx
40007ce2:	f7 d9                	neg    %ecx
40007ce4:	c1 f9 14             	sar    $0x14,%ecx
40007ce7:	83 f9 13             	cmp    $0x13,%ecx
40007cea:	7e 34                	jle    40007d20 <__ulp+0x80>
40007cec:	8d 41 ec             	lea    -0x14(%ecx),%eax
40007cef:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
40007cf6:	ba 01 00 00 00       	mov    $0x1,%edx
40007cfb:	83 f8 1e             	cmp    $0x1e,%eax
40007cfe:	7f 09                	jg     40007d09 <__ulp+0x69>
40007d00:	b9 1f 00 00 00       	mov    $0x1f,%ecx
40007d05:	29 c1                	sub    %eax,%ecx
40007d07:	d3 e2                	shl    %cl,%edx
40007d09:	89 55 f8             	mov    %edx,-0x8(%ebp)
40007d0c:	dd 45 f8             	fldl   -0x8(%ebp)
40007d0f:	c9                   	leave  
40007d10:	c3                   	ret    
40007d11:	eb 0d                	jmp    40007d20 <__ulp+0x80>
40007d13:	90                   	nop    
40007d14:	90                   	nop    
40007d15:	90                   	nop    
40007d16:	90                   	nop    
40007d17:	90                   	nop    
40007d18:	90                   	nop    
40007d19:	90                   	nop    
40007d1a:	90                   	nop    
40007d1b:	90                   	nop    
40007d1c:	90                   	nop    
40007d1d:	90                   	nop    
40007d1e:	90                   	nop    
40007d1f:	90                   	nop    
40007d20:	b8 00 00 08 00       	mov    $0x80000,%eax
40007d25:	d3 f8                	sar    %cl,%eax
40007d27:	eb 9e                	jmp    40007cc7 <__ulp+0x27>
40007d29:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

40007d30 <__b2d>:
40007d30:	55                   	push   %ebp
40007d31:	89 e5                	mov    %esp,%ebp
40007d33:	57                   	push   %edi
40007d34:	56                   	push   %esi
40007d35:	53                   	push   %ebx
40007d36:	83 ec 1c             	sub    $0x1c,%esp
40007d39:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
40007d40:	8b 45 08             	mov    0x8(%ebp),%eax
40007d43:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
40007d4a:	8d 50 14             	lea    0x14(%eax),%edx
40007d4d:	89 55 e8             	mov    %edx,-0x18(%ebp)
40007d50:	8b 50 10             	mov    0x10(%eax),%edx
40007d53:	8d 7c 90 10          	lea    0x10(%eax,%edx,4),%edi
40007d57:	89 fe                	mov    %edi,%esi
40007d59:	8b 1f                	mov    (%edi),%ebx
40007d5b:	53                   	push   %ebx
40007d5c:	e8 ef fd ff ff       	call   40007b50 <__hi0bits>
40007d61:	59                   	pop    %ecx
40007d62:	89 45 dc             	mov    %eax,-0x24(%ebp)
40007d65:	8b 55 dc             	mov    -0x24(%ebp),%edx
40007d68:	b8 20 00 00 00       	mov    $0x20,%eax
40007d6d:	29 d0                	sub    %edx,%eax
40007d6f:	8b 55 0c             	mov    0xc(%ebp),%edx
40007d72:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
40007d76:	89 02                	mov    %eax,(%edx)
40007d78:	7f 46                	jg     40007dc0 <__b2d+0x90>
40007d7a:	8b 4d dc             	mov    -0x24(%ebp),%ecx
40007d7d:	ba 0b 00 00 00       	mov    $0xb,%edx
40007d82:	29 ca                	sub    %ecx,%edx
40007d84:	89 d8                	mov    %ebx,%eax
40007d86:	88 d1                	mov    %dl,%cl
40007d88:	d3 e8                	shr    %cl,%eax
40007d8a:	0d 00 00 f0 3f       	or     $0x3ff00000,%eax
40007d8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40007d92:	31 c0                	xor    %eax,%eax
40007d94:	39 7d e8             	cmp    %edi,-0x18(%ebp)
40007d97:	0f 82 a3 00 00 00    	jb     40007e40 <__b2d+0x110>
40007d9d:	8b 4d dc             	mov    -0x24(%ebp),%ecx
40007da0:	83 c1 15             	add    $0x15,%ecx
40007da3:	d3 e3                	shl    %cl,%ebx
40007da5:	09 d8                	or     %ebx,%eax
40007da7:	89 45 e0             	mov    %eax,-0x20(%ebp)
40007daa:	dd 45 e0             	fldl   -0x20(%ebp)
40007dad:	8d 65 f4             	lea    -0xc(%ebp),%esp
40007db0:	5b                   	pop    %ebx
40007db1:	5e                   	pop    %esi
40007db2:	5f                   	pop    %edi
40007db3:	5d                   	pop    %ebp
40007db4:	c3                   	ret    
40007db5:	8d 74 26 00          	lea    0x0(%esi),%esi
40007db9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40007dc0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40007dc7:	39 7d e8             	cmp    %edi,-0x18(%ebp)
40007dca:	72 44                	jb     40007e10 <__b2d+0xe0>
40007dcc:	8b 7d dc             	mov    -0x24(%ebp),%edi
40007dcf:	83 ef 0b             	sub    $0xb,%edi
40007dd2:	74 4d                	je     40007e21 <__b2d+0xf1>
40007dd4:	ba 20 00 00 00       	mov    $0x20,%edx
40007dd9:	89 f9                	mov    %edi,%ecx
40007ddb:	29 fa                	sub    %edi,%edx
40007ddd:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007de0:	d3 e3                	shl    %cl,%ebx
40007de2:	88 d1                	mov    %dl,%cl
40007de4:	81 cb 00 00 f0 3f    	or     $0x3ff00000,%ebx
40007dea:	d3 e8                	shr    %cl,%eax
40007dec:	09 c3                	or     %eax,%ebx
40007dee:	31 c0                	xor    %eax,%eax
40007df0:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
40007df3:	3b 75 e8             	cmp    -0x18(%ebp),%esi
40007df6:	77 58                	ja     40007e50 <__b2d+0x120>
40007df8:	89 f9                	mov    %edi,%ecx
40007dfa:	d3 65 ec             	shll   %cl,-0x14(%ebp)
40007dfd:	8b 55 ec             	mov    -0x14(%ebp),%edx
40007e00:	09 d0                	or     %edx,%eax
40007e02:	89 45 e0             	mov    %eax,-0x20(%ebp)
40007e05:	dd 45 e0             	fldl   -0x20(%ebp)
40007e08:	8d 65 f4             	lea    -0xc(%ebp),%esp
40007e0b:	5b                   	pop    %ebx
40007e0c:	5e                   	pop    %esi
40007e0d:	5f                   	pop    %edi
40007e0e:	5d                   	pop    %ebp
40007e0f:	c3                   	ret    
40007e10:	8b 7f fc             	mov    -0x4(%edi),%edi
40007e13:	83 ee 04             	sub    $0x4,%esi
40007e16:	89 7d ec             	mov    %edi,-0x14(%ebp)
40007e19:	8b 7d dc             	mov    -0x24(%ebp),%edi
40007e1c:	83 ef 0b             	sub    $0xb,%edi
40007e1f:	75 b3                	jne    40007dd4 <__b2d+0xa4>
40007e21:	8b 45 ec             	mov    -0x14(%ebp),%eax
40007e24:	81 cb 00 00 f0 3f    	or     $0x3ff00000,%ebx
40007e2a:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
40007e2d:	89 45 e0             	mov    %eax,-0x20(%ebp)
40007e30:	dd 45 e0             	fldl   -0x20(%ebp)
40007e33:	8d 65 f4             	lea    -0xc(%ebp),%esp
40007e36:	5b                   	pop    %ebx
40007e37:	5e                   	pop    %esi
40007e38:	5f                   	pop    %edi
40007e39:	5d                   	pop    %ebp
40007e3a:	c3                   	ret    
40007e3b:	90                   	nop    
40007e3c:	8d 74 26 00          	lea    0x0(%esi),%esi
40007e40:	8b 47 fc             	mov    -0x4(%edi),%eax
40007e43:	d3 e8                	shr    %cl,%eax
40007e45:	e9 53 ff ff ff       	jmp    40007d9d <__b2d+0x6d>
40007e4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40007e50:	8b 46 fc             	mov    -0x4(%esi),%eax
40007e53:	d3 e8                	shr    %cl,%eax
40007e55:	89 f9                	mov    %edi,%ecx
40007e57:	d3 65 ec             	shll   %cl,-0x14(%ebp)
40007e5a:	8b 55 ec             	mov    -0x14(%ebp),%edx
40007e5d:	09 d0                	or     %edx,%eax
40007e5f:	89 45 e0             	mov    %eax,-0x20(%ebp)
40007e62:	eb a1                	jmp    40007e05 <__b2d+0xd5>
40007e64:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40007e6a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

40007e70 <__ratio>:
40007e70:	55                   	push   %ebp
40007e71:	89 e5                	mov    %esp,%ebp
40007e73:	56                   	push   %esi
40007e74:	53                   	push   %ebx
40007e75:	83 ec 20             	sub    $0x20,%esp
40007e78:	8d 45 f4             	lea    -0xc(%ebp),%eax
40007e7b:	8b 5d 08             	mov    0x8(%ebp),%ebx
40007e7e:	8b 75 0c             	mov    0xc(%ebp),%esi
40007e81:	50                   	push   %eax
40007e82:	53                   	push   %ebx
40007e83:	e8 a8 fe ff ff       	call   40007d30 <__b2d>
40007e88:	8d 45 f0             	lea    -0x10(%ebp),%eax
40007e8b:	dd 5d e0             	fstpl  -0x20(%ebp)
40007e8e:	50                   	push   %eax
40007e8f:	56                   	push   %esi
40007e90:	e8 9b fe ff ff       	call   40007d30 <__b2d>
40007e95:	8b 45 f0             	mov    -0x10(%ebp),%eax
40007e98:	8b 55 f4             	mov    -0xc(%ebp),%edx
40007e9b:	8b 4e 10             	mov    0x10(%esi),%ecx
40007e9e:	29 c2                	sub    %eax,%edx
40007ea0:	8b 43 10             	mov    0x10(%ebx),%eax
40007ea3:	29 c8                	sub    %ecx,%eax
40007ea5:	83 c4 10             	add    $0x10,%esp
40007ea8:	c1 e0 05             	shl    $0x5,%eax
40007eab:	dd 5d d8             	fstpl  -0x28(%ebp)
40007eae:	8d 04 02             	lea    (%edx,%eax,1),%eax
40007eb1:	85 c0                	test   %eax,%eax
40007eb3:	7e 1b                	jle    40007ed0 <__ratio+0x60>
40007eb5:	c1 e0 14             	shl    $0x14,%eax
40007eb8:	8b 75 e4             	mov    -0x1c(%ebp),%esi
40007ebb:	01 c6                	add    %eax,%esi
40007ebd:	89 75 e4             	mov    %esi,-0x1c(%ebp)
40007ec0:	dd 45 e0             	fldl   -0x20(%ebp)
40007ec3:	dc 75 d8             	fdivl  -0x28(%ebp)
40007ec6:	8d 65 f8             	lea    -0x8(%ebp),%esp
40007ec9:	5b                   	pop    %ebx
40007eca:	5e                   	pop    %esi
40007ecb:	5d                   	pop    %ebp
40007ecc:	c3                   	ret    
40007ecd:	8d 76 00             	lea    0x0(%esi),%esi
40007ed0:	c1 e0 14             	shl    $0x14,%eax
40007ed3:	8b 5d dc             	mov    -0x24(%ebp),%ebx
40007ed6:	29 c3                	sub    %eax,%ebx
40007ed8:	89 5d dc             	mov    %ebx,-0x24(%ebp)
40007edb:	dd 45 e0             	fldl   -0x20(%ebp)
40007ede:	dc 75 d8             	fdivl  -0x28(%ebp)
40007ee1:	8d 65 f8             	lea    -0x8(%ebp),%esp
40007ee4:	5b                   	pop    %ebx
40007ee5:	5e                   	pop    %esi
40007ee6:	5d                   	pop    %ebp
40007ee7:	c3                   	ret    
40007ee8:	90                   	nop    
40007ee9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

40007ef0 <_mprec_log10>:
40007ef0:	55                   	push   %ebp
40007ef1:	89 e5                	mov    %esp,%ebp
40007ef3:	8b 45 08             	mov    0x8(%ebp),%eax
40007ef6:	83 f8 17             	cmp    $0x17,%eax
40007ef9:	7f 15                	jg     40007f10 <_mprec_log10+0x20>
40007efb:	dd 04 c5 20 c6 00 40 	fldl   0x4000c620(,%eax,8)
40007f02:	5d                   	pop    %ebp
40007f03:	c3                   	ret    
40007f04:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40007f0a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
40007f10:	d9 05 8c c5 00 40    	flds   0x4000c58c
40007f16:	8d 76 00             	lea    0x0(%esi),%esi
40007f19:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40007f20:	48                   	dec    %eax
40007f21:	d8 0d 90 c5 00 40    	fmuls  0x4000c590
40007f27:	75 f7                	jne    40007f20 <_mprec_log10+0x30>
40007f29:	5d                   	pop    %ebp
40007f2a:	c3                   	ret    
40007f2b:	90                   	nop    
40007f2c:	8d 74 26 00          	lea    0x0(%esi),%esi

40007f30 <__copybits>:
40007f30:	55                   	push   %ebp
40007f31:	89 e5                	mov    %esp,%ebp
40007f33:	56                   	push   %esi
40007f34:	53                   	push   %ebx
40007f35:	8b 55 0c             	mov    0xc(%ebp),%edx
40007f38:	8b 45 10             	mov    0x10(%ebp),%eax
40007f3b:	4a                   	dec    %edx
40007f3c:	8b 4d 08             	mov    0x8(%ebp),%ecx
40007f3f:	c1 fa 05             	sar    $0x5,%edx
40007f42:	8d 58 14             	lea    0x14(%eax),%ebx
40007f45:	8d 74 91 04          	lea    0x4(%ecx,%edx,4),%esi
40007f49:	8b 50 10             	mov    0x10(%eax),%edx
40007f4c:	8d 54 90 14          	lea    0x14(%eax,%edx,4),%edx
40007f50:	39 d3                	cmp    %edx,%ebx
40007f52:	73 35                	jae    40007f89 <__copybits+0x59>
40007f54:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40007f5a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
40007f60:	8b 03                	mov    (%ebx),%eax
40007f62:	83 c3 04             	add    $0x4,%ebx
40007f65:	89 01                	mov    %eax,(%ecx)
40007f67:	83 c1 04             	add    $0x4,%ecx
40007f6a:	39 da                	cmp    %ebx,%edx
40007f6c:	77 f2                	ja     40007f60 <__copybits+0x30>
40007f6e:	39 ce                	cmp    %ecx,%esi
40007f70:	76 1b                	jbe    40007f8d <__copybits+0x5d>
40007f72:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40007f79:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40007f80:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
40007f86:	83 c1 04             	add    $0x4,%ecx
40007f89:	39 ce                	cmp    %ecx,%esi
40007f8b:	77 f3                	ja     40007f80 <__copybits+0x50>
40007f8d:	5b                   	pop    %ebx
40007f8e:	5e                   	pop    %esi
40007f8f:	5d                   	pop    %ebp
40007f90:	c3                   	ret    
40007f91:	eb 0d                	jmp    40007fa0 <__any_on>
40007f93:	90                   	nop    
40007f94:	90                   	nop    
40007f95:	90                   	nop    
40007f96:	90                   	nop    
40007f97:	90                   	nop    
40007f98:	90                   	nop    
40007f99:	90                   	nop    
40007f9a:	90                   	nop    
40007f9b:	90                   	nop    
40007f9c:	90                   	nop    
40007f9d:	90                   	nop    
40007f9e:	90                   	nop    
40007f9f:	90                   	nop    

40007fa0 <__any_on>:
40007fa0:	55                   	push   %ebp
40007fa1:	89 e5                	mov    %esp,%ebp
40007fa3:	56                   	push   %esi
40007fa4:	53                   	push   %ebx
40007fa5:	8b 75 08             	mov    0x8(%ebp),%esi
40007fa8:	8b 55 0c             	mov    0xc(%ebp),%edx
40007fab:	c1 fa 05             	sar    $0x5,%edx
40007fae:	8b 46 10             	mov    0x10(%esi),%eax
40007fb1:	89 c3                	mov    %eax,%ebx
40007fb3:	39 d0                	cmp    %edx,%eax
40007fb5:	7c 19                	jl     40007fd0 <__any_on+0x30>
40007fb7:	7e 4d                	jle    40008006 <__any_on+0x66>
40007fb9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
40007fbc:	89 d3                	mov    %edx,%ebx
40007fbe:	83 e1 1f             	and    $0x1f,%ecx
40007fc1:	75 4d                	jne    40008010 <__any_on+0x70>
40007fc3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40007fc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40007fd0:	8d 54 9e 10          	lea    0x10(%esi,%ebx,4),%edx
40007fd4:	8d 4e 14             	lea    0x14(%esi),%ecx
40007fd7:	8d 42 04             	lea    0x4(%edx),%eax
40007fda:	39 c1                	cmp    %eax,%ecx
40007fdc:	73 2c                	jae    4000800a <__any_on+0x6a>
40007fde:	8b 1a                	mov    (%edx),%ebx
40007fe0:	89 d0                	mov    %edx,%eax
40007fe2:	85 db                	test   %ebx,%ebx
40007fe4:	75 17                	jne    40007ffd <__any_on+0x5d>
40007fe6:	8d 76 00             	lea    0x0(%esi),%esi
40007fe9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40007ff0:	39 c8                	cmp    %ecx,%eax
40007ff2:	76 16                	jbe    4000800a <__any_on+0x6a>
40007ff4:	83 e8 04             	sub    $0x4,%eax
40007ff7:	8b 10                	mov    (%eax),%edx
40007ff9:	85 d2                	test   %edx,%edx
40007ffb:	74 f3                	je     40007ff0 <__any_on+0x50>
40007ffd:	b8 01 00 00 00       	mov    $0x1,%eax
40008002:	5b                   	pop    %ebx
40008003:	5e                   	pop    %esi
40008004:	5d                   	pop    %ebp
40008005:	c3                   	ret    
40008006:	89 d3                	mov    %edx,%ebx
40008008:	eb c6                	jmp    40007fd0 <__any_on+0x30>
4000800a:	31 c0                	xor    %eax,%eax
4000800c:	5b                   	pop    %ebx
4000800d:	5e                   	pop    %esi
4000800e:	5d                   	pop    %ebp
4000800f:	c3                   	ret    
40008010:	8b 54 96 14          	mov    0x14(%esi,%edx,4),%edx
40008014:	89 d0                	mov    %edx,%eax
40008016:	d3 e8                	shr    %cl,%eax
40008018:	d3 e0                	shl    %cl,%eax
4000801a:	39 d0                	cmp    %edx,%eax
4000801c:	75 df                	jne    40007ffd <__any_on+0x5d>
4000801e:	eb b0                	jmp    40007fd0 <__any_on+0x30>

40008020 <_Balloc>:
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;

40008020:	55                   	push   %ebp
40008021:	89 e5                	mov    %esp,%ebp
40008023:	57                   	push   %edi
40008024:	56                   	push   %esi
40008025:	53                   	push   %ebx
40008026:	83 ec 0c             	sub    $0xc,%esp
40008029:	8b 75 08             	mov    0x8(%ebp),%esi
4000802c:	8b 7d 0c             	mov    0xc(%ebp),%edi
          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
            {
4000802f:	8b 46 4c             	mov    0x4c(%esi),%eax
40008032:	85 c0                	test   %eax,%eax
40008034:	74 25                	je     4000805b <_Balloc+0x3b>
                }
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
40008036:	8d 14 b8             	lea    (%eax,%edi,4),%edx
40008039:	8b 1a                	mov    (%edx),%ebx
4000803b:	85 db                	test   %ebx,%ebx
4000803d:	74 35                	je     40008074 <_Balloc+0x54>
              curoff -= fp->_r;
              if (HASUB (fp))
4000803f:	8b 03                	mov    (%ebx),%eax
40008041:	89 02                	mov    %eax,(%edx)
              fp->_p = fp->_bf._base;
              if (fp->_flags & __SOFF)
                fp->_offset = curoff;
            }
        } 
      _funlockfile (fp);
40008043:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
4000804a:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      return 0;
    }
40008051:	8d 65 f4             	lea    -0xc(%ebp),%esp
40008054:	89 d8                	mov    %ebx,%eax
40008056:	5b                   	pop    %ebx
40008057:	5e                   	pop    %esi
40008058:	5f                   	pop    %edi
40008059:	5d                   	pop    %ebp
4000805a:	c3                   	ret    
            curoff = fp->_offset;
          else
            {
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
4000805b:	50                   	push   %eax
4000805c:	6a 10                	push   $0x10
4000805e:	6a 04                	push   $0x4
40008060:	56                   	push   %esi
40008061:	e8 8a 2e 00 00       	call   4000aef0 <_calloc_r>
                {
                  _funlockfile (fp);
                  return 0;
40008066:	31 db                	xor    %ebx,%ebx
40008068:	83 c4 10             	add    $0x10,%esp
            curoff = fp->_offset;
          else
            {
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
4000806b:	89 46 4c             	mov    %eax,0x4c(%esi)
                {
                  _funlockfile (fp);
                  return 0;
4000806e:	85 c0                	test   %eax,%eax
40008070:	75 c4                	jne    40008036 <_Balloc+0x16>
40008072:	eb dd                	jmp    40008051 <_Balloc+0x31>
              curoff -= fp->_r;
              if (HASUB (fp))
                curoff -= fp->_ur;
            }
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
40008074:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
4000807b:	89 f9                	mov    %edi,%ecx
4000807d:	d3 65 f0             	shll   %cl,-0x10(%ebp)
            {
              /* Seek successful.  We can clear read buffer now.  */
40008080:	8b 55 f0             	mov    -0x10(%ebp),%edx
40008083:	50                   	push   %eax
40008084:	8d 04 95 14 00 00 00 	lea    0x14(,%edx,4),%eax
4000808b:	50                   	push   %eax
4000808c:	6a 01                	push   $0x1
4000808e:	56                   	push   %esi
4000808f:	e8 5c 2e 00 00       	call   4000aef0 <_calloc_r>
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
              fp->_p = fp->_bf._base;
              if (fp->_flags & __SOFF)
40008094:	83 c4 10             	add    $0x10,%esp
40008097:	85 c0                	test   %eax,%eax
40008099:	74 b6                	je     40008051 <_Balloc+0x31>
                fp->_offset = curoff;
            }
4000809b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
                curoff -= fp->_ur;
            }
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
              /* Seek successful.  We can clear read buffer now.  */
4000809e:	89 c3                	mov    %eax,%ebx
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
              fp->_p = fp->_bf._base;
              if (fp->_flags & __SOFF)
                fp->_offset = curoff;
400080a0:	89 78 04             	mov    %edi,0x4(%eax)
            }
400080a3:	89 48 08             	mov    %ecx,0x8(%eax)
400080a6:	eb 9b                	jmp    40008043 <_Balloc+0x23>
400080a8:	90                   	nop    
400080a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

400080b0 <__d2b>:
400080b0:	55                   	push   %ebp
400080b1:	89 e5                	mov    %esp,%ebp
400080b3:	57                   	push   %edi
400080b4:	56                   	push   %esi
400080b5:	53                   	push   %ebx
400080b6:	83 ec 24             	sub    $0x24,%esp
400080b9:	8b 75 10             	mov    0x10(%ebp),%esi
400080bc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
400080bf:	6a 01                	push   $0x1
400080c1:	8b 7d 08             	mov    0x8(%ebp),%edi
400080c4:	57                   	push   %edi
400080c5:	e8 56 ff ff ff       	call   40008020 <_Balloc>
400080ca:	89 c7                	mov    %eax,%edi
400080cc:	89 f0                	mov    %esi,%eax
400080ce:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
400080d3:	89 f2                	mov    %esi,%edx
400080d5:	89 c1                	mov    %eax,%ecx
400080d7:	81 e2 ff ff 0f 00    	and    $0xfffff,%edx
400080dd:	83 c4 10             	add    $0x10,%esp
400080e0:	89 55 ec             	mov    %edx,-0x14(%ebp)
400080e3:	c1 e9 14             	shr    $0x14,%ecx
400080e6:	89 4d e0             	mov    %ecx,-0x20(%ebp)
400080e9:	74 09                	je     400080f4 <__d2b+0x44>
400080eb:	81 ca 00 00 10 00    	or     $0x100000,%edx
400080f1:	89 55 ec             	mov    %edx,-0x14(%ebp)
400080f4:	85 db                	test   %ebx,%ebx
400080f6:	74 68                	je     40008160 <__d2b+0xb0>
400080f8:	89 5d f0             	mov    %ebx,-0x10(%ebp)
400080fb:	8d 45 f0             	lea    -0x10(%ebp),%eax
400080fe:	50                   	push   %eax
400080ff:	e8 ac fa ff ff       	call   40007bb0 <__lo0bits>
40008104:	59                   	pop    %ecx
40008105:	89 c3                	mov    %eax,%ebx
40008107:	85 c0                	test   %eax,%eax
40008109:	0f 85 a1 00 00 00    	jne    400081b0 <__d2b+0x100>
4000810f:	8b 45 f0             	mov    -0x10(%ebp),%eax
40008112:	89 47 14             	mov    %eax,0x14(%edi)
40008115:	8b 45 ec             	mov    -0x14(%ebp),%eax
40008118:	8b 75 e0             	mov    -0x20(%ebp),%esi
4000811b:	83 f8 01             	cmp    $0x1,%eax
4000811e:	89 47 18             	mov    %eax,0x18(%edi)
40008121:	19 d2                	sbb    %edx,%edx
40008123:	83 c2 02             	add    $0x2,%edx
40008126:	85 f6                	test   %esi,%esi
40008128:	89 57 10             	mov    %edx,0x10(%edi)
4000812b:	75 59                	jne    40008186 <__d2b+0xd6>
4000812d:	8b 4d 14             	mov    0x14(%ebp),%ecx
40008130:	8d 83 ce fb ff ff    	lea    -0x432(%ebx),%eax
40008136:	89 d3                	mov    %edx,%ebx
40008138:	c1 e3 05             	shl    $0x5,%ebx
4000813b:	89 01                	mov    %eax,(%ecx)
4000813d:	8b 4c 97 10          	mov    0x10(%edi,%edx,4),%ecx
40008141:	51                   	push   %ecx
40008142:	e8 09 fa ff ff       	call   40007b50 <__hi0bits>
40008147:	29 c3                	sub    %eax,%ebx
40008149:	8b 45 18             	mov    0x18(%ebp),%eax
4000814c:	5a                   	pop    %edx
4000814d:	89 18                	mov    %ebx,(%eax)
4000814f:	8d 65 f4             	lea    -0xc(%ebp),%esp
40008152:	89 f8                	mov    %edi,%eax
40008154:	5b                   	pop    %ebx
40008155:	5e                   	pop    %esi
40008156:	5f                   	pop    %edi
40008157:	5d                   	pop    %ebp
40008158:	c3                   	ret    
40008159:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40008160:	8d 45 ec             	lea    -0x14(%ebp),%eax
40008163:	50                   	push   %eax
40008164:	e8 47 fa ff ff       	call   40007bb0 <__lo0bits>
40008169:	8b 55 ec             	mov    -0x14(%ebp),%edx
4000816c:	c7 47 10 01 00 00 00 	movl   $0x1,0x10(%edi)
40008173:	89 57 14             	mov    %edx,0x14(%edi)
40008176:	8b 75 e0             	mov    -0x20(%ebp),%esi
40008179:	8d 58 20             	lea    0x20(%eax),%ebx
4000817c:	ba 01 00 00 00       	mov    $0x1,%edx
40008181:	58                   	pop    %eax
40008182:	85 f6                	test   %esi,%esi
40008184:	74 a7                	je     4000812d <__d2b+0x7d>
40008186:	8b 55 e0             	mov    -0x20(%ebp),%edx
40008189:	8b 4d 14             	mov    0x14(%ebp),%ecx
4000818c:	8d 84 13 cd fb ff ff 	lea    -0x433(%ebx,%edx,1),%eax
40008193:	8b 55 18             	mov    0x18(%ebp),%edx
40008196:	89 01                	mov    %eax,(%ecx)
40008198:	b8 35 00 00 00       	mov    $0x35,%eax
4000819d:	29 d8                	sub    %ebx,%eax
4000819f:	89 02                	mov    %eax,(%edx)
400081a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
400081a4:	89 f8                	mov    %edi,%eax
400081a6:	5b                   	pop    %ebx
400081a7:	5e                   	pop    %esi
400081a8:	5f                   	pop    %edi
400081a9:	5d                   	pop    %ebp
400081aa:	c3                   	ret    
400081ab:	90                   	nop    
400081ac:	8d 74 26 00          	lea    0x0(%esi),%esi
400081b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
400081b3:	b9 20 00 00 00       	mov    $0x20,%ecx
400081b8:	29 d9                	sub    %ebx,%ecx
400081ba:	89 c2                	mov    %eax,%edx
400081bc:	d3 e2                	shl    %cl,%edx
400081be:	89 d1                	mov    %edx,%ecx
400081c0:	8b 55 f0             	mov    -0x10(%ebp),%edx
400081c3:	09 d1                	or     %edx,%ecx
400081c5:	89 4f 14             	mov    %ecx,0x14(%edi)
400081c8:	88 d9                	mov    %bl,%cl
400081ca:	d3 e8                	shr    %cl,%eax
400081cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
400081cf:	e9 41 ff ff ff       	jmp    40008115 <__d2b+0x65>
400081d4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
400081da:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

400081e0 <__mdiff>:
400081e0:	55                   	push   %ebp
400081e1:	89 e5                	mov    %esp,%ebp
400081e3:	57                   	push   %edi
400081e4:	56                   	push   %esi
400081e5:	53                   	push   %ebx
400081e6:	83 ec 1c             	sub    $0x1c,%esp
400081e9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
400081ec:	8b 75 10             	mov    0x10(%ebp),%esi
400081ef:	56                   	push   %esi
400081f0:	53                   	push   %ebx
400081f1:	e8 4a fa ff ff       	call   40007c40 <__mcmp>
400081f6:	5a                   	pop    %edx
400081f7:	83 f8 00             	cmp    $0x0,%eax
400081fa:	59                   	pop    %ecx
400081fb:	0f 84 04 01 00 00    	je     40008305 <__mdiff+0x125>
40008201:	0f 8c 2a 01 00 00    	jl     40008331 <__mdiff+0x151>
40008207:	31 ff                	xor    %edi,%edi
40008209:	50                   	push   %eax
4000820a:	50                   	push   %eax
4000820b:	8b 43 04             	mov    0x4(%ebx),%eax
4000820e:	50                   	push   %eax
4000820f:	8b 4d 08             	mov    0x8(%ebp),%ecx
40008212:	51                   	push   %ecx
40008213:	e8 08 fe ff ff       	call   40008020 <_Balloc>
40008218:	89 45 dc             	mov    %eax,-0x24(%ebp)
4000821b:	8d 56 14             	lea    0x14(%esi),%edx
4000821e:	89 78 0c             	mov    %edi,0xc(%eax)
40008221:	8b 43 10             	mov    0x10(%ebx),%eax
40008224:	89 45 e0             	mov    %eax,-0x20(%ebp)
40008227:	8d 7b 14             	lea    0x14(%ebx),%edi
4000822a:	8d 5c 83 14          	lea    0x14(%ebx,%eax,4),%ebx
4000822e:	8b 46 10             	mov    0x10(%esi),%eax
40008231:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
40008234:	89 55 e8             	mov    %edx,-0x18(%ebp)
40008237:	8d 44 86 14          	lea    0x14(%esi,%eax,4),%eax
4000823b:	8b 75 dc             	mov    -0x24(%ebp),%esi
4000823e:	89 45 ec             	mov    %eax,-0x14(%ebp)
40008241:	83 c6 14             	add    $0x14,%esi
40008244:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4000824b:	83 c4 10             	add    $0x10,%esp
4000824e:	66 90                	xchg   %ax,%ax
40008250:	8b 55 e8             	mov    -0x18(%ebp),%edx
40008253:	8b 07                	mov    (%edi),%eax
40008255:	0f b7 d8             	movzwl %ax,%ebx
40008258:	8b 0a                	mov    (%edx),%ecx
4000825a:	83 c7 04             	add    $0x4,%edi
4000825d:	0f b7 d1             	movzwl %cx,%edx
40008260:	c1 e8 10             	shr    $0x10,%eax
40008263:	29 d3                	sub    %edx,%ebx
40008265:	c1 e9 10             	shr    $0x10,%ecx
40008268:	8b 55 f0             	mov    -0x10(%ebp),%edx
4000826b:	01 d3                	add    %edx,%ebx
4000826d:	29 c8                	sub    %ecx,%eax
4000826f:	89 da                	mov    %ebx,%edx
40008271:	8b 4d e8             	mov    -0x18(%ebp),%ecx
40008274:	c1 fa 10             	sar    $0x10,%edx
40008277:	83 c1 04             	add    $0x4,%ecx
4000827a:	01 d0                	add    %edx,%eax
4000827c:	89 4d e8             	mov    %ecx,-0x18(%ebp)
4000827f:	89 c2                	mov    %eax,%edx
40008281:	66 89 46 02          	mov    %ax,0x2(%esi)
40008285:	c1 fa 10             	sar    $0x10,%edx
40008288:	8b 45 e8             	mov    -0x18(%ebp),%eax
4000828b:	66 89 1e             	mov    %bx,(%esi)
4000828e:	89 55 f0             	mov    %edx,-0x10(%ebp)
40008291:	83 c6 04             	add    $0x4,%esi
40008294:	39 45 ec             	cmp    %eax,-0x14(%ebp)
40008297:	77 b7                	ja     40008250 <__mdiff+0x70>
40008299:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
4000829c:	73 30                	jae    400082ce <__mdiff+0xee>
4000829e:	66 90                	xchg   %ax,%ax
400082a0:	8b 07                	mov    (%edi),%eax
400082a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
400082a5:	0f b7 c8             	movzwl %ax,%ecx
400082a8:	01 d1                	add    %edx,%ecx
400082aa:	83 c7 04             	add    $0x4,%edi
400082ad:	89 ca                	mov    %ecx,%edx
400082af:	66 89 0e             	mov    %cx,(%esi)
400082b2:	c1 e8 10             	shr    $0x10,%eax
400082b5:	c1 fa 10             	sar    $0x10,%edx
400082b8:	01 c2                	add    %eax,%edx
400082ba:	89 d0                	mov    %edx,%eax
400082bc:	66 89 56 02          	mov    %dx,0x2(%esi)
400082c0:	c1 f8 10             	sar    $0x10,%eax
400082c3:	83 c6 04             	add    $0x4,%esi
400082c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
400082c9:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
400082cc:	77 d2                	ja     400082a0 <__mdiff+0xc0>
400082ce:	8b 46 fc             	mov    -0x4(%esi),%eax
400082d1:	85 c0                	test   %eax,%eax
400082d3:	75 1c                	jne    400082f1 <__mdiff+0x111>
400082d5:	89 f2                	mov    %esi,%edx
400082d7:	89 f6                	mov    %esi,%esi
400082d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
400082e0:	8b 45 e0             	mov    -0x20(%ebp),%eax
400082e3:	48                   	dec    %eax
400082e4:	89 45 e0             	mov    %eax,-0x20(%ebp)
400082e7:	8b 42 f8             	mov    -0x8(%edx),%eax
400082ea:	83 ea 04             	sub    $0x4,%edx
400082ed:	85 c0                	test   %eax,%eax
400082ef:	74 ef                	je     400082e0 <__mdiff+0x100>
400082f1:	8b 45 dc             	mov    -0x24(%ebp),%eax
400082f4:	8b 55 e0             	mov    -0x20(%ebp),%edx
400082f7:	89 50 10             	mov    %edx,0x10(%eax)
400082fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
400082fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
40008300:	5b                   	pop    %ebx
40008301:	5e                   	pop    %esi
40008302:	5f                   	pop    %edi
40008303:	5d                   	pop    %ebp
40008304:	c3                   	ret    
40008305:	50                   	push   %eax
40008306:	50                   	push   %eax
40008307:	6a 00                	push   $0x0
40008309:	8b 45 08             	mov    0x8(%ebp),%eax
4000830c:	50                   	push   %eax
4000830d:	e8 0e fd ff ff       	call   40008020 <_Balloc>
40008312:	89 45 dc             	mov    %eax,-0x24(%ebp)
40008315:	83 c4 10             	add    $0x10,%esp
40008318:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
4000831f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
40008326:	8b 45 dc             	mov    -0x24(%ebp),%eax
40008329:	8d 65 f4             	lea    -0xc(%ebp),%esp
4000832c:	5b                   	pop    %ebx
4000832d:	5e                   	pop    %esi
4000832e:	5f                   	pop    %edi
4000832f:	5d                   	pop    %ebp
40008330:	c3                   	ret    
40008331:	89 f0                	mov    %esi,%eax
40008333:	bf 01 00 00 00       	mov    $0x1,%edi
40008338:	89 de                	mov    %ebx,%esi
4000833a:	89 c3                	mov    %eax,%ebx
4000833c:	e9 c8 fe ff ff       	jmp    40008209 <__mdiff+0x29>
40008341:	eb 0d                	jmp    40008350 <__lshift>
40008343:	90                   	nop    
40008344:	90                   	nop    
40008345:	90                   	nop    
40008346:	90                   	nop    
40008347:	90                   	nop    
40008348:	90                   	nop    
40008349:	90                   	nop    
4000834a:	90                   	nop    
4000834b:	90                   	nop    
4000834c:	90                   	nop    
4000834d:	90                   	nop    
4000834e:	90                   	nop    
4000834f:	90                   	nop    

40008350 <__lshift>:
40008350:	55                   	push   %ebp
40008351:	89 e5                	mov    %esp,%ebp
40008353:	57                   	push   %edi
40008354:	56                   	push   %esi
40008355:	53                   	push   %ebx
40008356:	83 ec 1c             	sub    $0x1c,%esp
40008359:	8b 45 0c             	mov    0xc(%ebp),%eax
4000835c:	8b 5d 10             	mov    0x10(%ebp),%ebx
4000835f:	c1 fb 05             	sar    $0x5,%ebx
40008362:	89 c1                	mov    %eax,%ecx
40008364:	8b 50 04             	mov    0x4(%eax),%edx
40008367:	8b 40 10             	mov    0x10(%eax),%eax
4000836a:	40                   	inc    %eax
4000836b:	8d 34 18             	lea    (%eax,%ebx,1),%esi
4000836e:	8b 41 08             	mov    0x8(%ecx),%eax
40008371:	39 c6                	cmp    %eax,%esi
40008373:	7e 12                	jle    40008387 <__lshift+0x37>
40008375:	8d 74 26 00          	lea    0x0(%esi),%esi
40008379:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40008380:	01 c0                	add    %eax,%eax
40008382:	42                   	inc    %edx
40008383:	39 c6                	cmp    %eax,%esi
40008385:	7f f9                	jg     40008380 <__lshift+0x30>
40008387:	8b 7d 08             	mov    0x8(%ebp),%edi
4000838a:	50                   	push   %eax
4000838b:	50                   	push   %eax
4000838c:	52                   	push   %edx
4000838d:	57                   	push   %edi
4000838e:	e8 8d fc ff ff       	call   40008020 <_Balloc>
40008393:	89 45 e8             	mov    %eax,-0x18(%ebp)
40008396:	83 c0 14             	add    $0x14,%eax
40008399:	83 c4 10             	add    $0x10,%esp
4000839c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000839f:	85 db                	test   %ebx,%ebx
400083a1:	7e 2b                	jle    400083ce <__lshift+0x7e>
400083a3:	31 c0                	xor    %eax,%eax
400083a5:	8d 74 26 00          	lea    0x0(%esi),%esi
400083a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
400083b0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
400083b3:	40                   	inc    %eax
400083b4:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
400083ba:	83 c2 04             	add    $0x4,%edx
400083bd:	89 55 e4             	mov    %edx,-0x1c(%ebp)
400083c0:	39 d8                	cmp    %ebx,%eax
400083c2:	75 ec                	jne    400083b0 <__lshift+0x60>
400083c4:	8b 4d e8             	mov    -0x18(%ebp),%ecx
400083c7:	8d 5c 99 14          	lea    0x14(%ecx,%ebx,4),%ebx
400083cb:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
400083ce:	8b 5d 0c             	mov    0xc(%ebp),%ebx
400083d1:	8b 55 0c             	mov    0xc(%ebp),%edx
400083d4:	83 c2 14             	add    $0x14,%edx
400083d7:	8b 43 10             	mov    0x10(%ebx),%eax
400083da:	8d 7c 83 14          	lea    0x14(%ebx,%eax,4),%edi
400083de:	8b 45 10             	mov    0x10(%ebp),%eax
400083e1:	83 e0 1f             	and    $0x1f,%eax
400083e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
400083e7:	74 67                	je     40008450 <__lshift+0x100>
400083e9:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
400083f0:	31 db                	xor    %ebx,%ebx
400083f2:	8b 4d ec             	mov    -0x14(%ebp),%ecx
400083f5:	29 c1                	sub    %eax,%ecx
400083f7:	89 4d ec             	mov    %ecx,-0x14(%ebp)
400083fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40008400:	8b 02                	mov    (%edx),%eax
40008402:	8a 4d f0             	mov    -0x10(%ebp),%cl
40008405:	d3 e0                	shl    %cl,%eax
40008407:	09 c3                	or     %eax,%ebx
40008409:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000840c:	8a 4d ec             	mov    -0x14(%ebp),%cl
4000840f:	89 18                	mov    %ebx,(%eax)
40008411:	83 c0 04             	add    $0x4,%eax
40008414:	8b 1a                	mov    (%edx),%ebx
40008416:	83 c2 04             	add    $0x4,%edx
40008419:	d3 eb                	shr    %cl,%ebx
4000841b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000841e:	39 d7                	cmp    %edx,%edi
40008420:	77 de                	ja     40008400 <__lshift+0xb0>
40008422:	89 18                	mov    %ebx,(%eax)
40008424:	85 db                	test   %ebx,%ebx
40008426:	74 01                	je     40008429 <__lshift+0xd9>
40008428:	46                   	inc    %esi
40008429:	8b 55 e8             	mov    -0x18(%ebp),%edx
4000842c:	8d 46 ff             	lea    -0x1(%esi),%eax
4000842f:	8b 5d 08             	mov    0x8(%ebp),%ebx
40008432:	8b 75 0c             	mov    0xc(%ebp),%esi
40008435:	89 42 10             	mov    %eax,0x10(%edx)
40008438:	56                   	push   %esi
40008439:	53                   	push   %ebx
4000843a:	e8 f1 f6 ff ff       	call   40007b30 <_Bfree>
4000843f:	8b 45 e8             	mov    -0x18(%ebp),%eax
40008442:	8d 65 f4             	lea    -0xc(%ebp),%esp
40008445:	5b                   	pop    %ebx
40008446:	5e                   	pop    %esi
40008447:	5f                   	pop    %edi
40008448:	5d                   	pop    %ebp
40008449:	c3                   	ret    
4000844a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40008450:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
40008453:	8b 02                	mov    (%edx),%eax
40008455:	83 c2 04             	add    $0x4,%edx
40008458:	89 03                	mov    %eax,(%ebx)
4000845a:	83 c3 04             	add    $0x4,%ebx
4000845d:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
40008460:	39 d7                	cmp    %edx,%edi
40008462:	77 ec                	ja     40008450 <__lshift+0x100>
40008464:	eb c3                	jmp    40008429 <__lshift+0xd9>
40008466:	8d 76 00             	lea    0x0(%esi),%esi
40008469:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40008470 <__multiply>:
40008470:	55                   	push   %ebp
40008471:	89 e5                	mov    %esp,%ebp
40008473:	57                   	push   %edi
40008474:	56                   	push   %esi
40008475:	53                   	push   %ebx
40008476:	83 ec 2c             	sub    $0x2c,%esp
40008479:	8b 5d 0c             	mov    0xc(%ebp),%ebx
4000847c:	8b 45 10             	mov    0x10(%ebp),%eax
4000847f:	8b 73 10             	mov    0x10(%ebx),%esi
40008482:	8b 78 10             	mov    0x10(%eax),%edi
40008485:	39 fe                	cmp    %edi,%esi
40008487:	7d 0b                	jge    40008494 <__multiply+0x24>
40008489:	89 5d 10             	mov    %ebx,0x10(%ebp)
4000848c:	89 c3                	mov    %eax,%ebx
4000848e:	89 f8                	mov    %edi,%eax
40008490:	89 f7                	mov    %esi,%edi
40008492:	89 c6                	mov    %eax,%esi
40008494:	8d 14 37             	lea    (%edi,%esi,1),%edx
40008497:	8b 4b 04             	mov    0x4(%ebx),%ecx
4000849a:	3b 53 08             	cmp    0x8(%ebx),%edx
4000849d:	89 55 d0             	mov    %edx,-0x30(%ebp)
400084a0:	0f 9f c0             	setg   %al
400084a3:	25 ff 00 00 00       	and    $0xff,%eax
400084a8:	52                   	push   %edx
400084a9:	01 c8                	add    %ecx,%eax
400084ab:	8b 4d 08             	mov    0x8(%ebp),%ecx
400084ae:	52                   	push   %edx
400084af:	50                   	push   %eax
400084b0:	51                   	push   %ecx
400084b1:	e8 6a fb ff ff       	call   40008020 <_Balloc>
400084b6:	8b 4d d0             	mov    -0x30(%ebp),%ecx
400084b9:	89 c2                	mov    %eax,%edx
400084bb:	83 c2 14             	add    $0x14,%edx
400084be:	83 c4 10             	add    $0x10,%esp
400084c1:	8d 4c 88 14          	lea    0x14(%eax,%ecx,4),%ecx
400084c5:	89 45 cc             	mov    %eax,-0x34(%ebp)
400084c8:	89 4d dc             	mov    %ecx,-0x24(%ebp)
400084cb:	39 ca                	cmp    %ecx,%edx
400084cd:	73 1f                	jae    400084ee <__multiply+0x7e>
400084cf:	89 d0                	mov    %edx,%eax
400084d1:	eb 0d                	jmp    400084e0 <__multiply+0x70>
400084d3:	90                   	nop    
400084d4:	90                   	nop    
400084d5:	90                   	nop    
400084d6:	90                   	nop    
400084d7:	90                   	nop    
400084d8:	90                   	nop    
400084d9:	90                   	nop    
400084da:	90                   	nop    
400084db:	90                   	nop    
400084dc:	90                   	nop    
400084dd:	90                   	nop    
400084de:	90                   	nop    
400084df:	90                   	nop    
400084e0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
400084e6:	83 c0 04             	add    $0x4,%eax
400084e9:	39 45 dc             	cmp    %eax,-0x24(%ebp)
400084ec:	77 f2                	ja     400084e0 <__multiply+0x70>
400084ee:	8b 4d 10             	mov    0x10(%ebp),%ecx
400084f1:	8b 45 10             	mov    0x10(%ebp),%eax
400084f4:	83 c0 14             	add    $0x14,%eax
400084f7:	8d 74 b3 14          	lea    0x14(%ebx,%esi,4),%esi
400084fb:	8d 7c b9 14          	lea    0x14(%ecx,%edi,4),%edi
400084ff:	89 75 e0             	mov    %esi,-0x20(%ebp)
40008502:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40008505:	89 7d e8             	mov    %edi,-0x18(%ebp)
40008508:	39 f8                	cmp    %edi,%eax
4000850a:	0f 83 fe 00 00 00    	jae    4000860e <__multiply+0x19e>
40008510:	83 c3 14             	add    $0x14,%ebx
40008513:	89 55 ec             	mov    %edx,-0x14(%ebp)
40008516:	89 5d c8             	mov    %ebx,-0x38(%ebp)
40008519:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40008520:	8b 55 e4             	mov    -0x1c(%ebp),%edx
40008523:	8b 02                	mov    (%edx),%eax
40008525:	89 c1                	mov    %eax,%ecx
40008527:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
4000852d:	89 4d d8             	mov    %ecx,-0x28(%ebp)
40008530:	74 5b                	je     4000858d <__multiply+0x11d>
40008532:	8b 7d c8             	mov    -0x38(%ebp),%edi
40008535:	8b 75 ec             	mov    -0x14(%ebp),%esi
40008538:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
4000853f:	90                   	nop    
40008540:	8b 07                	mov    (%edi),%eax
40008542:	8b 55 d8             	mov    -0x28(%ebp),%edx
40008545:	0f b7 c8             	movzwl %ax,%ecx
40008548:	0f af ca             	imul   %edx,%ecx
4000854b:	8b 1e                	mov    (%esi),%ebx
4000854d:	83 c7 04             	add    $0x4,%edi
40008550:	0f b7 d3             	movzwl %bx,%edx
40008553:	c1 e8 10             	shr    $0x10,%eax
40008556:	01 d1                	add    %edx,%ecx
40008558:	c1 eb 10             	shr    $0x10,%ebx
4000855b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
4000855e:	01 d1                	add    %edx,%ecx
40008560:	8b 55 d8             	mov    -0x28(%ebp),%edx
40008563:	0f af c2             	imul   %edx,%eax
40008566:	89 ca                	mov    %ecx,%edx
40008568:	01 d8                	add    %ebx,%eax
4000856a:	c1 ea 10             	shr    $0x10,%edx
4000856d:	66 89 0e             	mov    %cx,(%esi)
40008570:	01 d0                	add    %edx,%eax
40008572:	89 c2                	mov    %eax,%edx
40008574:	66 89 46 02          	mov    %ax,0x2(%esi)
40008578:	c1 ea 10             	shr    $0x10,%edx
4000857b:	83 c6 04             	add    $0x4,%esi
4000857e:	89 55 d4             	mov    %edx,-0x2c(%ebp)
40008581:	39 7d e0             	cmp    %edi,-0x20(%ebp)
40008584:	77 ba                	ja     40008540 <__multiply+0xd0>
40008586:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40008589:	89 16                	mov    %edx,(%esi)
4000858b:	8b 01                	mov    (%ecx),%eax
4000858d:	c1 e8 10             	shr    $0x10,%eax
40008590:	89 45 f0             	mov    %eax,-0x10(%ebp)
40008593:	74 5a                	je     400085ef <__multiply+0x17f>
40008595:	8b 45 ec             	mov    -0x14(%ebp),%eax
40008598:	8b 7d c8             	mov    -0x38(%ebp),%edi
4000859b:	89 c6                	mov    %eax,%esi
4000859d:	31 c9                	xor    %ecx,%ecx
4000859f:	8b 18                	mov    (%eax),%ebx
400085a1:	89 da                	mov    %ebx,%edx
400085a3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
400085a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
400085b0:	0f b7 07             	movzwl (%edi),%eax
400085b3:	0f af 45 f0          	imul   -0x10(%ebp),%eax
400085b7:	c1 eb 10             	shr    $0x10,%ebx
400085ba:	66 89 16             	mov    %dx,(%esi)
400085bd:	8b 17                	mov    (%edi),%edx
400085bf:	8d 04 01             	lea    (%ecx,%eax,1),%eax
400085c2:	c1 ea 10             	shr    $0x10,%edx
400085c5:	8b 4d f0             	mov    -0x10(%ebp),%ecx
400085c8:	0f af d1             	imul   %ecx,%edx
400085cb:	01 d8                	add    %ebx,%eax
400085cd:	83 c7 04             	add    $0x4,%edi
400085d0:	66 89 46 02          	mov    %ax,0x2(%esi)
400085d4:	83 c6 04             	add    $0x4,%esi
400085d7:	c1 e8 10             	shr    $0x10,%eax
400085da:	8b 1e                	mov    (%esi),%ebx
400085dc:	0f b7 cb             	movzwl %bx,%ecx
400085df:	01 ca                	add    %ecx,%edx
400085e1:	01 c2                	add    %eax,%edx
400085e3:	89 d1                	mov    %edx,%ecx
400085e5:	c1 e9 10             	shr    $0x10,%ecx
400085e8:	39 7d e0             	cmp    %edi,-0x20(%ebp)
400085eb:	77 c3                	ja     400085b0 <__multiply+0x140>
400085ed:	89 16                	mov    %edx,(%esi)
400085ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400085f2:	83 c0 04             	add    $0x4,%eax
400085f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400085f8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
400085fb:	39 55 e8             	cmp    %edx,-0x18(%ebp)
400085fe:	76 0e                	jbe    4000860e <__multiply+0x19e>
40008600:	8b 45 ec             	mov    -0x14(%ebp),%eax
40008603:	83 c0 04             	add    $0x4,%eax
40008606:	89 45 ec             	mov    %eax,-0x14(%ebp)
40008609:	e9 12 ff ff ff       	jmp    40008520 <__multiply+0xb0>
4000860e:	8b 45 d0             	mov    -0x30(%ebp),%eax
40008611:	85 c0                	test   %eax,%eax
40008613:	7e 2a                	jle    4000863f <__multiply+0x1cf>
40008615:	8b 4d dc             	mov    -0x24(%ebp),%ecx
40008618:	8b 41 fc             	mov    -0x4(%ecx),%eax
4000861b:	85 c0                	test   %eax,%eax
4000861d:	75 20                	jne    4000863f <__multiply+0x1cf>
4000861f:	89 ca                	mov    %ecx,%edx
40008621:	eb 17                	jmp    4000863a <__multiply+0x1ca>
40008623:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40008629:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40008630:	8b 42 f8             	mov    -0x8(%edx),%eax
40008633:	83 ea 04             	sub    $0x4,%edx
40008636:	85 c0                	test   %eax,%eax
40008638:	75 05                	jne    4000863f <__multiply+0x1cf>
4000863a:	ff 4d d0             	decl   -0x30(%ebp)
4000863d:	75 f1                	jne    40008630 <__multiply+0x1c0>
4000863f:	8b 55 cc             	mov    -0x34(%ebp),%edx
40008642:	8b 45 d0             	mov    -0x30(%ebp),%eax
40008645:	89 42 10             	mov    %eax,0x10(%edx)
40008648:	8d 65 f4             	lea    -0xc(%ebp),%esp
4000864b:	89 d0                	mov    %edx,%eax
4000864d:	5b                   	pop    %ebx
4000864e:	5e                   	pop    %esi
4000864f:	5f                   	pop    %edi
40008650:	5d                   	pop    %ebp
40008651:	c3                   	ret    
40008652:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40008659:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40008660 <__i2b>:
40008660:	55                   	push   %ebp
40008661:	89 e5                	mov    %esp,%ebp
40008663:	83 ec 10             	sub    $0x10,%esp
40008666:	8b 45 08             	mov    0x8(%ebp),%eax
40008669:	6a 01                	push   $0x1
4000866b:	50                   	push   %eax
4000866c:	e8 af f9 ff ff       	call   40008020 <_Balloc>
40008671:	8b 55 0c             	mov    0xc(%ebp),%edx
40008674:	89 50 14             	mov    %edx,0x14(%eax)
40008677:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
4000867e:	c9                   	leave  
4000867f:	c3                   	ret    

40008680 <__multadd>:
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
    {
      t = (*fp->_write) (fp->_cookie, (char *) p, n);
40008680:	55                   	push   %ebp
40008681:	89 e5                	mov    %esp,%ebp
40008683:	57                   	push   %edi
40008684:	56                   	push   %esi
40008685:	53                   	push   %ebx
40008686:	83 ec 0c             	sub    $0xc,%esp
          _funlockfile (fp);
          return EOF;
	}
      p += t;
      n -= t;
    }
40008689:	31 f6                	xor    %esi,%esi
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
	}
      p += t;
      n -= t;
4000868b:	8b 45 0c             	mov    0xc(%ebp),%eax
    }
4000868e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
40008691:	83 c3 14             	add    $0x14,%ebx
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
	}
      p += t;
      n -= t;
40008694:	8b 40 10             	mov    0x10(%eax),%eax
40008697:	89 45 f0             	mov    %eax,-0x10(%ebp)
4000869a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    }
  _funlockfile (fp);
  return 0;
}
400086a0:	8b 0b                	mov    (%ebx),%ecx
400086a2:	8b 45 10             	mov    0x10(%ebp),%eax
400086a5:	0f b7 d1             	movzwl %cx,%edx
400086a8:	0f af d0             	imul   %eax,%edx
400086ab:	c1 e9 10             	shr    $0x10,%ecx
400086ae:	8b 7d 10             	mov    0x10(%ebp),%edi
400086b1:	0f af cf             	imul   %edi,%ecx
  _funlockfile (fp);
  return 0;
}
400086b4:	8b 45 14             	mov    0x14(%ebp),%eax
400086b7:	46                   	inc    %esi
  _funlockfile (fp);
  return 0;
}
400086b8:	01 c2                	add    %eax,%edx
400086ba:	89 d0                	mov    %edx,%eax
400086bc:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  return 0;
}
400086c2:	c1 e8 10             	shr    $0x10,%eax
400086c5:	01 c8                	add    %ecx,%eax
400086c7:	89 c7                	mov    %eax,%edi
400086c9:	c1 e0 10             	shl    $0x10,%eax
}
400086cc:	c1 ef 10             	shr    $0x10,%edi
400086cf:	01 d0                	add    %edx,%eax
400086d1:	89 03                	mov    %eax,(%ebx)
}
400086d3:	89 7d 14             	mov    %edi,0x14(%ebp)
400086d6:	83 c3 04             	add    $0x4,%ebx
400086d9:	39 75 f0             	cmp    %esi,-0x10(%ebp)
400086dc:	7f c2                	jg     400086a0 <__multadd+0x20>
400086de:	85 ff                	test   %edi,%edi
400086e0:	74 19                	je     400086fb <__multadd+0x7b>
400086e2:	8b 45 0c             	mov    0xc(%ebp),%eax
400086e5:	8b 55 f0             	mov    -0x10(%ebp),%edx
400086e8:	3b 50 08             	cmp    0x8(%eax),%edx
400086eb:	7d 19                	jge    40008706 <__multadd+0x86>
400086ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
400086f0:	8b 55 0c             	mov    0xc(%ebp),%edx
400086f3:	89 7c 82 14          	mov    %edi,0x14(%edx,%eax,4)
400086f7:	40                   	inc    %eax
400086f8:	89 42 10             	mov    %eax,0x10(%edx)
400086fb:	8b 45 0c             	mov    0xc(%ebp),%eax
400086fe:	8d 65 f4             	lea    -0xc(%ebp),%esp
40008701:	5b                   	pop    %ebx
40008702:	5e                   	pop    %esi
40008703:	5f                   	pop    %edi
40008704:	5d                   	pop    %ebp
40008705:	c3                   	ret    
40008706:	52                   	push   %edx
40008707:	52                   	push   %edx
40008708:	8b 40 04             	mov    0x4(%eax),%eax
4000870b:	40                   	inc    %eax
4000870c:	50                   	push   %eax
4000870d:	8b 45 08             	mov    0x8(%ebp),%eax
40008710:	50                   	push   %eax
40008711:	e8 0a f9 ff ff       	call   40008020 <_Balloc>
40008716:	8b 55 0c             	mov    0xc(%ebp),%edx
40008719:	89 c3                	mov    %eax,%ebx
4000871b:	83 c4 0c             	add    $0xc,%esp
4000871e:	8b 42 10             	mov    0x10(%edx),%eax
40008721:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
40008728:	50                   	push   %eax
40008729:	89 d0                	mov    %edx,%eax
4000872b:	83 c0 0c             	add    $0xc,%eax
4000872e:	50                   	push   %eax
4000872f:	8d 43 0c             	lea    0xc(%ebx),%eax
40008732:	50                   	push   %eax
40008733:	e8 18 f3 ff ff       	call   40007a50 <memcpy>
40008738:	8b 45 0c             	mov    0xc(%ebp),%eax
4000873b:	50                   	push   %eax
4000873c:	8b 45 08             	mov    0x8(%ebp),%eax
4000873f:	50                   	push   %eax
40008740:	e8 eb f3 ff ff       	call   40007b30 <_Bfree>
40008745:	83 c4 18             	add    $0x18,%esp
40008748:	89 5d 0c             	mov    %ebx,0xc(%ebp)
4000874b:	eb a0                	jmp    400086ed <__multadd+0x6d>
4000874d:	8d 76 00             	lea    0x0(%esi),%esi

40008750 <__pow5mult>:
40008750:	55                   	push   %ebp
40008751:	89 e5                	mov    %esp,%ebp
40008753:	57                   	push   %edi
40008754:	56                   	push   %esi
40008755:	53                   	push   %ebx
40008756:	83 ec 0c             	sub    $0xc,%esp
40008759:	8b 5d 10             	mov    0x10(%ebp),%ebx
4000875c:	89 d8                	mov    %ebx,%eax
4000875e:	83 e0 03             	and    $0x3,%eax
40008761:	0f 85 8f 00 00 00    	jne    400087f6 <__pow5mult+0xa6>
40008767:	89 df                	mov    %ebx,%edi
40008769:	c1 ff 02             	sar    $0x2,%edi
4000876c:	74 62                	je     400087d0 <__pow5mult+0x80>
4000876e:	8b 45 08             	mov    0x8(%ebp),%eax
40008771:	8b 70 48             	mov    0x48(%eax),%esi
40008774:	85 f6                	test   %esi,%esi
40008776:	0f 84 9c 00 00 00    	je     40008818 <__pow5mult+0xc8>
4000877c:	f7 c7 01 00 00 00    	test   $0x1,%edi
40008782:	75 20                	jne    400087a4 <__pow5mult+0x54>
40008784:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000878a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
40008790:	d1 ff                	sar    %edi
40008792:	74 3c                	je     400087d0 <__pow5mult+0x80>
40008794:	8b 06                	mov    (%esi),%eax
40008796:	85 c0                	test   %eax,%eax
40008798:	74 41                	je     400087db <__pow5mult+0x8b>
4000879a:	89 c6                	mov    %eax,%esi
4000879c:	f7 c7 01 00 00 00    	test   $0x1,%edi
400087a2:	74 ec                	je     40008790 <__pow5mult+0x40>
400087a4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
400087a7:	8b 55 08             	mov    0x8(%ebp),%edx
400087aa:	53                   	push   %ebx
400087ab:	56                   	push   %esi
400087ac:	51                   	push   %ecx
400087ad:	52                   	push   %edx
400087ae:	e8 bd fc ff ff       	call   40008470 <__multiply>
400087b3:	89 c3                	mov    %eax,%ebx
400087b5:	8b 45 0c             	mov    0xc(%ebp),%eax
400087b8:	50                   	push   %eax
400087b9:	8b 45 08             	mov    0x8(%ebp),%eax
400087bc:	50                   	push   %eax
400087bd:	e8 6e f3 ff ff       	call   40007b30 <_Bfree>
400087c2:	83 c4 18             	add    $0x18,%esp
400087c5:	89 5d 0c             	mov    %ebx,0xc(%ebp)
400087c8:	d1 ff                	sar    %edi
400087ca:	75 c8                	jne    40008794 <__pow5mult+0x44>
400087cc:	8d 74 26 00          	lea    0x0(%esi),%esi
400087d0:	8b 45 0c             	mov    0xc(%ebp),%eax
400087d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
400087d6:	5b                   	pop    %ebx
400087d7:	5e                   	pop    %esi
400087d8:	5f                   	pop    %edi
400087d9:	5d                   	pop    %ebp
400087da:	c3                   	ret    
400087db:	50                   	push   %eax
400087dc:	8b 45 08             	mov    0x8(%ebp),%eax
400087df:	56                   	push   %esi
400087e0:	56                   	push   %esi
400087e1:	50                   	push   %eax
400087e2:	e8 89 fc ff ff       	call   40008470 <__multiply>
400087e7:	83 c4 10             	add    $0x10,%esp
400087ea:	89 06                	mov    %eax,(%esi)
400087ec:	89 c6                	mov    %eax,%esi
400087ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
400087f4:	eb a6                	jmp    4000879c <__pow5mult+0x4c>
400087f6:	8b 04 85 64 c7 00 40 	mov    0x4000c764(,%eax,4),%eax
400087fd:	6a 00                	push   $0x0
400087ff:	8b 7d 08             	mov    0x8(%ebp),%edi
40008802:	50                   	push   %eax
40008803:	8b 45 0c             	mov    0xc(%ebp),%eax
40008806:	50                   	push   %eax
40008807:	57                   	push   %edi
40008808:	e8 73 fe ff ff       	call   40008680 <__multadd>
4000880d:	83 c4 10             	add    $0x10,%esp
40008810:	89 45 0c             	mov    %eax,0xc(%ebp)
40008813:	e9 4f ff ff ff       	jmp    40008767 <__pow5mult+0x17>
40008818:	56                   	push   %esi
40008819:	56                   	push   %esi
4000881a:	68 71 02 00 00       	push   $0x271
4000881f:	50                   	push   %eax
40008820:	e8 3b fe ff ff       	call   40008660 <__i2b>
40008825:	83 c4 10             	add    $0x10,%esp
40008828:	89 c6                	mov    %eax,%esi
4000882a:	8b 45 08             	mov    0x8(%ebp),%eax
4000882d:	89 70 48             	mov    %esi,0x48(%eax)
40008830:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
40008836:	e9 41 ff ff ff       	jmp    4000877c <__pow5mult+0x2c>
4000883b:	90                   	nop    
4000883c:	8d 74 26 00          	lea    0x0(%esi),%esi

40008840 <__s2b>:
40008840:	55                   	push   %ebp
40008841:	ba 39 8e e3 38       	mov    $0x38e38e39,%edx
40008846:	89 e5                	mov    %esp,%ebp
40008848:	57                   	push   %edi
40008849:	56                   	push   %esi
4000884a:	53                   	push   %ebx
4000884b:	83 ec 0c             	sub    $0xc,%esp
4000884e:	8b 4d 14             	mov    0x14(%ebp),%ecx
40008851:	8b 7d 08             	mov    0x8(%ebp),%edi
40008854:	83 c1 08             	add    $0x8,%ecx
40008857:	8b 75 0c             	mov    0xc(%ebp),%esi
4000885a:	89 c8                	mov    %ecx,%eax
4000885c:	f7 ea                	imul   %edx
4000885e:	c1 f9 1f             	sar    $0x1f,%ecx
40008861:	d1 fa                	sar    %edx
40008863:	29 ca                	sub    %ecx,%edx
40008865:	31 c9                	xor    %ecx,%ecx
40008867:	83 fa 01             	cmp    $0x1,%edx
4000886a:	7e 1b                	jle    40008887 <__s2b+0x47>
4000886c:	b8 01 00 00 00       	mov    $0x1,%eax
40008871:	eb 0d                	jmp    40008880 <__s2b+0x40>
40008873:	90                   	nop    
40008874:	90                   	nop    
40008875:	90                   	nop    
40008876:	90                   	nop    
40008877:	90                   	nop    
40008878:	90                   	nop    
40008879:	90                   	nop    
4000887a:	90                   	nop    
4000887b:	90                   	nop    
4000887c:	90                   	nop    
4000887d:	90                   	nop    
4000887e:	90                   	nop    
4000887f:	90                   	nop    
40008880:	01 c0                	add    %eax,%eax
40008882:	41                   	inc    %ecx
40008883:	39 c2                	cmp    %eax,%edx
40008885:	7f f9                	jg     40008880 <__s2b+0x40>
40008887:	50                   	push   %eax
40008888:	50                   	push   %eax
40008889:	51                   	push   %ecx
4000888a:	57                   	push   %edi
4000888b:	e8 90 f7 ff ff       	call   40008020 <_Balloc>
40008890:	83 c4 10             	add    $0x10,%esp
40008893:	89 c2                	mov    %eax,%edx
40008895:	8b 45 18             	mov    0x18(%ebp),%eax
40008898:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
4000889c:	89 42 14             	mov    %eax,0x14(%edx)
4000889f:	c7 42 10 01 00 00 00 	movl   $0x1,0x10(%edx)
400088a6:	7e 6e                	jle    40008916 <__s2b+0xd6>
400088a8:	8d 4e 09             	lea    0x9(%esi),%ecx
400088ab:	bb 09 00 00 00       	mov    $0x9,%ebx
400088b0:	89 4d f0             	mov    %ecx,-0x10(%ebp)
400088b3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
400088b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
400088c0:	0f be 04 33          	movsbl (%ebx,%esi,1),%eax
400088c4:	83 e8 30             	sub    $0x30,%eax
400088c7:	43                   	inc    %ebx
400088c8:	50                   	push   %eax
400088c9:	6a 0a                	push   $0xa
400088cb:	52                   	push   %edx
400088cc:	57                   	push   %edi
400088cd:	e8 ae fd ff ff       	call   40008680 <__multadd>
400088d2:	83 c4 10             	add    $0x10,%esp
400088d5:	89 c2                	mov    %eax,%edx
400088d7:	3b 5d 10             	cmp    0x10(%ebp),%ebx
400088da:	75 e4                	jne    400088c0 <__s2b+0x80>
400088dc:	8b 4d 10             	mov    0x10(%ebp),%ecx
400088df:	8b 45 f0             	mov    -0x10(%ebp),%eax
400088e2:	89 cb                	mov    %ecx,%ebx
400088e4:	8d 74 08 f8          	lea    -0x8(%eax,%ecx,1),%esi
400088e8:	39 5d 14             	cmp    %ebx,0x14(%ebp)
400088eb:	7e 1f                	jle    4000890c <__s2b+0xcc>
400088ed:	8d 76 00             	lea    0x0(%esi),%esi
400088f0:	0f be 06             	movsbl (%esi),%eax
400088f3:	83 e8 30             	sub    $0x30,%eax
400088f6:	43                   	inc    %ebx
400088f7:	50                   	push   %eax
400088f8:	6a 0a                	push   $0xa
400088fa:	52                   	push   %edx
400088fb:	57                   	push   %edi
400088fc:	e8 7f fd ff ff       	call   40008680 <__multadd>
40008901:	46                   	inc    %esi
40008902:	83 c4 10             	add    $0x10,%esp
40008905:	89 c2                	mov    %eax,%edx
40008907:	3b 5d 14             	cmp    0x14(%ebp),%ebx
4000890a:	75 e4                	jne    400088f0 <__s2b+0xb0>
4000890c:	8d 65 f4             	lea    -0xc(%ebp),%esp
4000890f:	89 d0                	mov    %edx,%eax
40008911:	5b                   	pop    %ebx
40008912:	5e                   	pop    %esi
40008913:	5f                   	pop    %edi
40008914:	5d                   	pop    %ebp
40008915:	c3                   	ret    
40008916:	83 c6 0a             	add    $0xa,%esi
40008919:	bb 09 00 00 00       	mov    $0x9,%ebx
4000891e:	eb c8                	jmp    400088e8 <__s2b+0xa8>

40008920 <_read_r>:
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
*/

#include <_ansi.h>
40008920:	55                   	push   %ebp
40008921:	89 e5                	mov    %esp,%ebp
40008923:	83 ec 0c             	sub    $0xc,%esp
#include <stdio.h>
#include "local.h"

40008926:	c7 05 60 d9 00 40 00 	movl   $0x0,0x4000d960
4000892d:	00 00 00 
/* Flush a single file, or (if fp is NULL) all files.  */
40008930:	8b 4d 14             	mov    0x14(%ebp),%ecx
40008933:	51                   	push   %ecx
40008934:	8b 55 10             	mov    0x10(%ebp),%edx
40008937:	52                   	push   %edx
40008938:	8b 45 0c             	mov    0xc(%ebp),%eax
4000893b:	50                   	push   %eax
4000893c:	e8 ff 8a ff ff       	call   40001440 <read>
40008941:	83 c4 10             	add    $0x10,%esp
40008944:	83 f8 ff             	cmp    $0xffffffff,%eax
40008947:	74 07                	je     40008950 <_read_r+0x30>

int
_DEFUN(fflush, (fp),
40008949:	c9                   	leave  
4000894a:	c3                   	ret    
4000894b:	90                   	nop    
4000894c:	8d 74 26 00          	lea    0x0(%esi),%esi

#include <_ansi.h>
#include <stdio.h>
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */
40008950:	8b 15 60 d9 00 40    	mov    0x4000d960,%edx
40008956:	85 d2                	test   %edx,%edx
40008958:	74 ef                	je     40008949 <_read_r+0x29>

4000895a:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000895d:	89 11                	mov    %edx,(%ecx)
int
_DEFUN(fflush, (fp),
4000895f:	c9                   	leave  
40008960:	c3                   	ret    
40008961:	90                   	nop    
40008962:	90                   	nop    
40008963:	90                   	nop    
40008964:	90                   	nop    
40008965:	90                   	nop    
40008966:	90                   	nop    
40008967:	90                   	nop    
40008968:	90                   	nop    
40008969:	90                   	nop    
4000896a:	90                   	nop    
4000896b:	90                   	nop    
4000896c:	90                   	nop    
4000896d:	90                   	nop    
4000896e:	90                   	nop    
4000896f:	90                   	nop    

40008970 <_realloc_r>:
#if __STD_C
Void_t* rEALLOc(RARG Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
#endif
{
40008970:	55                   	push   %ebp
40008971:	89 e5                	mov    %esp,%ebp
40008973:	57                   	push   %edi
40008974:	56                   	push   %esi
40008975:	53                   	push   %ebx
40008976:	83 ec 2c             	sub    $0x2c,%esp
40008979:	8b 55 0c             	mov    0xc(%ebp),%edx
4000897c:	8b 45 08             	mov    0x8(%ebp),%eax
4000897f:	8b 4d 10             	mov    0x10(%ebp),%ecx
40008982:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40008985:	89 55 d0             	mov    %edx,-0x30(%ebp)
40008988:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
4000898b:	85 d2                	test   %edx,%edx
4000898d:	0f 84 ed 01 00 00    	je     40008b80 <_realloc_r+0x210>

  MALLOC_LOCK;
40008993:	83 ec 0c             	sub    $0xc,%esp
40008996:	8b 45 d4             	mov    -0x2c(%ebp),%eax
40008999:	50                   	push   %eax
4000899a:	e8 91 86 ff ff       	call   40001030 <__malloc_lock>

  newp    = oldp    = mem2chunk(oldmem);
4000899f:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
400089a2:	83 c4 10             	add    $0x10,%esp
  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);

  MALLOC_LOCK;

  newp    = oldp    = mem2chunk(oldmem);
400089a5:	83 eb 08             	sub    $0x8,%ebx
400089a8:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  newsize = oldsize = chunksize(oldp);
400089ab:	8b 43 04             	mov    0x4(%ebx),%eax
400089ae:	89 45 dc             	mov    %eax,-0x24(%ebp)


  nb = request2size(bytes);
400089b1:	8b 45 cc             	mov    -0x34(%ebp),%eax
400089b4:	83 c0 0b             	add    $0xb,%eax
400089b7:	83 f8 16             	cmp    $0x16,%eax
400089ba:	77 34                	ja     400089f0 <_realloc_r+0x80>
400089bc:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%ebp)

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
400089c3:	8b 55 cc             	mov    -0x34(%ebp),%edx

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
400089c6:	31 c0                	xor    %eax,%eax
400089c8:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
400089cf:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
400089d2:	73 30                	jae    40008a04 <_realloc_r+0x94>
  {
    RERRNO = ENOMEM;
400089d4:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
400089d7:	31 db                	xor    %ebx,%ebx
400089d9:	c7 01 0c 00 00 00    	movl   $0xc,(%ecx)
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
400089df:	8d 65 f4             	lea    -0xc(%ebp),%esp
400089e2:	89 d8                	mov    %ebx,%eax
400089e4:	5b                   	pop    %ebx
400089e5:	5e                   	pop    %esi
400089e6:	5f                   	pop    %edi
400089e7:	5d                   	pop    %ebp
400089e8:	c3                   	ret    
400089e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
400089f0:	83 e0 f8             	and    $0xfffffff8,%eax

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
400089f3:	8b 55 cc             	mov    -0x34(%ebp),%edx

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
400089f6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400089f9:	89 45 e8             	mov    %eax,-0x18(%ebp)
400089fc:	c1 e8 1f             	shr    $0x1f,%eax

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
400089ff:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
40008a02:	72 d0                	jb     400089d4 <_realloc_r+0x64>
40008a04:	84 c0                	test   %al,%al
40008a06:	75 cc                	jne    400089d4 <_realloc_r+0x64>
  if (oldmem == 0) return mALLOc(RCALL bytes);

  MALLOC_LOCK;

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
40008a08:	8b 7d dc             	mov    -0x24(%ebp),%edi
40008a0b:	83 e7 fc             	and    $0xfffffffc,%edi
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
40008a0e:	3b 7d e8             	cmp    -0x18(%ebp),%edi
40008a11:	0f 8d f9 00 00 00    	jge    40008b10 <_realloc_r+0x1a0>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
40008a17:	8b 5d d8             	mov    -0x28(%ebp),%ebx
    if (next == top || !inuse(next)) 
40008a1a:	a1 88 d4 00 40       	mov    0x4000d488,%eax
  if ((long)(oldsize) < (long)(nb))  
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
40008a1f:	01 fb                	add    %edi,%ebx
    if (next == top || !inuse(next)) 
40008a21:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if ((long)(oldsize) < (long)(nb))  
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
40008a24:	89 d9                	mov    %ebx,%ecx
    if (next == top || !inuse(next)) 
40008a26:	39 d8                	cmp    %ebx,%eax
40008a28:	0f 84 15 03 00 00    	je     40008d43 <_realloc_r+0x3d3>
40008a2e:	8b 53 04             	mov    0x4(%ebx),%edx
40008a31:	89 d0                	mov    %edx,%eax
40008a33:	83 e0 fe             	and    $0xfffffffe,%eax
40008a36:	f6 44 03 04 01       	testb  $0x1,0x4(%ebx,%eax,1)
40008a3b:	0f 84 1f 01 00 00    	je     40008b60 <_realloc_r+0x1f0>
      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      { 
        unlink(next, bck, fwd);
        newsize  += nextsize;
        goto split;
40008a41:	31 c9                	xor    %ecx,%ecx
40008a43:	31 d2                	xor    %edx,%edx
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
40008a45:	f6 45 dc 01          	testb  $0x1,-0x24(%ebp)
40008a49:	0f 85 91 01 00 00    	jne    40008be0 <_realloc_r+0x270>
    {
      prev = prev_chunk(oldp);
40008a4f:	8b 5d d8             	mov    -0x28(%ebp),%ebx
40008a52:	8b 03                	mov    (%ebx),%eax
40008a54:	29 c3                	sub    %eax,%ebx
40008a56:	89 5d e0             	mov    %ebx,-0x20(%ebp)
      prevsize = chunksize(prev);
40008a59:	8b 43 04             	mov    0x4(%ebx),%eax
40008a5c:	83 e0 fc             	and    $0xfffffffc,%eax

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
40008a5f:	85 c9                	test   %ecx,%ecx
40008a61:	0f 84 3e 02 00 00    	je     40008ca5 <_realloc_r+0x335>
      {
        /* into top */
        if (next == top)
40008a67:	3b 4d f0             	cmp    -0x10(%ebp),%ecx
40008a6a:	0f 84 78 03 00 00    	je     40008de8 <_realloc_r+0x478>
            return newmem;
          }
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
40008a70:	01 f8                	add    %edi,%eax
40008a72:	89 45 ec             	mov    %eax,-0x14(%ebp)
40008a75:	8d 34 02             	lea    (%edx,%eax,1),%esi
40008a78:	3b 75 e8             	cmp    -0x18(%ebp),%esi
40008a7b:	0f 8c 2f 02 00 00    	jl     40008cb0 <_realloc_r+0x340>
        {
          unlink(next, bck, fwd);
40008a81:	8b 51 0c             	mov    0xc(%ecx),%edx
40008a84:	8b 41 08             	mov    0x8(%ecx),%eax
          unlink(prev, bck, fwd);
40008a87:	8b 5d e0             	mov    -0x20(%ebp),%ebx
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
        {
          unlink(next, bck, fwd);
40008a8a:	89 50 0c             	mov    %edx,0xc(%eax)
40008a8d:	89 42 08             	mov    %eax,0x8(%edx)
          unlink(prev, bck, fwd);
40008a90:	8b 43 08             	mov    0x8(%ebx),%eax
40008a93:	8b 53 0c             	mov    0xc(%ebx),%edx
40008a96:	89 50 0c             	mov    %edx,0xc(%eax)
40008a99:	89 42 08             	mov    %eax,0x8(%edx)
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
40008a9c:	89 d8                	mov    %ebx,%eax
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008a9e:	8d 5f fc             	lea    -0x4(%edi),%ebx
        {
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
40008aa1:	83 c0 08             	add    $0x8,%eax
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008aa4:	83 fb 24             	cmp    $0x24,%ebx
40008aa7:	0f 87 f6 02 00 00    	ja     40008da3 <_realloc_r+0x433>
40008aad:	8b 55 d0             	mov    -0x30(%ebp),%edx
40008ab0:	89 c1                	mov    %eax,%ecx
40008ab2:	83 fb 13             	cmp    $0x13,%ebx
40008ab5:	76 42                	jbe    40008af9 <_realloc_r+0x189>
40008ab7:	8b 02                	mov    (%edx),%eax
40008ab9:	8b 55 e0             	mov    -0x20(%ebp),%edx
40008abc:	8b 4d d0             	mov    -0x30(%ebp),%ecx
40008abf:	89 42 08             	mov    %eax,0x8(%edx)
40008ac2:	8b 41 04             	mov    0x4(%ecx),%eax
40008ac5:	89 d1                	mov    %edx,%ecx
40008ac7:	89 42 0c             	mov    %eax,0xc(%edx)
40008aca:	8b 55 d0             	mov    -0x30(%ebp),%edx
40008acd:	83 c1 10             	add    $0x10,%ecx
40008ad0:	83 c2 08             	add    $0x8,%edx
40008ad3:	83 fb 1b             	cmp    $0x1b,%ebx
40008ad6:	76 21                	jbe    40008af9 <_realloc_r+0x189>
40008ad8:	8b 55 d0             	mov    -0x30(%ebp),%edx
40008adb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
40008ade:	8b 42 08             	mov    0x8(%edx),%eax
40008ae1:	89 41 10             	mov    %eax,0x10(%ecx)
40008ae4:	8b 42 0c             	mov    0xc(%edx),%eax
40008ae7:	83 c2 10             	add    $0x10,%edx
40008aea:	89 41 14             	mov    %eax,0x14(%ecx)
40008aed:	83 c1 18             	add    $0x18,%ecx
40008af0:	83 fb 24             	cmp    $0x24,%ebx
40008af3:	0f 84 e3 03 00 00    	je     40008edc <_realloc_r+0x56c>
40008af9:	8b 02                	mov    (%edx),%eax
40008afb:	8b 5d e0             	mov    -0x20(%ebp),%ebx
40008afe:	89 01                	mov    %eax,(%ecx)
40008b00:	8b 42 04             	mov    0x4(%edx),%eax
40008b03:	89 41 04             	mov    %eax,0x4(%ecx)
40008b06:	8b 42 08             	mov    0x8(%edx),%eax
40008b09:	89 41 08             	mov    %eax,0x8(%ecx)
40008b0c:	eb 07                	jmp    40008b15 <_realloc_r+0x1a5>
40008b0e:	66 90                	xchg   %ax,%ax

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
    fREe(RCALL oldmem);
    MALLOC_UNLOCK;
    return newmem;
40008b10:	8b 5d d8             	mov    -0x28(%ebp),%ebx
40008b13:	89 fe                	mov    %edi,%esi
  }


 split:  /* split off extra room in old or expanded chunk */

  remainder_size = long_sub_size_t(newsize, nb);
40008b15:	89 f1                	mov    %esi,%ecx
40008b17:	8b 7d e4             	mov    -0x1c(%ebp),%edi
40008b1a:	29 f9                	sub    %edi,%ecx

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
40008b1c:	83 f9 0f             	cmp    $0xf,%ecx
40008b1f:	77 6f                	ja     40008b90 <_realloc_r+0x220>
    set_inuse_bit_at_offset(remainder, remainder_size);
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
  }
  else
  {
    set_head_size(newp, newsize);
40008b21:	8b 43 04             	mov    0x4(%ebx),%eax
40008b24:	83 e0 01             	and    $0x1,%eax
40008b27:	09 f0                	or     %esi,%eax
40008b29:	89 43 04             	mov    %eax,0x4(%ebx)
    set_inuse_bit_at_offset(newp, newsize);
40008b2c:	8b 54 1e 04          	mov    0x4(%esi,%ebx,1),%edx
40008b30:	83 ca 01             	or     $0x1,%edx
40008b33:	89 54 1e 04          	mov    %edx,0x4(%esi,%ebx,1)
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
40008b37:	83 ec 0c             	sub    $0xc,%esp
40008b3a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  return chunk2mem(newp);
40008b3d:	83 c3 08             	add    $0x8,%ebx
    set_head_size(newp, newsize);
    set_inuse_bit_at_offset(newp, newsize);
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
40008b40:	50                   	push   %eax
40008b41:	e8 fa 84 ff ff       	call   40001040 <__malloc_unlock>
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
40008b46:	89 d8                	mov    %ebx,%eax
    set_inuse_bit_at_offset(newp, newsize);
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);
40008b48:	83 c4 10             	add    $0x10,%esp

#endif /* MALLOC_PROVIDED */
}
40008b4b:	8d 65 f4             	lea    -0xc(%ebp),%esp
40008b4e:	5b                   	pop    %ebx
40008b4f:	5e                   	pop    %esi
40008b50:	5f                   	pop    %edi
40008b51:	5d                   	pop    %ebp
40008b52:	c3                   	ret    
40008b53:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40008b59:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next)) 
    {
      nextsize = chunksize(next);
40008b60:	83 e2 fc             	and    $0xfffffffc,%edx
          return chunk2mem(oldp);
        }
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
40008b63:	8d 34 3a             	lea    (%edx,%edi,1),%esi
40008b66:	3b 75 e8             	cmp    -0x18(%ebp),%esi
40008b69:	0f 8c d6 fe ff ff    	jl     40008a45 <_realloc_r+0xd5>
      { 
        unlink(next, bck, fwd);
40008b6f:	8b 53 0c             	mov    0xc(%ebx),%edx
40008b72:	8b 43 08             	mov    0x8(%ebx),%eax
40008b75:	8b 5d d8             	mov    -0x28(%ebp),%ebx
40008b78:	89 50 0c             	mov    %edx,0xc(%eax)
40008b7b:	89 42 08             	mov    %eax,0x8(%edx)
40008b7e:	eb 95                	jmp    40008b15 <_realloc_r+0x1a5>
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
40008b80:	89 4d 0c             	mov    %ecx,0xc(%ebp)
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
40008b83:	8d 65 f4             	lea    -0xc(%ebp),%esp
40008b86:	5b                   	pop    %ebx
40008b87:	5e                   	pop    %esi
40008b88:	5f                   	pop    %edi
40008b89:	5d                   	pop    %ebp
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
40008b8a:	e9 51 7c ff ff       	jmp    400007e0 <_malloc_r>
40008b8f:	90                   	nop    

  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
40008b90:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    set_head_size(newp, nb);
40008b93:	8b 75 e4             	mov    -0x1c(%ebp),%esi

  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
40008b96:	8d 04 13             	lea    (%ebx,%edx,1),%eax
    set_head_size(newp, nb);
40008b99:	8b 53 04             	mov    0x4(%ebx),%edx
40008b9c:	83 e2 01             	and    $0x1,%edx
40008b9f:	09 d6                	or     %edx,%esi
40008ba1:	89 75 e4             	mov    %esi,-0x1c(%ebp)
40008ba4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
40008ba7:	89 53 04             	mov    %edx,0x4(%ebx)
    set_head(remainder, remainder_size | PREV_INUSE);
40008baa:	89 ca                	mov    %ecx,%edx
40008bac:	83 ca 01             	or     $0x1,%edx
40008baf:	89 50 04             	mov    %edx,0x4(%eax)
    set_inuse_bit_at_offset(remainder, remainder_size);
40008bb2:	8b 7c 08 04          	mov    0x4(%eax,%ecx,1),%edi
40008bb6:	83 cf 01             	or     $0x1,%edi
40008bb9:	89 7c 08 04          	mov    %edi,0x4(%eax,%ecx,1)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
40008bbd:	83 c0 08             	add    $0x8,%eax
40008bc0:	56                   	push   %esi
40008bc1:	56                   	push   %esi
40008bc2:	50                   	push   %eax
40008bc3:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
40008bc6:	51                   	push   %ecx
40008bc7:	e8 94 e3 ff ff       	call   40006f60 <_free_r>
40008bcc:	83 c4 10             	add    $0x10,%esp
40008bcf:	e9 63 ff ff ff       	jmp    40008b37 <_realloc_r+0x1c7>
40008bd4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40008bda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
      }
    }

    /* Must allocate */

    newmem = mALLOc (RCALL bytes);
40008be0:	50                   	push   %eax
40008be1:	50                   	push   %eax
40008be2:	8b 75 cc             	mov    -0x34(%ebp),%esi
40008be5:	56                   	push   %esi
40008be6:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
40008be9:	53                   	push   %ebx
40008bea:	e8 f1 7b ff ff       	call   400007e0 <_malloc_r>

    if (newmem == 0)  /* propagate failure */
40008bef:	83 c4 10             	add    $0x10,%esp
      }
    }

    /* Must allocate */

    newmem = mALLOc (RCALL bytes);
40008bf2:	89 c3                	mov    %eax,%ebx

    if (newmem == 0)  /* propagate failure */
40008bf4:	85 c0                	test   %eax,%eax
40008bf6:	0f 84 22 03 00 00    	je     40008f1e <_realloc_r+0x5ae>
    }

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
40008bfc:	8b 4d d8             	mov    -0x28(%ebp),%ecx
40008bff:	8d 50 f8             	lea    -0x8(%eax),%edx
40008c02:	8b 41 04             	mov    0x4(%ecx),%eax
40008c05:	83 e0 fe             	and    $0xfffffffe,%eax
40008c08:	01 c8                	add    %ecx,%eax
40008c0a:	39 c2                	cmp    %eax,%edx
40008c0c:	0f 84 a9 02 00 00    	je     40008ebb <_realloc_r+0x54b>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008c12:	8d 77 fc             	lea    -0x4(%edi),%esi
40008c15:	83 fe 24             	cmp    $0x24,%esi
40008c18:	0f 87 b6 01 00 00    	ja     40008dd4 <_realloc_r+0x464>
40008c1e:	8b 55 d0             	mov    -0x30(%ebp),%edx
40008c21:	89 d9                	mov    %ebx,%ecx
40008c23:	83 fe 13             	cmp    $0x13,%esi
40008c26:	76 47                	jbe    40008c6f <_realloc_r+0x2ff>
40008c28:	8b 02                	mov    (%edx),%eax
40008c2a:	8d 4b 08             	lea    0x8(%ebx),%ecx
40008c2d:	89 03                	mov    %eax,(%ebx)
40008c2f:	8b 42 04             	mov    0x4(%edx),%eax
40008c32:	83 c2 08             	add    $0x8,%edx
40008c35:	89 43 04             	mov    %eax,0x4(%ebx)
40008c38:	83 fe 1b             	cmp    $0x1b,%esi
40008c3b:	76 32                	jbe    40008c6f <_realloc_r+0x2ff>
40008c3d:	8b 4d d0             	mov    -0x30(%ebp),%ecx
40008c40:	8b 55 d0             	mov    -0x30(%ebp),%edx
40008c43:	83 c2 10             	add    $0x10,%edx
40008c46:	83 fe 24             	cmp    $0x24,%esi
40008c49:	8b 41 08             	mov    0x8(%ecx),%eax
40008c4c:	89 43 08             	mov    %eax,0x8(%ebx)
40008c4f:	8b 41 0c             	mov    0xc(%ecx),%eax
40008c52:	8d 4b 10             	lea    0x10(%ebx),%ecx
40008c55:	89 43 0c             	mov    %eax,0xc(%ebx)
40008c58:	75 15                	jne    40008c6f <_realloc_r+0x2ff>
40008c5a:	8b 55 d0             	mov    -0x30(%ebp),%edx
40008c5d:	8d 4b 18             	lea    0x18(%ebx),%ecx
40008c60:	8b 42 10             	mov    0x10(%edx),%eax
40008c63:	89 43 10             	mov    %eax,0x10(%ebx)
40008c66:	8b 42 14             	mov    0x14(%edx),%eax
40008c69:	83 c2 18             	add    $0x18,%edx
40008c6c:	89 43 14             	mov    %eax,0x14(%ebx)
40008c6f:	8b 02                	mov    (%edx),%eax
40008c71:	89 01                	mov    %eax,(%ecx)
40008c73:	8b 42 04             	mov    0x4(%edx),%eax
40008c76:	89 41 04             	mov    %eax,0x4(%ecx)
40008c79:	8b 42 08             	mov    0x8(%edx),%eax
40008c7c:	89 41 08             	mov    %eax,0x8(%ecx)
    fREe(RCALL oldmem);
40008c7f:	50                   	push   %eax
40008c80:	50                   	push   %eax
40008c81:	8b 45 d0             	mov    -0x30(%ebp),%eax
40008c84:	50                   	push   %eax
40008c85:	8b 45 d4             	mov    -0x2c(%ebp),%eax
40008c88:	50                   	push   %eax
40008c89:	e8 d2 e2 ff ff       	call   40006f60 <_free_r>
    MALLOC_UNLOCK;
40008c8e:	58                   	pop    %eax
40008c8f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
40008c92:	50                   	push   %eax
40008c93:	e8 a8 83 ff ff       	call   40001040 <__malloc_unlock>
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
40008c98:	89 d8                	mov    %ebx,%eax

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
    fREe(RCALL oldmem);
    MALLOC_UNLOCK;
    return newmem;
40008c9a:	83 c4 10             	add    $0x10,%esp
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
40008c9d:	8d 65 f4             	lea    -0xc(%ebp),%esp
40008ca0:	5b                   	pop    %ebx
40008ca1:	5e                   	pop    %esi
40008ca2:	5f                   	pop    %edi
40008ca3:	5d                   	pop    %ebp
40008ca4:	c3                   	ret    
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008ca5:	01 f8                	add    %edi,%eax
40008ca7:	89 45 ec             	mov    %eax,-0x14(%ebp)
40008caa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
          goto split;
        }
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
40008cb0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
40008cb3:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
40008cb6:	0f 8c 24 ff ff ff    	jl     40008be0 <_realloc_r+0x270>
      {
        unlink(prev, bck, fwd);
40008cbc:	8b 5d e0             	mov    -0x20(%ebp),%ebx
40008cbf:	8b 43 08             	mov    0x8(%ebx),%eax
40008cc2:	8b 53 0c             	mov    0xc(%ebx),%edx
40008cc5:	89 50 0c             	mov    %edx,0xc(%eax)
40008cc8:	89 42 08             	mov    %eax,0x8(%edx)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
40008ccb:	89 d8                	mov    %ebx,%eax
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008ccd:	8d 5f fc             	lea    -0x4(%edi),%ebx
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
40008cd0:	83 c0 08             	add    $0x8,%eax
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008cd3:	83 fb 24             	cmp    $0x24,%ebx
40008cd6:	0f 87 de 00 00 00    	ja     40008dba <_realloc_r+0x44a>
40008cdc:	8b 55 d0             	mov    -0x30(%ebp),%edx
40008cdf:	89 c1                	mov    %eax,%ecx
40008ce1:	83 fb 13             	cmp    $0x13,%ebx
40008ce4:	76 42                	jbe    40008d28 <_realloc_r+0x3b8>
40008ce6:	8b 02                	mov    (%edx),%eax
40008ce8:	8b 55 e0             	mov    -0x20(%ebp),%edx
40008ceb:	8b 4d d0             	mov    -0x30(%ebp),%ecx
40008cee:	89 42 08             	mov    %eax,0x8(%edx)
40008cf1:	8b 41 04             	mov    0x4(%ecx),%eax
40008cf4:	89 d1                	mov    %edx,%ecx
40008cf6:	89 42 0c             	mov    %eax,0xc(%edx)
40008cf9:	8b 55 d0             	mov    -0x30(%ebp),%edx
40008cfc:	83 c1 10             	add    $0x10,%ecx
40008cff:	83 c2 08             	add    $0x8,%edx
40008d02:	83 fb 1b             	cmp    $0x1b,%ebx
40008d05:	76 21                	jbe    40008d28 <_realloc_r+0x3b8>
40008d07:	8b 55 d0             	mov    -0x30(%ebp),%edx
40008d0a:	8b 4d e0             	mov    -0x20(%ebp),%ecx
40008d0d:	8b 42 08             	mov    0x8(%edx),%eax
40008d10:	89 41 10             	mov    %eax,0x10(%ecx)
40008d13:	8b 42 0c             	mov    0xc(%edx),%eax
40008d16:	83 c2 10             	add    $0x10,%edx
40008d19:	89 41 14             	mov    %eax,0x14(%ecx)
40008d1c:	83 c1 18             	add    $0x18,%ecx
40008d1f:	83 fb 24             	cmp    $0x24,%ebx
40008d22:	0f 84 d5 01 00 00    	je     40008efd <_realloc_r+0x58d>
40008d28:	8b 02                	mov    (%edx),%eax
40008d2a:	8b 5d e0             	mov    -0x20(%ebp),%ebx
40008d2d:	89 01                	mov    %eax,(%ecx)
40008d2f:	8b 75 ec             	mov    -0x14(%ebp),%esi
40008d32:	8b 42 04             	mov    0x4(%edx),%eax
40008d35:	89 41 04             	mov    %eax,0x4(%ecx)
40008d38:	8b 42 08             	mov    0x8(%edx),%eax
40008d3b:	89 41 08             	mov    %eax,0x8(%ecx)
40008d3e:	e9 d2 fd ff ff       	jmp    40008b15 <_realloc_r+0x1a5>
    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next)) 
    {
      nextsize = chunksize(next);
40008d43:	8b 53 04             	mov    0x4(%ebx),%edx

      /* Forward into top only if a remainder */
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
40008d46:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next)) 
    {
      nextsize = chunksize(next);
40008d49:	83 e2 fc             	and    $0xfffffffc,%edx

      /* Forward into top only if a remainder */
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
40008d4c:	83 c0 10             	add    $0x10,%eax
40008d4f:	8d 1c 3a             	lea    (%edx,%edi,1),%ebx
40008d52:	39 c3                	cmp    %eax,%ebx
40008d54:	0f 8c eb fc ff ff    	jl     40008a45 <_realloc_r+0xd5>
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
40008d5a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
          set_head(top, (newsize - nb) | PREV_INUSE);
40008d5d:	8b 75 e4             	mov    -0x1c(%ebp),%esi
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
40008d60:	8b 45 d8             	mov    -0x28(%ebp),%eax
          set_head(top, (newsize - nb) | PREV_INUSE);
40008d63:	29 f3                	sub    %esi,%ebx
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
40008d65:	01 f8                	add    %edi,%eax
          set_head(top, (newsize - nb) | PREV_INUSE);
          set_head_size(oldp, nb);
40008d67:	8b 55 d8             	mov    -0x28(%ebp),%edx
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
40008d6a:	83 cb 01             	or     $0x1,%ebx
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
40008d6d:	a3 88 d4 00 40       	mov    %eax,0x4000d488
          set_head(top, (newsize - nb) | PREV_INUSE);
40008d72:	89 58 04             	mov    %ebx,0x4(%eax)
          set_head_size(oldp, nb);
40008d75:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40008d78:	8b 42 04             	mov    0x4(%edx),%eax
	  MALLOC_UNLOCK;
40008d7b:	83 ec 0c             	sub    $0xc,%esp
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
          set_head_size(oldp, nb);
40008d7e:	83 e0 01             	and    $0x1,%eax
40008d81:	09 c1                	or     %eax,%ecx
	  MALLOC_UNLOCK;
40008d83:	8b 45 d4             	mov    -0x2c(%ebp),%eax
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
          set_head_size(oldp, nb);
40008d86:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
40008d89:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40008d8c:	89 4a 04             	mov    %ecx,0x4(%edx)
	  MALLOC_UNLOCK;
40008d8f:	50                   	push   %eax
40008d90:	e8 ab 82 ff ff       	call   40001040 <__malloc_unlock>
          return chunk2mem(oldp);
40008d95:	8b 5d d8             	mov    -0x28(%ebp),%ebx
40008d98:	83 c3 08             	add    $0x8,%ebx
40008d9b:	83 c4 10             	add    $0x10,%esp
40008d9e:	e9 3c fc ff ff       	jmp    400089df <_realloc_r+0x6f>
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008da3:	57                   	push   %edi
40008da4:	53                   	push   %ebx
40008da5:	8b 5d d0             	mov    -0x30(%ebp),%ebx
40008da8:	53                   	push   %ebx
40008da9:	50                   	push   %eax
40008daa:	e8 f1 ec ff ff       	call   40007aa0 <memmove>
40008daf:	8b 5d e0             	mov    -0x20(%ebp),%ebx
40008db2:	83 c4 10             	add    $0x10,%esp
40008db5:	e9 5b fd ff ff       	jmp    40008b15 <_realloc_r+0x1a5>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008dba:	51                   	push   %ecx
40008dbb:	53                   	push   %ebx
40008dbc:	8b 55 d0             	mov    -0x30(%ebp),%edx
40008dbf:	52                   	push   %edx
40008dc0:	50                   	push   %eax
40008dc1:	e8 da ec ff ff       	call   40007aa0 <memmove>
40008dc6:	8b 5d e0             	mov    -0x20(%ebp),%ebx
40008dc9:	8b 75 ec             	mov    -0x14(%ebp),%esi
40008dcc:	83 c4 10             	add    $0x10,%esp
40008dcf:	e9 41 fd ff ff       	jmp    40008b15 <_realloc_r+0x1a5>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008dd4:	52                   	push   %edx
40008dd5:	56                   	push   %esi
40008dd6:	8b 45 d0             	mov    -0x30(%ebp),%eax
40008dd9:	50                   	push   %eax
40008dda:	53                   	push   %ebx
40008ddb:	e8 c0 ec ff ff       	call   40007aa0 <memmove>
40008de0:	83 c4 10             	add    $0x10,%esp
40008de3:	e9 97 fe ff ff       	jmp    40008c7f <_realloc_r+0x30f>
      if (next != 0)
      {
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
40008de8:	01 f8                	add    %edi,%eax
40008dea:	89 45 ec             	mov    %eax,-0x14(%ebp)
40008ded:	8d 34 02             	lea    (%edx,%eax,1),%esi
40008df0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40008df3:	83 c0 10             	add    $0x10,%eax
40008df6:	39 c6                	cmp    %eax,%esi
40008df8:	0f 8c b2 fe ff ff    	jl     40008cb0 <_realloc_r+0x340>
          {
            unlink(prev, bck, fwd);
40008dfe:	8b 53 0c             	mov    0xc(%ebx),%edx
40008e01:	8b 43 08             	mov    0x8(%ebx),%eax
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008e04:	83 ef 04             	sub    $0x4,%edi
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
40008e07:	83 c3 08             	add    $0x8,%ebx
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
          {
            unlink(prev, bck, fwd);
40008e0a:	89 50 0c             	mov    %edx,0xc(%eax)
40008e0d:	89 42 08             	mov    %eax,0x8(%edx)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008e10:	83 ff 24             	cmp    $0x24,%edi
40008e13:	0f 87 b2 00 00 00    	ja     40008ecb <_realloc_r+0x55b>
40008e19:	8b 55 d0             	mov    -0x30(%ebp),%edx
40008e1c:	89 d9                	mov    %ebx,%ecx
40008e1e:	83 ff 13             	cmp    $0x13,%edi
40008e21:	76 42                	jbe    40008e65 <_realloc_r+0x4f5>
40008e23:	8b 02                	mov    (%edx),%eax
40008e25:	8b 55 e0             	mov    -0x20(%ebp),%edx
40008e28:	8b 4d d0             	mov    -0x30(%ebp),%ecx
40008e2b:	89 42 08             	mov    %eax,0x8(%edx)
40008e2e:	8b 41 04             	mov    0x4(%ecx),%eax
40008e31:	89 d1                	mov    %edx,%ecx
40008e33:	89 42 0c             	mov    %eax,0xc(%edx)
40008e36:	8b 55 d0             	mov    -0x30(%ebp),%edx
40008e39:	83 c1 10             	add    $0x10,%ecx
40008e3c:	83 c2 08             	add    $0x8,%edx
40008e3f:	83 ff 1b             	cmp    $0x1b,%edi
40008e42:	76 21                	jbe    40008e65 <_realloc_r+0x4f5>
40008e44:	8b 55 d0             	mov    -0x30(%ebp),%edx
40008e47:	8b 4d e0             	mov    -0x20(%ebp),%ecx
40008e4a:	8b 42 08             	mov    0x8(%edx),%eax
40008e4d:	89 41 10             	mov    %eax,0x10(%ecx)
40008e50:	8b 42 0c             	mov    0xc(%edx),%eax
40008e53:	83 c2 10             	add    $0x10,%edx
40008e56:	89 41 14             	mov    %eax,0x14(%ecx)
40008e59:	83 c1 18             	add    $0x18,%ecx
40008e5c:	83 ff 24             	cmp    $0x24,%edi
40008e5f:	0f 84 cd 00 00 00    	je     40008f32 <_realloc_r+0x5c2>
40008e65:	8b 02                	mov    (%edx),%eax
40008e67:	89 01                	mov    %eax,(%ecx)
40008e69:	8b 42 04             	mov    0x4(%edx),%eax
40008e6c:	89 41 04             	mov    %eax,0x4(%ecx)
40008e6f:	8b 42 08             	mov    0x8(%edx),%eax
40008e72:	89 41 08             	mov    %eax,0x8(%ecx)
            top = chunk_at_offset(newp, nb);
40008e75:	8b 55 e4             	mov    -0x1c(%ebp),%edx
40008e78:	8b 45 e0             	mov    -0x20(%ebp),%eax
40008e7b:	01 d0                	add    %edx,%eax
            set_head(top, (newsize - nb) | PREV_INUSE);
40008e7d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
40008e80:	ba 80 d4 00 40       	mov    $0x4000d480,%edx
            set_head(top, (newsize - nb) | PREV_INUSE);
40008e85:	29 fe                	sub    %edi,%esi
40008e87:	83 ce 01             	or     $0x1,%esi
            set_head_size(newp, nb);
40008e8a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
40008e8d:	89 42 08             	mov    %eax,0x8(%edx)
            set_head(top, (newsize - nb) | PREV_INUSE);
            set_head_size(newp, nb);
40008e90:	8b 55 e0             	mov    -0x20(%ebp),%edx
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
40008e93:	89 70 04             	mov    %esi,0x4(%eax)
            set_head_size(newp, nb);
	    MALLOC_UNLOCK;
40008e96:	83 ec 0c             	sub    $0xc,%esp
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
            set_head_size(newp, nb);
40008e99:	8b 42 04             	mov    0x4(%edx),%eax
40008e9c:	83 e0 01             	and    $0x1,%eax
40008e9f:	09 c1                	or     %eax,%ecx
	    MALLOC_UNLOCK;
40008ea1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
            set_head_size(newp, nb);
40008ea4:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
40008ea7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40008eaa:	89 4a 04             	mov    %ecx,0x4(%edx)
	    MALLOC_UNLOCK;
40008ead:	50                   	push   %eax
40008eae:	e8 8d 81 ff ff       	call   40001040 <__malloc_unlock>
            return newmem;
40008eb3:	83 c4 10             	add    $0x10,%esp
40008eb6:	e9 24 fb ff ff       	jmp    400089df <_realloc_r+0x6f>
    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
    {
      newsize += chunksize(newp);
40008ebb:	8b 42 04             	mov    0x4(%edx),%eax
40008ebe:	89 cb                	mov    %ecx,%ebx
40008ec0:	83 e0 fc             	and    $0xfffffffc,%eax
40008ec3:	8d 34 38             	lea    (%eax,%edi,1),%esi
40008ec6:	e9 4a fc ff ff       	jmp    40008b15 <_realloc_r+0x1a5>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008ecb:	50                   	push   %eax
40008ecc:	57                   	push   %edi
40008ecd:	8b 4d d0             	mov    -0x30(%ebp),%ecx
40008ed0:	51                   	push   %ecx
40008ed1:	53                   	push   %ebx
40008ed2:	e8 c9 eb ff ff       	call   40007aa0 <memmove>
40008ed7:	83 c4 10             	add    $0x10,%esp
40008eda:	eb 99                	jmp    40008e75 <_realloc_r+0x505>
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008edc:	8b 5d d0             	mov    -0x30(%ebp),%ebx
40008edf:	8b 55 e0             	mov    -0x20(%ebp),%edx
40008ee2:	89 d1                	mov    %edx,%ecx
40008ee4:	8b 43 10             	mov    0x10(%ebx),%eax
40008ee7:	83 c1 20             	add    $0x20,%ecx
40008eea:	89 42 18             	mov    %eax,0x18(%edx)
40008eed:	8b 43 14             	mov    0x14(%ebx),%eax
40008ef0:	89 42 1c             	mov    %eax,0x1c(%edx)
40008ef3:	89 da                	mov    %ebx,%edx
40008ef5:	83 c2 18             	add    $0x18,%edx
40008ef8:	e9 fc fb ff ff       	jmp    40008af9 <_realloc_r+0x189>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008efd:	8b 5d d0             	mov    -0x30(%ebp),%ebx
40008f00:	8b 55 e0             	mov    -0x20(%ebp),%edx
40008f03:	89 d1                	mov    %edx,%ecx
40008f05:	8b 43 10             	mov    0x10(%ebx),%eax
40008f08:	83 c1 20             	add    $0x20,%ecx
40008f0b:	89 42 18             	mov    %eax,0x18(%edx)
40008f0e:	8b 43 14             	mov    0x14(%ebx),%eax
40008f11:	89 42 1c             	mov    %eax,0x1c(%edx)
40008f14:	89 da                	mov    %ebx,%edx
40008f16:	83 c2 18             	add    $0x18,%edx
40008f19:	e9 0a fe ff ff       	jmp    40008d28 <_realloc_r+0x3b8>

    newmem = mALLOc (RCALL bytes);

    if (newmem == 0)  /* propagate failure */
    {
      MALLOC_UNLOCK;
40008f1e:	83 ec 0c             	sub    $0xc,%esp
40008f21:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
40008f24:	51                   	push   %ecx
40008f25:	e8 16 81 ff ff       	call   40001040 <__malloc_unlock>
      return 0;
40008f2a:	83 c4 10             	add    $0x10,%esp
40008f2d:	e9 ad fa ff ff       	jmp    400089df <_realloc_r+0x6f>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
40008f32:	8b 55 d0             	mov    -0x30(%ebp),%edx
40008f35:	8b 4d e0             	mov    -0x20(%ebp),%ecx
40008f38:	8b 42 10             	mov    0x10(%edx),%eax
40008f3b:	89 41 18             	mov    %eax,0x18(%ecx)
40008f3e:	8b 42 14             	mov    0x14(%edx),%eax
40008f41:	83 c2 18             	add    $0x18,%edx
40008f44:	89 41 1c             	mov    %eax,0x1c(%ecx)
40008f47:	83 c1 20             	add    $0x20,%ecx
40008f4a:	e9 16 ff ff ff       	jmp    40008e65 <_realloc_r+0x4f5>
40008f4f:	90                   	nop    

40008f50 <_wrapup_reent>:
                fp->_offset = curoff;
            }
        } 
      _funlockfile (fp);
      return 0;
    }
40008f50:	55                   	push   %ebp
40008f51:	89 e5                	mov    %esp,%ebp
40008f53:	57                   	push   %edi
40008f54:	56                   	push   %esi
40008f55:	53                   	push   %ebx
40008f56:	83 ec 0c             	sub    $0xc,%esp
40008f59:	8b 45 08             	mov    0x8(%ebp),%eax
40008f5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if ((p = fp->_bf._base) == NULL)
    {
      /* Nothing to flush.  */
      _funlockfile (fp);
40008f5f:	85 c0                	test   %eax,%eax
40008f61:	74 62                	je     40008fc5 <_wrapup_reent+0x75>
    }
  n = fp->_p - p;		/* write this much */

  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
40008f63:	8b 45 ec             	mov    -0x14(%ebp),%eax
40008f66:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
40008f6c:	89 45 f0             	mov    %eax,-0x10(%ebp)
40008f6f:	85 c0                	test   %eax,%eax
40008f71:	74 34                	je     40008fa7 <_wrapup_reent+0x57>
   * write function.
40008f73:	8b 45 f0             	mov    -0x10(%ebp),%eax
40008f76:	8b 78 04             	mov    0x4(%eax),%edi
40008f79:	89 f8                	mov    %edi,%eax
40008f7b:	48                   	dec    %eax
40008f7c:	78 1d                	js     40008f9b <_wrapup_reent+0x4b>
40008f7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
40008f81:	31 f6                	xor    %esi,%esi
40008f83:	8d 5c b8 08          	lea    0x8(%eax,%edi,4),%ebx
40008f87:	89 f6                	mov    %esi,%esi
40008f89:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
   */
40008f90:	46                   	inc    %esi
40008f91:	ff 53 fc             	call   *-0x4(%ebx)
40008f94:	83 eb 04             	sub    $0x4,%ebx
  n = fp->_p - p;		/* write this much */

  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
40008f97:	39 fe                	cmp    %edi,%esi
40008f99:	75 f5                	jne    40008f90 <_wrapup_reent+0x40>
    }
  n = fp->_p - p;		/* write this much */

  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
40008f9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
40008f9e:	8b 00                	mov    (%eax),%eax
40008fa0:	89 45 f0             	mov    %eax,-0x10(%ebp)
40008fa3:	85 c0                	test   %eax,%eax
40008fa5:	75 cc                	jne    40008f73 <_wrapup_reent+0x23>
   * write function.
   */
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
40008fa7:	8b 45 ec             	mov    -0x14(%ebp),%eax
40008faa:	8b 48 3c             	mov    0x3c(%eax),%ecx
40008fad:	85 c9                	test   %ecx,%ecx
40008faf:	74 0c                	je     40008fbd <_wrapup_reent+0x6d>

40008fb1:	89 45 08             	mov    %eax,0x8(%ebp)
  while (n > 0)
40008fb4:	83 c4 0c             	add    $0xc,%esp
40008fb7:	5b                   	pop    %ebx
40008fb8:	5e                   	pop    %esi
40008fb9:	5f                   	pop    %edi
40008fba:	5d                   	pop    %ebp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

40008fbb:	ff e1                	jmp    *%ecx
  while (n > 0)
40008fbd:	83 c4 0c             	add    $0xc,%esp
40008fc0:	5b                   	pop    %ebx
40008fc1:	5e                   	pop    %esi
40008fc2:	5f                   	pop    %edi
40008fc3:	5d                   	pop    %ebp
40008fc4:	c3                   	ret    
    }
  if ((p = fp->_bf._base) == NULL)
    {
      /* Nothing to flush.  */
      _funlockfile (fp);
      return 0;
40008fc5:	a1 60 d0 00 40       	mov    0x4000d060,%eax
40008fca:	89 45 ec             	mov    %eax,-0x14(%ebp)
40008fcd:	eb 94                	jmp    40008f63 <_wrapup_reent+0x13>
40008fcf:	90                   	nop    

40008fd0 <cleanup_glue>:
	int fflush(<[fp]>)
	FILE *<[fp]>;

DESCRIPTION
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.
40008fd0:	55                   	push   %ebp
40008fd1:	89 e5                	mov    %esp,%ebp
40008fd3:	56                   	push   %esi
40008fd4:	53                   	push   %ebx
40008fd5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
40008fd8:	8b 75 08             	mov    0x8(%ebp),%esi

Use <<fflush>> to deliver any such pending output (for the file
40008fdb:	8b 03                	mov    (%ebx),%eax
40008fdd:	85 c0                	test   %eax,%eax
40008fdf:	74 0c                	je     40008fed <cleanup_glue+0x1d>
or stream identified by <[fp]>) to the host system.
40008fe1:	52                   	push   %edx
40008fe2:	52                   	push   %edx
40008fe3:	50                   	push   %eax
40008fe4:	56                   	push   %esi
40008fe5:	e8 e6 ff ff ff       	call   40008fd0 <cleanup_glue>
40008fea:	83 c4 10             	add    $0x10,%esp

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
40008fed:	89 5d 0c             	mov    %ebx,0xc(%ebp)
40008ff0:	89 75 08             	mov    %esi,0x8(%ebp)
open files.
40008ff3:	8d 65 f8             	lea    -0x8(%ebp),%esp
40008ff6:	5b                   	pop    %ebx
40008ff7:	5e                   	pop    %esi
40008ff8:	5d                   	pop    %ebp
to the host system, in order to minimize the overhead of system calls.

Use <<fflush>> to deliver any such pending output (for the file
or stream identified by <[fp]>) to the host system.

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
40008ff9:	e9 62 df ff ff       	jmp    40006f60 <_free_r>
40008ffe:	66 90                	xchg   %ax,%ax

40009000 <_reclaim_reent>:
open files.

RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.

40009000:	55                   	push   %ebp
40009001:	89 e5                	mov    %esp,%ebp
40009003:	57                   	push   %edi
40009004:	56                   	push   %esi
40009005:	53                   	push   %ebx
40009006:	83 ec 0c             	sub    $0xc,%esp
40009009:	8b 75 08             	mov    0x8(%ebp),%esi
PORTABILITY
4000900c:	3b 35 60 d0 00 40    	cmp    0x4000d060,%esi
40009012:	0f 84 c6 00 00 00    	je     400090de <_reclaim_reent+0xde>
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
*/

#include <_ansi.h>
40009018:	8b 46 4c             	mov    0x4c(%esi),%eax
4000901b:	85 c0                	test   %eax,%eax
4000901d:	74 41                	je     40009060 <_reclaim_reent+0x60>
4000901f:	31 ff                	xor    %edi,%edi
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */

int
_DEFUN(fflush, (fp),
40009021:	8b 04 38             	mov    (%eax,%edi,1),%eax
       register FILE * fp)
40009024:	85 c0                	test   %eax,%eax
40009026:	75 0a                	jne    40009032 <_reclaim_reent+0x32>
40009028:	eb 1a                	jmp    40009044 <_reclaim_reent+0x44>
4000902a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40009030:	89 d8                	mov    %ebx,%eax
{
  register unsigned char *p;
  register int n, t;
40009032:	8b 18                	mov    (%eax),%ebx

40009034:	52                   	push   %edx
40009035:	52                   	push   %edx
40009036:	50                   	push   %eax
40009037:	56                   	push   %esi
40009038:	e8 23 df ff ff       	call   40006f60 <_free_r>

/* Flush a single file, or (if fp is NULL) all files.  */

int
_DEFUN(fflush, (fp),
       register FILE * fp)
4000903d:	83 c4 10             	add    $0x10,%esp
40009040:	85 db                	test   %ebx,%ebx
40009042:	75 ec                	jne    40009030 <_reclaim_reent+0x30>
40009044:	83 c7 04             	add    $0x4,%edi
*/

#include <_ansi.h>
#include <stdio.h>
#include "local.h"

40009047:	83 ff 3c             	cmp    $0x3c,%edi
4000904a:	74 05                	je     40009051 <_reclaim_reent+0x51>
4000904c:	8b 46 4c             	mov    0x4c(%esi),%eax
4000904f:	eb d0                	jmp    40009021 <_reclaim_reent+0x21>
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

  CHECK_INIT (_REENT, fp);
40009051:	57                   	push   %edi
40009052:	57                   	push   %edi
40009053:	8b 5e 4c             	mov    0x4c(%esi),%ebx
40009056:	53                   	push   %ebx
40009057:	56                   	push   %esi
40009058:	e8 03 df ff ff       	call   40006f60 <_free_r>
4000905d:	83 c4 10             	add    $0x10,%esp

  _flockfile (fp);
40009060:	8b 46 40             	mov    0x40(%esi),%eax
40009063:	85 c0                	test   %eax,%eax
40009065:	74 0c                	je     40009073 <_reclaim_reent+0x73>

40009067:	51                   	push   %ecx
40009068:	51                   	push   %ecx
40009069:	50                   	push   %eax
4000906a:	56                   	push   %esi
4000906b:	e8 f0 de ff ff       	call   40006f60 <_free_r>
40009070:	83 c4 10             	add    $0x10,%esp
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
40009073:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
40009079:	85 c0                	test   %eax,%eax
4000907b:	74 27                	je     400090a4 <_reclaim_reent+0xa4>
4000907d:	8d be 4c 01 00 00    	lea    0x14c(%esi),%edi
40009083:	39 f8                	cmp    %edi,%eax
40009085:	75 0b                	jne    40009092 <_reclaim_reent+0x92>
40009087:	eb 1b                	jmp    400090a4 <_reclaim_reent+0xa4>
40009089:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;
40009090:	89 d8                	mov    %ebx,%eax

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
40009092:	8b 18                	mov    (%eax),%ebx
            curoff = fp->_offset;
40009094:	52                   	push   %edx
40009095:	52                   	push   %edx
40009096:	50                   	push   %eax
40009097:	56                   	push   %esi
40009098:	e8 c3 de ff ff       	call   40006f60 <_free_r>
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;
4000909d:	83 c4 10             	add    $0x10,%esp
400090a0:	39 df                	cmp    %ebx,%edi
400090a2:	75 ec                	jne    40009090 <_reclaim_reent+0x90>
            curoff = fp->_offset;
          else
            {
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
400090a4:	8b 46 54             	mov    0x54(%esi),%eax
400090a7:	85 c0                	test   %eax,%eax
400090a9:	74 0c                	je     400090b7 <_reclaim_reent+0xb7>
                {
400090ab:	57                   	push   %edi
400090ac:	57                   	push   %edi
400090ad:	50                   	push   %eax
400090ae:	56                   	push   %esi
400090af:	e8 ac de ff ff       	call   40006f60 <_free_r>
400090b4:	83 c4 10             	add    $0x10,%esp
                  _funlockfile (fp);
                  return 0;
400090b7:	8b 5e 38             	mov    0x38(%esi),%ebx
400090ba:	85 db                	test   %ebx,%ebx
400090bc:	74 20                	je     400090de <_reclaim_reent+0xde>
                }
            }
          if (fp->_flags & __SRD)
            {
400090be:	83 ec 0c             	sub    $0xc,%esp
400090c1:	56                   	push   %esi
400090c2:	ff 56 3c             	call   *0x3c(%esi)
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
400090c5:	8b 86 e0 02 00 00    	mov    0x2e0(%esi),%eax
400090cb:	83 c4 10             	add    $0x10,%esp
400090ce:	85 c0                	test   %eax,%eax
400090d0:	74 0c                	je     400090de <_reclaim_reent+0xde>
              curoff -= fp->_r;
400090d2:	51                   	push   %ecx
400090d3:	51                   	push   %ecx
400090d4:	50                   	push   %eax
400090d5:	56                   	push   %esi
400090d6:	e8 f5 fe ff ff       	call   40008fd0 <cleanup_glue>
400090db:	83 c4 10             	add    $0x10,%esp
              if (HASUB (fp))
                curoff -= fp->_ur;
            }
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
400090de:	8d 65 f4             	lea    -0xc(%ebp),%esp
400090e1:	5b                   	pop    %ebx
400090e2:	5e                   	pop    %esi
400090e3:	5f                   	pop    %edi
400090e4:	5d                   	pop    %ebp
400090e5:	c3                   	ret    
400090e6:	90                   	nop    
400090e7:	90                   	nop    
400090e8:	90                   	nop    
400090e9:	90                   	nop    
400090ea:	90                   	nop    
400090eb:	90                   	nop    
400090ec:	90                   	nop    
400090ed:	90                   	nop    
400090ee:	90                   	nop    
400090ef:	90                   	nop    

400090f0 <lflush>:
	fflush

ANSI_SYNOPSIS
	#include <stdio.h>
	int fflush(FILE *<[fp]>);

400090f0:	55                   	push   %ebp
400090f1:	89 e5                	mov    %esp,%ebp
400090f3:	8b 55 08             	mov    0x8(%ebp),%edx
TRAD_SYNOPSIS
400090f6:	0f bf 42 0c          	movswl 0xc(%edx),%eax
400090fa:	83 e0 09             	and    $0x9,%eax
400090fd:	83 f8 09             	cmp    $0x9,%eax
40009100:	74 0e                	je     40009110 <lflush+0x20>
	#include <stdio.h>
	int fflush(<[fp]>)
	FILE *<[fp]>;
40009102:	31 c0                	xor    %eax,%eax
40009104:	5d                   	pop    %ebp
40009105:	c3                   	ret    
40009106:	8d 76 00             	lea    0x0(%esi),%esi
40009109:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40009110:	5d                   	pop    %ebp
ANSI_SYNOPSIS
	#include <stdio.h>
	int fflush(FILE *<[fp]>);

TRAD_SYNOPSIS
	#include <stdio.h>
40009111:	e9 da 70 ff ff       	jmp    400001f0 <fflush>
40009116:	8d 76 00             	lea    0x0(%esi),%esi
40009119:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

40009120 <__srefill_r>:
Use <<fflush>> to deliver any such pending output (for the file
or stream identified by <[fp]>) to the host system.

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
open files.

40009120:	55                   	push   %ebp
40009121:	89 e5                	mov    %esp,%ebp
40009123:	53                   	push   %ebx
40009124:	83 ec 04             	sub    $0x4,%esp
RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.
40009127:	a1 60 d0 00 40       	mov    0x4000d060,%eax
Use <<fflush>> to deliver any such pending output (for the file
or stream identified by <[fp]>) to the host system.

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
open files.

4000912c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.
4000912f:	85 c0                	test   %eax,%eax
40009131:	74 0b                	je     4000913e <__srefill_r+0x1e>
40009133:	8b 50 38             	mov    0x38(%eax),%edx
40009136:	85 d2                	test   %edx,%edx
40009138:	0f 84 c2 00 00 00    	je     40009200 <__srefill_r+0xe0>

PORTABILITY
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
*/
4000913e:	0f bf 43 0c          	movswl 0xc(%ebx),%eax

RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.

PORTABILITY
40009142:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
*/
40009149:	a8 20                	test   $0x20,%al
4000914b:	0f 85 9f 00 00 00    	jne    400091f0 <__srefill_r+0xd0>

#include <_ansi.h>
#include <stdio.h>
#include "local.h"

40009151:	a8 04                	test   $0x4,%al
40009153:	75 5b                	jne    400091b0 <__srefill_r+0x90>
/* Flush a single file, or (if fp is NULL) all files.  */

40009155:	a8 10                	test   $0x10,%al
40009157:	0f 84 22 01 00 00    	je     4000927f <__srefill_r+0x15f>
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  register unsigned char *p;
  register int n, t;

4000915d:	a8 08                	test   $0x8,%al
4000915f:	0f 85 30 01 00 00    	jne    40009295 <__srefill_r+0x175>

  CHECK_INIT (_REENT, fp);

  _flockfile (fp);

  t = fp->_flags;
40009165:	66 83 4b 0c 04       	orw    $0x4,0xc(%ebx)
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;

          /* Get the physical position we are at in the file.  */
4000916a:	8b 43 10             	mov    0x10(%ebx),%eax
4000916d:	85 c0                	test   %eax,%eax
4000916f:	0f 84 f9 00 00 00    	je     4000926e <__srefill_r+0x14e>
            {
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
                  _funlockfile (fp);
40009175:	f6 43 0c 03          	testb  $0x3,0xc(%ebx)
40009179:	0f 85 c1 00 00 00    	jne    40009240 <__srefill_r+0x120>
                  return 0;
                }
4000917f:	8b 43 10             	mov    0x10(%ebx),%eax
40009182:	89 03                	mov    %eax,(%ebx)
            }
40009184:	51                   	push   %ecx
40009185:	8b 53 14             	mov    0x14(%ebx),%edx
40009188:	52                   	push   %edx
40009189:	50                   	push   %eax
4000918a:	8b 43 1c             	mov    0x1c(%ebx),%eax
4000918d:	50                   	push   %eax
4000918e:	ff 53 20             	call   *0x20(%ebx)
          if (fp->_flags & __SRD)
40009191:	8b 53 0c             	mov    0xc(%ebx),%edx
            {
              /* Current offset is at end of buffer.  Compensate for
40009194:	83 c4 10             	add    $0x10,%esp
                {
                  _funlockfile (fp);
                  return 0;
                }
            }
          if (fp->_flags & __SRD)
40009197:	80 e6 df             	and    $0xdf,%dh
            {
              /* Current offset is at end of buffer.  Compensate for
4000919a:	31 c9                	xor    %ecx,%ecx
              if (curoff == -1L)
                {
                  _funlockfile (fp);
                  return 0;
                }
            }
4000919c:	89 43 04             	mov    %eax,0x4(%ebx)
          if (fp->_flags & __SRD)
4000919f:	66 89 53 0c          	mov    %dx,0xc(%ebx)
            {
              /* Current offset is at end of buffer.  Compensate for
400091a3:	83 f8 00             	cmp    $0x0,%eax
400091a6:	7e 78                	jle    40009220 <__srefill_r+0x100>
              fp->_p = fp->_bf._base;
              if (fp->_flags & __SOFF)
                fp->_offset = curoff;
            }
        } 
      _funlockfile (fp);
400091a8:	89 c8                	mov    %ecx,%eax
400091aa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400091ad:	c9                   	leave  
400091ae:	c3                   	ret    
400091af:	90                   	nop    
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;

      /* For a seekable stream with buffered read characters, we will attempt
400091b0:	8b 53 30             	mov    0x30(%ebx),%edx
400091b3:	85 d2                	test   %edx,%edx
400091b5:	74 b3                	je     4000916a <__srefill_r+0x4a>
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
400091b7:	8d 43 40             	lea    0x40(%ebx),%eax
400091ba:	39 c2                	cmp    %eax,%edx
400091bc:	74 11                	je     400091cf <__srefill_r+0xaf>
400091be:	50                   	push   %eax
400091bf:	50                   	push   %eax
400091c0:	52                   	push   %edx
400091c1:	a1 60 d0 00 40       	mov    0x4000d060,%eax
400091c6:	50                   	push   %eax
400091c7:	e8 94 dd ff ff       	call   40006f60 <_free_r>
400091cc:	83 c4 10             	add    $0x10,%esp
         to the POSIX and SUSv3 standards.  Note that the standards allow
400091cf:	8b 43 3c             	mov    0x3c(%ebx),%eax
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;

      /* For a seekable stream with buffered read characters, we will attempt
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
400091d2:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
         to the POSIX and SUSv3 standards.  Note that the standards allow
400091d9:	89 43 04             	mov    %eax,0x4(%ebx)
400091dc:	85 c0                	test   %eax,%eax
400091de:	74 8a                	je     4000916a <__srefill_r+0x4a>
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
400091e0:	8b 43 38             	mov    0x38(%ebx),%eax
400091e3:	31 c9                	xor    %ecx,%ecx
400091e5:	89 03                	mov    %eax,(%ebx)
              fp->_p = fp->_bf._base;
              if (fp->_flags & __SOFF)
                fp->_offset = curoff;
            }
        } 
      _funlockfile (fp);
400091e7:	89 c8                	mov    %ecx,%eax
400091e9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400091ec:	c9                   	leave  
400091ed:	c3                   	ret    
400091ee:	66 90                	xchg   %ax,%ax
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
              fp->_p = fp->_bf._base;
400091f0:	83 c9 ff             	or     $0xffffffff,%ecx
              if (fp->_flags & __SOFF)
                fp->_offset = curoff;
            }
        } 
      _funlockfile (fp);
400091f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400091f6:	89 c8                	mov    %ecx,%eax
400091f8:	c9                   	leave  
400091f9:	c3                   	ret    
400091fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
open files.

RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.
40009200:	83 ec 0c             	sub    $0xc,%esp
40009203:	50                   	push   %eax
40009204:	e8 f7 71 ff ff       	call   40000400 <__sinit>
40009209:	83 c4 10             	add    $0x10,%esp
4000920c:	e9 2d ff ff ff       	jmp    4000913e <__srefill_r+0x1e>
40009211:	eb 0d                	jmp    40009220 <__srefill_r+0x100>
40009213:	90                   	nop    
40009214:	90                   	nop    
40009215:	90                   	nop    
40009216:	90                   	nop    
40009217:	90                   	nop    
40009218:	90                   	nop    
40009219:	90                   	nop    
4000921a:	90                   	nop    
4000921b:	90                   	nop    
4000921c:	90                   	nop    
4000921d:	90                   	nop    
4000921e:	90                   	nop    
4000921f:	90                   	nop    
              curoff -= fp->_r;
              if (HASUB (fp))
                curoff -= fp->_ur;
            }
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
40009220:	75 38                	jne    4000925a <__srefill_r+0x13a>
            {
40009222:	83 ca 20             	or     $0x20,%edx
40009225:	83 c9 ff             	or     $0xffffffff,%ecx
40009228:	66 89 53 0c          	mov    %dx,0xc(%ebx)
4000922c:	e9 77 ff ff ff       	jmp    400091a8 <__srefill_r+0x88>
40009231:	eb 0d                	jmp    40009240 <__srefill_r+0x120>
40009233:	90                   	nop    
40009234:	90                   	nop    
40009235:	90                   	nop    
40009236:	90                   	nop    
40009237:	90                   	nop    
40009238:	90                   	nop    
40009239:	90                   	nop    
4000923a:	90                   	nop    
4000923b:	90                   	nop    
4000923c:	90                   	nop    
4000923d:	90                   	nop    
4000923e:	90                   	nop    
4000923f:	90                   	nop    
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
                  _funlockfile (fp);
                  return 0;
40009240:	50                   	push   %eax
40009241:	50                   	push   %eax
40009242:	a1 34 bc 00 40       	mov    0x4000bc34,%eax
40009247:	68 f0 90 00 40       	push   $0x400090f0
4000924c:	50                   	push   %eax
4000924d:	e8 ae 74 ff ff       	call   40000700 <_fwalk>
40009252:	83 c4 10             	add    $0x10,%esp
40009255:	e9 25 ff ff ff       	jmp    4000917f <__srefill_r+0x5f>
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
              fp->_p = fp->_bf._base;
4000925a:	66 83 4b 0c 40       	orw    $0x40,0xc(%ebx)
4000925f:	83 c9 ff             	or     $0xffffffff,%ecx
          /* Now physically seek to after byte last read.  */
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
40009262:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
40009269:	e9 3a ff ff ff       	jmp    400091a8 <__srefill_r+0x88>
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
4000926e:	83 ec 0c             	sub    $0xc,%esp
40009271:	53                   	push   %ebx
40009272:	e8 a9 e5 ff ff       	call   40007820 <__smakebuf>
40009277:	83 c4 10             	add    $0x10,%esp
4000927a:	e9 f6 fe ff ff       	jmp    40009175 <__srefill_r+0x55>

/* Flush a single file, or (if fp is NULL) all files.  */

int
_DEFUN(fflush, (fp),
       register FILE * fp)
4000927f:	66 83 4b 0c 40       	orw    $0x40,0xc(%ebx)
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */

int
_DEFUN(fflush, (fp),
40009284:	8b 45 08             	mov    0x8(%ebp),%eax
       register FILE * fp)
40009287:	83 c9 ff             	or     $0xffffffff,%ecx
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */

int
_DEFUN(fflush, (fp),
4000928a:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
40009290:	e9 13 ff ff ff       	jmp    400091a8 <__srefill_r+0x88>
{
  register unsigned char *p;
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);
40009295:	83 ec 0c             	sub    $0xc,%esp
40009298:	53                   	push   %ebx
40009299:	e8 52 6f ff ff       	call   400001f0 <fflush>
4000929e:	83 c4 10             	add    $0x10,%esp
400092a1:	85 c0                	test   %eax,%eax
400092a3:	0f 85 47 ff ff ff    	jne    400091f0 <__srefill_r+0xd0>

  CHECK_INIT (_REENT, fp);
400092a9:	66 83 63 0c f7       	andw   $0xfffffff7,0xc(%ebx)

400092ae:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  _flockfile (fp);
400092b5:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
400092bc:	e9 a4 fe ff ff       	jmp    40009165 <__srefill_r+0x45>
400092c1:	90                   	nop    
400092c2:	90                   	nop    
400092c3:	90                   	nop    
400092c4:	90                   	nop    
400092c5:	90                   	nop    
400092c6:	90                   	nop    
400092c7:	90                   	nop    
400092c8:	90                   	nop    
400092c9:	90                   	nop    
400092ca:	90                   	nop    
400092cb:	90                   	nop    
400092cc:	90                   	nop    
400092cd:	90                   	nop    
400092ce:	90                   	nop    
400092cf:	90                   	nop    

400092d0 <__isinfd>:
  to dl@cs.oswego.edu

* VERSION 2.6.4  Thu Nov 28 07:54:55 1996  Doug Lea  (dl at gee)
  
   Note: There may be an updated version of this malloc obtainable at
           ftp://g.oswego.edu/pub/misc/malloc.c
400092d0:	55                   	push   %ebp
400092d1:	89 e5                	mov    %esp,%ebp
         Check before installing!

400092d3:	8b 45 08             	mov    0x8(%ebp),%eax
400092d6:	8b 55 0c             	mov    0xc(%ebp),%edx
* Why use this malloc?

400092d9:	89 c1                	mov    %eax,%ecx
  This is not the fastest, most space-conserving, most portable, or
  most tunable malloc ever written. However it is among the fastest
  while also being among the most space-conserving, portable and tunable.
400092db:	5d                   	pop    %ebp
   Note: There may be an updated version of this malloc obtainable at
           ftp://g.oswego.edu/pub/misc/malloc.c
         Check before installing!

* Why use this malloc?

400092dc:	f7 d9                	neg    %ecx
400092de:	09 c1                	or     %eax,%ecx
400092e0:	89 d0                	mov    %edx,%eax
400092e2:	c1 e9 1f             	shr    $0x1f,%ecx
400092e5:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
400092ea:	09 c1                	or     %eax,%ecx
  This is not the fastest, most space-conserving, most portable, or
400092ec:	b8 00 00 f0 7f       	mov    $0x7ff00000,%eax
400092f1:	29 c8                	sub    %ecx,%eax
400092f3:	89 c2                	mov    %eax,%edx
400092f5:	f7 da                	neg    %edx
400092f7:	09 c2                	or     %eax,%edx
400092f9:	b8 01 00 00 00       	mov    $0x1,%eax
400092fe:	c1 ea 1f             	shr    $0x1f,%edx
40009301:	29 d0                	sub    %edx,%eax
  most tunable malloc ever written. However it is among the fastest
  while also being among the most space-conserving, portable and tunable.
40009303:	c3                   	ret    
40009304:	90                   	nop    
40009305:	90                   	nop    
40009306:	90                   	nop    
40009307:	90                   	nop    
40009308:	90                   	nop    
40009309:	90                   	nop    
4000930a:	90                   	nop    
4000930b:	90                   	nop    
4000930c:	90                   	nop    
4000930d:	90                   	nop    
4000930e:	90                   	nop    
4000930f:	90                   	nop    

40009310 <__isnand>:
       that `size_t' may be defined on a system as either a signed or
       an unsigned type. To be conservative, values that would appear
       as negative numbers are avoided.  
       Requests for sizes with a negative sign bit will return a
       minimum-sized chunk.

40009310:	55                   	push   %ebp
40009311:	89 e5                	mov    %esp,%ebp
  Maximum overhead wastage per allocated chunk: normally 15 bytes

40009313:	8b 45 08             	mov    0x8(%ebp),%eax
40009316:	8b 55 0c             	mov    0xc(%ebp),%edx
       Alignnment demands, plus the minimum allocatable size restriction
       make the normal worst-case wastage 15 bytes (i.e., up to 15
40009319:	89 c1                	mov    %eax,%ecx
       more bytes will be allocated than were requested in malloc), with 
       two exceptions:
         1. Because requests for zero bytes allocate non-zero space,
4000931b:	5d                   	pop    %ebp
       minimum-sized chunk.

  Maximum overhead wastage per allocated chunk: normally 15 bytes

       Alignnment demands, plus the minimum allocatable size restriction
       make the normal worst-case wastage 15 bytes (i.e., up to 15
4000931c:	f7 d9                	neg    %ecx
4000931e:	09 c1                	or     %eax,%ecx
40009320:	89 d0                	mov    %edx,%eax
40009322:	c1 e9 1f             	shr    $0x1f,%ecx
40009325:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
4000932a:	09 c1                	or     %eax,%ecx
       more bytes will be allocated than were requested in malloc), with 
4000932c:	b8 00 00 f0 7f       	mov    $0x7ff00000,%eax
40009331:	29 c8                	sub    %ecx,%eax
40009333:	c1 e8 1f             	shr    $0x1f,%eax
       two exceptions:
         1. Because requests for zero bytes allocate non-zero space,
40009336:	c3                   	ret    
40009337:	90                   	nop    
40009338:	90                   	nop    
40009339:	90                   	nop    
4000933a:	90                   	nop    
4000933b:	90                   	nop    
4000933c:	90                   	nop    
4000933d:	90                   	nop    
4000933e:	90                   	nop    
4000933f:	90                   	nop    

40009340 <__sccl>:
	FILE *<[fp]>;

DESCRIPTION
The <<stdio>> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

40009340:	55                   	push   %ebp
40009341:	89 e5                	mov    %esp,%ebp
40009343:	57                   	push   %edi
40009344:	56                   	push   %esi
40009345:	53                   	push   %ebx
40009346:	83 ec 08             	sub    $0x8,%esp
40009349:	8b 55 0c             	mov    0xc(%ebp),%edx
4000934c:	8b 4d 08             	mov    0x8(%ebp),%ecx
Use <<fflush>> to deliver any such pending output (for the file
or stream identified by <[fp]>) to the host system.

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
4000934f:	8a 02                	mov    (%edx),%al
40009351:	8d 72 01             	lea    0x1(%edx),%esi
open files.
40009354:	3c 5e                	cmp    $0x5e,%al
40009356:	74 62                	je     400093ba <__sccl+0x7a>
to the host system, in order to minimize the overhead of system calls.

Use <<fflush>> to deliver any such pending output (for the file
or stream identified by <[fp]>) to the host system.

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
40009358:	31 db                	xor    %ebx,%ebx
4000935a:	31 ff                	xor    %edi,%edi
4000935c:	88 c3                	mov    %al,%bl
4000935e:	31 d2                	xor    %edx,%edx
situation, it returns <<EOF>>.

PORTABILITY
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
40009360:	88 11                	mov    %dl,(%ecx)
40009362:	b8 02 00 00 00       	mov    $0x2,%eax
40009367:	89 f6                	mov    %esi,%esi
40009369:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40009370:	88 54 08 ff          	mov    %dl,-0x1(%eax,%ecx,1)
40009374:	40                   	inc    %eax
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.

PORTABILITY
ANSI C requires <<fflush>>.

40009375:	3d 01 01 00 00       	cmp    $0x101,%eax
4000937a:	75 f4                	jne    40009370 <__sccl+0x30>
No supporting OS subroutines are required.
*/
4000937c:	85 db                	test   %ebx,%ebx
4000937e:	74 2c                	je     400093ac <__sccl+0x6c>

40009380:	b8 01 00 00 00       	mov    $0x1,%eax
40009385:	89 fa                	mov    %edi,%edx
40009387:	28 d0                	sub    %dl,%al
40009389:	88 45 f3             	mov    %al,-0xd(%ebp)
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  register unsigned char *p;
  register int n, t;

4000938c:	8a 45 f3             	mov    -0xd(%ebp),%al
4000938f:	8d 7e 01             	lea    0x1(%esi),%edi
40009392:	88 04 19             	mov    %al,(%ecx,%ebx,1)
  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);
40009395:	8a 57 ff             	mov    -0x1(%edi),%dl
40009398:	31 c0                	xor    %eax,%eax
4000939a:	88 d0                	mov    %dl,%al
4000939c:	89 fe                	mov    %edi,%esi

4000939e:	80 fa 2d             	cmp    $0x2d,%dl
400093a1:	74 28                	je     400093cb <__sccl+0x8b>
400093a3:	80 fa 5d             	cmp    $0x5d,%dl
400093a6:	74 05                	je     400093ad <__sccl+0x6d>
400093a8:	84 d2                	test   %dl,%dl
400093aa:	75 0a                	jne    400093b6 <__sccl+0x76>
  CHECK_INIT (_REENT, fp);

  _flockfile (fp);

400093ac:	4e                   	dec    %esi
              fp->_p = fp->_bf._base;
              if (fp->_flags & __SOFF)
                fp->_offset = curoff;
            }
        } 
      _funlockfile (fp);
400093ad:	89 f0                	mov    %esi,%eax
400093af:	5a                   	pop    %edx
400093b0:	59                   	pop    %ecx
400093b1:	5b                   	pop    %ebx
400093b2:	5e                   	pop    %esi
400093b3:	5f                   	pop    %edi
400093b4:	5d                   	pop    %ebp
400093b5:	c3                   	ret    
  register unsigned char *p;
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

400093b6:	89 c3                	mov    %eax,%ebx
400093b8:	eb d2                	jmp    4000938c <__sccl+0x4c>

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
open files.

RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
400093ba:	31 db                	xor    %ebx,%ebx
400093bc:	8d 72 02             	lea    0x2(%edx),%esi
400093bf:	8a 5a 01             	mov    0x1(%edx),%bl
400093c2:	bf 01 00 00 00       	mov    $0x1,%edi
400093c7:	b2 01                	mov    $0x1,%dl
400093c9:	eb 95                	jmp    40009360 <__sccl+0x20>

      /* For a seekable stream with buffered read characters, we will attempt
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
400093cb:	31 d2                	xor    %edx,%edx
400093cd:	8a 17                	mov    (%edi),%dl
400093cf:	89 55 ec             	mov    %edx,-0x14(%ebp)
         to make the change simpler, more contained, and less likely
400093d2:	83 fa 5d             	cmp    $0x5d,%edx
400093d5:	74 04                	je     400093db <__sccl+0x9b>
400093d7:	39 da                	cmp    %ebx,%edx
400093d9:	7d 15                	jge    400093f0 <__sccl+0xb0>
PORTABILITY
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
*/

400093db:	bb 2d 00 00 00       	mov    $0x2d,%ebx
400093e0:	eb aa                	jmp    4000938c <__sccl+0x4c>
400093e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
400093e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
      /* For a seekable stream with buffered read characters, we will attempt
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
400093f0:	8d 14 0b             	lea    (%ebx,%ecx,1),%edx
        {
          _fpos_t curoff;

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
400093f3:	8a 45 f3             	mov    -0xd(%ebp),%al
400093f6:	43                   	inc    %ebx
400093f7:	88 42 01             	mov    %al,0x1(%edx)
400093fa:	42                   	inc    %edx
          else
            {
400093fb:	39 5d ec             	cmp    %ebx,-0x14(%ebp)
400093fe:	7f f3                	jg     400093f3 <__sccl+0xb3>
40009400:	83 c7 02             	add    $0x2,%edi
40009403:	eb 90                	jmp    40009395 <__sccl+0x55>
40009405:	90                   	nop    
40009406:	90                   	nop    
40009407:	90                   	nop    
40009408:	90                   	nop    
40009409:	90                   	nop    
4000940a:	90                   	nop    
4000940b:	90                   	nop    
4000940c:	90                   	nop    
4000940d:	90                   	nop    
4000940e:	90                   	nop    
4000940f:	90                   	nop    

40009410 <nanf>:
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
40009410:	55                   	push   %ebp
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
40009411:	b8 00 00 c0 7f       	mov    $0x7fc00000,%eax
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
40009416:	89 e5                	mov    %esp,%ebp
40009418:	83 ec 04             	sub    $0x4,%esp
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
4000941b:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000941e:	d9 45 fc             	flds   -0x4(%ebp)
40009421:	c9                   	leave  
40009422:	c3                   	ret    
40009423:	90                   	nop    
40009424:	90                   	nop    
40009425:	90                   	nop    
40009426:	90                   	nop    
40009427:	90                   	nop    
40009428:	90                   	nop    
40009429:	90                   	nop    
4000942a:	90                   	nop    
4000942b:	90                   	nop    
4000942c:	90                   	nop    
4000942d:	90                   	nop    
4000942e:	90                   	nop    
4000942f:	90                   	nop    

40009430 <sprintf>:
40009430:	55                   	push   %ebp
40009431:	89 e5                	mov    %esp,%ebp
40009433:	83 ec 68             	sub    $0x68,%esp
40009436:	8b 45 08             	mov    0x8(%ebp),%eax
40009439:	8b 55 0c             	mov    0xc(%ebp),%edx
4000943c:	89 45 a0             	mov    %eax,-0x60(%ebp)
4000943f:	89 45 b0             	mov    %eax,-0x50(%ebp)
40009442:	8d 45 10             	lea    0x10(%ebp),%eax
40009445:	66 c7 45 ac 08 02    	movw   $0x208,-0x54(%ebp)
4000944b:	50                   	push   %eax
4000944c:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000944f:	8d 45 a0             	lea    -0x60(%ebp),%eax
40009452:	52                   	push   %edx
40009453:	50                   	push   %eax
40009454:	a1 60 d0 00 40       	mov    0x4000d060,%eax
40009459:	c7 45 a8 ff ff ff 7f 	movl   $0x7fffffff,-0x58(%ebp)
40009460:	c7 45 b4 ff ff ff 7f 	movl   $0x7fffffff,-0x4c(%ebp)
40009467:	66 c7 45 ae ff ff    	movw   $0xffff,-0x52(%ebp)
4000946d:	50                   	push   %eax
4000946e:	e8 4d 81 ff ff       	call   400015c0 <_vfprintf_r>
40009473:	8b 55 a0             	mov    -0x60(%ebp),%edx
40009476:	c6 02 00             	movb   $0x0,(%edx)
40009479:	c9                   	leave  
4000947a:	c3                   	ret    
4000947b:	90                   	nop    
4000947c:	8d 74 26 00          	lea    0x0(%esi),%esi

40009480 <_sprintf_r>:
40009480:	55                   	push   %ebp
40009481:	89 e5                	mov    %esp,%ebp
40009483:	83 ec 68             	sub    $0x68,%esp
40009486:	8b 45 0c             	mov    0xc(%ebp),%eax
40009489:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000948c:	89 45 a0             	mov    %eax,-0x60(%ebp)
4000948f:	89 45 b0             	mov    %eax,-0x50(%ebp)
40009492:	8d 45 14             	lea    0x14(%ebp),%eax
40009495:	66 c7 45 ac 08 02    	movw   $0x208,-0x54(%ebp)
4000949b:	50                   	push   %eax
4000949c:	89 45 fc             	mov    %eax,-0x4(%ebp)
4000949f:	8b 45 10             	mov    0x10(%ebp),%eax
400094a2:	c7 45 a8 ff ff ff 7f 	movl   $0x7fffffff,-0x58(%ebp)
400094a9:	50                   	push   %eax
400094aa:	8d 45 a0             	lea    -0x60(%ebp),%eax
400094ad:	50                   	push   %eax
400094ae:	c7 45 b4 ff ff ff 7f 	movl   $0x7fffffff,-0x4c(%ebp)
400094b5:	66 c7 45 ae ff ff    	movw   $0xffff,-0x52(%ebp)
400094bb:	51                   	push   %ecx
400094bc:	e8 ff 80 ff ff       	call   400015c0 <_vfprintf_r>
400094c1:	8b 55 a0             	mov    -0x60(%ebp),%edx
400094c4:	c6 02 00             	movb   $0x0,(%edx)
400094c7:	c9                   	leave  
400094c8:	c3                   	ret    
400094c9:	90                   	nop    
400094ca:	90                   	nop    
400094cb:	90                   	nop    
400094cc:	90                   	nop    
400094cd:	90                   	nop    
400094ce:	90                   	nop    
400094cf:	90                   	nop    

400094d0 <strcmp>:

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  register unsigned char *p;
400094d0:	55                   	push   %ebp
400094d1:	89 e5                	mov    %esp,%ebp
400094d3:	53                   	push   %ebx
400094d4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
400094d7:	8b 55 08             	mov    0x8(%ebp),%edx

  t = fp->_flags;
  if ((t & __SWR) == 0)
    {
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));

400094da:	89 c8                	mov    %ecx,%eax
400094dc:	09 d0                	or     %edx,%eax
400094de:	a8 03                	test   $0x3,%al
400094e0:	75 24                	jne    40009506 <strcmp+0x36>
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
400094e2:	89 d3                	mov    %edx,%ebx
      fp->_flags |= __SNPT;

400094e4:	8b 12                	mov    (%edx),%edx
400094e6:	3b 11                	cmp    (%ecx),%edx
400094e8:	74 42                	je     4000952c <strcmp+0x5c>
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
        {
          _fpos_t curoff;

          /* Get the physical position we are at in the file.  */
400094ea:	89 da                	mov    %ebx,%edx
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
            {
400094ec:	8a 02                	mov    (%edx),%al
400094ee:	84 c0                	test   %al,%al
400094f0:	74 1a                	je     4000950c <strcmp+0x3c>
400094f2:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
400094f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40009500:	3a 01                	cmp    (%ecx),%al
40009502:	75 08                	jne    4000950c <strcmp+0x3c>
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
40009504:	42                   	inc    %edx
              if (curoff == -1L)
40009505:	41                   	inc    %ecx

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
          else
            {
40009506:	8a 02                	mov    (%edx),%al
40009508:	84 c0                	test   %al,%al
4000950a:	75 f4                	jne    40009500 <strcmp+0x30>
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
                  _funlockfile (fp);
4000950c:	8a 12                	mov    (%edx),%dl
4000950e:	31 c0                	xor    %eax,%eax
40009510:	8a 01                	mov    (%ecx),%al
40009512:	81 e2 ff 00 00 00    	and    $0xff,%edx
40009518:	29 c2                	sub    %eax,%edx
                  return 0;
                }
4000951a:	5b                   	pop    %ebx
4000951b:	89 d0                	mov    %edx,%eax
4000951d:	5d                   	pop    %ebp
4000951e:	c3                   	ret    
4000951f:	90                   	nop    
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
40009520:	83 c3 04             	add    $0x4,%ebx
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
40009523:	83 c1 04             	add    $0x4,%ecx

      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;

40009526:	8b 13                	mov    (%ebx),%edx
40009528:	3b 11                	cmp    (%ecx),%edx
4000952a:	75 be                	jne    400094ea <strcmp+0x1a>
      /* For a seekable stream with buffered read characters, we will attempt
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
4000952c:	8d 82 ff fe fe fe    	lea    -0x1010101(%edx),%eax
40009532:	83 f2 ff             	xor    $0xffffffff,%edx
40009535:	21 d0                	and    %edx,%eax
40009537:	a9 80 80 80 80       	test   $0x80808080,%eax
4000953c:	74 e2                	je     40009520 <strcmp+0x50>
            {
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
                  _funlockfile (fp);
4000953e:	31 d2                	xor    %edx,%edx
                  return 0;
                }
40009540:	5b                   	pop    %ebx
40009541:	89 d0                	mov    %edx,%eax
40009543:	5d                   	pop    %ebp
40009544:	c3                   	ret    
40009545:	90                   	nop    
40009546:	90                   	nop    
40009547:	90                   	nop    
40009548:	90                   	nop    
40009549:	90                   	nop    
4000954a:	90                   	nop    
4000954b:	90                   	nop    
4000954c:	90                   	nop    
4000954d:	90                   	nop    
4000954e:	90                   	nop    
4000954f:	90                   	nop    

40009550 <match>:
40009550:	55                   	push   %ebp
40009551:	89 e5                	mov    %esp,%ebp
40009553:	56                   	push   %esi
40009554:	53                   	push   %ebx
40009555:	89 c6                	mov    %eax,%esi
40009557:	8b 18                	mov    (%eax),%ebx
40009559:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40009560:	8a 02                	mov    (%edx),%al
40009562:	42                   	inc    %edx
40009563:	84 c0                	test   %al,%al
40009565:	74 26                	je     4000958d <match+0x3d>
40009567:	43                   	inc    %ebx
40009568:	0f be 0b             	movsbl (%ebx),%ecx
4000956b:	83 f9 40             	cmp    $0x40,%ecx
4000956e:	7e 10                	jle    40009580 <match+0x30>
40009570:	83 f9 5a             	cmp    $0x5a,%ecx
40009573:	7f 0b                	jg     40009580 <match+0x30>
40009575:	83 c1 20             	add    $0x20,%ecx
40009578:	90                   	nop    
40009579:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40009580:	0f be c0             	movsbl %al,%eax
40009583:	39 c1                	cmp    %eax,%ecx
40009585:	74 d9                	je     40009560 <match+0x10>
40009587:	31 c0                	xor    %eax,%eax
40009589:	5b                   	pop    %ebx
4000958a:	5e                   	pop    %esi
4000958b:	5d                   	pop    %ebp
4000958c:	c3                   	ret    
4000958d:	8d 43 01             	lea    0x1(%ebx),%eax
40009590:	89 06                	mov    %eax,(%esi)
40009592:	b8 01 00 00 00       	mov    $0x1,%eax
40009597:	5b                   	pop    %ebx
40009598:	5e                   	pop    %esi
40009599:	5d                   	pop    %ebp
4000959a:	c3                   	ret    
4000959b:	90                   	nop    
4000959c:	8d 74 26 00          	lea    0x0(%esi),%esi

400095a0 <_strtod_r>:
400095a0:	55                   	push   %ebp
400095a1:	89 e5                	mov    %esp,%ebp
400095a3:	57                   	push   %edi
400095a4:	56                   	push   %esi
400095a5:	53                   	push   %ebx
400095a6:	81 ec dc 00 00 00    	sub    $0xdc,%esp
400095ac:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
400095b3:	8b 7d 0c             	mov    0xc(%ebp),%edi
400095b6:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
400095bd:	89 7d dc             	mov    %edi,-0x24(%ebp)
400095c0:	8b 4d dc             	mov    -0x24(%ebp),%ecx
400095c3:	80 39 2d             	cmpb   $0x2d,(%ecx)
400095c6:	0f 86 84 01 00 00    	jbe    40009750 <_strtod_r+0x1b0>
400095cc:	c7 85 70 ff ff ff 00 	movl   $0x0,-0x90(%ebp)
400095d3:	00 00 00 
400095d6:	c7 85 6c ff ff ff 00 	movl   $0x0,-0x94(%ebp)
400095dd:	00 00 00 
400095e0:	80 39 30             	cmpb   $0x30,(%ecx)
400095e3:	0f 84 0d 02 00 00    	je     400097f6 <_strtod_r+0x256>
400095e9:	89 8d 74 ff ff ff    	mov    %ecx,-0x8c(%ebp)
400095ef:	8a 01                	mov    (%ecx),%al
400095f1:	0f be d0             	movsbl %al,%edx
400095f4:	83 fa 2f             	cmp    $0x2f,%edx
400095f7:	0f 8e 93 0c 00 00    	jle    4000a290 <_strtod_r+0xcf0>
400095fd:	83 fa 39             	cmp    $0x39,%edx
40009600:	0f 8f 8a 0c 00 00    	jg     4000a290 <_strtod_r+0xcf0>
40009606:	31 db                	xor    %ebx,%ebx
40009608:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
4000960f:	00 00 00 
40009612:	c7 45 80 00 00 00 00 	movl   $0x0,-0x80(%ebp)
40009619:	eb 3a                	jmp    40009655 <_strtod_r+0xb5>
4000961b:	90                   	nop    
4000961c:	8d 74 26 00          	lea    0x0(%esi),%esi
40009620:	83 fb 0f             	cmp    $0xf,%ebx
40009623:	7f 48                	jg     4000966d <_strtod_r+0xcd>
40009625:	8b 75 80             	mov    -0x80(%ebp),%esi
40009628:	41                   	inc    %ecx
40009629:	89 4d dc             	mov    %ecx,-0x24(%ebp)
4000962c:	43                   	inc    %ebx
4000962d:	8d 04 b6             	lea    (%esi,%esi,4),%eax
40009630:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
40009634:	89 45 80             	mov    %eax,-0x80(%ebp)
40009637:	8a 01                	mov    (%ecx),%al
40009639:	0f be d0             	movsbl %al,%edx
4000963c:	83 fa 2f             	cmp    $0x2f,%edx
4000963f:	7e 3b                	jle    4000967c <_strtod_r+0xdc>
40009641:	eb 0d                	jmp    40009650 <_strtod_r+0xb0>
40009643:	90                   	nop    
40009644:	90                   	nop    
40009645:	90                   	nop    
40009646:	90                   	nop    
40009647:	90                   	nop    
40009648:	90                   	nop    
40009649:	90                   	nop    
4000964a:	90                   	nop    
4000964b:	90                   	nop    
4000964c:	90                   	nop    
4000964d:	90                   	nop    
4000964e:	90                   	nop    
4000964f:	90                   	nop    
40009650:	83 fa 39             	cmp    $0x39,%edx
40009653:	7f 27                	jg     4000967c <_strtod_r+0xdc>
40009655:	83 fb 08             	cmp    $0x8,%ebx
40009658:	7f c6                	jg     40009620 <_strtod_r+0x80>
4000965a:	8b b5 7c ff ff ff    	mov    -0x84(%ebp),%esi
40009660:	8d 04 b6             	lea    (%esi,%esi,4),%eax
40009663:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
40009667:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
4000966d:	41                   	inc    %ecx
4000966e:	43                   	inc    %ebx
4000966f:	89 4d dc             	mov    %ecx,-0x24(%ebp)
40009672:	8a 01                	mov    (%ecx),%al
40009674:	0f be d0             	movsbl %al,%edx
40009677:	83 fa 2f             	cmp    $0x2f,%edx
4000967a:	7f d4                	jg     40009650 <_strtod_r+0xb0>
4000967c:	3c 2e                	cmp    $0x2e,%al
4000967e:	0f 84 cc 02 00 00    	je     40009950 <_strtod_r+0x3b0>
40009684:	89 5d 8c             	mov    %ebx,-0x74(%ebp)
40009687:	c7 85 58 ff ff ff 00 	movl   $0x0,-0xa8(%ebp)
4000968e:	00 00 00 
40009691:	c7 85 64 ff ff ff 00 	movl   $0x0,-0x9c(%ebp)
40009698:	00 00 00 
4000969b:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%ebp)
400096a2:	00 00 00 
400096a5:	83 fa 65             	cmp    $0x65,%edx
400096a8:	0f 84 a1 01 00 00    	je     4000984f <_strtod_r+0x2af>
400096ae:	83 fa 45             	cmp    $0x45,%edx
400096b1:	0f 84 98 01 00 00    	je     4000984f <_strtod_r+0x2af>
400096b7:	31 c0                	xor    %eax,%eax
400096b9:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
400096bc:	85 c9                	test   %ecx,%ecx
400096be:	0f 84 97 00 00 00    	je     4000975b <_strtod_r+0x1bb>
400096c4:	8b bd 64 ff ff ff    	mov    -0x9c(%ebp),%edi
400096ca:	29 f8                	sub    %edi,%eax
400096cc:	85 db                	test   %ebx,%ebx
400096ce:	89 45 90             	mov    %eax,-0x70(%ebp)
400096d1:	75 03                	jne    400096d6 <_strtod_r+0x136>
400096d3:	8b 5d 8c             	mov    -0x74(%ebp),%ebx
400096d6:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
400096d9:	83 f9 10             	cmp    $0x10,%ecx
400096dc:	7e 05                	jle    400096e3 <_strtod_r+0x143>
400096de:	b9 10 00 00 00       	mov    $0x10,%ecx
400096e3:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
400096e9:	31 d2                	xor    %edx,%edx
400096eb:	52                   	push   %edx
400096ec:	50                   	push   %eax
400096ed:	df 2c 24             	fildll (%esp)
400096f0:	83 c4 08             	add    $0x8,%esp
400096f3:	83 f9 09             	cmp    $0x9,%ecx
400096f6:	dd 55 c0             	fstl   -0x40(%ebp)
400096f9:	0f 8e bc 06 00 00    	jle    40009dbb <_strtod_r+0x81b>
400096ff:	dc 0c cd d8 c5 00 40 	fmull  0x4000c5d8(,%ecx,8)
40009706:	8b 45 80             	mov    -0x80(%ebp),%eax
40009709:	31 d2                	xor    %edx,%edx
4000970b:	52                   	push   %edx
4000970c:	50                   	push   %eax
4000970d:	df 2c 24             	fildll (%esp)
40009710:	de c1                	faddp  %st,%st(1)
40009712:	83 c4 08             	add    $0x8,%esp
40009715:	dd 5d c0             	fstpl  -0x40(%ebp)
40009718:	83 7d 8c 0f          	cmpl   $0xf,-0x74(%ebp)
4000971c:	0f 8f 0e 03 00 00    	jg     40009a30 <_strtod_r+0x490>
40009722:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
40009726:	74 65                	je     4000978d <_strtod_r+0x1ed>
40009728:	0f 8e ff 0e 00 00    	jle    4000a62d <_strtod_r+0x108d>
4000972e:	83 7d 90 16          	cmpl   $0x16,-0x70(%ebp)
40009732:	0f 8f 56 0e 00 00    	jg     4000a58e <_strtod_r+0xfee>
40009738:	8b 75 90             	mov    -0x70(%ebp),%esi
4000973b:	dd 45 c0             	fldl   -0x40(%ebp)
4000973e:	dc 0c f5 20 c6 00 40 	fmull  0x4000c620(,%esi,8)
40009745:	dd 5d c0             	fstpl  -0x40(%ebp)
40009748:	eb 43                	jmp    4000978d <_strtod_r+0x1ed>
4000974a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40009750:	31 c0                	xor    %eax,%eax
40009752:	8a 01                	mov    (%ecx),%al
40009754:	ff 24 85 80 c7 00 40 	jmp    *0x4000c780(,%eax,4)
4000975b:	8b 8d 68 ff ff ff    	mov    -0x98(%ebp),%ecx
40009761:	0b 8d 6c ff ff ff    	or     -0x94(%ebp),%ecx
40009767:	75 24                	jne    4000978d <_strtod_r+0x1ed>
40009769:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
4000976f:	85 c0                	test   %eax,%eax
40009771:	0f 84 c8 06 00 00    	je     40009e3f <_strtod_r+0x89f>
40009777:	89 f6                	mov    %esi,%esi
40009779:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40009780:	89 7d dc             	mov    %edi,-0x24(%ebp)
40009783:	c7 85 70 ff ff ff 00 	movl   $0x0,-0x90(%ebp)
4000978a:	00 00 00 
4000978d:	8b 55 10             	mov    0x10(%ebp),%edx
40009790:	85 d2                	test   %edx,%edx
40009792:	74 08                	je     4000979c <_strtod_r+0x1fc>
40009794:	8b 4d 10             	mov    0x10(%ebp),%ecx
40009797:	8b 45 dc             	mov    -0x24(%ebp),%eax
4000979a:	89 01                	mov    %eax,(%ecx)
4000979c:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
400097a2:	85 c0                	test   %eax,%eax
400097a4:	74 1a                	je     400097c0 <_strtod_r+0x220>
400097a6:	dd 45 c0             	fldl   -0x40(%ebp)
400097a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
400097ac:	d9 e0                	fchs   
400097ae:	5b                   	pop    %ebx
400097af:	5e                   	pop    %esi
400097b0:	5f                   	pop    %edi
400097b1:	5d                   	pop    %ebp
400097b2:	c3                   	ret    
400097b3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
400097b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
400097c0:	dd 45 c0             	fldl   -0x40(%ebp)
400097c3:	8d 65 f4             	lea    -0xc(%ebp),%esp
400097c6:	5b                   	pop    %ebx
400097c7:	5e                   	pop    %esi
400097c8:	5f                   	pop    %edi
400097c9:	5d                   	pop    %ebp
400097ca:	c3                   	ret    
400097cb:	c7 85 70 ff ff ff 01 	movl   $0x1,-0x90(%ebp)
400097d2:	00 00 00 
400097d5:	8d 41 01             	lea    0x1(%ecx),%eax
400097d8:	89 45 dc             	mov    %eax,-0x24(%ebp)
400097db:	80 79 01 00          	cmpb   $0x0,0x1(%ecx)
400097df:	74 9f                	je     40009780 <_strtod_r+0x1e0>
400097e1:	89 c1                	mov    %eax,%ecx
400097e3:	c7 85 6c ff ff ff 00 	movl   $0x0,-0x94(%ebp)
400097ea:	00 00 00 
400097ed:	80 39 30             	cmpb   $0x30,(%ecx)
400097f0:	0f 85 f3 fd ff ff    	jne    400095e9 <_strtod_r+0x49>
400097f6:	8a 41 01             	mov    0x1(%ecx),%al
400097f9:	3c 58                	cmp    $0x58,%al
400097fb:	0f 84 9f 09 00 00    	je     4000a1a0 <_strtod_r+0xc00>
40009801:	3c 78                	cmp    $0x78,%al
40009803:	75 0d                	jne    40009812 <_strtod_r+0x272>
40009805:	e9 96 09 00 00       	jmp    4000a1a0 <_strtod_r+0xc00>
4000980a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40009810:	89 d1                	mov    %edx,%ecx
40009812:	8d 51 01             	lea    0x1(%ecx),%edx
40009815:	89 55 dc             	mov    %edx,-0x24(%ebp)
40009818:	8a 41 01             	mov    0x1(%ecx),%al
4000981b:	3c 30                	cmp    $0x30,%al
4000981d:	74 f1                	je     40009810 <_strtod_r+0x270>
4000981f:	84 c0                	test   %al,%al
40009821:	0f 84 66 ff ff ff    	je     4000978d <_strtod_r+0x1ed>
40009827:	89 d1                	mov    %edx,%ecx
40009829:	c7 85 6c ff ff ff 01 	movl   $0x1,-0x94(%ebp)
40009830:	00 00 00 
40009833:	e9 b1 fd ff ff       	jmp    400095e9 <_strtod_r+0x49>
40009838:	c7 85 70 ff ff ff 00 	movl   $0x0,-0x90(%ebp)
4000983f:	00 00 00 
40009842:	eb 91                	jmp    400097d5 <_strtod_r+0x235>
40009844:	8d 41 01             	lea    0x1(%ecx),%eax
40009847:	89 45 dc             	mov    %eax,-0x24(%ebp)
4000984a:	e9 71 fd ff ff       	jmp    400095c0 <_strtod_r+0x20>
4000984f:	8b 45 8c             	mov    -0x74(%ebp),%eax
40009852:	8b 95 68 ff ff ff    	mov    -0x98(%ebp),%edx
40009858:	09 d0                	or     %edx,%eax
4000985a:	0b 85 6c ff ff ff    	or     -0x94(%ebp),%eax
40009860:	0f 84 1a ff ff ff    	je     40009780 <_strtod_r+0x1e0>
40009866:	8b 7d dc             	mov    -0x24(%ebp),%edi
40009869:	8d 57 01             	lea    0x1(%edi),%edx
4000986c:	89 55 dc             	mov    %edx,-0x24(%ebp)
4000986f:	8a 47 01             	mov    0x1(%edi),%al
40009872:	3c 2b                	cmp    $0x2b,%al
40009874:	74 1d                	je     40009893 <_strtod_r+0x2f3>
40009876:	c7 85 5c ff ff ff 01 	movl   $0x1,-0xa4(%ebp)
4000987d:	00 00 00 
40009880:	3c 2d                	cmp    $0x2d,%al
40009882:	74 19                	je     4000989d <_strtod_r+0x2fd>
40009884:	0f be d0             	movsbl %al,%edx
40009887:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
4000988e:	00 00 00 
40009891:	eb 14                	jmp    400098a7 <_strtod_r+0x307>
40009893:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
4000989a:	00 00 00 
4000989d:	8d 42 01             	lea    0x1(%edx),%eax
400098a0:	89 45 dc             	mov    %eax,-0x24(%ebp)
400098a3:	0f be 52 01          	movsbl 0x1(%edx),%edx
400098a7:	8d 42 d0             	lea    -0x30(%edx),%eax
400098aa:	83 f8 09             	cmp    $0x9,%eax
400098ad:	0f 87 82 05 00 00    	ja     40009e35 <_strtod_r+0x895>
400098b3:	83 fa 30             	cmp    $0x30,%edx
400098b6:	75 13                	jne    400098cb <_strtod_r+0x32b>
400098b8:	8b 45 dc             	mov    -0x24(%ebp),%eax
400098bb:	8d 50 01             	lea    0x1(%eax),%edx
400098be:	89 55 dc             	mov    %edx,-0x24(%ebp)
400098c1:	8a 40 01             	mov    0x1(%eax),%al
400098c4:	0f be d0             	movsbl %al,%edx
400098c7:	3c 30                	cmp    $0x30,%al
400098c9:	74 ed                	je     400098b8 <_strtod_r+0x318>
400098cb:	8d 42 cf             	lea    -0x31(%edx),%eax
400098ce:	83 f8 08             	cmp    $0x8,%eax
400098d1:	0f 87 e0 fd ff ff    	ja     400096b7 <_strtod_r+0x117>
400098d7:	8b 4d dc             	mov    -0x24(%ebp),%ecx
400098da:	8d 72 d0             	lea    -0x30(%edx),%esi
400098dd:	89 8d 78 ff ff ff    	mov    %ecx,-0x88(%ebp)
400098e3:	41                   	inc    %ecx
400098e4:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
400098ea:	89 4d dc             	mov    %ecx,-0x24(%ebp)
400098ed:	0f be 50 01          	movsbl 0x1(%eax),%edx
400098f1:	83 fa 2f             	cmp    $0x2f,%edx
400098f4:	7f 23                	jg     40009919 <_strtod_r+0x379>
400098f6:	eb 26                	jmp    4000991e <_strtod_r+0x37e>
400098f8:	90                   	nop    
400098f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
40009900:	8d 04 b6             	lea    (%esi,%esi,4),%eax
40009903:	8d 74 42 d0          	lea    -0x30(%edx,%eax,2),%esi
40009907:	8b 45 dc             	mov    -0x24(%ebp),%eax
4000990a:	8d 48 01             	lea    0x1(%eax),%ecx
4000990d:	89 4d dc             	mov    %ecx,-0x24(%ebp)
40009910:	0f be 50 01          	movsbl 0x1(%eax),%edx
40009914:	83 fa 2f             	cmp    $0x2f,%edx
40009917:	7e 05                	jle    4000991e <_strtod_r+0x37e>
40009919:	83 fa 39             	cmp    $0x39,%edx
4000991c:	7e e2                	jle    40009900 <_strtod_r+0x360>
4000991e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
40009924:	29 c1                	sub    %eax,%ecx
40009926:	83 f9 08             	cmp    $0x8,%ecx
40009929:	7f 0a                	jg     40009935 <_strtod_r+0x395>
4000992b:	89 f0                	mov    %esi,%eax
4000992d:	81 fe 1f 4e 00 00    	cmp    $0x4e1f,%esi
40009933:	7e 05                	jle    4000993a <_strtod_r+0x39a>
40009935:	b8 1f 4e 00 00       	mov    $0x4e1f,%eax
4000993a:	8b b5 5c ff ff ff    	mov    -0xa4(%ebp),%esi
40009940:	85 f6                	test   %esi,%esi
40009942:	0f 84 71 fd ff ff    	je     400096b9 <_strtod_r+0x119>
40009948:	f7 d8                	neg    %eax
4000994a:	e9 6a fd ff ff       	jmp    400096b9 <_strtod_r+0x119>
4000994f:	90                   	nop    
40009950:	8d 41 01             	lea    0x1(%ecx),%eax
40009953:	85 db                	test   %ebx,%ebx
40009955:	89 45 dc             	mov    %eax,-0x24(%ebp)
40009958:	8a 41 01             	mov    0x1(%ecx),%al
4000995b:	0f be d0             	movsbl %al,%edx
4000995e:	0f 84 5e 04 00 00    	je     40009dc2 <_strtod_r+0x822>
40009964:	89 5d 8c             	mov    %ebx,-0x74(%ebp)
40009967:	c7 85 64 ff ff ff 00 	movl   $0x0,-0x9c(%ebp)
4000996e:	00 00 00 
40009971:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%ebp)
40009978:	00 00 00 
4000997b:	8d 42 d0             	lea    -0x30(%edx),%eax
4000997e:	c7 85 58 ff ff ff 01 	movl   $0x1,-0xa8(%ebp)
40009985:	00 00 00 
40009988:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
4000998e:	83 f8 09             	cmp    $0x9,%eax
40009991:	0f 87 0e fd ff ff    	ja     400096a5 <_strtod_r+0x105>
40009997:	8b 8d 68 ff ff ff    	mov    -0x98(%ebp),%ecx
4000999d:	8b 55 8c             	mov    -0x74(%ebp),%edx
400099a0:	41                   	inc    %ecx
400099a1:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)
400099a7:	89 8d 68 ff ff ff    	mov    %ecx,-0x98(%ebp)
400099ad:	8b 4d dc             	mov    -0x24(%ebp),%ecx
400099b0:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
400099b6:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
400099bc:	89 45 8c             	mov    %eax,-0x74(%ebp)
400099bf:	85 d2                	test   %edx,%edx
400099c1:	0f 84 03 09 00 00    	je     4000a2ca <_strtod_r+0xd2a>
400099c7:	8b 95 68 ff ff ff    	mov    -0x98(%ebp),%edx
400099cd:	8b b5 64 ff ff ff    	mov    -0x9c(%ebp),%esi
400099d3:	01 d6                	add    %edx,%esi
400099d5:	4a                   	dec    %edx
400099d6:	89 b5 64 ff ff ff    	mov    %esi,-0x9c(%ebp)
400099dc:	0f 8e 5b 0b 00 00    	jle    4000a53d <_strtod_r+0xf9d>
400099e2:	89 c6                	mov    %eax,%esi
400099e4:	ba 01 00 00 00       	mov    $0x1,%edx
400099e9:	eb 23                	jmp    40009a0e <_strtod_r+0x46e>
400099eb:	83 fe 10             	cmp    $0x10,%esi
400099ee:	7f 11                	jg     40009a01 <_strtod_r+0x461>
400099f0:	8b 45 80             	mov    -0x80(%ebp),%eax
400099f3:	8d 04 80             	lea    (%eax,%eax,4),%eax
400099f6:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
400099fc:	01 c0                	add    %eax,%eax
400099fe:	89 45 80             	mov    %eax,-0x80(%ebp)
40009a01:	42                   	inc    %edx
40009a02:	3b 95 68 ff ff ff    	cmp    -0x98(%ebp),%edx
40009a08:	0f 84 19 0b 00 00    	je     4000a527 <_strtod_r+0xf87>
40009a0e:	46                   	inc    %esi
40009a0f:	8d 46 ff             	lea    -0x1(%esi),%eax
40009a12:	83 f8 08             	cmp    $0x8,%eax
40009a15:	7f d4                	jg     400099eb <_strtod_r+0x44b>
40009a17:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
40009a1d:	8d 04 80             	lea    (%eax,%eax,4),%eax
40009a20:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
40009a26:	01 c0                	add    %eax,%eax
40009a28:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
40009a2e:	eb d1                	jmp    40009a01 <_strtod_r+0x461>
40009a30:	8b 45 8c             	mov    -0x74(%ebp),%eax
40009a33:	8b 55 90             	mov    -0x70(%ebp),%edx
40009a36:	29 c8                	sub    %ecx,%eax
40009a38:	01 d0                	add    %edx,%eax
40009a3a:	83 f8 00             	cmp    $0x0,%eax
40009a3d:	0f 8e 0a 0a 00 00    	jle    4000a44d <_strtod_r+0xead>
40009a43:	89 c2                	mov    %eax,%edx
40009a45:	83 e2 0f             	and    $0xf,%edx
40009a48:	74 0d                	je     40009a57 <_strtod_r+0x4b7>
40009a4a:	dd 45 c0             	fldl   -0x40(%ebp)
40009a4d:	dc 0c d5 20 c6 00 40 	fmull  0x4000c620(,%edx,8)
40009a54:	dd 5d c0             	fstpl  -0x40(%ebp)
40009a57:	83 e0 f0             	and    $0xfffffff0,%eax
40009a5a:	0f 85 e4 04 00 00    	jne    40009f44 <_strtod_r+0x9a4>
40009a60:	c7 85 48 ff ff ff 00 	movl   $0x0,-0xb8(%ebp)
40009a67:	00 00 00 
40009a6a:	83 ec 0c             	sub    $0xc,%esp
40009a6d:	8b 8d 7c ff ff ff    	mov    -0x84(%ebp),%ecx
40009a73:	51                   	push   %ecx
40009a74:	8b 55 8c             	mov    -0x74(%ebp),%edx
40009a77:	52                   	push   %edx
40009a78:	53                   	push   %ebx
40009a79:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
40009a7f:	50                   	push   %eax
40009a80:	8b 45 08             	mov    0x8(%ebp),%eax
40009a83:	50                   	push   %eax
40009a84:	e8 b7 ed ff ff       	call   40008840 <__s2b>
40009a89:	8b 75 90             	mov    -0x70(%ebp),%esi
40009a8c:	83 c4 20             	add    $0x20,%esp
40009a8f:	8d 48 0c             	lea    0xc(%eax),%ecx
40009a92:	89 45 88             	mov    %eax,-0x78(%ebp)
40009a95:	f7 de                	neg    %esi
40009a97:	89 8d 40 ff ff ff    	mov    %ecx,-0xc0(%ebp)
40009a9d:	89 b5 3c ff ff ff    	mov    %esi,-0xc4(%ebp)
40009aa3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40009aa9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
40009ab0:	50                   	push   %eax
40009ab1:	50                   	push   %eax
40009ab2:	8b 45 88             	mov    -0x78(%ebp),%eax
40009ab5:	8d 75 e4             	lea    -0x1c(%ebp),%esi
40009ab8:	8b 40 04             	mov    0x4(%eax),%eax
40009abb:	50                   	push   %eax
40009abc:	8b 45 08             	mov    0x8(%ebp),%eax
40009abf:	50                   	push   %eax
40009ac0:	e8 5b e5 ff ff       	call   40008020 <_Balloc>
40009ac5:	8b 55 88             	mov    -0x78(%ebp),%edx
40009ac8:	89 45 84             	mov    %eax,-0x7c(%ebp)
40009acb:	83 c4 0c             	add    $0xc,%esp
40009ace:	8b 42 10             	mov    0x10(%edx),%eax
40009ad1:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
40009ad8:	50                   	push   %eax
40009ad9:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
40009adf:	50                   	push   %eax
40009ae0:	8b 45 84             	mov    -0x7c(%ebp),%eax
40009ae3:	83 c0 0c             	add    $0xc,%eax
40009ae6:	50                   	push   %eax
40009ae7:	e8 64 df ff ff       	call   40007a50 <memcpy>
40009aec:	8d 4d e0             	lea    -0x20(%ebp),%ecx
40009aef:	89 0c 24             	mov    %ecx,(%esp)
40009af2:	56                   	push   %esi
40009af3:	8b 7d c4             	mov    -0x3c(%ebp),%edi
40009af6:	57                   	push   %edi
40009af7:	8b 75 c0             	mov    -0x40(%ebp),%esi
40009afa:	56                   	push   %esi
40009afb:	8b 5d 08             	mov    0x8(%ebp),%ebx
40009afe:	53                   	push   %ebx
40009aff:	e8 ac e5 ff ff       	call   400080b0 <__d2b>
40009b04:	83 c4 18             	add    $0x18,%esp
40009b07:	89 45 d8             	mov    %eax,-0x28(%ebp)
40009b0a:	6a 01                	push   $0x1
40009b0c:	8b 4d 08             	mov    0x8(%ebp),%ecx
40009b0f:	51                   	push   %ecx
40009b10:	e8 4b eb ff ff       	call   40008660 <__i2b>
40009b15:	8b 55 90             	mov    -0x70(%ebp),%edx
40009b18:	83 c4 10             	add    $0x10,%esp
40009b1b:	89 45 94             	mov    %eax,-0x6c(%ebp)
40009b1e:	85 d2                	test   %edx,%edx
40009b20:	0f 88 4a 05 00 00    	js     4000a070 <_strtod_r+0xad0>
40009b26:	8b 45 90             	mov    -0x70(%ebp),%eax
40009b29:	31 db                	xor    %ebx,%ebx
40009b2b:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
40009b31:	89 c7                	mov    %eax,%edi
40009b33:	c7 85 4c ff ff ff 00 	movl   $0x0,-0xb4(%ebp)
40009b3a:	00 00 00 
40009b3d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40009b40:	85 c0                	test   %eax,%eax
40009b42:	0f 88 21 05 00 00    	js     4000a069 <_strtod_r+0xac9>
40009b48:	01 c3                	add    %eax,%ebx
40009b4a:	89 c2                	mov    %eax,%edx
40009b4c:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
40009b52:	29 c2                	sub    %eax,%edx
40009b54:	8b 4d e0             	mov    -0x20(%ebp),%ecx
40009b57:	8d 44 0a ff          	lea    -0x1(%edx,%ecx,1),%eax
40009b5b:	3d 02 fc ff ff       	cmp    $0xfffffc02,%eax
40009b60:	0f 8c 8a 04 00 00    	jl     40009ff0 <_strtod_r+0xa50>
40009b66:	ba 36 00 00 00       	mov    $0x36,%edx
40009b6b:	29 ca                	sub    %ecx,%edx
40009b6d:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
40009b73:	8d 34 1a             	lea    (%edx,%ebx,1),%esi
40009b76:	8d 04 0f             	lea    (%edi,%ecx,1),%eax
40009b79:	8d 3c 10             	lea    (%eax,%edx,1),%edi
40009b7c:	89 f0                	mov    %esi,%eax
40009b7e:	39 fe                	cmp    %edi,%esi
40009b80:	7e 02                	jle    40009b84 <_strtod_r+0x5e4>
40009b82:	89 f8                	mov    %edi,%eax
40009b84:	39 d8                	cmp    %ebx,%eax
40009b86:	7e 02                	jle    40009b8a <_strtod_r+0x5ea>
40009b88:	89 d8                	mov    %ebx,%eax
40009b8a:	89 9d 54 ff ff ff    	mov    %ebx,-0xac(%ebp)
40009b90:	85 c0                	test   %eax,%eax
40009b92:	7e 0c                	jle    40009ba0 <_strtod_r+0x600>
40009b94:	29 c3                	sub    %eax,%ebx
40009b96:	29 c6                	sub    %eax,%esi
40009b98:	29 c7                	sub    %eax,%edi
40009b9a:	89 9d 54 ff ff ff    	mov    %ebx,-0xac(%ebp)
40009ba0:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
40009ba6:	85 c0                	test   %eax,%eax
40009ba8:	7e 40                	jle    40009bea <_strtod_r+0x64a>
40009baa:	50                   	push   %eax
40009bab:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
40009bb1:	50                   	push   %eax
40009bb2:	8b 45 94             	mov    -0x6c(%ebp),%eax
40009bb5:	50                   	push   %eax
40009bb6:	8b 45 08             	mov    0x8(%ebp),%eax
40009bb9:	50                   	push   %eax
40009bba:	e8 91 eb ff ff       	call   40008750 <__pow5mult>
40009bbf:	83 c4 0c             	add    $0xc,%esp
40009bc2:	8b 5d d8             	mov    -0x28(%ebp),%ebx
40009bc5:	89 45 94             	mov    %eax,-0x6c(%ebp)
40009bc8:	53                   	push   %ebx
40009bc9:	50                   	push   %eax
40009bca:	8b 4d 08             	mov    0x8(%ebp),%ecx
40009bcd:	51                   	push   %ecx
40009bce:	e8 9d e8 ff ff       	call   40008470 <__multiply>
40009bd3:	89 c3                	mov    %eax,%ebx
40009bd5:	58                   	pop    %eax
40009bd6:	8b 45 d8             	mov    -0x28(%ebp),%eax
40009bd9:	5a                   	pop    %edx
40009bda:	50                   	push   %eax
40009bdb:	8b 4d 08             	mov    0x8(%ebp),%ecx
40009bde:	51                   	push   %ecx
40009bdf:	e8 4c df ff ff       	call   40007b30 <_Bfree>
40009be4:	89 5d d8             	mov    %ebx,-0x28(%ebp)
40009be7:	83 c4 10             	add    $0x10,%esp
40009bea:	85 f6                	test   %esi,%esi
40009bec:	7e 15                	jle    40009c03 <_strtod_r+0x663>
40009bee:	52                   	push   %edx
40009bef:	56                   	push   %esi
40009bf0:	8b 45 d8             	mov    -0x28(%ebp),%eax
40009bf3:	50                   	push   %eax
40009bf4:	8b 45 08             	mov    0x8(%ebp),%eax
40009bf7:	50                   	push   %eax
40009bf8:	e8 53 e7 ff ff       	call   40008350 <__lshift>
40009bfd:	83 c4 10             	add    $0x10,%esp
40009c00:	89 45 d8             	mov    %eax,-0x28(%ebp)
40009c03:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
40009c09:	85 c0                	test   %eax,%eax
40009c0b:	0f 85 05 04 00 00    	jne    4000a016 <_strtod_r+0xa76>
40009c11:	85 ff                	test   %edi,%edi
40009c13:	7e 15                	jle    40009c2a <_strtod_r+0x68a>
40009c15:	53                   	push   %ebx
40009c16:	57                   	push   %edi
40009c17:	8b 4d 84             	mov    -0x7c(%ebp),%ecx
40009c1a:	51                   	push   %ecx
40009c1b:	8b 55 08             	mov    0x8(%ebp),%edx
40009c1e:	52                   	push   %edx
40009c1f:	e8 2c e7 ff ff       	call   40008350 <__lshift>
40009c24:	83 c4 10             	add    $0x10,%esp
40009c27:	89 45 84             	mov    %eax,-0x7c(%ebp)
40009c2a:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
40009c30:	85 c0                	test   %eax,%eax
40009c32:	7e 1b                	jle    40009c4f <_strtod_r+0x6af>
40009c34:	50                   	push   %eax
40009c35:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
40009c3b:	50                   	push   %eax
40009c3c:	8b 45 94             	mov    -0x6c(%ebp),%eax
40009c3f:	50                   	push   %eax
40009c40:	8b 45 08             	mov    0x8(%ebp),%eax
40009c43:	50                   	push   %eax
40009c44:	e8 07 e7 ff ff       	call   40008350 <__lshift>
40009c49:	83 c4 10             	add    $0x10,%esp
40009c4c:	89 45 94             	mov    %eax,-0x6c(%ebp)
40009c4f:	50                   	push   %eax
40009c50:	8b 7d 84             	mov    -0x7c(%ebp),%edi
40009c53:	57                   	push   %edi
40009c54:	8b 75 d8             	mov    -0x28(%ebp),%esi
40009c57:	56                   	push   %esi
40009c58:	8b 5d 08             	mov    0x8(%ebp),%ebx
40009c5b:	53                   	push   %ebx
40009c5c:	e8 7f e5 ff ff       	call   400081e0 <__mdiff>
40009c61:	89 c6                	mov    %eax,%esi
40009c63:	8b 78 0c             	mov    0xc(%eax),%edi
40009c66:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
40009c6d:	5a                   	pop    %edx
40009c6e:	8b 45 94             	mov    -0x6c(%ebp),%eax
40009c71:	59                   	pop    %ecx
40009c72:	50                   	push   %eax
40009c73:	56                   	push   %esi
40009c74:	e8 c7 df ff ff       	call   40007c40 <__mcmp>
40009c79:	83 c4 10             	add    $0x10,%esp
40009c7c:	83 f8 00             	cmp    $0x0,%eax
40009c7f:	0f 8c 97 06 00 00    	jl     4000a31c <_strtod_r+0xd7c>
40009c85:	0f 84 60 07 00 00    	je     4000a3eb <_strtod_r+0xe4b>
40009c8b:	50                   	push   %eax
40009c8c:	50                   	push   %eax
40009c8d:	8b 45 94             	mov    -0x6c(%ebp),%eax
40009c90:	50                   	push   %eax
40009c91:	56                   	push   %esi
40009c92:	e8 d9 e1 ff ff       	call   40007e70 <__ratio>
40009c97:	83 c4 10             	add    $0x10,%esp
40009c9a:	d9 05 88 c8 00 40    	flds   0x4000c888
40009ca0:	dd e9                	fucomp %st(1)
40009ca2:	df e0                	fnstsw %ax
40009ca4:	f6 c4 01             	test   $0x1,%ah
40009ca7:	0f 85 53 03 00 00    	jne    4000a000 <_strtod_r+0xa60>
40009cad:	85 ff                	test   %edi,%edi
40009caf:	0f 84 81 03 00 00    	je     4000a036 <_strtod_r+0xa96>
40009cb5:	dd d8                	fstp   %st(0)
40009cb7:	d9 e8                	fld1   
40009cb9:	dd 55 c8             	fstl   -0x38(%ebp)
40009cbc:	8d 74 26 00          	lea    0x0(%esi),%esi
40009cc0:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
40009cc3:	81 e3 00 00 f0 7f    	and    $0x7ff00000,%ebx
40009cc9:	81 fb 00 00 e0 7f    	cmp    $0x7fe00000,%ebx
40009ccf:	0f 84 dc 03 00 00    	je     4000a0b1 <_strtod_r+0xb11>
40009cd5:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
40009cdb:	85 c0                	test   %eax,%eax
40009cdd:	74 56                	je     40009d35 <_strtod_r+0x795>
40009cdf:	81 fb 00 00 a0 06    	cmp    $0x6a00000,%ebx
40009ce5:	77 4e                	ja     40009d35 <_strtod_r+0x795>
40009ce7:	dd 05 90 c8 00 40    	fldl   0x4000c890
40009ced:	dd e9                	fucomp %st(1)
40009cef:	df e0                	fnstsw %ax
40009cf1:	f6 c4 01             	test   $0x1,%ah
40009cf4:	75 32                	jne    40009d28 <_strtod_r+0x788>
40009cf6:	d9 7d a6             	fnstcw -0x5a(%ebp)
40009cf9:	66 8b 45 a6          	mov    -0x5a(%ebp),%ax
40009cfd:	b4 0c                	mov    $0xc,%ah
40009cff:	66 89 45 a4          	mov    %ax,-0x5c(%ebp)
40009d03:	d9 6d a4             	fldcw  -0x5c(%ebp)
40009d06:	df 7d 98             	fistpll -0x68(%ebp)
40009d09:	d9 6d a6             	fldcw  -0x5a(%ebp)
40009d0c:	8b 45 98             	mov    -0x68(%ebp),%eax
40009d0f:	85 c0                	test   %eax,%eax
40009d11:	0f 85 39 04 00 00    	jne    4000a150 <_strtod_r+0xbb0>
40009d17:	d9 05 8c c5 00 40    	flds   0x4000c58c
40009d1d:	d9 c0                	fld    %st(0)
40009d1f:	85 ff                	test   %edi,%edi
40009d21:	75 02                	jne    40009d25 <_strtod_r+0x785>
40009d23:	d9 e0                	fchs   
40009d25:	dd 5d c8             	fstpl  -0x38(%ebp)
40009d28:	8b 45 cc             	mov    -0x34(%ebp),%eax
40009d2b:	05 00 00 b0 06       	add    $0x6b00000,%eax
40009d30:	29 d8                	sub    %ebx,%eax
40009d32:	89 45 cc             	mov    %eax,-0x34(%ebp)
40009d35:	50                   	push   %eax
40009d36:	50                   	push   %eax
40009d37:	8b 45 c4             	mov    -0x3c(%ebp),%eax
40009d3a:	50                   	push   %eax
40009d3b:	8b 45 c0             	mov    -0x40(%ebp),%eax
40009d3e:	50                   	push   %eax
40009d3f:	dd 9d 28 ff ff ff    	fstpl  -0xd8(%ebp)
40009d45:	e8 56 df ff ff       	call   40007ca0 <__ulp>
40009d4a:	83 c4 10             	add    $0x10,%esp
40009d4d:	dc 4d c8             	fmull  -0x38(%ebp)
40009d50:	dc 45 c0             	faddl  -0x40(%ebp)
40009d53:	dd 5d c0             	fstpl  -0x40(%ebp)
40009d56:	dd 85 28 ff ff ff    	fldl   -0xd8(%ebp)
40009d5c:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
40009d62:	8b 55 c4             	mov    -0x3c(%ebp),%edx
40009d65:	85 c0                	test   %eax,%eax
40009d67:	75 0f                	jne    40009d78 <_strtod_r+0x7d8>
40009d69:	89 d0                	mov    %edx,%eax
40009d6b:	25 00 00 f0 7f       	and    $0x7ff00000,%eax
40009d70:	39 c3                	cmp    %eax,%ebx
40009d72:	0f 84 28 01 00 00    	je     40009ea0 <_strtod_r+0x900>
40009d78:	dd d8                	fstp   %st(0)
40009d7a:	57                   	push   %edi
40009d7b:	57                   	push   %edi
40009d7c:	8b 5d d8             	mov    -0x28(%ebp),%ebx
40009d7f:	53                   	push   %ebx
40009d80:	8b 4d 08             	mov    0x8(%ebp),%ecx
40009d83:	51                   	push   %ecx
40009d84:	e8 a7 dd ff ff       	call   40007b30 <_Bfree>
40009d89:	58                   	pop    %eax
40009d8a:	8b 45 84             	mov    -0x7c(%ebp),%eax
40009d8d:	5a                   	pop    %edx
40009d8e:	50                   	push   %eax
40009d8f:	8b 45 08             	mov    0x8(%ebp),%eax
40009d92:	50                   	push   %eax
40009d93:	e8 98 dd ff ff       	call   40007b30 <_Bfree>
40009d98:	8b 5d 94             	mov    -0x6c(%ebp),%ebx
40009d9b:	5f                   	pop    %edi
40009d9c:	58                   	pop    %eax
40009d9d:	53                   	push   %ebx
40009d9e:	8b 4d 08             	mov    0x8(%ebp),%ecx
40009da1:	51                   	push   %ecx
40009da2:	e8 89 dd ff ff       	call   40007b30 <_Bfree>
40009da7:	58                   	pop    %eax
40009da8:	5a                   	pop    %edx
40009da9:	56                   	push   %esi
40009daa:	8b 45 08             	mov    0x8(%ebp),%eax
40009dad:	50                   	push   %eax
40009dae:	e8 7d dd ff ff       	call   40007b30 <_Bfree>
40009db3:	83 c4 10             	add    $0x10,%esp
40009db6:	e9 f5 fc ff ff       	jmp    40009ab0 <_strtod_r+0x510>
40009dbb:	dd d8                	fstp   %st(0)
40009dbd:	e9 56 f9 ff ff       	jmp    40009718 <_strtod_r+0x178>
40009dc2:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%ebp)
40009dc9:	00 00 00 
40009dcc:	3c 30                	cmp    $0x30,%al
40009dce:	75 20                	jne    40009df0 <_strtod_r+0x850>
40009dd0:	8b 45 dc             	mov    -0x24(%ebp),%eax
40009dd3:	8b 8d 68 ff ff ff    	mov    -0x98(%ebp),%ecx
40009dd9:	41                   	inc    %ecx
40009dda:	8d 50 01             	lea    0x1(%eax),%edx
40009ddd:	89 8d 68 ff ff ff    	mov    %ecx,-0x98(%ebp)
40009de3:	89 55 dc             	mov    %edx,-0x24(%ebp)
40009de6:	8a 40 01             	mov    0x1(%eax),%al
40009de9:	0f be d0             	movsbl %al,%edx
40009dec:	3c 30                	cmp    $0x30,%al
40009dee:	74 e0                	je     40009dd0 <_strtod_r+0x830>
40009df0:	8d 42 cf             	lea    -0x31(%edx),%eax
40009df3:	83 f8 08             	cmp    $0x8,%eax
40009df6:	0f 87 ce 01 00 00    	ja     40009fca <_strtod_r+0xa2a>
40009dfc:	8b 45 dc             	mov    -0x24(%ebp),%eax
40009dff:	8b b5 68 ff ff ff    	mov    -0x98(%ebp),%esi
40009e05:	83 ea 30             	sub    $0x30,%edx
40009e08:	89 c1                	mov    %eax,%ecx
40009e0a:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
40009e10:	c7 85 60 ff ff ff 00 	movl   $0x0,-0xa0(%ebp)
40009e17:	00 00 00 
40009e1a:	89 b5 64 ff ff ff    	mov    %esi,-0x9c(%ebp)
40009e20:	c7 85 68 ff ff ff 01 	movl   $0x1,-0x98(%ebp)
40009e27:	00 00 00 
40009e2a:	89 95 44 ff ff ff    	mov    %edx,-0xbc(%ebp)
40009e30:	e9 7b fb ff ff       	jmp    400099b0 <_strtod_r+0x410>
40009e35:	31 c0                	xor    %eax,%eax
40009e37:	89 7d dc             	mov    %edi,-0x24(%ebp)
40009e3a:	e9 7a f8 ff ff       	jmp    400096b9 <_strtod_r+0x119>
40009e3f:	83 fa 4e             	cmp    $0x4e,%edx
40009e42:	0f 84 92 07 00 00    	je     4000a5da <_strtod_r+0x103a>
40009e48:	0f 8f 7a 07 00 00    	jg     4000a5c8 <_strtod_r+0x1028>
40009e4e:	83 fa 49             	cmp    $0x49,%edx
40009e51:	0f 85 29 f9 ff ff    	jne    40009780 <_strtod_r+0x1e0>
40009e57:	8d 5d dc             	lea    -0x24(%ebp),%ebx
40009e5a:	ba 85 bc 00 40       	mov    $0x4000bc85,%edx
40009e5f:	89 d8                	mov    %ebx,%eax
40009e61:	e8 ea f6 ff ff       	call   40009550 <match>
40009e66:	85 c0                	test   %eax,%eax
40009e68:	0f 84 12 f9 ff ff    	je     40009780 <_strtod_r+0x1e0>
40009e6e:	8b 45 dc             	mov    -0x24(%ebp),%eax
40009e71:	ba 63 c5 00 40       	mov    $0x4000c563,%edx
40009e76:	48                   	dec    %eax
40009e77:	89 45 dc             	mov    %eax,-0x24(%ebp)
40009e7a:	89 d8                	mov    %ebx,%eax
40009e7c:	e8 cf f6 ff ff       	call   40009550 <match>
40009e81:	8b 55 dc             	mov    -0x24(%ebp),%edx
40009e84:	83 f8 01             	cmp    $0x1,%eax
40009e87:	c7 45 c4 00 00 f0 7f 	movl   $0x7ff00000,-0x3c(%ebp)
40009e8e:	83 d2 00             	adc    $0x0,%edx
40009e91:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
40009e98:	89 55 dc             	mov    %edx,-0x24(%ebp)
40009e9b:	e9 ed f8 ff ff       	jmp    4000978d <_strtod_r+0x1ed>
40009ea0:	d9 7d a6             	fnstcw -0x5a(%ebp)
40009ea3:	66 8b 45 a6          	mov    -0x5a(%ebp),%ax
40009ea7:	b4 0c                	mov    $0xc,%ah
40009ea9:	66 89 45 a4          	mov    %ax,-0x5c(%ebp)
40009ead:	d9 6d a4             	fldcw  -0x5c(%ebp)
40009eb0:	db 55 a0             	fistl  -0x60(%ebp)
40009eb3:	d9 6d a6             	fldcw  -0x5a(%ebp)
40009eb6:	8b 45 a0             	mov    -0x60(%ebp),%eax
40009eb9:	50                   	push   %eax
40009eba:	db 04 24             	fildl  (%esp)
40009ebd:	de e9                	fsubrp %st,%st(1)
40009ebf:	83 c4 04             	add    $0x4,%esp
40009ec2:	85 ff                	test   %edi,%edi
40009ec4:	0f 85 58 02 00 00    	jne    4000a122 <_strtod_r+0xb82>
40009eca:	8b 45 c0             	mov    -0x40(%ebp),%eax
40009ecd:	85 c0                	test   %eax,%eax
40009ecf:	0f 85 4d 02 00 00    	jne    4000a122 <_strtod_r+0xb82>
40009ed5:	81 e2 ff ff 0f 00    	and    $0xfffff,%edx
40009edb:	0f 85 41 02 00 00    	jne    4000a122 <_strtod_r+0xb82>
40009ee1:	dd 05 a8 c8 00 40    	fldl   0x4000c8a8
40009ee7:	da e9                	fucompp 
40009ee9:	df e0                	fnstsw %ax
40009eeb:	f6 c4 45             	test   $0x45,%ah
40009eee:	0f 85 86 fe ff ff    	jne    40009d7a <_strtod_r+0x7da>
40009ef4:	57                   	push   %edi
40009ef5:	57                   	push   %edi
40009ef6:	8b 5d d8             	mov    -0x28(%ebp),%ebx
40009ef9:	53                   	push   %ebx
40009efa:	8b 4d 08             	mov    0x8(%ebp),%ecx
40009efd:	51                   	push   %ecx
40009efe:	e8 2d dc ff ff       	call   40007b30 <_Bfree>
40009f03:	58                   	pop    %eax
40009f04:	8b 45 84             	mov    -0x7c(%ebp),%eax
40009f07:	5a                   	pop    %edx
40009f08:	50                   	push   %eax
40009f09:	8b 45 08             	mov    0x8(%ebp),%eax
40009f0c:	50                   	push   %eax
40009f0d:	e8 1e dc ff ff       	call   40007b30 <_Bfree>
40009f12:	8b 5d 94             	mov    -0x6c(%ebp),%ebx
40009f15:	5f                   	pop    %edi
40009f16:	58                   	pop    %eax
40009f17:	53                   	push   %ebx
40009f18:	8b 4d 08             	mov    0x8(%ebp),%ecx
40009f1b:	51                   	push   %ecx
40009f1c:	e8 0f dc ff ff       	call   40007b30 <_Bfree>
40009f21:	58                   	pop    %eax
40009f22:	8b 45 88             	mov    -0x78(%ebp),%eax
40009f25:	5a                   	pop    %edx
40009f26:	50                   	push   %eax
40009f27:	8b 45 08             	mov    0x8(%ebp),%eax
40009f2a:	50                   	push   %eax
40009f2b:	e8 00 dc ff ff       	call   40007b30 <_Bfree>
40009f30:	5b                   	pop    %ebx
40009f31:	5f                   	pop    %edi
40009f32:	56                   	push   %esi
40009f33:	8b 4d 08             	mov    0x8(%ebp),%ecx
40009f36:	51                   	push   %ecx
40009f37:	e8 f4 db ff ff       	call   40007b30 <_Bfree>
40009f3c:	83 c4 10             	add    $0x10,%esp
40009f3f:	e9 49 f8 ff ff       	jmp    4000978d <_strtod_r+0x1ed>
40009f44:	3d 34 01 00 00       	cmp    $0x134,%eax
40009f49:	0f 8f b1 03 00 00    	jg     4000a300 <_strtod_r+0xd60>
40009f4f:	c1 f8 04             	sar    $0x4,%eax
40009f52:	31 d2                	xor    %edx,%edx
40009f54:	83 f8 01             	cmp    $0x1,%eax
40009f57:	7e 19                	jle    40009f72 <_strtod_r+0x9d2>
40009f59:	a8 01                	test   $0x1,%al
40009f5b:	74 0d                	je     40009f6a <_strtod_r+0x9ca>
40009f5d:	dd 45 c0             	fldl   -0x40(%ebp)
40009f60:	dc 0c d5 00 c7 00 40 	fmull  0x4000c700(,%edx,8)
40009f67:	dd 5d c0             	fstpl  -0x40(%ebp)
40009f6a:	d1 f8                	sar    %eax
40009f6c:	42                   	inc    %edx
40009f6d:	83 f8 01             	cmp    $0x1,%eax
40009f70:	7f e7                	jg     40009f59 <_strtod_r+0x9b9>
40009f72:	8b 45 c4             	mov    -0x3c(%ebp),%eax
40009f75:	2d 00 00 50 03       	sub    $0x3500000,%eax
40009f7a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
40009f7d:	dd 45 c0             	fldl   -0x40(%ebp)
40009f80:	dc 0c d5 00 c7 00 40 	fmull  0x4000c700(,%edx,8)
40009f87:	dd 5d c0             	fstpl  -0x40(%ebp)
40009f8a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
40009f8d:	89 c2                	mov    %eax,%edx
40009f8f:	81 e2 00 00 f0 7f    	and    $0x7ff00000,%edx
40009f95:	81 fa 00 00 a0 7c    	cmp    $0x7ca00000,%edx
40009f9b:	0f 87 5f 03 00 00    	ja     4000a300 <_strtod_r+0xd60>
40009fa1:	81 fa 00 00 90 7c    	cmp    $0x7c900000,%edx
40009fa7:	0f 86 de 06 00 00    	jbe    4000a68b <_strtod_r+0x10eb>
40009fad:	c7 45 c4 ff ff ef 7f 	movl   $0x7fefffff,-0x3c(%ebp)
40009fb4:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%ebp)
40009fbb:	c7 85 48 ff ff ff 00 	movl   $0x0,-0xb8(%ebp)
40009fc2:	00 00 00 
40009fc5:	e9 a0 fa ff ff       	jmp    40009a6a <_strtod_r+0x4ca>
40009fca:	c7 45 8c 00 00 00 00 	movl   $0x0,-0x74(%ebp)
40009fd1:	c7 85 58 ff ff ff 01 	movl   $0x1,-0xa8(%ebp)
40009fd8:	00 00 00 
40009fdb:	c7 85 64 ff ff ff 00 	movl   $0x0,-0x9c(%ebp)
40009fe2:	00 00 00 
40009fe5:	e9 bb f6 ff ff       	jmp    400096a5 <_strtod_r+0x105>
40009fea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
40009ff0:	81 c2 33 04 00 00    	add    $0x433,%edx
40009ff6:	e9 72 fb ff ff       	jmp    40009b6d <_strtod_r+0x5cd>
40009ffb:	90                   	nop    
40009ffc:	8d 74 26 00          	lea    0x0(%esi),%esi
4000a000:	d8 0d 9c c5 00 40    	fmuls  0x4000c59c
4000a006:	85 ff                	test   %edi,%edi
4000a008:	d9 c0                	fld    %st(0)
4000a00a:	75 02                	jne    4000a00e <_strtod_r+0xa6e>
4000a00c:	d9 e0                	fchs   
4000a00e:	dd 5d c8             	fstpl  -0x38(%ebp)
4000a011:	e9 aa fc ff ff       	jmp    40009cc0 <_strtod_r+0x720>
4000a016:	50                   	push   %eax
4000a017:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
4000a01d:	50                   	push   %eax
4000a01e:	8b 45 84             	mov    -0x7c(%ebp),%eax
4000a021:	50                   	push   %eax
4000a022:	8b 75 08             	mov    0x8(%ebp),%esi
4000a025:	56                   	push   %esi
4000a026:	e8 25 e7 ff ff       	call   40008750 <__pow5mult>
4000a02b:	83 c4 10             	add    $0x10,%esp
4000a02e:	89 45 84             	mov    %eax,-0x7c(%ebp)
4000a031:	e9 db fb ff ff       	jmp    40009c11 <_strtod_r+0x671>
4000a036:	8b 45 c0             	mov    -0x40(%ebp),%eax
4000a039:	85 c0                	test   %eax,%eax
4000a03b:	75 52                	jne    4000a08f <_strtod_r+0xaef>
4000a03d:	f7 45 c4 ff ff 0f 00 	testl  $0xfffff,-0x3c(%ebp)
4000a044:	0f 85 23 01 00 00    	jne    4000a16d <_strtod_r+0xbcd>
4000a04a:	d9 05 8c c5 00 40    	flds   0x4000c58c
4000a050:	dd e9                	fucomp %st(1)
4000a052:	df e0                	fnstsw %ax
4000a054:	f6 c4 45             	test   $0x45,%ah
4000a057:	0f 84 1e 05 00 00    	je     4000a57b <_strtod_r+0xfdb>
4000a05d:	d8 0d 9c c5 00 40    	fmuls  0x4000c59c
4000a063:	d9 c0                	fld    %st(0)
4000a065:	d9 e0                	fchs   
4000a067:	eb a5                	jmp    4000a00e <_strtod_r+0xa6e>
4000a069:	29 c7                	sub    %eax,%edi
4000a06b:	e9 da fa ff ff       	jmp    40009b4a <_strtod_r+0x5aa>
4000a070:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
4000a076:	31 ff                	xor    %edi,%edi
4000a078:	89 d3                	mov    %edx,%ebx
4000a07a:	89 95 4c ff ff ff    	mov    %edx,-0xb4(%ebp)
4000a080:	c7 85 50 ff ff ff 00 	movl   $0x0,-0xb0(%ebp)
4000a087:	00 00 00 
4000a08a:	e9 ae fa ff ff       	jmp    40009b3d <_strtod_r+0x59d>
4000a08f:	dd d8                	fstp   %st(0)
4000a091:	48                   	dec    %eax
4000a092:	0f 84 dc 00 00 00    	je     4000a174 <_strtod_r+0xbd4>
4000a098:	d9 05 8c c5 00 40    	flds   0x4000c58c
4000a09e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
4000a0a5:	c7 45 cc 00 00 f0 bf 	movl   $0xbff00000,-0x34(%ebp)
4000a0ac:	e9 0f fc ff ff       	jmp    40009cc0 <_strtod_r+0x720>
4000a0b1:	8b 45 c0             	mov    -0x40(%ebp),%eax
4000a0b4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
4000a0b7:	89 45 b8             	mov    %eax,-0x48(%ebp)
4000a0ba:	8b 45 c4             	mov    -0x3c(%ebp),%eax
4000a0bd:	2d 00 00 50 03       	sub    $0x3500000,%eax
4000a0c2:	89 55 bc             	mov    %edx,-0x44(%ebp)
4000a0c5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
4000a0c8:	50                   	push   %eax
4000a0c9:	50                   	push   %eax
4000a0ca:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
4000a0cd:	51                   	push   %ecx
4000a0ce:	8b 55 c0             	mov    -0x40(%ebp),%edx
4000a0d1:	52                   	push   %edx
4000a0d2:	dd 9d 28 ff ff ff    	fstpl  -0xd8(%ebp)
4000a0d8:	e8 c3 db ff ff       	call   40007ca0 <__ulp>
4000a0dd:	83 c4 10             	add    $0x10,%esp
4000a0e0:	dc 4d c8             	fmull  -0x38(%ebp)
4000a0e3:	dc 45 c0             	faddl  -0x40(%ebp)
4000a0e6:	dd 5d c0             	fstpl  -0x40(%ebp)
4000a0e9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
4000a0ec:	89 d0                	mov    %edx,%eax
4000a0ee:	25 00 00 f0 7f       	and    $0x7ff00000,%eax
4000a0f3:	3d ff ff 9f 7c       	cmp    $0x7c9fffff,%eax
4000a0f8:	dd 85 28 ff ff ff    	fldl   -0xd8(%ebp)
4000a0fe:	76 5f                	jbe    4000a15f <_strtod_r+0xbbf>
4000a100:	dd d8                	fstp   %st(0)
4000a102:	81 7d bc ff ff ef 7f 	cmpl   $0x7fefffff,-0x44(%ebp)
4000a109:	0f 84 ca 01 00 00    	je     4000a2d9 <_strtod_r+0xd39>
4000a10f:	c7 45 c4 ff ff ef 7f 	movl   $0x7fefffff,-0x3c(%ebp)
4000a116:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%ebp)
4000a11d:	e9 58 fc ff ff       	jmp    40009d7a <_strtod_r+0x7da>
4000a122:	dd 05 98 c8 00 40    	fldl   0x4000c898
4000a128:	dd e9                	fucomp %st(1)
4000a12a:	df e0                	fnstsw %ax
4000a12c:	f6 c4 45             	test   $0x45,%ah
4000a12f:	0f 84 db 05 00 00    	je     4000a710 <_strtod_r+0x1170>
4000a135:	dd 05 a0 c8 00 40    	fldl   0x4000c8a0
4000a13b:	d9 c9                	fxch   %st(1)
4000a13d:	da e9                	fucompp 
4000a13f:	df e0                	fnstsw %ax
4000a141:	f6 c4 45             	test   $0x45,%ah
4000a144:	0f 85 30 fc ff ff    	jne    40009d7a <_strtod_r+0x7da>
4000a14a:	e9 a5 fd ff ff       	jmp    40009ef4 <_strtod_r+0x954>
4000a14f:	90                   	nop    
4000a150:	31 d2                	xor    %edx,%edx
4000a152:	52                   	push   %edx
4000a153:	50                   	push   %eax
4000a154:	df 2c 24             	fildll (%esp)
4000a157:	83 c4 08             	add    $0x8,%esp
4000a15a:	e9 be fb ff ff       	jmp    40009d1d <_strtod_r+0x77d>
4000a15f:	8d 82 00 00 50 03    	lea    0x3500000(%edx),%eax
4000a165:	89 45 c4             	mov    %eax,-0x3c(%ebp)
4000a168:	e9 ef fb ff ff       	jmp    40009d5c <_strtod_r+0x7bc>
4000a16d:	dd d8                	fstp   %st(0)
4000a16f:	e9 24 ff ff ff       	jmp    4000a098 <_strtod_r+0xaf8>
4000a174:	8b 45 c4             	mov    -0x3c(%ebp),%eax
4000a177:	85 c0                	test   %eax,%eax
4000a179:	0f 85 19 ff ff ff    	jne    4000a098 <_strtod_r+0xaf8>
4000a17f:	8b 55 08             	mov    0x8(%ebp),%edx
4000a182:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
4000a189:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
4000a190:	c7 02 22 00 00 00    	movl   $0x22,(%edx)
4000a196:	e9 59 fd ff ff       	jmp    40009ef4 <_strtod_r+0x954>
4000a19b:	90                   	nop    
4000a19c:	8d 74 26 00          	lea    0x0(%esi),%esi
4000a1a0:	50                   	push   %eax
4000a1a1:	50                   	push   %eax
4000a1a2:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
4000a1a8:	50                   	push   %eax
4000a1a9:	8d 45 d8             	lea    -0x28(%ebp),%eax
4000a1ac:	50                   	push   %eax
4000a1ad:	8d 45 d4             	lea    -0x2c(%ebp),%eax
4000a1b0:	50                   	push   %eax
4000a1b1:	8d 45 dc             	lea    -0x24(%ebp),%eax
4000a1b4:	68 bc d8 00 40       	push   $0x4000d8bc
4000a1b9:	50                   	push   %eax
4000a1ba:	8b 45 08             	mov    0x8(%ebp),%eax
4000a1bd:	50                   	push   %eax
4000a1be:	e8 9d 0f 00 00       	call   4000b160 <__gethex>
4000a1c3:	89 c3                	mov    %eax,%ebx
4000a1c5:	83 c4 20             	add    $0x20,%esp
4000a1c8:	83 e3 07             	and    $0x7,%ebx
4000a1cb:	89 c6                	mov    %eax,%esi
4000a1cd:	0f 84 ba f5 ff ff    	je     4000978d <_strtod_r+0x1ed>
4000a1d3:	83 fb 06             	cmp    $0x6,%ebx
4000a1d6:	0f 84 a4 f5 ff ff    	je     40009780 <_strtod_r+0x1e0>
4000a1dc:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000a1df:	85 c0                	test   %eax,%eax
4000a1e1:	74 24                	je     4000a207 <_strtod_r+0xc67>
4000a1e3:	57                   	push   %edi
4000a1e4:	50                   	push   %eax
4000a1e5:	8b 0d bc d8 00 40    	mov    0x4000d8bc,%ecx
4000a1eb:	8d 45 b0             	lea    -0x50(%ebp),%eax
4000a1ee:	51                   	push   %ecx
4000a1ef:	50                   	push   %eax
4000a1f0:	e8 3b dd ff ff       	call   40007f30 <__copybits>
4000a1f5:	58                   	pop    %eax
4000a1f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000a1f9:	5a                   	pop    %edx
4000a1fa:	50                   	push   %eax
4000a1fb:	8b 7d 08             	mov    0x8(%ebp),%edi
4000a1fe:	57                   	push   %edi
4000a1ff:	e8 2c d9 ff ff       	call   40007b30 <_Bfree>
4000a204:	83 c4 10             	add    $0x10,%esp
4000a207:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
    {
      t = (*fp->_write) (fp->_cookie, (char *) p, n);
      if (t <= 0)
4000a20a:	83 fb 06             	cmp    $0x6,%ebx
4000a20d:	77 15                	ja     4000a224 <_strtod_r+0xc84>
4000a20f:	ff 24 9d 38 c8 00 40 	jmp    *0x4000c838(,%ebx,4)
4000a216:	c7 45 c4 ff ff ff 7f 	movl   $0x7fffffff,-0x3c(%ebp)
4000a21d:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%ebp)
4000a224:	83 e6 08             	and    $0x8,%esi
4000a227:	0f 84 60 f5 ff ff    	je     4000978d <_strtod_r+0x1ed>
4000a22d:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
4000a230:	81 cb 00 00 00 80    	or     $0x80000000,%ebx
4000a236:	89 5d c4             	mov    %ebx,-0x3c(%ebp)
4000a239:	e9 4f f5 ff ff       	jmp    4000978d <_strtod_r+0x1ed>
4000a23e:	c7 45 c4 00 00 f0 7f 	movl   $0x7ff00000,-0x3c(%ebp)
4000a245:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
4000a24c:	eb d6                	jmp    4000a224 <_strtod_r+0xc84>
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
	}
      p += t;
      n -= t;
4000a24e:	8b 45 b0             	mov    -0x50(%ebp),%eax
4000a251:	89 45 c0             	mov    %eax,-0x40(%ebp)
    }
4000a254:	8b 45 b4             	mov    -0x4c(%ebp),%eax
4000a257:	89 45 c4             	mov    %eax,-0x3c(%ebp)
4000a25a:	eb c8                	jmp    4000a224 <_strtod_r+0xc84>
  _funlockfile (fp);
  return 0;
}
4000a25c:	8b 45 b0             	mov    -0x50(%ebp),%eax
4000a25f:	89 45 c0             	mov    %eax,-0x40(%ebp)
4000a262:	8d 82 33 04 00 00    	lea    0x433(%edx),%eax
4000a268:	c1 e0 14             	shl    $0x14,%eax
4000a26b:	8b 55 b4             	mov    -0x4c(%ebp),%edx
4000a26e:	81 e2 ff ff ef ff    	and    $0xffefffff,%edx
4000a274:	09 d0                	or     %edx,%eax
4000a276:	89 45 c4             	mov    %eax,-0x3c(%ebp)
4000a279:	eb a9                	jmp    4000a224 <_strtod_r+0xc84>
    {
      t = (*fp->_write) (fp->_cookie, (char *) p, n);
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
4000a27b:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
4000a282:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
4000a289:	eb 99                	jmp    4000a224 <_strtod_r+0xc84>
4000a28b:	90                   	nop    
4000a28c:	8d 74 26 00          	lea    0x0(%esi),%esi
4000a290:	31 db                	xor    %ebx,%ebx
4000a292:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
4000a299:	00 00 00 
4000a29c:	c7 45 80 00 00 00 00 	movl   $0x0,-0x80(%ebp)
4000a2a3:	e9 d4 f3 ff ff       	jmp    4000967c <_strtod_r+0xdc>
4000a2a8:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%ebp)
4000a2af:	00 00 00 
4000a2b2:	83 7d 8c 10          	cmpl   $0x10,-0x74(%ebp)
4000a2b6:	7f 12                	jg     4000a2ca <_strtod_r+0xd2a>
4000a2b8:	8b 55 80             	mov    -0x80(%ebp),%edx
4000a2bb:	8b b5 44 ff ff ff    	mov    -0xbc(%ebp),%esi
4000a2c1:	8d 04 92             	lea    (%edx,%edx,4),%eax
4000a2c4:	8d 04 46             	lea    (%esi,%eax,2),%eax
4000a2c7:	89 45 80             	mov    %eax,-0x80(%ebp)
4000a2ca:	8d 41 01             	lea    0x1(%ecx),%eax
4000a2cd:	89 45 dc             	mov    %eax,-0x24(%ebp)
4000a2d0:	0f be 51 01          	movsbl 0x1(%ecx),%edx
4000a2d4:	e9 a2 f6 ff ff       	jmp    4000997b <_strtod_r+0x3db>
4000a2d9:	83 7d b8 ff          	cmpl   $0xffffffff,-0x48(%ebp)
4000a2dd:	0f 85 2c fe ff ff    	jne    4000a10f <_strtod_r+0xb6f>
4000a2e3:	8b 55 08             	mov    0x8(%ebp),%edx
4000a2e6:	c7 02 22 00 00 00    	movl   $0x22,(%edx)
4000a2ec:	c7 45 c4 00 00 f0 7f 	movl   $0x7ff00000,-0x3c(%ebp)
4000a2f3:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
4000a2fa:	e9 f5 fb ff ff       	jmp    40009ef4 <_strtod_r+0x954>
4000a2ff:	90                   	nop    
4000a300:	8b 75 08             	mov    0x8(%ebp),%esi
4000a303:	c7 06 22 00 00 00    	movl   $0x22,(%esi)
4000a309:	c7 45 c4 00 00 f0 7f 	movl   $0x7ff00000,-0x3c(%ebp)
4000a310:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
4000a317:	e9 71 f4 ff ff       	jmp    4000978d <_strtod_r+0x1ed>
4000a31c:	85 ff                	test   %edi,%edi
4000a31e:	0f 85 16 01 00 00    	jne    4000a43a <_strtod_r+0xe9a>
4000a324:	8b 45 c0             	mov    -0x40(%ebp),%eax
4000a327:	85 c0                	test   %eax,%eax
4000a329:	0f 85 0b 01 00 00    	jne    4000a43a <_strtod_r+0xe9a>
4000a32f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
4000a332:	a9 ff ff 0f 00       	test   $0xfffff,%eax
4000a337:	0f 85 fd 00 00 00    	jne    4000a43a <_strtod_r+0xe9a>
4000a33d:	25 00 00 f0 7f       	and    $0x7ff00000,%eax
4000a342:	3d 00 00 b0 06       	cmp    $0x6b00000,%eax
4000a347:	0f 86 ed 00 00 00    	jbe    4000a43a <_strtod_r+0xe9a>
4000a34d:	8b 46 14             	mov    0x14(%esi),%eax
4000a350:	85 c0                	test   %eax,%eax
4000a352:	75 0a                	jne    4000a35e <_strtod_r+0xdbe>
4000a354:	83 7e 10 01          	cmpl   $0x1,0x10(%esi)
4000a358:	0f 8e dc 00 00 00    	jle    4000a43a <_strtod_r+0xe9a>
4000a35e:	50                   	push   %eax
4000a35f:	6a 01                	push   $0x1
4000a361:	56                   	push   %esi
4000a362:	8b 45 08             	mov    0x8(%ebp),%eax
4000a365:	50                   	push   %eax
4000a366:	e8 e5 df ff ff       	call   40008350 <__lshift>
4000a36b:	8b 5d 94             	mov    -0x6c(%ebp),%ebx
4000a36e:	89 c6                	mov    %eax,%esi
4000a370:	5f                   	pop    %edi
4000a371:	58                   	pop    %eax
4000a372:	53                   	push   %ebx
4000a373:	56                   	push   %esi
4000a374:	e8 c7 d8 ff ff       	call   40007c40 <__mcmp>
4000a379:	83 c4 10             	add    $0x10,%esp
4000a37c:	85 c0                	test   %eax,%eax
4000a37e:	0f 8e b6 00 00 00    	jle    4000a43a <_strtod_r+0xe9a>
4000a384:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
4000a38a:	85 c0                	test   %eax,%eax
4000a38c:	0f 84 5d 03 00 00    	je     4000a6ef <_strtod_r+0x114f>
4000a392:	8b 45 c4             	mov    -0x3c(%ebp),%eax
4000a395:	25 00 00 f0 7f       	and    $0x7ff00000,%eax
4000a39a:	3d 00 00 b0 06       	cmp    $0x6b00000,%eax
4000a39f:	0f 87 4a 03 00 00    	ja     4000a6ef <_strtod_r+0x114f>
4000a3a5:	3d 00 00 70 03       	cmp    $0x3700000,%eax
4000a3aa:	0f 86 cf fd ff ff    	jbe    4000a17f <_strtod_r+0xbdf>
4000a3b0:	dd 45 c0             	fldl   -0x40(%ebp)
4000a3b3:	c7 45 bc 00 00 50 39 	movl   $0x39500000,-0x44(%ebp)
4000a3ba:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
4000a3c1:	dc 4d b8             	fmull  -0x48(%ebp)
4000a3c4:	dd 5d c0             	fstpl  -0x40(%ebp)
4000a3c7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
4000a3ca:	85 c0                	test   %eax,%eax
4000a3cc:	0f 85 22 fb ff ff    	jne    40009ef4 <_strtod_r+0x954>
4000a3d2:	8b 45 c0             	mov    -0x40(%ebp),%eax
4000a3d5:	85 c0                	test   %eax,%eax
4000a3d7:	0f 85 17 fb ff ff    	jne    40009ef4 <_strtod_r+0x954>
4000a3dd:	8b 55 08             	mov    0x8(%ebp),%edx
4000a3e0:	c7 02 22 00 00 00    	movl   $0x22,(%edx)
4000a3e6:	e9 09 fb ff ff       	jmp    40009ef4 <_strtod_r+0x954>
4000a3eb:	85 ff                	test   %edi,%edi
4000a3ed:	0f 84 1d 02 00 00    	je     4000a610 <_strtod_r+0x1070>
4000a3f3:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
4000a3f6:	89 d8                	mov    %ebx,%eax
4000a3f8:	25 ff ff 0f 00       	and    $0xfffff,%eax
4000a3fd:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
4000a402:	0f 84 9a 02 00 00    	je     4000a6a2 <_strtod_r+0x1102>
4000a408:	8b 55 c0             	mov    -0x40(%ebp),%edx
4000a40b:	83 e2 01             	and    $0x1,%edx
4000a40e:	74 2a                	je     4000a43a <_strtod_r+0xe9a>
4000a410:	85 ff                	test   %edi,%edi
4000a412:	0f 84 38 02 00 00    	je     4000a650 <_strtod_r+0x10b0>
4000a418:	dd 45 c0             	fldl   -0x40(%ebp)
4000a41b:	83 ec 10             	sub    $0x10,%esp
4000a41e:	dd 14 24             	fstl   (%esp)
4000a421:	dd 9d 28 ff ff ff    	fstpl  -0xd8(%ebp)
4000a427:	e8 74 d8 ff ff       	call   40007ca0 <__ulp>
4000a42c:	83 c4 10             	add    $0x10,%esp
4000a42f:	dd 85 28 ff ff ff    	fldl   -0xd8(%ebp)
4000a435:	de c1                	faddp  %st,%st(1)
4000a437:	dd 5d c0             	fstpl  -0x40(%ebp)
4000a43a:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
4000a440:	85 c0                	test   %eax,%eax
4000a442:	0f 84 ac fa ff ff    	je     40009ef4 <_strtod_r+0x954>
4000a448:	e9 63 ff ff ff       	jmp    4000a3b0 <_strtod_r+0xe10>
4000a44d:	0f 84 0d f6 ff ff    	je     40009a60 <_strtod_r+0x4c0>
4000a453:	f7 d8                	neg    %eax
4000a455:	89 c2                	mov    %eax,%edx
4000a457:	83 e2 0f             	and    $0xf,%edx
4000a45a:	74 0d                	je     4000a469 <_strtod_r+0xec9>
4000a45c:	dd 45 c0             	fldl   -0x40(%ebp)
4000a45f:	dc 34 d5 20 c6 00 40 	fdivl  0x4000c620(,%edx,8)
4000a466:	dd 5d c0             	fstpl  -0x40(%ebp)
4000a469:	89 c2                	mov    %eax,%edx
4000a46b:	c1 fa 04             	sar    $0x4,%edx
4000a46e:	0f 84 ec f5 ff ff    	je     40009a60 <_strtod_r+0x4c0>
4000a474:	83 fa 1f             	cmp    $0x1f,%edx
4000a477:	0f 8f 8e 00 00 00    	jg     4000a50b <_strtod_r+0xf6b>
4000a47d:	89 d0                	mov    %edx,%eax
4000a47f:	83 e0 10             	and    $0x10,%eax
4000a482:	83 f8 01             	cmp    $0x1,%eax
4000a485:	19 c9                	sbb    %ecx,%ecx
4000a487:	83 f1 ff             	xor    $0xffffffff,%ecx
4000a48a:	83 e1 6a             	and    $0x6a,%ecx
4000a48d:	85 d2                	test   %edx,%edx
4000a48f:	89 8d 48 ff ff ff    	mov    %ecx,-0xb8(%ebp)
4000a495:	7e 1d                	jle    4000a4b4 <_strtod_r+0xf14>
4000a497:	31 c0                	xor    %eax,%eax
4000a499:	eb 01                	jmp    4000a49c <_strtod_r+0xefc>
4000a49b:	40                   	inc    %eax
4000a49c:	f6 c2 01             	test   $0x1,%dl
4000a49f:	74 0d                	je     4000a4ae <_strtod_r+0xf0e>
4000a4a1:	dd 45 c0             	fldl   -0x40(%ebp)
4000a4a4:	dc 0c c5 60 c8 00 40 	fmull  0x4000c860(,%eax,8)
4000a4ab:	dd 5d c0             	fstpl  -0x40(%ebp)
4000a4ae:	d1 fa                	sar    %edx
4000a4b0:	85 d2                	test   %edx,%edx
4000a4b2:	7f e7                	jg     4000a49b <_strtod_r+0xefb>
4000a4b4:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
4000a4ba:	85 c0                	test   %eax,%eax
4000a4bc:	74 36                	je     4000a4f4 <_strtod_r+0xf54>
4000a4be:	8b 45 c4             	mov    -0x3c(%ebp),%eax
4000a4c1:	b9 6b 00 00 00       	mov    $0x6b,%ecx
4000a4c6:	25 00 00 f0 7f       	and    $0x7ff00000,%eax
4000a4cb:	c1 e8 14             	shr    $0x14,%eax
4000a4ce:	29 c1                	sub    %eax,%ecx
4000a4d0:	85 c9                	test   %ecx,%ecx
4000a4d2:	7e 20                	jle    4000a4f4 <_strtod_r+0xf54>
4000a4d4:	83 f9 1f             	cmp    $0x1f,%ecx
4000a4d7:	0f 8e 71 02 00 00    	jle    4000a74e <_strtod_r+0x11ae>
4000a4dd:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
4000a4e4:	83 f9 34             	cmp    $0x34,%ecx
4000a4e7:	0f 8e 73 02 00 00    	jle    4000a760 <_strtod_r+0x11c0>
4000a4ed:	c7 45 c4 00 00 70 03 	movl   $0x3700000,-0x3c(%ebp)
4000a4f4:	dd 45 c0             	fldl   -0x40(%ebp)
4000a4f7:	d9 ee                	fldz   
4000a4f9:	d9 c9                	fxch   %st(1)
4000a4fb:	da e9                	fucompp 
4000a4fd:	df e0                	fnstsw %ax
4000a4ff:	80 e4 45             	and    $0x45,%ah
4000a502:	80 fc 40             	cmp    $0x40,%ah
4000a505:	0f 85 5f f5 ff ff    	jne    40009a6a <_strtod_r+0x4ca>
4000a50b:	8b 45 08             	mov    0x8(%ebp),%eax
4000a50e:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
4000a515:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
4000a51c:	c7 00 22 00 00 00    	movl   $0x22,(%eax)
4000a522:	e9 66 f2 ff ff       	jmp    4000978d <_strtod_r+0x1ed>
4000a527:	8b b5 60 ff ff ff    	mov    -0xa0(%ebp),%esi
4000a52d:	8b 95 68 ff ff ff    	mov    -0x98(%ebp),%edx
4000a533:	8d 54 32 ff          	lea    -0x1(%edx,%esi,1),%edx
4000a537:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)
4000a53d:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
4000a543:	40                   	inc    %eax
4000a544:	89 45 8c             	mov    %eax,-0x74(%ebp)
4000a547:	83 bd 60 ff ff ff 08 	cmpl   $0x8,-0xa0(%ebp)
4000a54e:	0f 8f 54 fd ff ff    	jg     4000a2a8 <_strtod_r+0xd08>
4000a554:	8b 95 7c ff ff ff    	mov    -0x84(%ebp),%edx
4000a55a:	8b b5 44 ff ff ff    	mov    -0xbc(%ebp),%esi
4000a560:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%ebp)
4000a567:	00 00 00 
4000a56a:	8d 04 92             	lea    (%edx,%edx,4),%eax
4000a56d:	8d 04 46             	lea    (%esi,%eax,2),%eax
4000a570:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
4000a576:	e9 4f fd ff ff       	jmp    4000a2ca <_strtod_r+0xd2a>
4000a57b:	dd d8                	fstp   %st(0)
4000a57d:	d9 05 9c c5 00 40    	flds   0x4000c59c
4000a583:	d9 05 8c c8 00 40    	flds   0x4000c88c
4000a589:	e9 80 fa ff ff       	jmp    4000a00e <_strtod_r+0xa6e>
4000a58e:	ba 0f 00 00 00       	mov    $0xf,%edx
4000a593:	8b 75 8c             	mov    -0x74(%ebp),%esi
4000a596:	29 f2                	sub    %esi,%edx
4000a598:	8d 42 16             	lea    0x16(%edx),%eax
4000a59b:	39 45 90             	cmp    %eax,-0x70(%ebp)
4000a59e:	0f 8f 8c f4 ff ff    	jg     40009a30 <_strtod_r+0x490>
4000a5a4:	8b 4d 90             	mov    -0x70(%ebp),%ecx
4000a5a7:	dd 45 c0             	fldl   -0x40(%ebp)
4000a5aa:	29 d1                	sub    %edx,%ecx
4000a5ac:	dc 0c d5 20 c6 00 40 	fmull  0x4000c620(,%edx,8)
4000a5b3:	89 4d 90             	mov    %ecx,-0x70(%ebp)
4000a5b6:	8b 45 90             	mov    -0x70(%ebp),%eax
4000a5b9:	dc 0c c5 20 c6 00 40 	fmull  0x4000c620(,%eax,8)
4000a5c0:	dd 5d c0             	fstpl  -0x40(%ebp)
4000a5c3:	e9 c5 f1 ff ff       	jmp    4000978d <_strtod_r+0x1ed>
4000a5c8:	83 fa 69             	cmp    $0x69,%edx
4000a5cb:	0f 84 86 f8 ff ff    	je     40009e57 <_strtod_r+0x8b7>
4000a5d1:	83 fa 6e             	cmp    $0x6e,%edx
4000a5d4:	0f 85 a6 f1 ff ff    	jne    40009780 <_strtod_r+0x1e0>
4000a5da:	8d 5d dc             	lea    -0x24(%ebp),%ebx
4000a5dd:	ba 56 bc 00 40       	mov    $0x4000bc56,%edx
4000a5e2:	89 d8                	mov    %ebx,%eax
4000a5e4:	e8 67 ef ff ff       	call   40009550 <match>
4000a5e9:	85 c0                	test   %eax,%eax
4000a5eb:	0f 84 8f f1 ff ff    	je     40009780 <_strtod_r+0x1e0>
4000a5f1:	8b 45 dc             	mov    -0x24(%ebp),%eax
4000a5f4:	80 38 28             	cmpb   $0x28,(%eax)
4000a5f7:	0f 84 1f 01 00 00    	je     4000a71c <_strtod_r+0x117c>
4000a5fd:	c7 45 c4 00 00 f8 ff 	movl   $0xfff80000,-0x3c(%ebp)
4000a604:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
4000a60b:	e9 7d f1 ff ff       	jmp    4000978d <_strtod_r+0x1ed>
4000a610:	f7 45 c4 ff ff 0f 00 	testl  $0xfffff,-0x3c(%ebp)
4000a617:	0f 85 eb fd ff ff    	jne    4000a408 <_strtod_r+0xe68>
4000a61d:	8b 55 c0             	mov    -0x40(%ebp),%edx
4000a620:	85 d2                	test   %edx,%edx
4000a622:	0f 85 e3 fd ff ff    	jne    4000a40b <_strtod_r+0xe6b>
4000a628:	e9 57 fd ff ff       	jmp    4000a384 <_strtod_r+0xde4>
4000a62d:	83 7d 90 ea          	cmpl   $0xffffffea,-0x70(%ebp)
4000a631:	0f 8c f9 f3 ff ff    	jl     40009a30 <_strtod_r+0x490>
4000a637:	8b 45 90             	mov    -0x70(%ebp),%eax
4000a63a:	c1 e0 03             	shl    $0x3,%eax
4000a63d:	f7 d8                	neg    %eax
4000a63f:	dd 45 c0             	fldl   -0x40(%ebp)
4000a642:	dc b0 20 c6 00 40    	fdivl  0x4000c620(%eax)
4000a648:	dd 5d c0             	fstpl  -0x40(%ebp)
4000a64b:	e9 3d f1 ff ff       	jmp    4000978d <_strtod_r+0x1ed>
4000a650:	dd 45 c0             	fldl   -0x40(%ebp)
4000a653:	83 ec 10             	sub    $0x10,%esp
4000a656:	dd 14 24             	fstl   (%esp)
4000a659:	dd 9d 28 ff ff ff    	fstpl  -0xd8(%ebp)
4000a65f:	e8 3c d6 ff ff       	call   40007ca0 <__ulp>
4000a664:	83 c4 10             	add    $0x10,%esp
4000a667:	dd 85 28 ff ff ff    	fldl   -0xd8(%ebp)
4000a66d:	de e1                	fsubp  %st,%st(1)
4000a66f:	dd 55 c0             	fstl   -0x40(%ebp)
4000a672:	d9 ee                	fldz   
4000a674:	d9 c9                	fxch   %st(1)
4000a676:	da e9                	fucompp 
4000a678:	df e0                	fnstsw %ax
4000a67a:	80 e4 45             	and    $0x45,%ah
4000a67d:	80 fc 40             	cmp    $0x40,%ah
4000a680:	0f 84 f9 fa ff ff    	je     4000a17f <_strtod_r+0xbdf>
4000a686:	e9 af fd ff ff       	jmp    4000a43a <_strtod_r+0xe9a>
4000a68b:	05 00 00 50 03       	add    $0x3500000,%eax
4000a690:	c7 85 48 ff ff ff 00 	movl   $0x0,-0xb8(%ebp)
4000a697:	00 00 00 
4000a69a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
4000a69d:	e9 c8 f3 ff ff       	jmp    40009a6a <_strtod_r+0x4ca>
4000a6a2:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
4000a6a8:	8b 55 c0             	mov    -0x40(%ebp),%edx
4000a6ab:	85 c9                	test   %ecx,%ecx
4000a6ad:	74 68                	je     4000a717 <_strtod_r+0x1177>
4000a6af:	89 d8                	mov    %ebx,%eax
4000a6b1:	25 00 00 f0 7f       	and    $0x7ff00000,%eax
4000a6b6:	3d 00 00 a0 06       	cmp    $0x6a00000,%eax
4000a6bb:	77 5a                	ja     4000a717 <_strtod_r+0x1177>
4000a6bd:	c1 e8 14             	shr    $0x14,%eax
4000a6c0:	b9 6b 00 00 00       	mov    $0x6b,%ecx
4000a6c5:	29 c1                	sub    %eax,%ecx
4000a6c7:	83 c8 ff             	or     $0xffffffff,%eax
4000a6ca:	d3 e0                	shl    %cl,%eax
4000a6cc:	39 c2                	cmp    %eax,%edx
4000a6ce:	0f 85 37 fd ff ff    	jne    4000a40b <_strtod_r+0xe6b>
4000a6d4:	81 e3 00 00 f0 7f    	and    $0x7ff00000,%ebx
4000a6da:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
4000a6e1:	8d 83 00 00 10 00    	lea    0x100000(%ebx),%eax
4000a6e7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
4000a6ea:	e9 4b fd ff ff       	jmp    4000a43a <_strtod_r+0xe9a>
4000a6ef:	8b 45 c4             	mov    -0x3c(%ebp),%eax
4000a6f2:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%ebp)
4000a6f9:	25 00 00 f0 7f       	and    $0x7ff00000,%eax
4000a6fe:	2d 00 00 10 00       	sub    $0x100000,%eax
4000a703:	0d ff ff 0f 00       	or     $0xfffff,%eax
4000a708:	89 45 c4             	mov    %eax,-0x3c(%ebp)
4000a70b:	e9 2a fd ff ff       	jmp    4000a43a <_strtod_r+0xe9a>
4000a710:	dd d8                	fstp   %st(0)
4000a712:	e9 dd f7 ff ff       	jmp    40009ef4 <_strtod_r+0x954>
4000a717:	83 c8 ff             	or     $0xffffffff,%eax
4000a71a:	eb b0                	jmp    4000a6cc <_strtod_r+0x112c>
4000a71c:	50                   	push   %eax
4000a71d:	8d 45 b0             	lea    -0x50(%ebp),%eax
4000a720:	50                   	push   %eax
4000a721:	68 a8 d8 00 40       	push   $0x4000d8a8
4000a726:	53                   	push   %ebx
4000a727:	e8 24 12 00 00       	call   4000b950 <__hexnan>
4000a72c:	83 c4 10             	add    $0x10,%esp
4000a72f:	83 f8 05             	cmp    $0x5,%eax
4000a732:	0f 85 c5 fe ff ff    	jne    4000a5fd <_strtod_r+0x105d>
4000a738:	8b 45 b4             	mov    -0x4c(%ebp),%eax
4000a73b:	0d 00 00 f0 7f       	or     $0x7ff00000,%eax
4000a740:	89 45 c4             	mov    %eax,-0x3c(%ebp)
4000a743:	8b 45 b0             	mov    -0x50(%ebp),%eax
4000a746:	89 45 c0             	mov    %eax,-0x40(%ebp)
4000a749:	e9 3f f0 ff ff       	jmp    4000978d <_strtod_r+0x1ed>
4000a74e:	83 c8 ff             	or     $0xffffffff,%eax
4000a751:	8b 75 c0             	mov    -0x40(%ebp),%esi
4000a754:	d3 e0                	shl    %cl,%eax
4000a756:	21 c6                	and    %eax,%esi
4000a758:	89 75 c0             	mov    %esi,-0x40(%ebp)
4000a75b:	e9 94 fd ff ff       	jmp    4000a4f4 <_strtod_r+0xf54>
4000a760:	83 e9 20             	sub    $0x20,%ecx
4000a763:	83 c8 ff             	or     $0xffffffff,%eax
4000a766:	8b 7d c4             	mov    -0x3c(%ebp),%edi
4000a769:	d3 e0                	shl    %cl,%eax
4000a76b:	21 c7                	and    %eax,%edi
4000a76d:	89 7d c4             	mov    %edi,-0x3c(%ebp)
4000a770:	e9 7f fd ff ff       	jmp    4000a4f4 <_strtod_r+0xf54>
4000a775:	8d 74 26 00          	lea    0x0(%esi),%esi
4000a779:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

4000a780 <strtof>:
4000a780:	55                   	push   %ebp
4000a781:	89 e5                	mov    %esp,%ebp
4000a783:	83 ec 1c             	sub    $0x1c,%esp
4000a786:	8b 45 0c             	mov    0xc(%ebp),%eax
4000a789:	50                   	push   %eax
4000a78a:	8b 45 08             	mov    0x8(%ebp),%eax
4000a78d:	50                   	push   %eax
4000a78e:	a1 60 d0 00 40       	mov    0x4000d060,%eax
4000a793:	50                   	push   %eax
4000a794:	e8 07 ee ff ff       	call   400095a0 <_strtod_r>
4000a799:	dd 55 f0             	fstl   -0x10(%ebp)
4000a79c:	dd 1c 24             	fstpl  (%esp)
4000a79f:	e8 6c eb ff ff       	call   40009310 <__isnand>
4000a7a4:	83 c4 10             	add    $0x10,%esp
4000a7a7:	85 c0                	test   %eax,%eax
4000a7a9:	75 15                	jne    4000a7c0 <strtof+0x40>
4000a7ab:	dd 45 f0             	fldl   -0x10(%ebp)
4000a7ae:	d9 5d fc             	fstps  -0x4(%ebp)
4000a7b1:	d9 45 fc             	flds   -0x4(%ebp)
4000a7b4:	c9                   	leave  
4000a7b5:	c3                   	ret    
4000a7b6:	8d 76 00             	lea    0x0(%esi),%esi
4000a7b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
4000a7c0:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
4000a7c7:	c9                   	leave  
4000a7c8:	e9 43 ec ff ff       	jmp    40009410 <nanf>
4000a7cd:	8d 76 00             	lea    0x0(%esi),%esi

4000a7d0 <strtod>:
4000a7d0:	55                   	push   %ebp
4000a7d1:	89 e5                	mov    %esp,%ebp
4000a7d3:	83 ec 0c             	sub    $0xc,%esp
4000a7d6:	8b 15 60 d0 00 40    	mov    0x4000d060,%edx
4000a7dc:	8b 45 0c             	mov    0xc(%ebp),%eax
4000a7df:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000a7e2:	50                   	push   %eax
4000a7e3:	51                   	push   %ecx
4000a7e4:	52                   	push   %edx
4000a7e5:	e8 b6 ed ff ff       	call   400095a0 <_strtod_r>
4000a7ea:	c9                   	leave  
4000a7eb:	c3                   	ret    
4000a7ec:	90                   	nop    
4000a7ed:	90                   	nop    
4000a7ee:	90                   	nop    
4000a7ef:	90                   	nop    

4000a7f0 <_strtol_r>:
      return 0;
    }
  n = fp->_p - p;		/* write this much */

  /*
   * Set these immediately to avoid problems with longjmp
4000a7f0:	55                   	push   %ebp
4000a7f1:	89 e5                	mov    %esp,%ebp
4000a7f3:	57                   	push   %edi
4000a7f4:	56                   	push   %esi
4000a7f5:	53                   	push   %ebx
4000a7f6:	83 ec 18             	sub    $0x18,%esp
      t = (*fp->_write) (fp->_cookie, (char *) p, n);
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
4000a7f9:	a1 90 d8 00 40       	mov    0x4000d890,%eax
4000a7fe:	8b 4d 0c             	mov    0xc(%ebp),%ecx
4000a801:	89 45 e8             	mov    %eax,-0x18(%ebp)
4000a804:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000a80a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
    {
      t = (*fp->_write) (fp->_cookie, (char *) p, n);
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
4000a810:	8a 01                	mov    (%ecx),%al
          return EOF;
4000a812:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    {
      t = (*fp->_write) (fp->_cookie, (char *) p, n);
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
4000a815:	0f be d0             	movsbl %al,%edx
4000a818:	89 55 dc             	mov    %edx,-0x24(%ebp)
4000a81b:	41                   	inc    %ecx
          return EOF;
4000a81c:	f6 04 13 08          	testb  $0x8,(%ebx,%edx,1)
4000a820:	75 ee                	jne    4000a810 <_strtol_r+0x20>
	}
4000a822:	3c 2d                	cmp    $0x2d,%al
4000a824:	0f 84 2e 01 00 00    	je     4000a958 <_strtol_r+0x168>
      p += t;
      n -= t;
    }
4000a82a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000a831:	3c 2b                	cmp    $0x2b,%al
4000a833:	0f 84 4b 01 00 00    	je     4000a984 <_strtol_r+0x194>
  _funlockfile (fp);
  return 0;
4000a839:	8b 7d 14             	mov    0x14(%ebp),%edi
4000a83c:	85 ff                	test   %edi,%edi
4000a83e:	0f 94 c0             	sete   %al
4000a841:	0f 84 cc 00 00 00    	je     4000a913 <_strtol_r+0x123>
4000a847:	83 7d 14 10          	cmpl   $0x10,0x14(%ebp)
4000a84b:	0f 84 c2 00 00 00    	je     4000a913 <_strtol_r+0x123>
}
4000a851:	8b 5d 14             	mov    0x14(%ebp),%ebx
4000a854:	89 5d f0             	mov    %ebx,-0x10(%ebp)
4000a857:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
4000a85b:	19 c0                	sbb    %eax,%eax
4000a85d:	31 d2                	xor    %edx,%edx
4000a85f:	2d 00 00 00 80       	sub    $0x80000000,%eax
4000a864:	31 ff                	xor    %edi,%edi
4000a866:	f7 75 f0             	divl   -0x10(%ebp)
4000a869:	31 db                	xor    %ebx,%ebx
4000a86b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
4000a86e:	89 45 e0             	mov    %eax,-0x20(%ebp)
4000a871:	eb 44                	jmp    4000a8b7 <_strtol_r+0xc7>
4000a873:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000a879:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
4000a880:	83 ea 30             	sub    $0x30,%edx
4000a883:	39 55 14             	cmp    %edx,0x14(%ebp)
4000a886:	7e 59                	jle    4000a8e1 <_strtol_r+0xf1>
4000a888:	85 db                	test   %ebx,%ebx
4000a88a:	0f 88 c0 00 00 00    	js     4000a950 <_strtol_r+0x160>
4000a890:	3b 7d e0             	cmp    -0x20(%ebp),%edi
4000a893:	0f 87 b7 00 00 00    	ja     4000a950 <_strtol_r+0x160>
4000a899:	0f 84 a1 00 00 00    	je     4000a940 <_strtol_r+0x150>
4000a89f:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000a8a2:	bb 01 00 00 00       	mov    $0x1,%ebx
4000a8a7:	0f af c7             	imul   %edi,%eax
4000a8aa:	8d 3c 02             	lea    (%edx,%eax,1),%edi
4000a8ad:	8d 76 00             	lea    0x0(%esi),%esi
4000a8b0:	0f be 31             	movsbl (%ecx),%esi
4000a8b3:	41                   	inc    %ecx
4000a8b4:	89 75 dc             	mov    %esi,-0x24(%ebp)
4000a8b7:	8b 75 e8             	mov    -0x18(%ebp),%esi
4000a8ba:	8b 55 dc             	mov    -0x24(%ebp),%edx
4000a8bd:	0f be 04 16          	movsbl (%esi,%edx,1),%eax
4000a8c1:	a8 04                	test   $0x4,%al
4000a8c3:	75 bb                	jne    4000a880 <_strtol_r+0x90>
4000a8c5:	a8 03                	test   $0x3,%al
4000a8c7:	74 18                	je     4000a8e1 <_strtol_r+0xf1>
4000a8c9:	83 e0 01             	and    $0x1,%eax
4000a8cc:	8b 55 dc             	mov    -0x24(%ebp),%edx
4000a8cf:	83 f8 01             	cmp    $0x1,%eax
4000a8d2:	19 c0                	sbb    %eax,%eax
4000a8d4:	83 e0 20             	and    $0x20,%eax
4000a8d7:	83 c0 37             	add    $0x37,%eax
4000a8da:	29 c2                	sub    %eax,%edx
4000a8dc:	39 55 14             	cmp    %edx,0x14(%ebp)
4000a8df:	7f a7                	jg     4000a888 <_strtol_r+0x98>
4000a8e1:	85 db                	test   %ebx,%ebx
4000a8e3:	0f 88 82 00 00 00    	js     4000a96b <_strtol_r+0x17b>
4000a8e9:	8b 75 ec             	mov    -0x14(%ebp),%esi
4000a8ec:	89 f8                	mov    %edi,%eax
4000a8ee:	85 f6                	test   %esi,%esi
4000a8f0:	74 02                	je     4000a8f4 <_strtol_r+0x104>
4000a8f2:	f7 d8                	neg    %eax
4000a8f4:	8b 55 10             	mov    0x10(%ebp),%edx
4000a8f7:	85 d2                	test   %edx,%edx
4000a8f9:	74 10                	je     4000a90b <_strtol_r+0x11b>
4000a8fb:	85 db                	test   %ebx,%ebx
4000a8fd:	74 04                	je     4000a903 <_strtol_r+0x113>
4000a8ff:	49                   	dec    %ecx
4000a900:	89 4d 0c             	mov    %ecx,0xc(%ebp)
4000a903:	8b 4d 10             	mov    0x10(%ebp),%ecx
4000a906:	8b 5d 0c             	mov    0xc(%ebp),%ebx
4000a909:	89 19                	mov    %ebx,(%ecx)
4000a90b:	83 c4 18             	add    $0x18,%esp
4000a90e:	5b                   	pop    %ebx
4000a90f:	5e                   	pop    %esi
4000a910:	5f                   	pop    %edi
4000a911:	5d                   	pop    %ebp
4000a912:	c3                   	ret    
	}
      p += t;
      n -= t;
    }
  _funlockfile (fp);
  return 0;
4000a913:	83 7d dc 30          	cmpl   $0x30,-0x24(%ebp)
4000a917:	74 77                	je     4000a990 <_strtol_r+0x1a0>
}
4000a919:	84 c0                	test   %al,%al
4000a91b:	0f 84 30 ff ff ff    	je     4000a851 <_strtol_r+0x61>
4000a921:	83 7d dc 30          	cmpl   $0x30,-0x24(%ebp)
4000a925:	0f 95 c0             	setne  %al
4000a928:	25 ff 00 00 00       	and    $0xff,%eax
4000a92d:	8d 74 00 08          	lea    0x8(%eax,%eax,1),%esi
4000a931:	89 75 f0             	mov    %esi,-0x10(%ebp)
4000a934:	89 75 14             	mov    %esi,0x14(%ebp)
4000a937:	e9 1b ff ff ff       	jmp    4000a857 <_strtol_r+0x67>
4000a93c:	8d 74 26 00          	lea    0x0(%esi),%esi
4000a940:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
4000a943:	0f 8e 56 ff ff ff    	jle    4000a89f <_strtol_r+0xaf>
4000a949:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
4000a950:	83 cb ff             	or     $0xffffffff,%ebx
4000a953:	e9 58 ff ff ff       	jmp    4000a8b0 <_strtol_r+0xc0>
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
	}
      p += t;
      n -= t;
4000a958:	0f be 31             	movsbl (%ecx),%esi
4000a95b:	41                   	inc    %ecx
4000a95c:	89 75 dc             	mov    %esi,-0x24(%ebp)
4000a95f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
4000a966:	e9 ce fe ff ff       	jmp    4000a839 <_strtol_r+0x49>
4000a96b:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
4000a96f:	19 c0                	sbb    %eax,%eax
4000a971:	8b 55 08             	mov    0x8(%ebp),%edx
4000a974:	2d 00 00 00 80       	sub    $0x80000000,%eax
4000a979:	c7 02 22 00 00 00    	movl   $0x22,(%edx)
4000a97f:	e9 70 ff ff ff       	jmp    4000a8f4 <_strtol_r+0x104>
          return EOF;
	}
      p += t;
      n -= t;
    }
  _funlockfile (fp);
4000a984:	0f be 01             	movsbl (%ecx),%eax
4000a987:	41                   	inc    %ecx
4000a988:	89 45 dc             	mov    %eax,-0x24(%ebp)
4000a98b:	e9 a9 fe ff ff       	jmp    4000a839 <_strtol_r+0x49>
  return 0;
4000a990:	8a 19                	mov    (%ecx),%bl
4000a992:	80 fb 78             	cmp    $0x78,%bl
4000a995:	74 09                	je     4000a9a0 <_strtol_r+0x1b0>
4000a997:	80 fb 58             	cmp    $0x58,%bl
4000a99a:	0f 85 79 ff ff ff    	jne    4000a919 <_strtol_r+0x129>
}
4000a9a0:	0f be 51 01          	movsbl 0x1(%ecx),%edx
4000a9a4:	83 c1 02             	add    $0x2,%ecx
      n -= t;
    }
  _funlockfile (fp);
  return 0;
}
4000a9a7:	89 55 dc             	mov    %edx,-0x24(%ebp)
4000a9aa:	c7 45 14 10 00 00 00 	movl   $0x10,0x14(%ebp)
4000a9b1:	c7 45 f0 10 00 00 00 	movl   $0x10,-0x10(%ebp)
4000a9b8:	e9 9a fe ff ff       	jmp    4000a857 <_strtol_r+0x67>
4000a9bd:	8d 76 00             	lea    0x0(%esi),%esi

4000a9c0 <strtol>:
4000a9c0:	55                   	push   %ebp
4000a9c1:	89 e5                	mov    %esp,%ebp
4000a9c3:	8b 45 10             	mov    0x10(%ebp),%eax
4000a9c6:	50                   	push   %eax
4000a9c7:	8b 45 0c             	mov    0xc(%ebp),%eax
4000a9ca:	50                   	push   %eax
4000a9cb:	8b 45 08             	mov    0x8(%ebp),%eax
4000a9ce:	50                   	push   %eax
4000a9cf:	a1 60 d0 00 40       	mov    0x4000d060,%eax
4000a9d4:	50                   	push   %eax
4000a9d5:	e8 16 fe ff ff       	call   4000a7f0 <_strtol_r>
4000a9da:	c9                   	leave  
4000a9db:	c3                   	ret    
4000a9dc:	90                   	nop    
4000a9dd:	90                   	nop    
4000a9de:	90                   	nop    
4000a9df:	90                   	nop    

4000a9e0 <_strtoul_r>:
* Synopsis of compile-time options:

    People have reported using previous versions of this malloc on all
    versions of Unix, sometimes by tweaking some of the defines
    below. It has been tested most extensively on Solaris and
    Linux. It is also reported to work on WIN32 platforms.
4000a9e0:	55                   	push   %ebp
4000a9e1:	89 e5                	mov    %esp,%ebp
4000a9e3:	57                   	push   %edi
4000a9e4:	56                   	push   %esi
4000a9e5:	53                   	push   %ebx
4000a9e6:	83 ec 18             	sub    $0x18,%esp
    (for example gcc -O2) that can simplify expressions and control
    paths.

  __STD_C                  (default: derived from C compiler defines)
     Nonzero if using ANSI-standard C compiler, a C++ compiler, or
     a C compiler sufficiently close to ANSI to get away with it.
4000a9e9:	a1 90 d8 00 40       	mov    0x4000d890,%eax
4000a9ee:	8b 4d 0c             	mov    0xc(%ebp),%ecx
4000a9f1:	89 45 e0             	mov    %eax,-0x20(%ebp)
4000a9f4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000a9fa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
    all usable, this code should be compiled using an optimizing compiler
    (for example gcc -O2) that can simplify expressions and control
    paths.

  __STD_C                  (default: derived from C compiler defines)
     Nonzero if using ANSI-standard C compiler, a C++ compiler, or
4000aa00:	8a 01                	mov    (%ecx),%al
     a C compiler sufficiently close to ANSI to get away with it.
4000aa02:	8b 5d e0             	mov    -0x20(%ebp),%ebx
    all usable, this code should be compiled using an optimizing compiler
    (for example gcc -O2) that can simplify expressions and control
    paths.

  __STD_C                  (default: derived from C compiler defines)
     Nonzero if using ANSI-standard C compiler, a C++ compiler, or
4000aa05:	0f be d0             	movsbl %al,%edx
4000aa08:	89 55 dc             	mov    %edx,-0x24(%ebp)
4000aa0b:	41                   	inc    %ecx
     a C compiler sufficiently close to ANSI to get away with it.
4000aa0c:	f6 04 13 08          	testb  $0x8,(%ebx,%edx,1)
4000aa10:	75 ee                	jne    4000aa00 <_strtoul_r+0x20>
  DEBUG                    (default: NOT defined)
4000aa12:	3c 2d                	cmp    $0x2d,%al
4000aa14:	0f 84 1e 01 00 00    	je     4000ab38 <_strtoul_r+0x158>
     Define to enable debugging. Adds fairly extensive assertion-based 
     checking to help track down memory errors, but noticeably slows down
     execution.
4000aa1a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
4000aa21:	3c 2b                	cmp    $0x2b,%al
4000aa23:	0f 84 22 01 00 00    	je     4000ab4b <_strtoul_r+0x16b>
  SEPARATE_OBJECTS	   (default: NOT defined)
     Define this to compile into separate .o files.  You must then
4000aa29:	8b 5d 14             	mov    0x14(%ebp),%ebx
4000aa2c:	85 db                	test   %ebx,%ebx
4000aa2e:	0f 94 c0             	sete   %al
4000aa31:	0f 84 bf 00 00 00    	je     4000aaf6 <_strtoul_r+0x116>
4000aa37:	83 7d 14 10          	cmpl   $0x10,0x14(%ebp)
4000aa3b:	0f 84 b5 00 00 00    	je     4000aaf6 <_strtoul_r+0x116>
     compile malloc.c several times, defining a DEFINE_* macro each
     time.  The list of DEFINE_* macros appears below.
  MALLOC_LOCK		   (default: NOT defined)
  MALLOC_UNLOCK		   (default: NOT defined)
     Define these to C expressions which are run to lock and unlock
     the malloc data structures.  Calls may be nested; that is,
4000aa41:	8b 5d 14             	mov    0x14(%ebp),%ebx
4000aa44:	89 5d f0             	mov    %ebx,-0x10(%ebp)
     MALLOC_LOCK may be called more than once before the corresponding
4000aa47:	83 c8 ff             	or     $0xffffffff,%eax
4000aa4a:	31 d2                	xor    %edx,%edx
4000aa4c:	f7 f3                	div    %ebx
4000aa4e:	89 55 ec             	mov    %edx,-0x14(%ebp)
4000aa51:	89 45 e8             	mov    %eax,-0x18(%ebp)
4000aa54:	31 ff                	xor    %edi,%edi
4000aa56:	31 db                	xor    %ebx,%ebx
4000aa58:	eb 3d                	jmp    4000aa97 <_strtoul_r+0xb7>
4000aa5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     MALLOC_UNLOCK calls.  MALLOC_LOCK must avoid waiting for a lock
     that it already holds.
  MALLOC_ALIGNMENT          (default: NOT defined)
     Define this to 16 if you need 16 byte alignment instead of 8 byte alignment
     which is the normal default.
4000aa60:	83 ea 30             	sub    $0x30,%edx
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
     Define this if you think that realloc(p, 0) should be equivalent
     to free(p). Otherwise, since malloc returns a unique pointer for
     malloc(0), so does realloc(p, 0).
  HAVE_MEMCPY               (default: defined)
4000aa63:	39 55 14             	cmp    %edx,0x14(%ebp)
4000aa66:	7e 59                	jle    4000aac1 <_strtoul_r+0xe1>
     Define if you are not otherwise using ANSI STD C, but still 
     have memcpy and memset in your C library and want to use them.
4000aa68:	85 db                	test   %ebx,%ebx
4000aa6a:	0f 88 c0 00 00 00    	js     4000ab30 <_strtoul_r+0x150>
4000aa70:	3b 7d e8             	cmp    -0x18(%ebp),%edi
4000aa73:	0f 87 b7 00 00 00    	ja     4000ab30 <_strtoul_r+0x150>
4000aa79:	0f 84 a1 00 00 00    	je     4000ab20 <_strtoul_r+0x140>
     Otherwise, simple internal versions are supplied.
  USE_MEMCPY               (default: 1 if HAVE_MEMCPY is defined, 0 otherwise)
     Define as 1 if you want the C library versions of memset and
     memcpy called in realloc and calloc (otherwise macro versions are used). 
4000aa7f:	8b 45 f0             	mov    -0x10(%ebp),%eax
     At least on some platforms, the simple macro versions usually
4000aa82:	bb 01 00 00 00       	mov    $0x1,%ebx
     Define if you are not otherwise using ANSI STD C, but still 
     have memcpy and memset in your C library and want to use them.
     Otherwise, simple internal versions are supplied.
  USE_MEMCPY               (default: 1 if HAVE_MEMCPY is defined, 0 otherwise)
     Define as 1 if you want the C library versions of memset and
     memcpy called in realloc and calloc (otherwise macro versions are used). 
4000aa87:	0f af c7             	imul   %edi,%eax
     At least on some platforms, the simple macro versions usually
4000aa8a:	8d 3c 02             	lea    (%edx,%eax,1),%edi
4000aa8d:	8d 76 00             	lea    0x0(%esi),%esi
     Define these to C expressions which are run to lock and unlock
     the malloc data structures.  Calls may be nested; that is,
     MALLOC_LOCK may be called more than once before the corresponding
     MALLOC_UNLOCK calls.  MALLOC_LOCK must avoid waiting for a lock
     that it already holds.
  MALLOC_ALIGNMENT          (default: NOT defined)
4000aa90:	0f be 31             	movsbl (%ecx),%esi
4000aa93:	41                   	inc    %ecx
4000aa94:	89 75 dc             	mov    %esi,-0x24(%ebp)
     Define this to 16 if you need 16 byte alignment instead of 8 byte alignment
4000aa97:	8b 75 e0             	mov    -0x20(%ebp),%esi
4000aa9a:	8b 55 dc             	mov    -0x24(%ebp),%edx
4000aa9d:	0f be 04 16          	movsbl (%esi,%edx,1),%eax
4000aaa1:	a8 04                	test   $0x4,%al
4000aaa3:	75 bb                	jne    4000aa60 <_strtoul_r+0x80>
     which is the normal default.
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
4000aaa5:	a8 03                	test   $0x3,%al
4000aaa7:	74 18                	je     4000aac1 <_strtoul_r+0xe1>
     Define this if you think that realloc(p, 0) should be equivalent
4000aaa9:	83 e0 01             	and    $0x1,%eax
4000aaac:	8b 55 dc             	mov    -0x24(%ebp),%edx
4000aaaf:	83 f8 01             	cmp    $0x1,%eax
4000aab2:	19 c0                	sbb    %eax,%eax
4000aab4:	83 e0 20             	and    $0x20,%eax
4000aab7:	83 c0 37             	add    $0x37,%eax
4000aaba:	29 c2                	sub    %eax,%edx
     to free(p). Otherwise, since malloc returns a unique pointer for
     malloc(0), so does realloc(p, 0).
  HAVE_MEMCPY               (default: defined)
4000aabc:	39 55 14             	cmp    %edx,0x14(%ebp)
4000aabf:	7f a7                	jg     4000aa68 <_strtoul_r+0x88>
     Define as 1 if you want the C library versions of memset and
     memcpy called in realloc and calloc (otherwise macro versions are used). 
     At least on some platforms, the simple macro versions usually
     outperform libc versions.
  HAVE_MMAP                 (default: defined as 1)
     Define to non-zero to optionally make malloc() use mmap() to
4000aac1:	85 db                	test   %ebx,%ebx
4000aac3:	0f 89 c5 00 00 00    	jns    4000ab8e <_strtoul_r+0x1ae>
     allocate very large blocks.  
  HAVE_MREMAP                 (default: defined as 0 unless Linux libc set)
4000aac9:	8b 45 08             	mov    0x8(%ebp),%eax
4000aacc:	83 cf ff             	or     $0xffffffff,%edi
4000aacf:	c7 00 22 00 00 00    	movl   $0x22,(%eax)
     Define to non-zero to optionally make realloc() use mremap() to
     reallocate very large blocks.  
  malloc_getpagesize        (default: derived from system #includes)
4000aad5:	8b 45 10             	mov    0x10(%ebp),%eax
4000aad8:	85 c0                	test   %eax,%eax
4000aada:	74 10                	je     4000aaec <_strtoul_r+0x10c>
     Either a constant or routine call returning the system page size.
4000aadc:	85 db                	test   %ebx,%ebx
4000aade:	74 04                	je     4000aae4 <_strtoul_r+0x104>
4000aae0:	49                   	dec    %ecx
4000aae1:	89 4d 0c             	mov    %ecx,0xc(%ebp)
4000aae4:	8b 55 10             	mov    0x10(%ebp),%edx
4000aae7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
4000aaea:	89 1a                	mov    %ebx,(%edx)
  HAVE_USR_INCLUDE_MALLOC_H (default: NOT defined) 
     Optionally define if you are on a system with a /usr/include/malloc.h
4000aaec:	83 c4 18             	add    $0x18,%esp
4000aaef:	89 f8                	mov    %edi,%eax
4000aaf1:	5b                   	pop    %ebx
4000aaf2:	5e                   	pop    %esi
4000aaf3:	5f                   	pop    %edi
4000aaf4:	5d                   	pop    %ebp
4000aaf5:	c3                   	ret    
  DEBUG                    (default: NOT defined)
     Define to enable debugging. Adds fairly extensive assertion-based 
     checking to help track down memory errors, but noticeably slows down
     execution.
  SEPARATE_OBJECTS	   (default: NOT defined)
     Define this to compile into separate .o files.  You must then
4000aaf6:	83 7d dc 30          	cmpl   $0x30,-0x24(%ebp)
4000aafa:	74 5b                	je     4000ab57 <_strtoul_r+0x177>
     compile malloc.c several times, defining a DEFINE_* macro each
     time.  The list of DEFINE_* macros appears below.
  MALLOC_LOCK		   (default: NOT defined)
  MALLOC_UNLOCK		   (default: NOT defined)
     Define these to C expressions which are run to lock and unlock
     the malloc data structures.  Calls may be nested; that is,
4000aafc:	84 c0                	test   %al,%al
4000aafe:	0f 84 3d ff ff ff    	je     4000aa41 <_strtoul_r+0x61>
     MALLOC_LOCK may be called more than once before the corresponding
4000ab04:	83 7d dc 30          	cmpl   $0x30,-0x24(%ebp)
4000ab08:	0f 95 c0             	setne  %al
4000ab0b:	25 ff 00 00 00       	and    $0xff,%eax
4000ab10:	8d 5c 00 08          	lea    0x8(%eax,%eax,1),%ebx
4000ab14:	89 5d f0             	mov    %ebx,-0x10(%ebp)
4000ab17:	89 5d 14             	mov    %ebx,0x14(%ebp)
4000ab1a:	e9 28 ff ff ff       	jmp    4000aa47 <_strtoul_r+0x67>
4000ab1f:	90                   	nop    
     Define this if you think that realloc(p, 0) should be equivalent
     to free(p). Otherwise, since malloc returns a unique pointer for
     malloc(0), so does realloc(p, 0).
  HAVE_MEMCPY               (default: defined)
     Define if you are not otherwise using ANSI STD C, but still 
     have memcpy and memset in your C library and want to use them.
4000ab20:	3b 55 ec             	cmp    -0x14(%ebp),%edx
4000ab23:	0f 8e 56 ff ff ff    	jle    4000aa7f <_strtoul_r+0x9f>
4000ab29:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
     Otherwise, simple internal versions are supplied.
  USE_MEMCPY               (default: 1 if HAVE_MEMCPY is defined, 0 otherwise)
     Define as 1 if you want the C library versions of memset and
     memcpy called in realloc and calloc (otherwise macro versions are used). 
     At least on some platforms, the simple macro versions usually
4000ab30:	83 cb ff             	or     $0xffffffff,%ebx
4000ab33:	e9 58 ff ff ff       	jmp    4000aa90 <_strtoul_r+0xb0>
  __STD_C                  (default: derived from C compiler defines)
     Nonzero if using ANSI-standard C compiler, a C++ compiler, or
     a C compiler sufficiently close to ANSI to get away with it.
  DEBUG                    (default: NOT defined)
     Define to enable debugging. Adds fairly extensive assertion-based 
     checking to help track down memory errors, but noticeably slows down
4000ab38:	0f be 31             	movsbl (%ecx),%esi
4000ab3b:	41                   	inc    %ecx
4000ab3c:	89 75 dc             	mov    %esi,-0x24(%ebp)
4000ab3f:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
4000ab46:	e9 de fe ff ff       	jmp    4000aa29 <_strtoul_r+0x49>
     execution.
  SEPARATE_OBJECTS	   (default: NOT defined)
4000ab4b:	0f be 01             	movsbl (%ecx),%eax
4000ab4e:	41                   	inc    %ecx
4000ab4f:	89 45 dc             	mov    %eax,-0x24(%ebp)
4000ab52:	e9 d2 fe ff ff       	jmp    4000aa29 <_strtoul_r+0x49>
     Define this to compile into separate .o files.  You must then
4000ab57:	8a 19                	mov    (%ecx),%bl
4000ab59:	80 fb 78             	cmp    $0x78,%bl
4000ab5c:	74 05                	je     4000ab63 <_strtoul_r+0x183>
4000ab5e:	80 fb 58             	cmp    $0x58,%bl
4000ab61:	75 99                	jne    4000aafc <_strtoul_r+0x11c>
     compile malloc.c several times, defining a DEFINE_* macro each
     time.  The list of DEFINE_* macros appears below.
4000ab63:	0f be 51 01          	movsbl 0x1(%ecx),%edx
  MALLOC_LOCK		   (default: NOT defined)
4000ab67:	83 c1 02             	add    $0x2,%ecx
     checking to help track down memory errors, but noticeably slows down
     execution.
  SEPARATE_OBJECTS	   (default: NOT defined)
     Define this to compile into separate .o files.  You must then
     compile malloc.c several times, defining a DEFINE_* macro each
     time.  The list of DEFINE_* macros appears below.
4000ab6a:	89 55 dc             	mov    %edx,-0x24(%ebp)
  MALLOC_LOCK		   (default: NOT defined)
4000ab6d:	c7 45 14 10 00 00 00 	movl   $0x10,0x14(%ebp)
4000ab74:	c7 45 f0 10 00 00 00 	movl   $0x10,-0x10(%ebp)
4000ab7b:	c7 45 e8 ff ff ff 0f 	movl   $0xfffffff,-0x18(%ebp)
4000ab82:	c7 45 ec 0f 00 00 00 	movl   $0xf,-0x14(%ebp)
4000ab89:	e9 c6 fe ff ff       	jmp    4000aa54 <_strtoul_r+0x74>
     outperform libc versions.
  HAVE_MMAP                 (default: defined as 1)
     Define to non-zero to optionally make malloc() use mmap() to
     allocate very large blocks.  
  HAVE_MREMAP                 (default: defined as 0 unless Linux libc set)
     Define to non-zero to optionally make realloc() use mremap() to
4000ab8e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
4000ab91:	85 d2                	test   %edx,%edx
4000ab93:	0f 84 3c ff ff ff    	je     4000aad5 <_strtoul_r+0xf5>
     reallocate very large blocks.  
4000ab99:	f7 df                	neg    %edi
4000ab9b:	e9 35 ff ff ff       	jmp    4000aad5 <_strtoul_r+0xf5>

4000aba0 <strtoul>:
     Define to a 32-bit type (probably `unsigned int') if you are on a 
     64-bit machine, yet do not want or need to allow malloc requests of 
     greater than 2^31 to be handled. This saves space, especially for
     very small chunks.
  INTERNAL_LINUX_C_LIB      (default: NOT defined)
     Defined only when compiled as part of Linux libc.
4000aba0:	55                   	push   %ebp
4000aba1:	89 e5                	mov    %esp,%ebp
     Also note that there is some odd internal name-mangling via defines
4000aba3:	8b 45 10             	mov    0x10(%ebp),%eax
4000aba6:	50                   	push   %eax
4000aba7:	8b 45 0c             	mov    0xc(%ebp),%eax
4000abaa:	50                   	push   %eax
4000abab:	8b 45 08             	mov    0x8(%ebp),%eax
4000abae:	50                   	push   %eax
4000abaf:	a1 60 d0 00 40       	mov    0x4000d060,%eax
4000abb4:	50                   	push   %eax
4000abb5:	e8 26 fe ff ff       	call   4000a9e0 <_strtoul_r>
     (for example, internally, `malloc' is named `mALLOc') needed
4000abba:	c9                   	leave  
4000abbb:	c3                   	ret    
4000abbc:	90                   	nop    
4000abbd:	90                   	nop    
4000abbe:	90                   	nop    
4000abbf:	90                   	nop    

4000abc0 <__submore>:
to the host system, in order to minimize the overhead of system calls.

Use <<fflush>> to deliver any such pending output (for the file
or stream identified by <[fp]>) to the host system.

If <[fp]> is <<NULL>>, <<fflush>> delivers pending output from all
4000abc0:	55                   	push   %ebp
4000abc1:	89 e5                	mov    %esp,%ebp
4000abc3:	57                   	push   %edi
4000abc4:	56                   	push   %esi
4000abc5:	53                   	push   %ebx
4000abc6:	83 ec 0c             	sub    $0xc,%esp
4000abc9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
4000abcc:	8b 4d 08             	mov    0x8(%ebp),%ecx
open files.

RETURNS
<<fflush>> returns <<0>> unless it encounters a write error; in that
4000abcf:	8b 53 30             	mov    0x30(%ebx),%edx
4000abd2:	8d 43 40             	lea    0x40(%ebx),%eax
4000abd5:	39 c2                	cmp    %eax,%edx
4000abd7:	74 57                	je     4000ac30 <__submore+0x70>
#include <stdio.h>
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */

int
4000abd9:	8b 7b 34             	mov    0x34(%ebx),%edi
_DEFUN(fflush, (fp),
4000abdc:	8d 04 3f             	lea    (%edi,%edi,1),%eax
4000abdf:	89 45 f0             	mov    %eax,-0x10(%ebp)
4000abe2:	56                   	push   %esi
4000abe3:	50                   	push   %eax
4000abe4:	52                   	push   %edx
4000abe5:	51                   	push   %ecx
4000abe6:	e8 85 dd ff ff       	call   40008970 <_realloc_r>
       register FILE * fp)
4000abeb:	83 c4 10             	add    $0x10,%esp
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */

int
_DEFUN(fflush, (fp),
4000abee:	89 c6                	mov    %eax,%esi
       register FILE * fp)
4000abf0:	85 c0                	test   %eax,%eax
4000abf2:	74 2c                	je     4000ac20 <__submore+0x60>
{
  register unsigned char *p;
4000abf4:	8d 04 38             	lea    (%eax,%edi,1),%eax
4000abf7:	89 45 ec             	mov    %eax,-0x14(%ebp)
4000abfa:	52                   	push   %edx
4000abfb:	57                   	push   %edi
4000abfc:	56                   	push   %esi
4000abfd:	50                   	push   %eax
4000abfe:	e8 4d ce ff ff       	call   40007a50 <memcpy>
  register int n, t;
4000ac03:	8b 45 ec             	mov    -0x14(%ebp),%eax

4000ac06:	89 73 30             	mov    %esi,0x30(%ebx)
int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  register unsigned char *p;
  register int n, t;
4000ac09:	89 03                	mov    %eax,(%ebx)

  if (fp == NULL)
4000ac0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000ac0e:	89 43 34             	mov    %eax,0x34(%ebx)
    return _fwalk (_GLOBAL_REENT, fflush);
4000ac11:	83 c4 10             	add    $0x10,%esp
       register FILE * fp)
{
  register unsigned char *p;
  register int n, t;

  if (fp == NULL)
4000ac14:	31 c0                	xor    %eax,%eax
    return _fwalk (_GLOBAL_REENT, fflush);

4000ac16:	8d 65 f4             	lea    -0xc(%ebp),%esp
4000ac19:	5b                   	pop    %ebx
4000ac1a:	5e                   	pop    %esi
4000ac1b:	5f                   	pop    %edi
4000ac1c:	5d                   	pop    %ebp
4000ac1d:	c3                   	ret    
4000ac1e:	66 90                	xchg   %ax,%ax
4000ac20:	8d 65 f4             	lea    -0xc(%ebp),%esp
{
  register unsigned char *p;
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);
4000ac23:	83 c8 ff             	or     $0xffffffff,%eax

4000ac26:	5b                   	pop    %ebx
4000ac27:	5e                   	pop    %esi
4000ac28:	5f                   	pop    %edi
4000ac29:	5d                   	pop    %ebp
4000ac2a:	c3                   	ret    
4000ac2b:	90                   	nop    
4000ac2c:	8d 74 26 00          	lea    0x0(%esi),%esi
<<fflush>> returns <<0>> unless it encounters a write error; in that
situation, it returns <<EOF>>.

PORTABILITY
ANSI C requires <<fflush>>.

4000ac30:	57                   	push   %edi
4000ac31:	57                   	push   %edi
4000ac32:	68 00 04 00 00       	push   $0x400
4000ac37:	51                   	push   %ecx
4000ac38:	e8 a3 5b ff ff       	call   400007e0 <_malloc_r>
4000ac3d:	83 c4 10             	add    $0x10,%esp
4000ac40:	89 c1                	mov    %eax,%ecx
4000ac42:	85 c0                	test   %eax,%eax
4000ac44:	74 da                	je     4000ac20 <__submore+0x60>
No supporting OS subroutines are required.
*/

#include <_ansi.h>
4000ac46:	8d 90 fd 03 00 00    	lea    0x3fd(%eax),%edx

PORTABILITY
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
*/
4000ac4c:	89 43 30             	mov    %eax,0x30(%ebx)

#include <_ansi.h>
#include <stdio.h>
#include "local.h"
4000ac4f:	8a 43 42             	mov    0x42(%ebx),%al
PORTABILITY
ANSI C requires <<fflush>>.

No supporting OS subroutines are required.
*/

4000ac52:	c7 43 34 00 04 00 00 	movl   $0x400,0x34(%ebx)
#include <_ansi.h>
#include <stdio.h>
#include "local.h"
4000ac59:	88 42 02             	mov    %al,0x2(%edx)
4000ac5c:	8a 43 41             	mov    0x41(%ebx),%al
4000ac5f:	88 42 01             	mov    %al,0x1(%edx)
4000ac62:	8a 43 40             	mov    0x40(%ebx),%al
4000ac65:	88 81 fd 03 00 00    	mov    %al,0x3fd(%ecx)

4000ac6b:	89 13                	mov    %edx,(%ebx)
4000ac6d:	31 c0                	xor    %eax,%eax
  register unsigned char *p;
  register int n, t;

  if (fp == NULL)
    return _fwalk (_GLOBAL_REENT, fflush);

4000ac6f:	8d 65 f4             	lea    -0xc(%ebp),%esp
4000ac72:	5b                   	pop    %ebx
4000ac73:	5e                   	pop    %esi
4000ac74:	5f                   	pop    %edi
4000ac75:	5d                   	pop    %ebp
4000ac76:	c3                   	ret    
4000ac77:	89 f6                	mov    %esi,%esi
4000ac79:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

4000ac80 <_ungetc_r>:

  _flockfile (fp);

  t = fp->_flags;
  if ((t & __SWR) == 0)
    {
4000ac80:	55                   	push   %ebp
4000ac81:	89 e5                	mov    %esp,%ebp
4000ac83:	57                   	push   %edi
4000ac84:	56                   	push   %esi
4000ac85:	53                   	push   %ebx
4000ac86:	83 ec 0c             	sub    $0xc,%esp
4000ac89:	8b 7d 0c             	mov    0xc(%ebp),%edi
4000ac8c:	8b 5d 10             	mov    0x10(%ebp),%ebx
      _fpos_t _EXFUN((*seekfn), (_PTR, _fpos_t, int));
4000ac8f:	83 ff ff             	cmp    $0xffffffff,%edi
4000ac92:	74 56                	je     4000acea <_ungetc_r+0x6a>
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;

      /* For a seekable stream with buffered read characters, we will attempt
4000ac94:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000ac97:	85 c9                	test   %ecx,%ecx
4000ac99:	74 0a                	je     4000aca5 <_ungetc_r+0x25>
4000ac9b:	8b 45 08             	mov    0x8(%ebp),%eax
4000ac9e:	8b 50 38             	mov    0x38(%eax),%edx
4000aca1:	85 d2                	test   %edx,%edx
4000aca3:	74 5b                	je     4000ad00 <_ungetc_r+0x80>
         a seek to the current position now.  A subsequent read will then get
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
4000aca5:	8b 43 0c             	mov    0xc(%ebx),%eax
4000aca8:	83 e0 df             	and    $0xffffffdf,%eax
4000acab:	66 89 43 0c          	mov    %ax,0xc(%ebx)
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && (seekfn = fp->_seek) != NULL)
4000acaf:	98                   	cwtl   
4000acb0:	a8 04                	test   $0x4,%al
4000acb2:	0f 84 b8 00 00 00    	je     4000ad70 <_ungetc_r+0xf0>
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
              if (HASUB (fp))
                curoff -= fp->_ur;
            }
4000acb8:	89 fa                	mov    %edi,%edx
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
              fp->_p = fp->_bf._base;
4000acba:	8b 43 30             	mov    0x30(%ebx),%eax
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
              if (HASUB (fp))
                curoff -= fp->_ur;
            }
4000acbd:	81 e2 ff 00 00 00    	and    $0xff,%edx
4000acc3:	89 fe                	mov    %edi,%esi
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
              fp->_p = fp->_bf._base;
4000acc5:	85 c0                	test   %eax,%eax
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
              if (HASUB (fp))
                curoff -= fp->_ur;
            }
4000acc7:	89 d7                	mov    %edx,%edi
          if ((*seekfn)(fp->_cookie, curoff, SEEK_SET) != -1)
            {
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
              fp->_p = fp->_bf._base;
4000acc9:	74 45                	je     4000ad10 <_ungetc_r+0x90>
              if (fp->_flags & __SOFF)
                fp->_offset = curoff;
4000accb:	8b 43 04             	mov    0x4(%ebx),%eax
4000acce:	3b 43 34             	cmp    0x34(%ebx),%eax
4000acd1:	0f 8d af 00 00 00    	jge    4000ad86 <_ungetc_r+0x106>
            }
        } 
      _funlockfile (fp);
      return 0;
    }
4000acd7:	8b 03                	mov    (%ebx),%eax
4000acd9:	8d 50 ff             	lea    -0x1(%eax),%edx
4000acdc:	89 13                	mov    %edx,(%ebx)
4000acde:	89 f2                	mov    %esi,%edx
4000ace0:	88 50 ff             	mov    %dl,-0x1(%eax)
  if ((p = fp->_bf._base) == NULL)
4000ace3:	8b 43 04             	mov    0x4(%ebx),%eax
4000ace6:	40                   	inc    %eax
4000ace7:	89 43 04             	mov    %eax,0x4(%ebx)
  _funlockfile (fp);
  return 0;
}
4000acea:	8d 65 f4             	lea    -0xc(%ebp),%esp
4000aced:	89 f8                	mov    %edi,%eax
4000acef:	5b                   	pop    %ebx
4000acf0:	5e                   	pop    %esi
4000acf1:	5f                   	pop    %edi
4000acf2:	5d                   	pop    %ebp
4000acf3:	c3                   	ret    
4000acf4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000acfa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;

      /* For a seekable stream with buffered read characters, we will attempt
4000ad00:	83 ec 0c             	sub    $0xc,%esp
4000ad03:	50                   	push   %eax
4000ad04:	e8 f7 56 ff ff       	call   40000400 <__sinit>
4000ad09:	83 c4 10             	add    $0x10,%esp
4000ad0c:	eb 97                	jmp    4000aca5 <_ungetc_r+0x25>
4000ad0e:	66 90                	xchg   %ax,%ax
  n = fp->_p - p;		/* write this much */

  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
4000ad10:	8b 43 10             	mov    0x10(%ebx),%eax
4000ad13:	85 c0                	test   %eax,%eax
4000ad15:	74 6b                	je     4000ad82 <_ungetc_r+0x102>
4000ad17:	8b 13                	mov    (%ebx),%edx
4000ad19:	39 d0                	cmp    %edx,%eax
4000ad1b:	73 13                	jae    4000ad30 <_ungetc_r+0xb0>
4000ad1d:	31 c0                	xor    %eax,%eax
4000ad1f:	8a 42 ff             	mov    -0x1(%edx),%al
4000ad22:	39 f8                	cmp    %edi,%eax
4000ad24:	74 3b                	je     4000ad61 <_ungetc_r+0xe1>
4000ad26:	8d 76 00             	lea    0x0(%esi),%esi
4000ad29:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
	}
4000ad30:	8b 43 04             	mov    0x4(%ebx),%eax
      p += t;
4000ad33:	89 53 38             	mov    %edx,0x38(%ebx)
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          _funlockfile (fp);
          return EOF;
	}
4000ad36:	89 43 3c             	mov    %eax,0x3c(%ebx)
      p += t;
      n -= t;
4000ad39:	8d 43 40             	lea    0x40(%ebx),%eax
4000ad3c:	89 43 30             	mov    %eax,0x30(%ebx)
    }
  _funlockfile (fp);
4000ad3f:	89 f0                	mov    %esi,%eax
4000ad41:	88 43 42             	mov    %al,0x42(%ebx)
  return 0;
4000ad44:	8d 43 42             	lea    0x42(%ebx),%eax
4000ad47:	89 03                	mov    %eax,(%ebx)
          _funlockfile (fp);
          return EOF;
	}
      p += t;
      n -= t;
    }
4000ad49:	c7 43 34 03 00 00 00 	movl   $0x3,0x34(%ebx)
  _funlockfile (fp);
  return 0;
}
4000ad50:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
4000ad57:	89 f8                	mov    %edi,%eax
4000ad59:	8d 65 f4             	lea    -0xc(%ebp),%esp
4000ad5c:	5b                   	pop    %ebx
4000ad5d:	5e                   	pop    %esi
4000ad5e:	5f                   	pop    %edi
4000ad5f:	5d                   	pop    %ebp
4000ad60:	c3                   	ret    
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
4000ad61:	8b 43 04             	mov    0x4(%ebx),%eax
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
4000ad64:	4a                   	dec    %edx
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
4000ad65:	40                   	inc    %eax
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
4000ad66:	89 13                	mov    %edx,(%ebx)
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
4000ad68:	89 43 04             	mov    %eax,0x4(%ebx)
4000ad6b:	e9 7a ff ff ff       	jmp    4000acea <_ungetc_r+0x6a>
        {
          _fpos_t curoff;

          /* Get the physical position we are at in the file.  */
          if (fp->_flags & __SOFF)
            curoff = fp->_offset;
4000ad70:	a8 10                	test   $0x10,%al
4000ad72:	74 29                	je     4000ad9d <_ungetc_r+0x11d>
          else
            {
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
4000ad74:	a8 08                	test   $0x8,%al
4000ad76:	75 2d                	jne    4000ada5 <_ungetc_r+0x125>
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
              if (HASUB (fp))
4000ad78:	66 83 4b 0c 04       	orw    $0x4,0xc(%ebx)
4000ad7d:	e9 36 ff ff ff       	jmp    4000acb8 <_ungetc_r+0x38>
4000ad82:	8b 13                	mov    (%ebx),%edx
4000ad84:	eb aa                	jmp    4000ad30 <_ungetc_r+0xb0>
              /* Seek successful.  We can clear read buffer now.  */
              fp->_flags &= ~__SNPT;
              fp->_r = 0;
              fp->_p = fp->_bf._base;
              if (fp->_flags & __SOFF)
                fp->_offset = curoff;
4000ad86:	50                   	push   %eax
4000ad87:	50                   	push   %eax
4000ad88:	53                   	push   %ebx
4000ad89:	8b 45 08             	mov    0x8(%ebp),%eax
4000ad8c:	50                   	push   %eax
4000ad8d:	e8 2e fe ff ff       	call   4000abc0 <__submore>
4000ad92:	83 c4 10             	add    $0x10,%esp
4000ad95:	85 c0                	test   %eax,%eax
4000ad97:	0f 84 3a ff ff ff    	je     4000acd7 <_ungetc_r+0x57>
    }
  _funlockfile (fp);
  return 0;
}
4000ad9d:	83 cf ff             	or     $0xffffffff,%edi
4000ada0:	e9 45 ff ff ff       	jmp    4000acea <_ungetc_r+0x6a>
            {
              /* We don't know current physical offset, so ask for it.  */
              curoff = (*seekfn) (fp->_cookie, (_fpos_t) 0, SEEK_CUR);
              if (curoff == -1L)
                {
                  _funlockfile (fp);
4000ada5:	83 ec 0c             	sub    $0xc,%esp
4000ada8:	53                   	push   %ebx
4000ada9:	e8 42 54 ff ff       	call   400001f0 <fflush>
4000adae:	83 c4 10             	add    $0x10,%esp
4000adb1:	85 c0                	test   %eax,%eax
4000adb3:	75 e8                	jne    4000ad9d <_ungetc_r+0x11d>
                  return 0;
                }
            }
          if (fp->_flags & __SRD)
            {
4000adb5:	66 83 63 0c f7       	andw   $0xfffffff7,0xc(%ebx)
              /* Current offset is at end of buffer.  Compensate for
4000adba:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
                 characters not yet read.  */
4000adc1:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
4000adc8:	eb ae                	jmp    4000ad78 <_ungetc_r+0xf8>
4000adca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

4000add0 <ungetc>:
4000add0:	55                   	push   %ebp
4000add1:	89 e5                	mov    %esp,%ebp
4000add3:	83 ec 0c             	sub    $0xc,%esp
4000add6:	8b 45 0c             	mov    0xc(%ebp),%eax
4000add9:	50                   	push   %eax
4000adda:	8b 45 08             	mov    0x8(%ebp),%eax
4000addd:	50                   	push   %eax
4000adde:	a1 60 d0 00 40       	mov    0x4000d060,%eax
4000ade3:	50                   	push   %eax
4000ade4:	e8 97 fe ff ff       	call   4000ac80 <_ungetc_r>
4000ade9:	c9                   	leave  
4000adea:	c3                   	ret    
4000adeb:	90                   	nop    
4000adec:	90                   	nop    
4000aded:	90                   	nop    
4000adee:	90                   	nop    
4000adef:	90                   	nop    

4000adf0 <__call_exitprocs>:
   Note: There may be an updated version of this malloc obtainable at
           ftp://g.oswego.edu/pub/misc/malloc.c
         Check before installing!

* Why use this malloc?

4000adf0:	55                   	push   %ebp
4000adf1:	89 e5                	mov    %esp,%ebp
4000adf3:	57                   	push   %edi
4000adf4:	56                   	push   %esi
4000adf5:	53                   	push   %ebx
4000adf6:	83 ec 0c             	sub    $0xc,%esp
  while also being among the most space-conserving, portable and tunable.
  Consistent balance across these factors results in a good general-purpose 
  allocator. For a high-level description, see 
     http://g.oswego.edu/dl/html/malloc.html

* Synopsis of public routines
4000adf9:	a1 34 bc 00 40       	mov    0x4000bc34,%eax
4000adfe:	8b b8 48 01 00 00    	mov    0x148(%eax),%edi

  (Much fuller descriptions are contained in the program documentation below.)
4000ae04:	85 ff                	test   %edi,%edi
4000ae06:	0f 84 b6 00 00 00    	je     4000aec2 <__call_exitprocs+0xd2>
  Consistent balance across these factors results in a good general-purpose 
  allocator. For a high-level description, see 
     http://g.oswego.edu/dl/html/malloc.html

* Synopsis of public routines

4000ae0c:	05 48 01 00 00       	add    $0x148,%eax
4000ae11:	89 45 f0             	mov    %eax,-0x10(%ebp)
  malloc(size_t n);
     Return a pointer to a newly allocated chunk of at least n bytes, or null
     if no space is available.
  free(Void_t* p);
     Release the chunk of memory pointed to by p, or no effect if p is null.
  realloc(Void_t* p, size_t n);
4000ae14:	8b 47 04             	mov    0x4(%edi),%eax
4000ae17:	89 c6                	mov    %eax,%esi
4000ae19:	4e                   	dec    %esi
4000ae1a:	0f 88 78 00 00 00    	js     4000ae98 <__call_exitprocs+0xa8>
4000ae20:	8d 9c 87 88 00 00 00 	lea    0x88(%edi,%eax,4),%ebx
4000ae27:	eb 18                	jmp    4000ae41 <__call_exitprocs+0x51>
4000ae29:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
     Return a pointer to a chunk of size n that contains the same data
     as does chunk p up to the minimum of (n, p's size) bytes, or null
     if no space is available. The returned pointer may or may not be
     the same as p. If p is null, equivalent to malloc.  Unless the
     #define REALLOC_ZERO_BYTES_FREES below is set, realloc with a
4000ae30:	8b 45 0c             	mov    0xc(%ebp),%eax
4000ae33:	39 43 7c             	cmp    %eax,0x7c(%ebx)
4000ae36:	74 10                	je     4000ae48 <__call_exitprocs+0x58>
  malloc(size_t n);
     Return a pointer to a newly allocated chunk of at least n bytes, or null
     if no space is available.
  free(Void_t* p);
     Release the chunk of memory pointed to by p, or no effect if p is null.
  realloc(Void_t* p, size_t n);
4000ae38:	4e                   	dec    %esi
4000ae39:	83 eb 04             	sub    $0x4,%ebx
4000ae3c:	83 fe ff             	cmp    $0xffffffff,%esi
4000ae3f:	74 54                	je     4000ae95 <__call_exitprocs+0xa5>
     Return a pointer to a chunk of size n that contains the same data
     as does chunk p up to the minimum of (n, p's size) bytes, or null
     if no space is available. The returned pointer may or may not be
     the same as p. If p is null, equivalent to malloc.  Unless the
     #define REALLOC_ZERO_BYTES_FREES below is set, realloc with a
4000ae41:	8b 45 0c             	mov    0xc(%ebp),%eax
4000ae44:	85 c0                	test   %eax,%eax
4000ae46:	75 e8                	jne    4000ae30 <__call_exitprocs+0x40>
     size argument of zero (re)allocates a minimum-sized chunk.
  memalign(size_t alignment, size_t n);
     Return a pointer to a newly allocated chunk of n bytes, aligned
     in accord with the alignment argument, which must be a power of
     two.
  valloc(size_t n);
4000ae48:	8b 47 04             	mov    0x4(%edi),%eax
     #define REALLOC_ZERO_BYTES_FREES below is set, realloc with a
     size argument of zero (re)allocates a minimum-sized chunk.
  memalign(size_t alignment, size_t n);
     Return a pointer to a newly allocated chunk of n bytes, aligned
     in accord with the alignment argument, which must be a power of
     two.
4000ae4b:	8b 93 7c ff ff ff    	mov    -0x84(%ebx),%edx
  valloc(size_t n);
4000ae51:	48                   	dec    %eax
4000ae52:	39 f0                	cmp    %esi,%eax
4000ae54:	74 74                	je     4000aeca <__call_exitprocs+0xda>
     Equivalent to memalign(pagesize, n), where pagesize is the page
     size of the system (or as near to this as can be figured out from
     all the includes/defines below.)
4000ae56:	c7 83 7c ff ff ff 00 	movl   $0x0,-0x84(%ebx)
4000ae5d:	00 00 00 
  pvalloc(size_t n);
     Equivalent to valloc(minimum-page-that-holds(n)), that is,
     round up n to nearest pagesize.
4000ae60:	85 d2                	test   %edx,%edx
4000ae62:	74 d4                	je     4000ae38 <__call_exitprocs+0x48>
  calloc(size_t unit, size_t quantity);
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
  cfree(Void_t* p);
4000ae64:	b8 01 00 00 00       	mov    $0x1,%eax
4000ae69:	89 f1                	mov    %esi,%ecx
4000ae6b:	d3 e0                	shl    %cl,%eax
4000ae6d:	85 87 88 01 00 00    	test   %eax,0x188(%edi)
4000ae73:	74 6b                	je     4000aee0 <__call_exitprocs+0xf0>
     Equivalent to free(p).
  malloc_trim(size_t pad);
4000ae75:	85 87 8c 01 00 00    	test   %eax,0x18c(%edi)
4000ae7b:	75 52                	jne    4000aecf <__call_exitprocs+0xdf>
     Release all but pad bytes of freed top-most memory back 
4000ae7d:	50                   	push   %eax
4000ae7e:	50                   	push   %eax
4000ae7f:	8b 43 fc             	mov    -0x4(%ebx),%eax
4000ae82:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000ae85:	50                   	push   %eax
  malloc(size_t n);
     Return a pointer to a newly allocated chunk of at least n bytes, or null
     if no space is available.
  free(Void_t* p);
     Release the chunk of memory pointed to by p, or no effect if p is null.
  realloc(Void_t* p, size_t n);
4000ae86:	4e                   	dec    %esi
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
  cfree(Void_t* p);
     Equivalent to free(p).
  malloc_trim(size_t pad);
     Release all but pad bytes of freed top-most memory back 
4000ae87:	51                   	push   %ecx
  malloc(size_t n);
     Return a pointer to a newly allocated chunk of at least n bytes, or null
     if no space is available.
  free(Void_t* p);
     Release the chunk of memory pointed to by p, or no effect if p is null.
  realloc(Void_t* p, size_t n);
4000ae88:	83 eb 04             	sub    $0x4,%ebx
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
  cfree(Void_t* p);
     Equivalent to free(p).
  malloc_trim(size_t pad);
     Release all but pad bytes of freed top-most memory back 
4000ae8b:	ff d2                	call   *%edx
4000ae8d:	83 c4 10             	add    $0x10,%esp
  malloc(size_t n);
     Return a pointer to a newly allocated chunk of at least n bytes, or null
     if no space is available.
  free(Void_t* p);
     Release the chunk of memory pointed to by p, or no effect if p is null.
  realloc(Void_t* p, size_t n);
4000ae90:	83 fe ff             	cmp    $0xffffffff,%esi
4000ae93:	75 ac                	jne    4000ae41 <__call_exitprocs+0x51>
4000ae95:	8b 47 04             	mov    0x4(%edi),%eax
     due to alignment and minimum size constraints.
  malloc_stats();
     Prints brief summary statistics on stderr.
  mallinfo()
     Returns (by copy) a struct containing various summary statistics.
  mallopt(int parameter_number, int parameter_value)
4000ae98:	85 c0                	test   %eax,%eax
4000ae9a:	75 4b                	jne    4000aee7 <__call_exitprocs+0xf7>
4000ae9c:	8b 07                	mov    (%edi),%eax
4000ae9e:	31 d2                	xor    %edx,%edx
4000aea0:	85 c0                	test   %eax,%eax
4000aea2:	74 45                	je     4000aee9 <__call_exitprocs+0xf9>
     Changes one of the tunable parameters described below. Returns
     1 if successful in changing the parameter, else 0.

4000aea4:	8b 55 f0             	mov    -0x10(%ebp),%edx
* Vital statistics:

  Alignment:                            8-byte
       8 byte alignment is currently hardwired into the design.  This
       seems to suffice for all current machines and C compilers.
4000aea7:	83 ec 0c             	sub    $0xc,%esp
  mallinfo()
     Returns (by copy) a struct containing various summary statistics.
  mallopt(int parameter_number, int parameter_value)
     Changes one of the tunable parameters described below. Returns
     1 if successful in changing the parameter, else 0.

4000aeaa:	89 02                	mov    %eax,(%edx)
* Vital statistics:

  Alignment:                            8-byte
       8 byte alignment is currently hardwired into the design.  This
       seems to suffice for all current machines and C compilers.
4000aeac:	57                   	push   %edi
4000aead:	e8 ae 0c 00 00       	call   4000bb60 <free>

4000aeb2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
     due to alignment and minimum size constraints.
  malloc_stats();
     Prints brief summary statistics on stderr.
  mallinfo()
     Returns (by copy) a struct containing various summary statistics.
  mallopt(int parameter_number, int parameter_value)
4000aeb5:	83 c4 10             	add    $0x10,%esp
* Vital statistics:

  Alignment:                            8-byte
       8 byte alignment is currently hardwired into the design.  This
       seems to suffice for all current machines and C compilers.

4000aeb8:	8b 39                	mov    (%ecx),%edi
  allocator. For a high-level description, see 
     http://g.oswego.edu/dl/html/malloc.html

* Synopsis of public routines

  (Much fuller descriptions are contained in the program documentation below.)
4000aeba:	85 ff                	test   %edi,%edi
4000aebc:	0f 85 52 ff ff ff    	jne    4000ae14 <__call_exitprocs+0x24>
       changes supporting this.

  Assumed size_t  representation:       4 or 8 bytes
       Note that size_t is allowed to be 4 bytes even if pointers are 8.        

  Minimum overhead per allocated chunk: 4 or 8 bytes
4000aec2:	8d 65 f4             	lea    -0xc(%ebp),%esp
4000aec5:	5b                   	pop    %ebx
4000aec6:	5e                   	pop    %esi
4000aec7:	5f                   	pop    %edi
4000aec8:	5d                   	pop    %ebp
4000aec9:	c3                   	ret    
  memalign(size_t alignment, size_t n);
     Return a pointer to a newly allocated chunk of n bytes, aligned
     in accord with the alignment argument, which must be a power of
     two.
  valloc(size_t n);
     Equivalent to memalign(pagesize, n), where pagesize is the page
4000aeca:	89 77 04             	mov    %esi,0x4(%edi)
4000aecd:	eb 91                	jmp    4000ae60 <__call_exitprocs+0x70>
  cfree(Void_t* p);
     Equivalent to free(p).
  malloc_trim(size_t pad);
     Release all but pad bytes of freed top-most memory back 
     to the system. Return 1 if successful, else 0.
  malloc_usable_size(Void_t* p);
4000aecf:	83 ec 0c             	sub    $0xc,%esp
4000aed2:	8b 43 fc             	mov    -0x4(%ebx),%eax
4000aed5:	50                   	push   %eax
4000aed6:	ff d2                	call   *%edx
4000aed8:	83 c4 10             	add    $0x10,%esp
4000aedb:	e9 58 ff ff ff       	jmp    4000ae38 <__call_exitprocs+0x48>
     round up n to nearest pagesize.
  calloc(size_t unit, size_t quantity);
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
  cfree(Void_t* p);
     Equivalent to free(p).
4000aee0:	ff d2                	call   *%edx
4000aee2:	e9 51 ff ff ff       	jmp    4000ae38 <__call_exitprocs+0x48>
     due to alignment and minimum size constraints.
  malloc_stats();
     Prints brief summary statistics on stderr.
  mallinfo()
     Returns (by copy) a struct containing various summary statistics.
  mallopt(int parameter_number, int parameter_value)
4000aee7:	8b 17                	mov    (%edi),%edx
       seems to suffice for all current machines and C compilers.

  Assumed pointer representation:       4 or 8 bytes
       Code for 8-byte pointers is untested by me but has worked
       reliably by Wolfram Gloger, who contributed most of the
       changes supporting this.
4000aee9:	89 7d f0             	mov    %edi,-0x10(%ebp)
4000aeec:	89 d7                	mov    %edx,%edi
4000aeee:	eb ca                	jmp    4000aeba <__call_exitprocs+0xca>

4000aef0 <_calloc_r>:
#if __STD_C
Void_t* cALLOc(RARG size_t n, size_t elem_size)
#else
Void_t* cALLOc(RARG n, elem_size) RDECL size_t n; size_t elem_size;
#endif
{
4000aef0:	55                   	push   %ebp
4000aef1:	89 e5                	mov    %esp,%ebp
4000aef3:	53                   	push   %ebx
4000aef4:	83 ec 0c             	sub    $0xc,%esp
  MALLOC_LOCK;
  oldtop = top;
  oldtopsize = chunksize(top);
#endif

  mem = mALLOc (RCALL sz);
4000aef7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#if __STD_C
Void_t* cALLOc(RARG size_t n, size_t elem_size)
#else
Void_t* cALLOc(RARG n, elem_size) RDECL size_t n; size_t elem_size;
#endif
{
4000aefa:	8b 45 10             	mov    0x10(%ebp),%eax
  MALLOC_LOCK;
  oldtop = top;
  oldtopsize = chunksize(top);
#endif

  mem = mALLOc (RCALL sz);
4000aefd:	0f af c3             	imul   %ebx,%eax
4000af00:	50                   	push   %eax
4000af01:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000af04:	51                   	push   %ecx
4000af05:	e8 d6 58 ff ff       	call   400007e0 <_malloc_r>

  if (mem == 0) 
4000af0a:	83 c4 10             	add    $0x10,%esp
  MALLOC_LOCK;
  oldtop = top;
  oldtopsize = chunksize(top);
#endif

  mem = mALLOc (RCALL sz);
4000af0d:	89 c3                	mov    %eax,%ebx

  if (mem == 0) 
4000af0f:	85 c0                	test   %eax,%eax
4000af11:	74 29                	je     4000af3c <_calloc_r+0x4c>
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
4000af13:	8b 40 fc             	mov    -0x4(%eax),%eax
4000af16:	83 e0 fc             	and    $0xfffffffc,%eax
4000af19:	83 e8 04             	sub    $0x4,%eax
4000af1c:	83 f8 24             	cmp    $0x24,%eax
4000af1f:	77 6f                	ja     4000af90 <_calloc_r+0xa0>
4000af21:	89 da                	mov    %ebx,%edx
4000af23:	83 f8 13             	cmp    $0x13,%eax
4000af26:	77 28                	ja     4000af50 <_calloc_r+0x60>
4000af28:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
4000af2e:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
4000af35:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
    return mem;
  }
}
4000af3c:	89 d8                	mov    %ebx,%eax
4000af3e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
4000af41:	c9                   	leave  
4000af42:	c3                   	ret    
4000af43:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000af49:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
4000af50:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
4000af56:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
4000af5d:	8d 53 08             	lea    0x8(%ebx),%edx
4000af60:	83 f8 1b             	cmp    $0x1b,%eax
4000af63:	76 c3                	jbe    4000af28 <_calloc_r+0x38>
4000af65:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
4000af6c:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
4000af73:	8d 53 10             	lea    0x10(%ebx),%edx
4000af76:	83 f8 24             	cmp    $0x24,%eax
4000af79:	75 ad                	jne    4000af28 <_calloc_r+0x38>
4000af7b:	8d 53 18             	lea    0x18(%ebx),%edx
4000af7e:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
4000af85:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
4000af8c:	eb 9a                	jmp    4000af28 <_calloc_r+0x38>
4000af8e:	66 90                	xchg   %ax,%ax
4000af90:	52                   	push   %edx
4000af91:	50                   	push   %eax
4000af92:	6a 00                	push   $0x0
4000af94:	53                   	push   %ebx
4000af95:	e8 4e 60 ff ff       	call   40000fe8 <memset>
    return mem;
  }
}
4000af9a:	89 d8                	mov    %ebx,%eax
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
4000af9c:	83 c4 10             	add    $0x10,%esp
    return mem;
  }
}
4000af9f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
4000afa2:	c9                   	leave  
4000afa3:	c3                   	ret    
4000afa4:	90                   	nop    
4000afa5:	90                   	nop    
4000afa6:	90                   	nop    
4000afa7:	90                   	nop    
4000afa8:	90                   	nop    
4000afa9:	90                   	nop    
4000afaa:	90                   	nop    
4000afab:	90                   	nop    
4000afac:	90                   	nop    
4000afad:	90                   	nop    
4000afae:	90                   	nop    
4000afaf:	90                   	nop    

4000afb0 <_fstat_r>:

#include <_ansi.h>
#include <stdio.h>
#include "local.h"

/* Flush a single file, or (if fp is NULL) all files.  */
4000afb0:	55                   	push   %ebp
4000afb1:	89 e5                	mov    %esp,%ebp
4000afb3:	83 ec 10             	sub    $0x10,%esp

int
_DEFUN(fflush, (fp),
4000afb6:	c7 05 60 d9 00 40 00 	movl   $0x0,0x4000d960
4000afbd:	00 00 00 
       register FILE * fp)
4000afc0:	8b 55 10             	mov    0x10(%ebp),%edx
4000afc3:	52                   	push   %edx
4000afc4:	8b 45 0c             	mov    0xc(%ebp),%eax
4000afc7:	50                   	push   %eax
4000afc8:	e8 d3 63 ff ff       	call   400013a0 <fstat>
4000afcd:	83 c4 10             	add    $0x10,%esp
4000afd0:	83 f8 ff             	cmp    $0xffffffff,%eax
4000afd3:	74 0b                	je     4000afe0 <_fstat_r+0x30>
{
  register unsigned char *p;
  register int n, t;
4000afd5:	c9                   	leave  
4000afd6:	c3                   	ret    
4000afd7:	89 f6                	mov    %esi,%esi
4000afd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

/* Flush a single file, or (if fp is NULL) all files.  */

int
_DEFUN(fflush, (fp),
       register FILE * fp)
4000afe0:	8b 15 60 d9 00 40    	mov    0x4000d960,%edx
4000afe6:	85 d2                	test   %edx,%edx
4000afe8:	74 eb                	je     4000afd5 <_fstat_r+0x25>
{
4000afea:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000afed:	89 11                	mov    %edx,(%ecx)
  register unsigned char *p;
  register int n, t;
4000afef:	c9                   	leave  
4000aff0:	c3                   	ret    
4000aff1:	90                   	nop    
4000aff2:	90                   	nop    
4000aff3:	90                   	nop    
4000aff4:	90                   	nop    
4000aff5:	90                   	nop    
4000aff6:	90                   	nop    
4000aff7:	90                   	nop    
4000aff8:	90                   	nop    
4000aff9:	90                   	nop    
4000affa:	90                   	nop    
4000affb:	90                   	nop    
4000affc:	90                   	nop    
4000affd:	90                   	nop    
4000affe:	90                   	nop    
4000afff:	90                   	nop    

4000b000 <htinit>:
     two.
  valloc(size_t n);
     Equivalent to memalign(pagesize, n), where pagesize is the page
     size of the system (or as near to this as can be figured out from
     all the includes/defines below.)
  pvalloc(size_t n);
4000b000:	55                   	push   %ebp
4000b001:	89 e5                	mov    %esp,%ebp
4000b003:	56                   	push   %esi
4000b004:	89 c6                	mov    %eax,%esi
     Equivalent to valloc(minimum-page-that-holds(n)), that is,
     round up n to nearest pagesize.
4000b006:	8a 02                	mov    (%edx),%al
     two.
  valloc(size_t n);
     Equivalent to memalign(pagesize, n), where pagesize is the page
     size of the system (or as near to this as can be figured out from
     all the includes/defines below.)
  pvalloc(size_t n);
4000b008:	53                   	push   %ebx
     Equivalent to valloc(minimum-page-that-holds(n)), that is,
     round up n to nearest pagesize.
4000b009:	84 c0                	test   %al,%al
     two.
  valloc(size_t n);
     Equivalent to memalign(pagesize, n), where pagesize is the page
     size of the system (or as near to this as can be figured out from
     all the includes/defines below.)
  pvalloc(size_t n);
4000b00b:	89 cb                	mov    %ecx,%ebx
     Equivalent to valloc(minimum-page-that-holds(n)), that is,
     round up n to nearest pagesize.
4000b00d:	74 23                	je     4000b032 <htinit+0x32>
4000b00f:	31 c9                	xor    %ecx,%ecx
  calloc(size_t unit, size_t quantity);
4000b011:	28 d3                	sub    %dl,%bl
     Equivalent to memalign(pagesize, n), where pagesize is the page
     size of the system (or as near to this as can be figured out from
     all the includes/defines below.)
  pvalloc(size_t n);
     Equivalent to valloc(minimum-page-that-holds(n)), that is,
     round up n to nearest pagesize.
4000b013:	88 c1                	mov    %al,%cl
4000b015:	8d 74 26 00          	lea    0x0(%esi),%esi
4000b019:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
  calloc(size_t unit, size_t quantity);
4000b020:	8d 04 13             	lea    (%ebx,%edx,1),%eax
4000b023:	88 04 0e             	mov    %al,(%esi,%ecx,1)
     Equivalent to memalign(pagesize, n), where pagesize is the page
     size of the system (or as near to this as can be figured out from
     all the includes/defines below.)
  pvalloc(size_t n);
     Equivalent to valloc(minimum-page-that-holds(n)), that is,
     round up n to nearest pagesize.
4000b026:	31 c9                	xor    %ecx,%ecx
4000b028:	8a 42 01             	mov    0x1(%edx),%al
4000b02b:	42                   	inc    %edx
4000b02c:	88 c1                	mov    %al,%cl
4000b02e:	84 c0                	test   %al,%al
4000b030:	75 ee                	jne    4000b020 <htinit+0x20>
  calloc(size_t unit, size_t quantity);
     Returns a pointer to quantity * unit bytes, with all locations
4000b032:	5b                   	pop    %ebx
4000b033:	5e                   	pop    %esi
4000b034:	5d                   	pop    %ebp
4000b035:	c3                   	ret    
4000b036:	8d 76 00             	lea    0x0(%esi),%esi
4000b039:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

4000b040 <__hexdig_init>:
     set to zero.
  cfree(Void_t* p);
     Equivalent to free(p).
  malloc_trim(size_t pad);
4000b040:	55                   	push   %ebp
     Release all but pad bytes of freed top-most memory back 
     to the system. Return 1 if successful, else 0.
4000b041:	b9 10 00 00 00       	mov    $0x10,%ecx
  calloc(size_t unit, size_t quantity);
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
  cfree(Void_t* p);
     Equivalent to free(p).
  malloc_trim(size_t pad);
4000b046:	89 e5                	mov    %esp,%ebp
     Release all but pad bytes of freed top-most memory back 
     to the system. Return 1 if successful, else 0.
4000b048:	ba b0 c8 00 40       	mov    $0x4000c8b0,%edx
4000b04d:	b8 80 d9 00 40       	mov    $0x4000d980,%eax
4000b052:	e8 a9 ff ff ff       	call   4000b000 <htinit>
  malloc_usable_size(Void_t* p);
4000b057:	b9 1a 00 00 00       	mov    $0x1a,%ecx
4000b05c:	ba 46 bc 00 40       	mov    $0x4000bc46,%edx
4000b061:	b8 80 d9 00 40       	mov    $0x4000d980,%eax
4000b066:	e8 95 ff ff ff       	call   4000b000 <htinit>
     Report the number usable allocated bytes associated with allocated
4000b06b:	b9 1a 00 00 00       	mov    $0x1a,%ecx
4000b070:	ba 63 bc 00 40       	mov    $0x4000bc63,%edx
4000b075:	b8 80 d9 00 40       	mov    $0x4000d980,%eax
     chunk p. This may or may not report more bytes than were requested,
4000b07a:	5d                   	pop    %ebp
     Equivalent to free(p).
  malloc_trim(size_t pad);
     Release all but pad bytes of freed top-most memory back 
     to the system. Return 1 if successful, else 0.
  malloc_usable_size(Void_t* p);
     Report the number usable allocated bytes associated with allocated
4000b07b:	eb 83                	jmp    4000b000 <htinit>
4000b07d:	8d 76 00             	lea    0x0(%esi),%esi

4000b080 <rshift>:
     due to alignment and minimum size constraints.
  malloc_stats();
     Prints brief summary statistics on stderr.
  mallinfo()
     Returns (by copy) a struct containing various summary statistics.
  mallopt(int parameter_number, int parameter_value)
4000b080:	55                   	push   %ebp
4000b081:	89 e5                	mov    %esp,%ebp
4000b083:	57                   	push   %edi
4000b084:	56                   	push   %esi
4000b085:	53                   	push   %ebx
4000b086:	83 ec 10             	sub    $0x10,%esp
4000b089:	89 45 e8             	mov    %eax,-0x18(%ebp)
     Changes one of the tunable parameters described below. Returns
     1 if successful in changing the parameter, else 0.

* Vital statistics:

  Alignment:                            8-byte
4000b08c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
     Returns (by copy) a struct containing various summary statistics.
  mallopt(int parameter_number, int parameter_value)
     Changes one of the tunable parameters described below. Returns
     1 if successful in changing the parameter, else 0.

* Vital statistics:
4000b08f:	83 c0 14             	add    $0x14,%eax

4000b092:	89 d6                	mov    %edx,%esi
     Returns (by copy) a struct containing various summary statistics.
  mallopt(int parameter_number, int parameter_value)
     Changes one of the tunable parameters described below. Returns
     1 if successful in changing the parameter, else 0.

* Vital statistics:
4000b094:	89 45 e4             	mov    %eax,-0x1c(%ebp)

4000b097:	c1 fe 05             	sar    $0x5,%esi
     Returns (by copy) a struct containing various summary statistics.
  mallopt(int parameter_number, int parameter_value)
     Changes one of the tunable parameters described below. Returns
     1 if successful in changing the parameter, else 0.

* Vital statistics:
4000b09a:	89 c3                	mov    %eax,%ebx

  Alignment:                            8-byte
4000b09c:	8b 41 10             	mov    0x10(%ecx),%eax
4000b09f:	39 c6                	cmp    %eax,%esi
4000b0a1:	7d 6d                	jge    4000b110 <rshift+0x90>
       8 byte alignment is currently hardwired into the design.  This
4000b0a3:	8d 7c 81 14          	lea    0x14(%ecx,%eax,4),%edi
       seems to suffice for all current machines and C compilers.
4000b0a7:	8d 44 b1 10          	lea    0x10(%ecx,%esi,4),%eax

4000b0ab:	83 e2 1f             	and    $0x1f,%edx

* Vital statistics:

  Alignment:                            8-byte
       8 byte alignment is currently hardwired into the design.  This
       seems to suffice for all current machines and C compilers.
4000b0ae:	8d 48 04             	lea    0x4(%eax),%ecx

4000b0b1:	89 55 f0             	mov    %edx,-0x10(%ebp)
4000b0b4:	0f 84 90 00 00 00    	je     4000b14a <rshift+0xca>
  Assumed pointer representation:       4 or 8 bytes
4000b0ba:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
4000b0c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
4000b0c4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
4000b0c7:	29 d1                	sub    %edx,%ecx
4000b0c9:	89 4d ec             	mov    %ecx,-0x14(%ebp)
       Code for 8-byte pointers is untested by me but has worked
4000b0cc:	8b 4d e8             	mov    -0x18(%ebp),%ecx
4000b0cf:	8b 54 b1 14          	mov    0x14(%ecx,%esi,4),%edx
4000b0d3:	8a 4d f0             	mov    -0x10(%ebp),%cl
4000b0d6:	8d 70 08             	lea    0x8(%eax),%esi
4000b0d9:	d3 ea                	shr    %cl,%edx
       reliably by Wolfram Gloger, who contributed most of the
4000b0db:	39 f7                	cmp    %esi,%edi
4000b0dd:	76 1d                	jbe    4000b0fc <rshift+0x7c>
4000b0df:	90                   	nop    
       changes supporting this.
4000b0e0:	8b 06                	mov    (%esi),%eax
4000b0e2:	8a 4d ec             	mov    -0x14(%ebp),%cl
4000b0e5:	d3 e0                	shl    %cl,%eax
4000b0e7:	09 c2                	or     %eax,%edx

4000b0e9:	8a 4d f0             	mov    -0x10(%ebp),%cl
       seems to suffice for all current machines and C compilers.

  Assumed pointer representation:       4 or 8 bytes
       Code for 8-byte pointers is untested by me but has worked
       reliably by Wolfram Gloger, who contributed most of the
       changes supporting this.
4000b0ec:	89 13                	mov    %edx,(%ebx)
4000b0ee:	83 c3 04             	add    $0x4,%ebx

4000b0f1:	8b 16                	mov    (%esi),%edx
4000b0f3:	83 c6 04             	add    $0x4,%esi
4000b0f6:	d3 ea                	shr    %cl,%edx
       8 byte alignment is currently hardwired into the design.  This
       seems to suffice for all current machines and C compilers.

  Assumed pointer representation:       4 or 8 bytes
       Code for 8-byte pointers is untested by me but has worked
       reliably by Wolfram Gloger, who contributed most of the
4000b0f8:	39 f7                	cmp    %esi,%edi
4000b0fa:	77 e4                	ja     4000b0e0 <rshift+0x60>
       changes supporting this.

  Assumed size_t  representation:       4 or 8 bytes
       Note that size_t is allowed to be 4 bytes even if pointers are 8.        
4000b0fc:	89 13                	mov    %edx,(%ebx)
4000b0fe:	85 d2                	test   %edx,%edx
4000b100:	75 4e                	jne    4000b150 <rshift+0xd0>
4000b102:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
4000b109:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
  Minimum overhead per allocated chunk: 4 or 8 bytes
       Each malloced chunk has a hidden overhead of 4 bytes holding size
       and status information.  

  Minimum allocated size: 4-byte ptrs:  16 bytes    (including 4 overhead)
                          8-byte ptrs:  24/32 bytes (including, 4/8 overhead)
4000b110:	8b 55 e4             	mov    -0x1c(%ebp),%edx
4000b113:	89 d8                	mov    %ebx,%eax
4000b115:	29 d0                	sub    %edx,%eax
4000b117:	8b 55 e8             	mov    -0x18(%ebp),%edx
4000b11a:	c1 f8 02             	sar    $0x2,%eax
4000b11d:	89 42 10             	mov    %eax,0x10(%edx)
4000b120:	85 c0                	test   %eax,%eax
4000b122:	75 07                	jne    4000b12b <rshift+0xab>
                                     
4000b124:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
       When a chunk is freed, 12 (for 4byte ptrs) or 20 (for 8 byte
4000b12b:	83 c4 10             	add    $0x10,%esp
4000b12e:	5b                   	pop    %ebx
4000b12f:	5e                   	pop    %esi
4000b130:	5f                   	pop    %edi
4000b131:	5d                   	pop    %ebp
4000b132:	c3                   	ret    
4000b133:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000b139:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
       Note that size_t is allowed to be 4 bytes even if pointers are 8.        

  Minimum overhead per allocated chunk: 4 or 8 bytes
       Each malloced chunk has a hidden overhead of 4 bytes holding size
       and status information.  

4000b140:	8b 01                	mov    (%ecx),%eax
4000b142:	83 c1 04             	add    $0x4,%ecx
4000b145:	89 03                	mov    %eax,(%ebx)
4000b147:	83 c3 04             	add    $0x4,%ebx
  Assumed size_t  representation:       4 or 8 bytes
       Note that size_t is allowed to be 4 bytes even if pointers are 8.        

  Minimum overhead per allocated chunk: 4 or 8 bytes
       Each malloced chunk has a hidden overhead of 4 bytes holding size
       and status information.  
4000b14a:	39 cf                	cmp    %ecx,%edi
4000b14c:	77 f2                	ja     4000b140 <rshift+0xc0>
4000b14e:	eb c0                	jmp    4000b110 <rshift+0x90>
       reliably by Wolfram Gloger, who contributed most of the
       changes supporting this.

  Assumed size_t  representation:       4 or 8 bytes
       Note that size_t is allowed to be 4 bytes even if pointers are 8.        

4000b150:	83 c3 04             	add    $0x4,%ebx
4000b153:	eb bb                	jmp    4000b110 <rshift+0x90>
4000b155:	8d 74 26 00          	lea    0x0(%esi),%esi
4000b159:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi

4000b160 <__gethex>:

    The implementation is in straight, hand-tuned ANSI C.  Among other
    consequences, it uses a lot of macros.  Because of this, to be at
    all usable, this code should be compiled using an optimizing compiler
    (for example gcc -O2) that can simplify expressions and control
    paths.
4000b160:	55                   	push   %ebp
4000b161:	89 e5                	mov    %esp,%ebp
4000b163:	57                   	push   %edi
4000b164:	56                   	push   %esi
4000b165:	53                   	push   %ebx
4000b166:	83 ec 2c             	sub    $0x2c,%esp
     checking to help track down memory errors, but noticeably slows down
     execution.
  SEPARATE_OBJECTS	   (default: NOT defined)
     Define this to compile into separate .o files.  You must then
     compile malloc.c several times, defining a DEFINE_* macro each
     time.  The list of DEFINE_* macros appears below.
4000b169:	80 3d b0 d9 00 40 00 	cmpb   $0x0,0x4000d9b0
4000b170:	0f 84 b5 02 00 00    	je     4000b42b <__gethex+0x2cb>
  MALLOC_LOCK		   (default: NOT defined)
  MALLOC_UNLOCK		   (default: NOT defined)
     Define these to C expressions which are run to lock and unlock
4000b176:	8b 45 0c             	mov    0xc(%ebp),%eax
4000b179:	8b 18                	mov    (%eax),%ebx
     the malloc data structures.  Calls may be nested; that is,
4000b17b:	8a 53 02             	mov    0x2(%ebx),%dl
     Define this to compile into separate .o files.  You must then
     compile malloc.c several times, defining a DEFINE_* macro each
     time.  The list of DEFINE_* macros appears below.
  MALLOC_LOCK		   (default: NOT defined)
  MALLOC_UNLOCK		   (default: NOT defined)
     Define these to C expressions which are run to lock and unlock
4000b17e:	8d 43 02             	lea    0x2(%ebx),%eax
     the malloc data structures.  Calls may be nested; that is,
4000b181:	80 fa 30             	cmp    $0x30,%dl
4000b184:	0f 85 ba 02 00 00    	jne    4000b444 <__gethex+0x2e4>
4000b18a:	8d 43 03             	lea    0x3(%ebx),%eax
4000b18d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
4000b194:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000b19a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
     MALLOC_LOCK may be called more than once before the corresponding
4000b1a0:	8b 55 d8             	mov    -0x28(%ebp),%edx
4000b1a3:	89 c1                	mov    %eax,%ecx
4000b1a5:	42                   	inc    %edx
4000b1a6:	89 55 d8             	mov    %edx,-0x28(%ebp)
     compile malloc.c several times, defining a DEFINE_* macro each
     time.  The list of DEFINE_* macros appears below.
  MALLOC_LOCK		   (default: NOT defined)
  MALLOC_UNLOCK		   (default: NOT defined)
     Define these to C expressions which are run to lock and unlock
     the malloc data structures.  Calls may be nested; that is,
4000b1a9:	8b 45 d8             	mov    -0x28(%ebp),%eax
4000b1ac:	8a 54 18 02          	mov    0x2(%eax,%ebx,1),%dl
4000b1b0:	8d 41 01             	lea    0x1(%ecx),%eax
4000b1b3:	80 fa 30             	cmp    $0x30,%dl
4000b1b6:	74 e8                	je     4000b1a0 <__gethex+0x40>
     MALLOC_UNLOCK calls.  MALLOC_LOCK must avoid waiting for a lock
     that it already holds.
  MALLOC_ALIGNMENT          (default: NOT defined)
     Define this to 16 if you need 16 byte alignment instead of 8 byte alignment
     which is the normal default.
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
4000b1b8:	31 c0                	xor    %eax,%eax
4000b1ba:	88 d0                	mov    %dl,%al
4000b1bc:	80 b8 80 d9 00 40 00 	cmpb   $0x0,0x4000d980(%eax)
4000b1c3:	0f 84 81 00 00 00    	je     4000b24a <__gethex+0xea>
4000b1c9:	8a 11                	mov    (%ecx),%dl
4000b1cb:	31 c0                	xor    %eax,%eax
4000b1cd:	88 d0                	mov    %dl,%al
4000b1cf:	89 cf                	mov    %ecx,%edi
4000b1d1:	89 cb                	mov    %ecx,%ebx
4000b1d3:	31 f6                	xor    %esi,%esi
4000b1d5:	8a 80 80 d9 00 40    	mov    0x4000d980(%eax),%al
4000b1db:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
4000b1e2:	88 45 ef             	mov    %al,-0x11(%ebp)
     Define as 1 if you want the C library versions of memset and
     memcpy called in realloc and calloc (otherwise macro versions are used). 
     At least on some platforms, the simple macro versions usually
     outperform libc versions.
  HAVE_MMAP                 (default: defined as 1)
     Define to non-zero to optionally make malloc() use mmap() to
4000b1e5:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
4000b1e9:	74 15                	je     4000b200 <__gethex+0xa0>
4000b1eb:	90                   	nop    
4000b1ec:	8d 74 26 00          	lea    0x0(%esi),%esi
     allocate very large blocks.  
4000b1f0:	43                   	inc    %ebx
     Define as 1 if you want the C library versions of memset and
     memcpy called in realloc and calloc (otherwise macro versions are used). 
     At least on some platforms, the simple macro versions usually
     outperform libc versions.
  HAVE_MMAP                 (default: defined as 1)
     Define to non-zero to optionally make malloc() use mmap() to
4000b1f1:	31 c0                	xor    %eax,%eax
4000b1f3:	8a 13                	mov    (%ebx),%dl
4000b1f5:	88 d0                	mov    %dl,%al
4000b1f7:	80 b8 80 d9 00 40 00 	cmpb   $0x0,0x4000d980(%eax)
4000b1fe:	75 f0                	jne    4000b1f0 <__gethex+0x90>
     allocate very large blocks.  
  HAVE_MREMAP                 (default: defined as 0 unless Linux libc set)
4000b200:	80 fa 2e             	cmp    $0x2e,%dl
4000b203:	0f 84 49 02 00 00    	je     4000b452 <__gethex+0x2f2>
     Define to non-zero to optionally make realloc() use mremap() to
     reallocate very large blocks.  
  malloc_getpagesize        (default: derived from system #includes)
     Either a constant or routine call returning the system page size.
  HAVE_USR_INCLUDE_MALLOC_H (default: NOT defined) 
4000b209:	85 f6                	test   %esi,%esi
4000b20b:	0f 84 79 02 00 00    	je     4000b48a <__gethex+0x32a>
     Optionally define if you are on a system with a /usr/include/malloc.h
4000b211:	29 de                	sub    %ebx,%esi
4000b213:	c1 e6 02             	shl    $0x2,%esi
4000b216:	89 75 e8             	mov    %esi,-0x18(%ebp)
4000b219:	8a 13                	mov    (%ebx),%dl
     that declares struct mallinfo. It is not at all necessary to
     define this even if you do, but will ensure consistency.
  INTERNAL_SIZE_T           (default: size_t)
4000b21b:	80 fa 50             	cmp    $0x50,%dl
4000b21e:	74 4c                	je     4000b26c <__gethex+0x10c>
4000b220:	80 fa 70             	cmp    $0x70,%dl
4000b223:	74 47                	je     4000b26c <__gethex+0x10c>
     Define this if your system does not have a <unistd.h>.
  MORECORE                  (default: sbrk)
     The name of the routine to call to obtain more memory from the system.
  MORECORE_FAILURE          (default: -1)
     The value returned upon failure of MORECORE.
  MORECORE_CLEARS           (default 1)
4000b225:	8b 55 0c             	mov    0xc(%ebp),%edx
     Define this on MS win (95, nt) platforms to compile in sbrk emulation.
  LACKS_UNISTD_H            (default: undefined)
     Define this if your system does not have a <unistd.h>.
  MORECORE                  (default: sbrk)
     The name of the routine to call to obtain more memory from the system.
  MORECORE_FAILURE          (default: -1)
4000b228:	89 d9                	mov    %ebx,%ecx
     The value returned upon failure of MORECORE.
  MORECORE_CLEARS           (default 1)
     True (1) if the routine mapped to MORECORE zeroes out memory (which
4000b22a:	8b 45 dc             	mov    -0x24(%ebp),%eax
     Define this if your system does not have a <unistd.h>.
  MORECORE                  (default: sbrk)
     The name of the routine to call to obtain more memory from the system.
  MORECORE_FAILURE          (default: -1)
     The value returned upon failure of MORECORE.
  MORECORE_CLEARS           (default 1)
4000b22d:	89 0a                	mov    %ecx,(%edx)
     True (1) if the routine mapped to MORECORE zeroes out memory (which
4000b22f:	85 c0                	test   %eax,%eax
4000b231:	0f 84 c9 00 00 00    	je     4000b300 <__gethex+0x1a0>
     holds for sbrk).
4000b237:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
4000b23b:	19 f6                	sbb    %esi,%esi
4000b23d:	83 e6 06             	and    $0x6,%esi
#define POINTER_UINT unsigned long
#define RARG
#define RONEARG
#define RDECL
#define RERRNO errno
#define RCALL
4000b240:	8d 65 f4             	lea    -0xc(%ebp),%esp
4000b243:	89 f0                	mov    %esi,%eax
4000b245:	5b                   	pop    %ebx
4000b246:	5e                   	pop    %esi
4000b247:	5f                   	pop    %edi
4000b248:	5d                   	pop    %ebp
4000b249:	c3                   	ret    
  MALLOC_ALIGNMENT          (default: NOT defined)
     Define this to 16 if you need 16 byte alignment instead of 8 byte alignment
     which is the normal default.
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
     Define this if you think that realloc(p, 0) should be equivalent
     to free(p). Otherwise, since malloc returns a unique pointer for
4000b24a:	80 fa 2e             	cmp    $0x2e,%dl
4000b24d:	0f 84 45 02 00 00    	je     4000b498 <__gethex+0x338>
4000b253:	8a 11                	mov    (%ecx),%dl
4000b255:	89 cf                	mov    %ecx,%edi
4000b257:	89 cb                	mov    %ecx,%ebx
4000b259:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
4000b260:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
     Either a constant or routine call returning the system page size.
  HAVE_USR_INCLUDE_MALLOC_H (default: NOT defined) 
     Optionally define if you are on a system with a /usr/include/malloc.h
     that declares struct mallinfo. It is not at all necessary to
     define this even if you do, but will ensure consistency.
  INTERNAL_SIZE_T           (default: size_t)
4000b267:	80 fa 50             	cmp    $0x50,%dl
4000b26a:	75 b4                	jne    4000b220 <__gethex+0xc0>
     Define to a 32-bit type (probably `unsigned int') if you are on a 
     64-bit machine, yet do not want or need to allow malloc requests of 
     greater than 2^31 to be handled. This saves space, especially for
     very small chunks.
4000b26c:	8a 43 01             	mov    0x1(%ebx),%al
4000b26f:	8d 53 01             	lea    0x1(%ebx),%edx
4000b272:	3c 2b                	cmp    $0x2b,%al
4000b274:	0f 84 5a 02 00 00    	je     4000b4d4 <__gethex+0x374>
4000b27a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
4000b281:	3c 2d                	cmp    $0x2d,%al
4000b283:	0f 84 3c 02 00 00    	je     4000b4c5 <__gethex+0x365>
     Defined only when compiled as part of Linux libc.
     Also note that there is some odd internal name-mangling via defines
     (for example, internally, `malloc' is named `mALLOc') needed
     when compiling in this case. These look funny but don't otherwise
     affect anything.
  INTERNAL_NEWLIB	    (default: NOT defined)
4000b289:	25 ff 00 00 00       	and    $0xff,%eax
4000b28e:	8a 80 80 d9 00 40    	mov    0x4000d980(%eax),%al
4000b294:	84 c0                	test   %al,%al
4000b296:	74 8d                	je     4000b225 <__gethex+0xc5>
4000b298:	25 ff 00 00 00       	and    $0xff,%eax
4000b29d:	83 f8 19             	cmp    $0x19,%eax
4000b2a0:	7f 83                	jg     4000b225 <__gethex+0xc5>
     Defined only when compiled as part of the Cygnus newlib
     distribution.
  WIN32                     (default: undefined)
     Define this on MS win (95, nt) platforms to compile in sbrk emulation.
4000b2a2:	8d 70 f0             	lea    -0x10(%eax),%esi
  LACKS_UNISTD_H            (default: undefined)
4000b2a5:	31 c0                	xor    %eax,%eax
4000b2a7:	8a 42 01             	mov    0x1(%edx),%al
4000b2aa:	8d 4a 01             	lea    0x1(%edx),%ecx
4000b2ad:	8a 80 80 d9 00 40    	mov    0x4000d980(%eax),%al
4000b2b3:	84 c0                	test   %al,%al
4000b2b5:	75 1f                	jne    4000b2d6 <__gethex+0x176>
4000b2b7:	eb 26                	jmp    4000b2df <__gethex+0x17f>
4000b2b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
     Define this if your system does not have a <unistd.h>.
4000b2c0:	8d 04 b6             	lea    (%esi,%esi,4),%eax
  INTERNAL_NEWLIB	    (default: NOT defined)
     Defined only when compiled as part of the Cygnus newlib
     distribution.
  WIN32                     (default: undefined)
     Define this on MS win (95, nt) platforms to compile in sbrk emulation.
  LACKS_UNISTD_H            (default: undefined)
4000b2c3:	41                   	inc    %ecx
     Define this if your system does not have a <unistd.h>.
4000b2c4:	8d 74 42 f0          	lea    -0x10(%edx,%eax,2),%esi
  INTERNAL_NEWLIB	    (default: NOT defined)
     Defined only when compiled as part of the Cygnus newlib
     distribution.
  WIN32                     (default: undefined)
     Define this on MS win (95, nt) platforms to compile in sbrk emulation.
  LACKS_UNISTD_H            (default: undefined)
4000b2c8:	31 c0                	xor    %eax,%eax
4000b2ca:	8a 01                	mov    (%ecx),%al
4000b2cc:	8a 80 80 d9 00 40    	mov    0x4000d980(%eax),%al
4000b2d2:	84 c0                	test   %al,%al
4000b2d4:	74 09                	je     4000b2df <__gethex+0x17f>
4000b2d6:	31 d2                	xor    %edx,%edx
4000b2d8:	88 c2                	mov    %al,%dl
4000b2da:	83 fa 19             	cmp    $0x19,%edx
4000b2dd:	7e e1                	jle    4000b2c0 <__gethex+0x160>
     Define this if your system does not have a <unistd.h>.
  MORECORE                  (default: sbrk)
4000b2df:	8b 45 d4             	mov    -0x2c(%ebp),%eax
4000b2e2:	85 c0                	test   %eax,%eax
4000b2e4:	74 02                	je     4000b2e8 <__gethex+0x188>
     The name of the routine to call to obtain more memory from the system.
4000b2e6:	f7 de                	neg    %esi
  MORECORE_FAILURE          (default: -1)
4000b2e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
     The value returned upon failure of MORECORE.
  MORECORE_CLEARS           (default 1)
4000b2eb:	8b 55 0c             	mov    0xc(%ebp),%edx
     Define this on MS win (95, nt) platforms to compile in sbrk emulation.
  LACKS_UNISTD_H            (default: undefined)
     Define this if your system does not have a <unistd.h>.
  MORECORE                  (default: sbrk)
     The name of the routine to call to obtain more memory from the system.
  MORECORE_FAILURE          (default: -1)
4000b2ee:	01 f0                	add    %esi,%eax
4000b2f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
     The value returned upon failure of MORECORE.
  MORECORE_CLEARS           (default 1)
     True (1) if the routine mapped to MORECORE zeroes out memory (which
4000b2f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
     Define this if your system does not have a <unistd.h>.
  MORECORE                  (default: sbrk)
     The name of the routine to call to obtain more memory from the system.
  MORECORE_FAILURE          (default: -1)
     The value returned upon failure of MORECORE.
  MORECORE_CLEARS           (default 1)
4000b2f6:	89 0a                	mov    %ecx,(%edx)
     True (1) if the routine mapped to MORECORE zeroes out memory (which
4000b2f8:	85 c0                	test   %eax,%eax
4000b2fa:	0f 85 37 ff ff ff    	jne    4000b237 <__gethex+0xd7>
     holds for sbrk).
  DEFAULT_TRIM_THRESHOLD
4000b300:	89 d8                	mov    %ebx,%eax
  DEFAULT_TOP_PAD       
4000b302:	31 d2                	xor    %edx,%edx
  MORECORE_FAILURE          (default: -1)
     The value returned upon failure of MORECORE.
  MORECORE_CLEARS           (default 1)
     True (1) if the routine mapped to MORECORE zeroes out memory (which
     holds for sbrk).
  DEFAULT_TRIM_THRESHOLD
4000b304:	29 f8                	sub    %edi,%eax
4000b306:	48                   	dec    %eax
  DEFAULT_TOP_PAD       
4000b307:	83 f8 07             	cmp    $0x7,%eax
4000b30a:	7e 0c                	jle    4000b318 <__gethex+0x1b8>
4000b30c:	8d 74 26 00          	lea    0x0(%esi),%esi
4000b310:	d1 f8                	sar    %eax
  DEFAULT_MMAP_THRESHOLD
4000b312:	42                   	inc    %edx
     The value returned upon failure of MORECORE.
  MORECORE_CLEARS           (default 1)
     True (1) if the routine mapped to MORECORE zeroes out memory (which
     holds for sbrk).
  DEFAULT_TRIM_THRESHOLD
  DEFAULT_TOP_PAD       
4000b313:	83 f8 07             	cmp    $0x7,%eax
4000b316:	7f f8                	jg     4000b310 <__gethex+0x1b0>
  DEFAULT_MMAP_THRESHOLD
  DEFAULT_MMAP_MAX      
4000b318:	50                   	push   %eax
4000b319:	50                   	push   %eax
4000b31a:	52                   	push   %edx
4000b31b:	8b 75 08             	mov    0x8(%ebp),%esi
4000b31e:	56                   	push   %esi
4000b31f:	e8 fc cc ff ff       	call   40008020 <_Balloc>
4000b324:	89 45 d0             	mov    %eax,-0x30(%ebp)
     Default values of tunable parameters (described in detail below)
4000b327:	83 c0 14             	add    $0x14,%eax
     controlling interaction with host system routines (sbrk, mmap, etc).
     These values may also be changed dynamically via mallopt(). The
     preset defaults are those that give best performance for typical
4000b32a:	83 c4 10             	add    $0x10,%esp
     holds for sbrk).
  DEFAULT_TRIM_THRESHOLD
  DEFAULT_TOP_PAD       
  DEFAULT_MMAP_THRESHOLD
  DEFAULT_MMAP_MAX      
     Default values of tunable parameters (described in detail below)
4000b32d:	89 45 cc             	mov    %eax,-0x34(%ebp)
     controlling interaction with host system routines (sbrk, mmap, etc).
     These values may also be changed dynamically via mallopt(). The
     preset defaults are those that give best performance for typical
4000b330:	39 df                	cmp    %ebx,%edi
4000b332:	73 72                	jae    4000b3a6 <__gethex+0x246>
4000b334:	89 da                	mov    %ebx,%edx
4000b336:	8b 75 cc             	mov    -0x34(%ebp),%esi
4000b339:	31 db                	xor    %ebx,%ebx
4000b33b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
4000b342:	eb 39                	jmp    4000b37d <__gethex+0x21d>
4000b344:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000b34a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
     programs/systems.


4000b350:	8d 4b 04             	lea    0x4(%ebx),%ecx
4000b353:	89 4d c8             	mov    %ecx,-0x38(%ebp)
*/




4000b356:	25 ff 00 00 00       	and    $0xff,%eax
4000b35b:	88 d9                	mov    %bl,%cl
4000b35d:	8b 5d c8             	mov    -0x38(%ebp),%ebx
4000b360:	8a 80 80 d9 00 40    	mov    0x4000d980(%eax),%al
4000b366:	25 ff 00 00 00       	and    $0xff,%eax
4000b36b:	83 e0 0f             	and    $0xf,%eax
4000b36e:	d3 e0                	shl    %cl,%eax
4000b370:	8b 4d e0             	mov    -0x20(%ebp),%ecx
4000b373:	09 c1                	or     %eax,%ecx
4000b375:	89 4d e0             	mov    %ecx,-0x20(%ebp)
4000b378:	4a                   	dec    %edx
  DEFAULT_MMAP_THRESHOLD
  DEFAULT_MMAP_MAX      
     Default values of tunable parameters (described in detail below)
     controlling interaction with host system routines (sbrk, mmap, etc).
     These values may also be changed dynamically via mallopt(). The
     preset defaults are those that give best performance for typical
4000b379:	39 d7                	cmp    %edx,%edi
4000b37b:	73 32                	jae    4000b3af <__gethex+0x24f>
     programs/systems.
4000b37d:	8a 42 ff             	mov    -0x1(%edx),%al
4000b380:	3c 2e                	cmp    $0x2e,%al
4000b382:	74 f4                	je     4000b378 <__gethex+0x218>


4000b384:	83 fb 20             	cmp    $0x20,%ebx
4000b387:	75 c7                	jne    4000b350 <__gethex+0x1f0>
*/
4000b389:	8b 45 e0             	mov    -0x20(%ebp),%eax
4000b38c:	31 db                	xor    %ebx,%ebx
4000b38e:	89 06                	mov    %eax,(%esi)
4000b390:	83 c6 04             	add    $0x4,%esi
4000b393:	8a 42 ff             	mov    -0x1(%edx),%al
4000b396:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
4000b39d:	c7 45 c8 04 00 00 00 	movl   $0x4,-0x38(%ebp)
4000b3a4:	eb b0                	jmp    4000b356 <__gethex+0x1f6>
  DEFAULT_MMAP_THRESHOLD
  DEFAULT_MMAP_MAX      
     Default values of tunable parameters (described in detail below)
     controlling interaction with host system routines (sbrk, mmap, etc).
     These values may also be changed dynamically via mallopt(). The
     preset defaults are those that give best performance for typical
4000b3a6:	89 c6                	mov    %eax,%esi
4000b3a8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)


/* Preliminaries */

#ifndef __STD_C
#ifdef __STDC__
4000b3af:	8b 55 cc             	mov    -0x34(%ebp),%edx
4000b3b2:	8d 5e 04             	lea    0x4(%esi),%ebx
4000b3b5:	29 d3                	sub    %edx,%ebx
4000b3b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
#define __STD_C     1
4000b3ba:	83 ec 0c             	sub    $0xc,%esp



/* Preliminaries */

#ifndef __STD_C
4000b3bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
#ifdef __STDC__
4000b3c0:	c1 fb 02             	sar    $0x2,%ebx



/* Preliminaries */

#ifndef __STD_C
4000b3c3:	89 06                	mov    %eax,(%esi)
#ifdef __STDC__
4000b3c5:	89 5a 10             	mov    %ebx,0x10(%edx)
#define __STD_C     1
4000b3c8:	50                   	push   %eax
4000b3c9:	e8 82 c7 ff ff       	call   40007b50 <__hi0bits>
4000b3ce:	89 da                	mov    %ebx,%edx
#else
4000b3d0:	8b 4d 10             	mov    0x10(%ebp),%ecx
#if __cplusplus
#define __STD_C     1
#else
4000b3d3:	83 c4 10             	add    $0x10,%esp

/* Preliminaries */

#ifndef __STD_C
#ifdef __STDC__
#define __STD_C     1
4000b3d6:	c1 e2 05             	shl    $0x5,%edx
4000b3d9:	29 c2                	sub    %eax,%edx
#else
4000b3db:	8b 39                	mov    (%ecx),%edi
#if __cplusplus
#define __STD_C     1
#else
4000b3dd:	39 fa                	cmp    %edi,%edx
4000b3df:	0f 8f f8 00 00 00    	jg     4000b4dd <__gethex+0x37d>
#else
#define Void_t      char
#endif
#endif /*Void_t*/

#if __STD_C
4000b3e5:	0f 8c 6f 01 00 00    	jl     4000b55a <__gethex+0x3fa>
4000b3eb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
#include <stddef.h>   /* for size_t */
#else
#include <sys/types.h>
#endif

#ifdef __cplusplus
4000b3f2:	8b 45 10             	mov    0x10(%ebp),%eax
4000b3f5:	8b 55 e8             	mov    -0x18(%ebp),%edx
4000b3f8:	3b 50 08             	cmp    0x8(%eax),%edx
4000b3fb:	0f 8e c7 01 00 00    	jle    4000b5c8 <__gethex+0x468>
extern "C" {
#endif
4000b401:	57                   	push   %edi
4000b402:	57                   	push   %edi
4000b403:	8b 75 d0             	mov    -0x30(%ebp),%esi
4000b406:	56                   	push   %esi

4000b407:	be a3 00 00 00       	mov    $0xa3,%esi
#include <sys/types.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif
4000b40c:	8b 5d 08             	mov    0x8(%ebp),%ebx
4000b40f:	53                   	push   %ebx
4000b410:	e8 1b c7 ff ff       	call   40007b30 <_Bfree>

4000b415:	8b 4d 18             	mov    0x18(%ebp),%ecx
#define POINTER_UINT unsigned long
#define RARG
#define RONEARG
#define RDECL
#define RERRNO errno
#define RCALL
4000b418:	89 f0                	mov    %esi,%eax

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>    /* needed for malloc_stats */
4000b41a:	83 c4 10             	add    $0x10,%esp
#endif

#ifdef __cplusplus
extern "C" {
#endif

4000b41d:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
#define POINTER_UINT unsigned long
#define RARG
#define RONEARG
#define RDECL
#define RERRNO errno
#define RCALL
4000b423:	8d 65 f4             	lea    -0xc(%ebp),%esp
4000b426:	5b                   	pop    %ebx
4000b427:	5e                   	pop    %esi
4000b428:	5f                   	pop    %edi
4000b429:	5d                   	pop    %ebp
4000b42a:	c3                   	ret    
     execution.
  SEPARATE_OBJECTS	   (default: NOT defined)
     Define this to compile into separate .o files.  You must then
     compile malloc.c several times, defining a DEFINE_* macro each
     time.  The list of DEFINE_* macros appears below.
  MALLOC_LOCK		   (default: NOT defined)
4000b42b:	e8 10 fc ff ff       	call   4000b040 <__hexdig_init>
  MALLOC_UNLOCK		   (default: NOT defined)
     Define these to C expressions which are run to lock and unlock
4000b430:	8b 45 0c             	mov    0xc(%ebp),%eax
4000b433:	8b 18                	mov    (%eax),%ebx
     the malloc data structures.  Calls may be nested; that is,
4000b435:	8a 53 02             	mov    0x2(%ebx),%dl
     Define this to compile into separate .o files.  You must then
     compile malloc.c several times, defining a DEFINE_* macro each
     time.  The list of DEFINE_* macros appears below.
  MALLOC_LOCK		   (default: NOT defined)
  MALLOC_UNLOCK		   (default: NOT defined)
     Define these to C expressions which are run to lock and unlock
4000b438:	8d 43 02             	lea    0x2(%ebx),%eax
     the malloc data structures.  Calls may be nested; that is,
4000b43b:	80 fa 30             	cmp    $0x30,%dl
4000b43e:	0f 84 46 fd ff ff    	je     4000b18a <__gethex+0x2a>
4000b444:	89 c1                	mov    %eax,%ecx
4000b446:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
4000b44d:	e9 66 fd ff ff       	jmp    4000b1b8 <__gethex+0x58>
     At least on some platforms, the simple macro versions usually
     outperform libc versions.
  HAVE_MMAP                 (default: defined as 1)
     Define to non-zero to optionally make malloc() use mmap() to
     allocate very large blocks.  
  HAVE_MREMAP                 (default: defined as 0 unless Linux libc set)
4000b452:	85 f6                	test   %esi,%esi
4000b454:	0f 85 b7 fd ff ff    	jne    4000b211 <__gethex+0xb1>
     Define to non-zero to optionally make realloc() use mremap() to
4000b45a:	43                   	inc    %ebx
     reallocate very large blocks.  
4000b45b:	31 c0                	xor    %eax,%eax
4000b45d:	89 de                	mov    %ebx,%esi
4000b45f:	8a 03                	mov    (%ebx),%al
4000b461:	80 b8 80 d9 00 40 00 	cmpb   $0x0,0x4000d980(%eax)
4000b468:	0f 84 9b fd ff ff    	je     4000b209 <__gethex+0xa9>
4000b46e:	89 da                	mov    %ebx,%edx
  malloc_getpagesize        (default: derived from system #includes)
4000b470:	42                   	inc    %edx
  HAVE_MMAP                 (default: defined as 1)
     Define to non-zero to optionally make malloc() use mmap() to
     allocate very large blocks.  
  HAVE_MREMAP                 (default: defined as 0 unless Linux libc set)
     Define to non-zero to optionally make realloc() use mremap() to
     reallocate very large blocks.  
4000b471:	31 c0                	xor    %eax,%eax
4000b473:	8a 02                	mov    (%edx),%al
4000b475:	80 b8 80 d9 00 40 00 	cmpb   $0x0,0x4000d980(%eax)
4000b47c:	75 f2                	jne    4000b470 <__gethex+0x310>
4000b47e:	89 de                	mov    %ebx,%esi
4000b480:	89 d3                	mov    %edx,%ebx
  malloc_getpagesize        (default: derived from system #includes)
     Either a constant or routine call returning the system page size.
  HAVE_USR_INCLUDE_MALLOC_H (default: NOT defined) 
4000b482:	85 f6                	test   %esi,%esi
4000b484:	0f 85 87 fd ff ff    	jne    4000b211 <__gethex+0xb1>
4000b48a:	8a 13                	mov    (%ebx),%dl
4000b48c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4000b493:	e9 83 fd ff ff       	jmp    4000b21b <__gethex+0xbb>
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
     Define this if you think that realloc(p, 0) should be equivalent
     to free(p). Otherwise, since malloc returns a unique pointer for
     malloc(0), so does realloc(p, 0).
  HAVE_MEMCPY               (default: defined)
     Define if you are not otherwise using ANSI STD C, but still 
4000b498:	31 c0                	xor    %eax,%eax
4000b49a:	8a 51 01             	mov    0x1(%ecx),%dl
4000b49d:	88 d0                	mov    %dl,%al
     which is the normal default.
  REALLOC_ZERO_BYTES_FREES (default: NOT defined) 
     Define this if you think that realloc(p, 0) should be equivalent
     to free(p). Otherwise, since malloc returns a unique pointer for
     malloc(0), so does realloc(p, 0).
  HAVE_MEMCPY               (default: defined)
4000b49f:	8d 59 01             	lea    0x1(%ecx),%ebx
     Define if you are not otherwise using ANSI STD C, but still 
4000b4a2:	8a 80 80 d9 00 40    	mov    0x4000d980(%eax),%al
4000b4a8:	84 c0                	test   %al,%al
4000b4aa:	0f 85 dd 00 00 00    	jne    4000b58d <__gethex+0x42d>
4000b4b0:	89 cf                	mov    %ecx,%edi
4000b4b2:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
4000b4b9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4000b4c0:	e9 56 fd ff ff       	jmp    4000b21b <__gethex+0xbb>
     define this even if you do, but will ensure consistency.
  INTERNAL_SIZE_T           (default: size_t)
     Define to a 32-bit type (probably `unsigned int') if you are on a 
     64-bit machine, yet do not want or need to allow malloc requests of 
     greater than 2^31 to be handled. This saves space, especially for
     very small chunks.
4000b4c5:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
  INTERNAL_LINUX_C_LIB      (default: NOT defined)
     Defined only when compiled as part of Linux libc.
     Also note that there is some odd internal name-mangling via defines
     (for example, internally, `malloc' is named `mALLOc') needed
     when compiling in this case. These look funny but don't otherwise
4000b4cc:	42                   	inc    %edx
4000b4cd:	8a 02                	mov    (%edx),%al
4000b4cf:	e9 b5 fd ff ff       	jmp    4000b289 <__gethex+0x129>
     define this even if you do, but will ensure consistency.
  INTERNAL_SIZE_T           (default: size_t)
     Define to a 32-bit type (probably `unsigned int') if you are on a 
     64-bit machine, yet do not want or need to allow malloc requests of 
     greater than 2^31 to be handled. This saves space, especially for
     very small chunks.
4000b4d4:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
4000b4db:	eb ef                	jmp    4000b4cc <__gethex+0x36c>
#define __STD_C     1
#else
#if __cplusplus
#define __STD_C     1
#else
#define __STD_C     0
4000b4dd:	89 d3                	mov    %edx,%ebx
#endif /*__cplusplus*/
4000b4df:	50                   	push   %eax
#define __STD_C     1
#else
#if __cplusplus
#define __STD_C     1
#else
#define __STD_C     0
4000b4e0:	29 fb                	sub    %edi,%ebx
#endif /*__cplusplus*/
4000b4e2:	50                   	push   %eax
4000b4e3:	53                   	push   %ebx
4000b4e4:	8b 45 d0             	mov    -0x30(%ebp),%eax
4000b4e7:	50                   	push   %eax
4000b4e8:	e8 b3 ca ff ff       	call   40007fa0 <__any_on>
4000b4ed:	83 c4 10             	add    $0x10,%esp
4000b4f0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
4000b4f7:	85 c0                	test   %eax,%eax
4000b4f9:	74 48                	je     4000b543 <__gethex+0x3e3>
#endif /*__STDC__*/
#endif /*__STD_C*/
4000b4fb:	8d 73 ff             	lea    -0x1(%ebx),%esi

4000b4fe:	b8 01 00 00 00       	mov    $0x1,%eax
4000b503:	89 f1                	mov    %esi,%ecx
4000b505:	89 f2                	mov    %esi,%edx
4000b507:	83 e1 1f             	and    $0x1f,%ecx
4000b50a:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
4000b511:	d3 e0                	shl    %cl,%eax
4000b513:	c1 fa 05             	sar    $0x5,%edx
4000b516:	8b 4d d0             	mov    -0x30(%ebp),%ecx
4000b519:	85 44 91 14          	test   %eax,0x14(%ecx,%edx,4)
4000b51d:	74 24                	je     4000b543 <__gethex+0x3e3>
#ifndef Void_t
#if __STD_C
4000b51f:	4e                   	dec    %esi
4000b520:	7e 1a                	jle    4000b53c <__gethex+0x3dc>
4000b522:	50                   	push   %eax
4000b523:	50                   	push   %eax
4000b524:	8d 43 fe             	lea    -0x2(%ebx),%eax
4000b527:	50                   	push   %eax
4000b528:	51                   	push   %ecx
4000b529:	e8 72 ca ff ff       	call   40007fa0 <__any_on>
4000b52e:	83 c4 10             	add    $0x10,%esp
4000b531:	c7 45 e4 03 00 00 00 	movl   $0x3,-0x1c(%ebp)
4000b538:	85 c0                	test   %eax,%eax
4000b53a:	75 07                	jne    4000b543 <__gethex+0x3e3>
4000b53c:	c7 45 e4 02 00 00 00 	movl   $0x2,-0x1c(%ebp)
#define Void_t      void
#else
#define Void_t      char
#endif
4000b543:	8b 45 d0             	mov    -0x30(%ebp),%eax
4000b546:	89 da                	mov    %ebx,%edx
4000b548:	e8 33 fb ff ff       	call   4000b080 <rshift>
#endif /*Void_t*/
4000b54d:	8b 45 e8             	mov    -0x18(%ebp),%eax
4000b550:	01 d8                	add    %ebx,%eax
4000b552:	89 45 e8             	mov    %eax,-0x18(%ebp)
4000b555:	e9 98 fe ff ff       	jmp    4000b3f2 <__gethex+0x292>

#if __STD_C
#include <stddef.h>   /* for size_t */
4000b55a:	89 fb                	mov    %edi,%ebx
#else
4000b55c:	50                   	push   %eax
#define Void_t      char
#endif
#endif /*Void_t*/

#if __STD_C
#include <stddef.h>   /* for size_t */
4000b55d:	29 d3                	sub    %edx,%ebx
#else
4000b55f:	53                   	push   %ebx
4000b560:	8b 75 d0             	mov    -0x30(%ebp),%esi
4000b563:	56                   	push   %esi
4000b564:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000b567:	51                   	push   %ecx
4000b568:	e8 e3 cd ff ff       	call   40008350 <__lshift>
#include <sys/types.h>
4000b56d:	8b 55 e8             	mov    -0x18(%ebp),%edx
#endif
#endif /*Void_t*/

#if __STD_C
#include <stddef.h>   /* for size_t */
#else
4000b570:	89 45 d0             	mov    %eax,-0x30(%ebp)
#include <sys/types.h>
4000b573:	29 da                	sub    %ebx,%edx
#endif
4000b575:	83 c0 14             	add    $0x14,%eax
4000b578:	83 c4 10             	add    $0x10,%esp
#endif /*Void_t*/

#if __STD_C
#include <stddef.h>   /* for size_t */
#else
#include <sys/types.h>
4000b57b:	89 55 e8             	mov    %edx,-0x18(%ebp)
#endif
4000b57e:	89 45 cc             	mov    %eax,-0x34(%ebp)
4000b581:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
4000b588:	e9 65 fe ff ff       	jmp    4000b3f2 <__gethex+0x292>
     to free(p). Otherwise, since malloc returns a unique pointer for
     malloc(0), so does realloc(p, 0).
  HAVE_MEMCPY               (default: defined)
     Define if you are not otherwise using ANSI STD C, but still 
     have memcpy and memset in your C library and want to use them.
     Otherwise, simple internal versions are supplied.
4000b58d:	89 d9                	mov    %ebx,%ecx
4000b58f:	80 fa 30             	cmp    $0x30,%dl
4000b592:	75 12                	jne    4000b5a6 <__gethex+0x446>
  USE_MEMCPY               (default: 1 if HAVE_MEMCPY is defined, 0 otherwise)
4000b594:	41                   	inc    %ecx
     to free(p). Otherwise, since malloc returns a unique pointer for
     malloc(0), so does realloc(p, 0).
  HAVE_MEMCPY               (default: defined)
     Define if you are not otherwise using ANSI STD C, but still 
     have memcpy and memset in your C library and want to use them.
     Otherwise, simple internal versions are supplied.
4000b595:	8a 11                	mov    (%ecx),%dl
4000b597:	80 fa 30             	cmp    $0x30,%dl
4000b59a:	74 f8                	je     4000b594 <__gethex+0x434>
4000b59c:	31 c0                	xor    %eax,%eax
4000b59e:	88 d0                	mov    %dl,%al
4000b5a0:	8a 80 80 d9 00 40    	mov    0x4000d980(%eax),%al
4000b5a6:	84 c0                	test   %al,%al
4000b5a8:	88 45 ef             	mov    %al,-0x11(%ebp)
4000b5ab:	0f 94 c0             	sete   %al
4000b5ae:	25 ff 00 00 00       	and    $0xff,%eax
4000b5b3:	89 de                	mov    %ebx,%esi
4000b5b5:	89 cf                	mov    %ecx,%edi
4000b5b7:	89 cb                	mov    %ecx,%ebx
4000b5b9:	89 45 dc             	mov    %eax,-0x24(%ebp)
4000b5bc:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
4000b5c3:	e9 1d fc ff ff       	jmp    4000b1e5 <__gethex+0x85>
#endif

#include <stdio.h>    /* needed for malloc_stats */
#include <limits.h>   /* needed for overflow checks */
#include <errno.h>    /* needed to set errno to ENOMEM */

4000b5c8:	8b 45 10             	mov    0x10(%ebp),%eax
4000b5cb:	be 01 00 00 00       	mov    $0x1,%esi
4000b5d0:	8b 50 04             	mov    0x4(%eax),%edx
4000b5d3:	39 55 e8             	cmp    %edx,-0x18(%ebp)
4000b5d6:	0f 8d 99 00 00 00    	jge    4000b675 <__gethex+0x515>
#ifdef WIN32
#define WIN32_LEAN_AND_MEAN
4000b5dc:	89 d6                	mov    %edx,%esi
4000b5de:	8b 4d e8             	mov    -0x18(%ebp),%ecx
4000b5e1:	29 ce                	sub    %ecx,%esi
#include <windows.h>
4000b5e3:	39 f7                	cmp    %esi,%edi
4000b5e5:	7f 41                	jg     4000b628 <__gethex+0x4c8>
#endif
4000b5e7:	8b 40 0c             	mov    0xc(%eax),%eax
4000b5ea:	83 f8 02             	cmp    $0x2,%eax
4000b5ed:	0f 84 8f 01 00 00    	je     4000b782 <__gethex+0x622>
4000b5f3:	83 f8 03             	cmp    $0x3,%eax
4000b5f6:	0f 84 f4 01 00 00    	je     4000b7f0 <__gethex+0x690>
4000b5fc:	48                   	dec    %eax
4000b5fd:	0f 84 b1 01 00 00    	je     4000b7b4 <__gethex+0x654>

#include <sys/config.h>

/*
  In newlib, all the publically visible routines take a reentrancy
  pointer.  We don't currently do anything much with it, but we do
4000b603:	51                   	push   %ecx
4000b604:	51                   	push   %ecx
4000b605:	8b 55 d0             	mov    -0x30(%ebp),%edx
  pass it to the lock routine.
4000b608:	be 50 00 00 00       	mov    $0x50,%esi

#include <sys/config.h>

/*
  In newlib, all the publically visible routines take a reentrancy
  pointer.  We don't currently do anything much with it, but we do
4000b60d:	52                   	push   %edx
4000b60e:	8b 45 08             	mov    0x8(%ebp),%eax
4000b611:	50                   	push   %eax
4000b612:	e8 19 c5 ff ff       	call   40007b30 <_Bfree>
  pass it to the lock routine.
4000b617:	8b 45 18             	mov    0x18(%ebp),%eax
 */
4000b61a:	83 c4 10             	add    $0x10,%esp
#include <sys/config.h>

/*
  In newlib, all the publically visible routines take a reentrancy
  pointer.  We don't currently do anything much with it, but we do
  pass it to the lock routine.
4000b61d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
4000b623:	e9 18 fc ff ff       	jmp    4000b240 <__gethex+0xe0>
 */

#include <reent.h>

4000b628:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  In newlib, all the publically visible routines take a reentrancy
  pointer.  We don't currently do anything much with it, but we do
  pass it to the lock routine.
 */

#include <reent.h>
4000b62b:	8d 5e ff             	lea    -0x1(%esi),%ebx

4000b62e:	85 c0                	test   %eax,%eax
4000b630:	74 7d                	je     4000b6af <__gethex+0x54f>
4000b632:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
#define POINTER_UINT unsigned _POINTER_INT
#define SEPARATE_OBJECTS
#define HAVE_MMAP 0
#define MORECORE(size) _sbrk_r(reent_ptr, (size))
4000b639:	89 da                	mov    %ebx,%edx
4000b63b:	83 e3 1f             	and    $0x1f,%ebx
4000b63e:	88 d9                	mov    %bl,%cl
4000b640:	b8 01 00 00 00       	mov    $0x1,%eax
4000b645:	d3 e0                	shl    %cl,%eax
4000b647:	c1 fa 05             	sar    $0x5,%edx
4000b64a:	8b 4d cc             	mov    -0x34(%ebp),%ecx
4000b64d:	85 04 91             	test   %eax,(%ecx,%edx,4)
4000b650:	74 09                	je     4000b65b <__gethex+0x4fb>
#define MORECORE_CLEARS 0
4000b652:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000b655:	83 c8 02             	or     $0x2,%eax
4000b658:	89 45 e4             	mov    %eax,-0x1c(%ebp)
#define MALLOC_LOCK __malloc_lock(reent_ptr)
#define MALLOC_UNLOCK __malloc_unlock(reent_ptr)
4000b65b:	89 f2                	mov    %esi,%edx
4000b65d:	8b 45 d0             	mov    -0x30(%ebp),%eax
4000b660:	e8 1b fa ff ff       	call   4000b080 <rshift>

4000b665:	8b 45 10             	mov    0x10(%ebp),%eax
4000b668:	8b 40 04             	mov    0x4(%eax),%eax
#define POINTER_UINT unsigned _POINTER_INT
#define SEPARATE_OBJECTS
#define HAVE_MMAP 0
#define MORECORE(size) _sbrk_r(reent_ptr, (size))
#define MORECORE_CLEARS 0
#define MALLOC_LOCK __malloc_lock(reent_ptr)
4000b66b:	29 f7                	sub    %esi,%edi
#define MALLOC_UNLOCK __malloc_unlock(reent_ptr)

4000b66d:	89 45 e8             	mov    %eax,-0x18(%ebp)
4000b670:	be 02 00 00 00       	mov    $0x2,%esi
#ifdef __CYGWIN__
# undef _WIN32
4000b675:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4000b678:	85 c0                	test   %eax,%eax
4000b67a:	74 1e                	je     4000b69a <__gethex+0x53a>
# undef WIN32
#endif
4000b67c:	8b 55 10             	mov    0x10(%ebp),%edx
4000b67f:	8b 42 0c             	mov    0xc(%edx),%eax
4000b682:	83 f8 02             	cmp    $0x2,%eax
4000b685:	0f 84 c2 00 00 00    	je     4000b74d <__gethex+0x5ed>
4000b68b:	83 f8 03             	cmp    $0x3,%eax
4000b68e:	74 3a                	je     4000b6ca <__gethex+0x56a>
4000b690:	48                   	dec    %eax
4000b691:	0f 84 c5 00 00 00    	je     4000b75c <__gethex+0x5fc>
#define RCALL reent_ptr,
#define RONECALL reent_ptr

#else /* ! INTERNAL_NEWLIB */

#define POINTER_UINT unsigned long
4000b697:	83 ce 10             	or     $0x10,%esi
#define RARG
#define RONEARG
4000b69a:	8b 4d 18             	mov    0x18(%ebp),%ecx
4000b69d:	8b 45 d0             	mov    -0x30(%ebp),%eax
#define RDECL
4000b6a0:	8b 55 14             	mov    0x14(%ebp),%edx

#else /* ! INTERNAL_NEWLIB */

#define POINTER_UINT unsigned long
#define RARG
#define RONEARG
4000b6a3:	89 01                	mov    %eax,(%ecx)
#define RDECL
4000b6a5:	8b 4d e8             	mov    -0x18(%ebp),%ecx
4000b6a8:	89 0a                	mov    %ecx,(%edx)
4000b6aa:	e9 91 fb ff ff       	jmp    4000b240 <__gethex+0xe0>
 */

#include <reent.h>

#define POINTER_UINT unsigned _POINTER_INT
#define SEPARATE_OBJECTS
4000b6af:	85 db                	test   %ebx,%ebx
4000b6b1:	7e 86                	jle    4000b639 <__gethex+0x4d9>
#define HAVE_MMAP 0
4000b6b3:	50                   	push   %eax
4000b6b4:	50                   	push   %eax
4000b6b5:	53                   	push   %ebx
4000b6b6:	8b 45 d0             	mov    -0x30(%ebp),%eax
4000b6b9:	50                   	push   %eax
4000b6ba:	e8 e1 c8 ff ff       	call   40007fa0 <__any_on>
4000b6bf:	83 c4 10             	add    $0x10,%esp
4000b6c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4000b6c5:	e9 6f ff ff ff       	jmp    4000b639 <__gethex+0x4d9>
#define MALLOC_UNLOCK __malloc_unlock(reent_ptr)

#ifdef __CYGWIN__
# undef _WIN32
# undef WIN32
#endif
4000b6ca:	8b 45 1c             	mov    0x1c(%ebp),%eax

#if __STD_C
extern void __malloc_lock(struct _reent *);
extern void __malloc_unlock(struct _reent *);
#else
extern void __malloc_lock();
4000b6cd:	85 c0                	test   %eax,%eax
4000b6cf:	74 c6                	je     4000b697 <__gethex+0x537>
extern void __malloc_unlock();
4000b6d1:	8b 45 d0             	mov    -0x30(%ebp),%eax
  Maximum allocated size: 4-byte size_t: 2^31 -  8 bytes
                          8-byte size_t: 2^63 - 16 bytes

       It is assumed that (possibly signed) size_t bit values suffice to
       represent chunk sizes. `Possibly signed' is due to the fact
       that `size_t' may be defined on a system as either a signed or
4000b6d4:	8b 4d d0             	mov    -0x30(%ebp),%ecx

  Maximum allocated size: 4-byte size_t: 2^31 -  8 bytes
                          8-byte size_t: 2^63 - 16 bytes

       It is assumed that (possibly signed) size_t bit values suffice to
       represent chunk sizes. `Possibly signed' is due to the fact
4000b6d7:	8b 55 cc             	mov    -0x34(%ebp),%edx
#if __STD_C
extern void __malloc_lock(struct _reent *);
extern void __malloc_unlock(struct _reent *);
#else
extern void __malloc_lock();
extern void __malloc_unlock();
4000b6da:	8b 40 10             	mov    0x10(%eax),%eax
4000b6dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
4000b6e0:	89 c3                	mov    %eax,%ebx
  Maximum allocated size: 4-byte size_t: 2^31 -  8 bytes
                          8-byte size_t: 2^63 - 16 bytes

       It is assumed that (possibly signed) size_t bit values suffice to
       represent chunk sizes. `Possibly signed' is due to the fact
       that `size_t' may be defined on a system as either a signed or
4000b6e2:	8d 4c 81 14          	lea    0x14(%ecx,%eax,4),%ecx
4000b6e6:	89 4d c8             	mov    %ecx,-0x38(%ebp)
       an unsigned type. To be conservative, values that would appear
       as negative numbers are avoided.  
       Requests for sizes with a negative sign bit will return a
4000b6e9:	8b 02                	mov    (%edx),%eax
4000b6eb:	83 f8 ff             	cmp    $0xffffffff,%eax
4000b6ee:	0f 85 09 01 00 00    	jne    4000b7fd <__gethex+0x69d>
       minimum-sized chunk.

  Maximum overhead wastage per allocated chunk: normally 15 bytes

4000b6f4:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
4000b6fa:	83 c2 04             	add    $0x4,%edx
       Alignnment demands, plus the minimum allocatable size restriction
4000b6fd:	39 55 c8             	cmp    %edx,-0x38(%ebp)
4000b700:	77 e7                	ja     4000b6e9 <__gethex+0x589>
            mmap(), the worst case wastage is 8 bytes plus the remainder
            from a system page (the minimal mmap unit); typically 4096 bytes.

* Limitations

    Here are some features that are NOT currently supported
4000b702:	8b 55 d0             	mov    -0x30(%ebp),%edx
4000b705:	8b 45 f0             	mov    -0x10(%ebp),%eax
4000b708:	3b 42 08             	cmp    0x8(%edx),%eax
4000b70b:	0f 8d 0f 01 00 00    	jge    4000b820 <__gethex+0x6c0>

    * No user-definable hooks for callbacks and the like.
    * No automated mechanism for fully checking that all accesses
      to malloced memory stay within their bounds.
    * No support for compaction.

4000b711:	8b 55 d0             	mov    -0x30(%ebp),%edx
4000b714:	8d 43 01             	lea    0x1(%ebx),%eax
4000b717:	c7 44 9a 14 01 00 00 	movl   $0x1,0x14(%edx,%ebx,4)
4000b71e:	00 
4000b71f:	89 42 10             	mov    %eax,0x10(%edx)
#else
extern void __malloc_lock();
extern void __malloc_unlock();
#endif

#if __STD_C
4000b722:	83 fe 02             	cmp    $0x2,%esi
4000b725:	0f 84 da 00 00 00    	je     4000b805 <__gethex+0x6a5>
#define RARG struct _reent *reent_ptr,
#define RONEARG struct _reent *reent_ptr
#else
#define RARG reent_ptr
#define RONEARG reent_ptr
4000b72b:	8b 45 d0             	mov    -0x30(%ebp),%eax
4000b72e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
4000b731:	3b 48 10             	cmp    0x10(%eax),%ecx
4000b734:	0f 8c 5a 01 00 00    	jl     4000b894 <__gethex+0x734>
4000b73a:	89 fb                	mov    %edi,%ebx
4000b73c:	83 e3 1f             	and    $0x1f,%ebx
4000b73f:	0f 85 2a 01 00 00    	jne    4000b86f <__gethex+0x70f>
#define RDECL struct _reent *reent_ptr;
#endif

#define RERRNO reent_ptr->_errno
#define RCALL reent_ptr,
4000b745:	83 ce 20             	or     $0x20,%esi
4000b748:	e9 4d ff ff ff       	jmp    4000b69a <__gethex+0x53a>
#define malloc_getpagesize (128)
#else
#define malloc_getpagesize (4096)
#endif
#endif

4000b74d:	b8 01 00 00 00       	mov    $0x1,%eax
4000b752:	8b 55 1c             	mov    0x1c(%ebp),%edx
4000b755:	29 d0                	sub    %edx,%eax
4000b757:	e9 71 ff ff ff       	jmp    4000b6cd <__gethex+0x56d>
# undef WIN32
#endif

#ifndef _WIN32
#ifdef SMALL_MEMORY
#define malloc_getpagesize (128)
4000b75c:	f6 45 e4 02          	testb  $0x2,-0x1c(%ebp)
4000b760:	0f 84 31 ff ff ff    	je     4000b697 <__gethex+0x537>
4000b766:	8b 4d cc             	mov    -0x34(%ebp),%ecx
4000b769:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
4000b76c:	8b 09                	mov    (%ecx),%ecx
4000b76e:	09 cb                	or     %ecx,%ebx
4000b770:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
4000b773:	f6 45 e4 01          	testb  $0x1,-0x1c(%ebp)
4000b777:	0f 85 54 ff ff ff    	jne    4000b6d1 <__gethex+0x571>
4000b77d:	e9 15 ff ff ff       	jmp    4000b697 <__gethex+0x537>

/*
  Compile-time options
*/


4000b782:	8b 75 1c             	mov    0x1c(%ebp),%esi
4000b785:	85 f6                	test   %esi,%esi
4000b787:	0f 85 76 fe ff ff    	jne    4000b603 <__gethex+0x4a3>
/*

  Special defines for Cygnus newlib distribution.

 */

4000b78d:	8b 4d 14             	mov    0x14(%ebp),%ecx
#ifdef INTERNAL_NEWLIB
4000b790:	8b 45 d0             	mov    -0x30(%ebp),%eax

4000b793:	be 62 00 00 00       	mov    $0x62,%esi
/*

  Special defines for Cygnus newlib distribution.

 */

4000b798:	89 11                	mov    %edx,(%ecx)
#ifdef INTERNAL_NEWLIB
4000b79a:	8b 55 cc             	mov    -0x34(%ebp),%edx

4000b79d:	8b 4d 18             	mov    0x18(%ebp),%ecx

  Special defines for Cygnus newlib distribution.

 */

#ifdef INTERNAL_NEWLIB
4000b7a0:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
4000b7a7:	c7 02 01 00 00 00    	movl   $0x1,(%edx)

4000b7ad:	89 01                	mov    %eax,(%ecx)
4000b7af:	e9 8c fa ff ff       	jmp    4000b240 <__gethex+0xe0>
#ifdef WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif

/*
4000b7b4:	39 fe                	cmp    %edi,%esi
4000b7b6:	0f 85 47 fe ff ff    	jne    4000b603 <__gethex+0x4a3>
4000b7bc:	83 ff 01             	cmp    $0x1,%edi
4000b7bf:	7e cc                	jle    4000b78d <__gethex+0x62d>
4000b7c1:	50                   	push   %eax
4000b7c2:	50                   	push   %eax
4000b7c3:	8d 47 ff             	lea    -0x1(%edi),%eax
4000b7c6:	50                   	push   %eax
4000b7c7:	8b 7d d0             	mov    -0x30(%ebp),%edi
4000b7ca:	57                   	push   %edi
4000b7cb:	e8 d0 c7 ff ff       	call   40007fa0 <__any_on>
4000b7d0:	83 c4 10             	add    $0x10,%esp
4000b7d3:	85 c0                	test   %eax,%eax
4000b7d5:	0f 84 28 fe ff ff    	je     4000b603 <__gethex+0x4a3>
4000b7db:	8b 45 10             	mov    0x10(%ebp),%eax
4000b7de:	8b 50 04             	mov    0x4(%eax),%edx
4000b7e1:	eb aa                	jmp    4000b78d <__gethex+0x62d>
4000b7e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000b7e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi


/*

  Special defines for Cygnus newlib distribution.

4000b7f0:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
4000b7f3:	85 db                	test   %ebx,%ebx
4000b7f5:	0f 84 08 fe ff ff    	je     4000b603 <__gethex+0x4a3>
4000b7fb:	eb 90                	jmp    4000b78d <__gethex+0x62d>
       represent chunk sizes. `Possibly signed' is due to the fact
       that `size_t' may be defined on a system as either a signed or
       an unsigned type. To be conservative, values that would appear
       as negative numbers are avoided.  
       Requests for sizes with a negative sign bit will return a
       minimum-sized chunk.
4000b7fd:	40                   	inc    %eax
4000b7fe:	89 02                	mov    %eax,(%edx)
4000b800:	e9 1d ff ff ff       	jmp    4000b722 <__gethex+0x5c2>
extern void __malloc_lock();
extern void __malloc_unlock();
#endif

#if __STD_C
#define RARG struct _reent *reent_ptr,
4000b805:	8b 4d 10             	mov    0x10(%ebp),%ecx
4000b808:	8b 01                	mov    (%ecx),%eax
4000b80a:	48                   	dec    %eax
4000b80b:	39 f8                	cmp    %edi,%eax
4000b80d:	0f 84 a9 00 00 00    	je     4000b8bc <__gethex+0x75c>
#define RONEARG reent_ptr
#define RDECL struct _reent *reent_ptr;
#endif

#define RERRNO reent_ptr->_errno
#define RCALL reent_ptr,
4000b813:	be 22 00 00 00       	mov    $0x22,%esi
4000b818:	e9 7d fe ff ff       	jmp    4000b69a <__gethex+0x53a>
4000b81d:	8d 76 00             	lea    0x0(%esi),%esi
            from a system page (the minimal mmap unit); typically 4096 bytes.

* Limitations

    Here are some features that are NOT currently supported

4000b820:	53                   	push   %ebx
4000b821:	53                   	push   %ebx
4000b822:	8b 42 04             	mov    0x4(%edx),%eax
4000b825:	40                   	inc    %eax
4000b826:	50                   	push   %eax
4000b827:	8b 4d 08             	mov    0x8(%ebp),%ecx
4000b82a:	51                   	push   %ecx
4000b82b:	e8 f0 c7 ff ff       	call   40008020 <_Balloc>
    * No user-definable hooks for callbacks and the like.
4000b830:	8b 4d d0             	mov    -0x30(%ebp),%ecx
            from a system page (the minimal mmap unit); typically 4096 bytes.

* Limitations

    Here are some features that are NOT currently supported

4000b833:	89 c3                	mov    %eax,%ebx
    * No user-definable hooks for callbacks and the like.
4000b835:	83 c4 0c             	add    $0xc,%esp
4000b838:	8b 41 10             	mov    0x10(%ecx),%eax
4000b83b:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
4000b842:	50                   	push   %eax
4000b843:	89 c8                	mov    %ecx,%eax
4000b845:	83 c0 0c             	add    $0xc,%eax
4000b848:	50                   	push   %eax
4000b849:	8d 43 0c             	lea    0xc(%ebx),%eax
4000b84c:	50                   	push   %eax
4000b84d:	e8 fe c1 ff ff       	call   40007a50 <memcpy>
    * No automated mechanism for fully checking that all accesses
4000b852:	58                   	pop    %eax
4000b853:	8b 45 d0             	mov    -0x30(%ebp),%eax
4000b856:	5a                   	pop    %edx
4000b857:	50                   	push   %eax
4000b858:	8b 45 08             	mov    0x8(%ebp),%eax
4000b85b:	50                   	push   %eax
4000b85c:	e8 cf c2 ff ff       	call   40007b30 <_Bfree>
4000b861:	89 5d d0             	mov    %ebx,-0x30(%ebp)
4000b864:	83 c4 10             	add    $0x10,%esp
4000b867:	8b 5b 10             	mov    0x10(%ebx),%ebx
4000b86a:	e9 a2 fe ff ff       	jmp    4000b711 <__gethex+0x5b1>
#if __STD_C
#define RARG struct _reent *reent_ptr,
#define RONEARG struct _reent *reent_ptr
#else
#define RARG reent_ptr
#define RONEARG reent_ptr
4000b86f:	8b 55 f0             	mov    -0x10(%ebp),%edx
4000b872:	8b 4d d0             	mov    -0x30(%ebp),%ecx
4000b875:	83 ec 0c             	sub    $0xc,%esp
4000b878:	8b 7c 91 10          	mov    0x10(%ecx,%edx,4),%edi
4000b87c:	57                   	push   %edi
4000b87d:	e8 ce c2 ff ff       	call   40007b50 <__hi0bits>
4000b882:	ba 20 00 00 00       	mov    $0x20,%edx
4000b887:	83 c4 10             	add    $0x10,%esp
4000b88a:	29 da                	sub    %ebx,%edx
4000b88c:	39 d0                	cmp    %edx,%eax
4000b88e:	0f 8d b1 fe ff ff    	jge    4000b745 <__gethex+0x5e5>
#define RDECL struct _reent *reent_ptr;
#endif

4000b894:	ba 01 00 00 00       	mov    $0x1,%edx
4000b899:	8b 45 d0             	mov    -0x30(%ebp),%eax
4000b89c:	e8 df f7 ff ff       	call   4000b080 <rshift>
#define RERRNO reent_ptr->_errno
4000b8a1:	8b 5d e8             	mov    -0x18(%ebp),%ebx
4000b8a4:	43                   	inc    %ebx
4000b8a5:	8b 45 10             	mov    0x10(%ebp),%eax
4000b8a8:	89 5d e8             	mov    %ebx,-0x18(%ebp)
4000b8ab:	8b 55 e8             	mov    -0x18(%ebp),%edx
4000b8ae:	3b 50 08             	cmp    0x8(%eax),%edx
4000b8b1:	0f 8f 4a fb ff ff    	jg     4000b401 <__gethex+0x2a1>
4000b8b7:	e9 89 fe ff ff       	jmp    4000b745 <__gethex+0x5e5>
extern void __malloc_lock();
extern void __malloc_unlock();
#endif

#if __STD_C
#define RARG struct _reent *reent_ptr,
4000b8bc:	89 f9                	mov    %edi,%ecx
4000b8be:	b8 01 00 00 00       	mov    $0x1,%eax
4000b8c3:	83 e1 1f             	and    $0x1f,%ecx
4000b8c6:	8b 55 d0             	mov    -0x30(%ebp),%edx
4000b8c9:	c1 ff 05             	sar    $0x5,%edi
4000b8cc:	66 be 21 00          	mov    $0x21,%si
4000b8d0:	d3 e0                	shl    %cl,%eax
4000b8d2:	85 44 ba 14          	test   %eax,0x14(%edx,%edi,4)
4000b8d6:	0f 85 be fd ff ff    	jne    4000b69a <__gethex+0x53a>
4000b8dc:	e9 32 ff ff ff       	jmp    4000b813 <__gethex+0x6b3>
4000b8e1:	90                   	nop    
4000b8e2:	90                   	nop    
4000b8e3:	90                   	nop    
4000b8e4:	90                   	nop    
4000b8e5:	90                   	nop    
4000b8e6:	90                   	nop    
4000b8e7:	90                   	nop    
4000b8e8:	90                   	nop    
4000b8e9:	90                   	nop    
4000b8ea:	90                   	nop    
4000b8eb:	90                   	nop    
4000b8ec:	90                   	nop    
4000b8ed:	90                   	nop    
4000b8ee:	90                   	nop    
4000b8ef:	90                   	nop    

4000b8f0 <L_shift>:
     Equivalent to memalign(pagesize, n), where pagesize is the page
     size of the system (or as near to this as can be figured out from
     all the includes/defines below.)
  pvalloc(size_t n);
     Equivalent to valloc(minimum-page-that-holds(n)), that is,
     round up n to nearest pagesize.
4000b8f0:	55                   	push   %ebp
4000b8f1:	89 e5                	mov    %esp,%ebp
4000b8f3:	57                   	push   %edi
4000b8f4:	56                   	push   %esi
4000b8f5:	53                   	push   %ebx
4000b8f6:	83 ec 08             	sub    $0x8,%esp
4000b8f9:	89 55 f0             	mov    %edx,-0x10(%ebp)
  calloc(size_t unit, size_t quantity);
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
4000b8fc:	ba 08 00 00 00       	mov    $0x8,%edx
  cfree(Void_t* p);
     Equivalent to free(p).
4000b901:	be 20 00 00 00       	mov    $0x20,%esi
  pvalloc(size_t n);
     Equivalent to valloc(minimum-page-that-holds(n)), that is,
     round up n to nearest pagesize.
  calloc(size_t unit, size_t quantity);
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
4000b906:	29 ca                	sub    %ecx,%edx
  cfree(Void_t* p);
     Equivalent to free(p).
4000b908:	8b 18                	mov    (%eax),%ebx
4000b90a:	89 45 ec             	mov    %eax,-0x14(%ebp)
     Equivalent to valloc(minimum-page-that-holds(n)), that is,
     round up n to nearest pagesize.
  calloc(size_t unit, size_t quantity);
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
  cfree(Void_t* p);
4000b90d:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
     Equivalent to free(p).
4000b914:	29 fe                	sub    %edi,%esi
4000b916:	8d 76 00             	lea    0x0(%esi),%esi
4000b919:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
  malloc_trim(size_t pad);
     Release all but pad bytes of freed top-most memory back 
4000b920:	8b 45 ec             	mov    -0x14(%ebp),%eax
4000b923:	89 f1                	mov    %esi,%ecx
4000b925:	8b 50 04             	mov    0x4(%eax),%edx
4000b928:	89 d0                	mov    %edx,%eax
4000b92a:	d3 e0                	shl    %cl,%eax
4000b92c:	09 c3                	or     %eax,%ebx
4000b92e:	8b 45 ec             	mov    -0x14(%ebp),%eax
     to the system. Return 1 if successful, else 0.
4000b931:	89 f9                	mov    %edi,%ecx
     Returns a pointer to quantity * unit bytes, with all locations
     set to zero.
  cfree(Void_t* p);
     Equivalent to free(p).
  malloc_trim(size_t pad);
     Release all but pad bytes of freed top-most memory back 
4000b933:	89 18                	mov    %ebx,(%eax)
     to the system. Return 1 if successful, else 0.
4000b935:	89 d3                	mov    %edx,%ebx
4000b937:	d3 eb                	shr    %cl,%ebx
4000b939:	89 58 04             	mov    %ebx,0x4(%eax)
4000b93c:	83 c0 04             	add    $0x4,%eax
4000b93f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  malloc_usable_size(Void_t* p);
4000b942:	39 45 f0             	cmp    %eax,-0x10(%ebp)
4000b945:	77 d9                	ja     4000b920 <L_shift+0x30>
     Report the number usable allocated bytes associated with allocated
4000b947:	58                   	pop    %eax
4000b948:	5a                   	pop    %edx
4000b949:	5b                   	pop    %ebx
4000b94a:	5e                   	pop    %esi
4000b94b:	5f                   	pop    %edi
4000b94c:	5d                   	pop    %ebp
4000b94d:	c3                   	ret    
4000b94e:	66 90                	xchg   %ax,%ax

4000b950 <__hexnan>:
     due to alignment and minimum size constraints.
  malloc_stats();
     Prints brief summary statistics on stderr.
  mallinfo()
     Returns (by copy) a struct containing various summary statistics.
  mallopt(int parameter_number, int parameter_value)
4000b950:	55                   	push   %ebp
4000b951:	89 e5                	mov    %esp,%ebp
4000b953:	57                   	push   %edi
4000b954:	56                   	push   %esi
4000b955:	53                   	push   %ebx
4000b956:	83 ec 1c             	sub    $0x1c,%esp
     Changes one of the tunable parameters described below. Returns
     1 if successful in changing the parameter, else 0.

* Vital statistics:

4000b959:	80 3d b0 d9 00 40 00 	cmpb   $0x0,0x4000d9b0
4000b960:	0f 84 b8 01 00 00    	je     4000bb1e <__hexnan+0x1ce>
  Alignment:                            8-byte
       8 byte alignment is currently hardwired into the design.  This
4000b966:	8b 45 0c             	mov    0xc(%ebp),%eax
       seems to suffice for all current machines and C compilers.
4000b969:	8b 4d 10             	mov    0x10(%ebp),%ecx
     1 if successful in changing the parameter, else 0.

* Vital statistics:

  Alignment:                            8-byte
       8 byte alignment is currently hardwired into the design.  This
4000b96c:	8b 00                	mov    (%eax),%eax
       seems to suffice for all current machines and C compilers.
4000b96e:	89 c2                	mov    %eax,%edx
4000b970:	c1 fa 05             	sar    $0x5,%edx

4000b973:	83 e0 1f             	and    $0x1f,%eax
4000b976:	89 45 e4             	mov    %eax,-0x1c(%ebp)

* Vital statistics:

  Alignment:                            8-byte
       8 byte alignment is currently hardwired into the design.  This
       seems to suffice for all current machines and C compilers.
4000b979:	8d 14 91             	lea    (%ecx,%edx,4),%edx

4000b97c:	74 03                	je     4000b981 <__hexnan+0x31>
  Assumed pointer representation:       4 or 8 bytes
4000b97e:	83 c2 04             	add    $0x4,%edx
       Code for 8-byte pointers is untested by me but has worked
4000b981:	8d 42 fc             	lea    -0x4(%edx),%eax
4000b984:	c7 42 fc 00 00 00 00 	movl   $0x0,-0x4(%edx)
       reliably by Wolfram Gloger, who contributed most of the
       changes supporting this.

4000b98b:	8b 55 08             	mov    0x8(%ebp),%edx
  Alignment:                            8-byte
       8 byte alignment is currently hardwired into the design.  This
       seems to suffice for all current machines and C compilers.

  Assumed pointer representation:       4 or 8 bytes
       Code for 8-byte pointers is untested by me but has worked
4000b98e:	89 45 f0             	mov    %eax,-0x10(%ebp)
       reliably by Wolfram Gloger, who contributed most of the
       changes supporting this.

4000b991:	89 c3                	mov    %eax,%ebx
4000b993:	89 45 e8             	mov    %eax,-0x18(%ebp)
4000b996:	8b 32                	mov    (%edx),%esi
4000b998:	31 ff                	xor    %edi,%edi
4000b99a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4000b9a1:	31 c9                	xor    %ecx,%ecx
4000b9a3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000b9a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi),%edi
  Assumed size_t  representation:       4 or 8 bytes
4000b9b0:	46                   	inc    %esi
4000b9b1:	8a 06                	mov    (%esi),%al
4000b9b3:	84 c0                	test   %al,%al
4000b9b5:	74 5b                	je     4000ba12 <__hexnan+0xc2>
4000b9b7:	31 d2                	xor    %edx,%edx
4000b9b9:	88 c2                	mov    %al,%dl
       Note that size_t is allowed to be 4 bytes even if pointers are 8.        
4000b9bb:	8a 82 80 d9 00 40    	mov    0x4000d980(%edx),%al
4000b9c1:	84 c0                	test   %al,%al
4000b9c3:	0f 85 c7 00 00 00    	jne    4000ba90 <__hexnan+0x140>

4000b9c9:	83 fa 20             	cmp    $0x20,%edx
4000b9cc:	0f 87 3a 01 00 00    	ja     4000bb0c <__hexnan+0x1bc>
  Minimum overhead per allocated chunk: 4 or 8 bytes
4000b9d2:	3b 7d ec             	cmp    -0x14(%ebp),%edi
4000b9d5:	7e d9                	jle    4000b9b0 <__hexnan+0x60>
       Each malloced chunk has a hidden overhead of 4 bytes holding size
4000b9d7:	3b 5d e8             	cmp    -0x18(%ebp),%ebx
4000b9da:	73 14                	jae    4000b9f0 <__hexnan+0xa0>
4000b9dc:	83 f9 07             	cmp    $0x7,%ecx
4000b9df:	7f 0f                	jg     4000b9f0 <__hexnan+0xa0>
       and status information.  
4000b9e1:	8b 55 e8             	mov    -0x18(%ebp),%edx
4000b9e4:	89 d8                	mov    %ebx,%eax
4000b9e6:	e8 05 ff ff ff       	call   4000b8f0 <L_shift>
4000b9eb:	90                   	nop    
4000b9ec:	8d 74 26 00          	lea    0x0(%esi),%esi

4000b9f0:	b9 08 00 00 00       	mov    $0x8,%ecx
4000b9f5:	3b 5d 10             	cmp    0x10(%ebp),%ebx
4000b9f8:	76 b6                	jbe    4000b9b0 <__hexnan+0x60>
  Minimum allocated size: 4-byte ptrs:  16 bytes    (including 4 overhead)
                          8-byte ptrs:  24/32 bytes (including, 4/8 overhead)
                                     
       When a chunk is freed, 12 (for 4byte ptrs) or 20 (for 8 byte
       ptrs but 4 byte size) or 24 (for 8/8) additional bytes are 
4000b9fa:	83 eb 04             	sub    $0x4,%ebx
  Assumed pointer representation:       4 or 8 bytes
       Code for 8-byte pointers is untested by me but has worked
       reliably by Wolfram Gloger, who contributed most of the
       changes supporting this.

  Assumed size_t  representation:       4 or 8 bytes
4000b9fd:	46                   	inc    %esi

  Minimum allocated size: 4-byte ptrs:  16 bytes    (including 4 overhead)
                          8-byte ptrs:  24/32 bytes (including, 4/8 overhead)
                                     
       When a chunk is freed, 12 (for 4byte ptrs) or 20 (for 8 byte
       ptrs but 4 byte size) or 24 (for 8/8) additional bytes are 
4000b9fe:	89 5d e8             	mov    %ebx,-0x18(%ebp)
4000ba01:	89 7d ec             	mov    %edi,-0x14(%ebp)
4000ba04:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
4000ba0a:	30 c9                	xor    %cl,%cl
  Assumed pointer representation:       4 or 8 bytes
       Code for 8-byte pointers is untested by me but has worked
       reliably by Wolfram Gloger, who contributed most of the
       changes supporting this.

  Assumed size_t  representation:       4 or 8 bytes
4000ba0c:	8a 06                	mov    (%esi),%al
4000ba0e:	84 c0                	test   %al,%al
4000ba10:	75 a5                	jne    4000b9b7 <__hexnan+0x67>
       Requests for sizes with a negative sign bit will return a
       minimum-sized chunk.

  Maximum overhead wastage per allocated chunk: normally 15 bytes

       Alignnment demands, plus the minimum allocatable size restriction
4000ba12:	85 ff                	test   %edi,%edi
4000ba14:	0f 84 f7 00 00 00    	je     4000bb11 <__hexnan+0x1c1>
       make the normal worst-case wastage 15 bytes (i.e., up to 15
       more bytes will be allocated than were requested in malloc), with 
4000ba1a:	3b 5d e8             	cmp    -0x18(%ebp),%ebx
4000ba1d:	0f 82 cc 00 00 00    	jb     4000baef <__hexnan+0x19f>
       two exceptions:
         1. Because requests for zero bytes allocate non-zero space,
4000ba23:	39 5d 10             	cmp    %ebx,0x10(%ebp)
4000ba26:	0f 83 9f 00 00 00    	jae    4000bacb <__hexnan+0x17b>
4000ba2c:	8b 55 10             	mov    0x10(%ebp),%edx
4000ba2f:	90                   	nop    
            the worst case wastage for a request of zero bytes is 24 bytes.
         2. For requests >= mmap_threshold that are serviced via
4000ba30:	8b 03                	mov    (%ebx),%eax
4000ba32:	83 c3 04             	add    $0x4,%ebx
4000ba35:	89 02                	mov    %eax,(%edx)
4000ba37:	83 c2 04             	add    $0x4,%edx
            mmap(), the worst case wastage is 8 bytes plus the remainder
4000ba3a:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
4000ba3d:	73 f1                	jae    4000ba30 <__hexnan+0xe0>
4000ba3f:	90                   	nop    
            from a system page (the minimal mmap unit); typically 4096 bytes.
4000ba40:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
4000ba46:	83 c2 04             	add    $0x4,%edx

4000ba49:	39 55 f0             	cmp    %edx,-0x10(%ebp)
4000ba4c:	73 f2                	jae    4000ba40 <__hexnan+0xf0>
4000ba4e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
4000ba51:	8b 01                	mov    (%ecx),%eax
    Here are some features that are NOT currently supported

    * No user-definable hooks for callbacks and the like.
    * No automated mechanism for fully checking that all accesses
      to malloced memory stay within their bounds.
    * No support for compaction.
4000ba53:	85 c0                	test   %eax,%eax
4000ba55:	75 2c                	jne    4000ba83 <__hexnan+0x133>

* Synopsis of compile-time options:

    People have reported using previous versions of this malloc on all
4000ba57:	8b 45 f0             	mov    -0x10(%ebp),%eax
    * No user-definable hooks for callbacks and the like.
    * No automated mechanism for fully checking that all accesses
      to malloced memory stay within their bounds.
    * No support for compaction.

* Synopsis of compile-time options:
4000ba5a:	39 45 10             	cmp    %eax,0x10(%ebp)
4000ba5d:	75 1d                	jne    4000ba7c <__hexnan+0x12c>
4000ba5f:	e9 c4 00 00 00       	jmp    4000bb28 <__hexnan+0x1d8>
4000ba64:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000ba6a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
4000ba70:	83 e8 04             	sub    $0x4,%eax
4000ba73:	39 45 10             	cmp    %eax,0x10(%ebp)
4000ba76:	0f 84 ac 00 00 00    	je     4000bb28 <__hexnan+0x1d8>
    Here are some features that are NOT currently supported

    * No user-definable hooks for callbacks and the like.
    * No automated mechanism for fully checking that all accesses
      to malloced memory stay within their bounds.
    * No support for compaction.
4000ba7c:	8b 48 fc             	mov    -0x4(%eax),%ecx
4000ba7f:	85 c9                	test   %ecx,%ecx
4000ba81:	74 ed                	je     4000ba70 <__hexnan+0x120>

    People have reported using previous versions of this malloc on all
    versions of Unix, sometimes by tweaking some of the defines
    below. It has been tested most extensively on Solaris and
    Linux. It is also reported to work on WIN32 platforms.
    People have also reported adapting this malloc for use in
4000ba83:	83 c4 1c             	add    $0x1c,%esp
    Here are some features that are NOT currently supported

    * No user-definable hooks for callbacks and the like.
    * No automated mechanism for fully checking that all accesses
      to malloced memory stay within their bounds.
    * No support for compaction.
4000ba86:	b8 05 00 00 00       	mov    $0x5,%eax

    People have reported using previous versions of this malloc on all
    versions of Unix, sometimes by tweaking some of the defines
    below. It has been tested most extensively on Solaris and
    Linux. It is also reported to work on WIN32 platforms.
    People have also reported adapting this malloc for use in
4000ba8b:	5b                   	pop    %ebx
4000ba8c:	5e                   	pop    %esi
4000ba8d:	5f                   	pop    %edi
4000ba8e:	5d                   	pop    %ebp
4000ba8f:	c3                   	ret    
  Maximum allocated size: 4-byte size_t: 2^31 -  8 bytes
                          8-byte size_t: 2^63 - 16 bytes

       It is assumed that (possibly signed) size_t bit values suffice to
       represent chunk sizes. `Possibly signed' is due to the fact
       that `size_t' may be defined on a system as either a signed or
4000ba90:	41                   	inc    %ecx

  Maximum allocated size: 4-byte size_t: 2^31 -  8 bytes
                          8-byte size_t: 2^63 - 16 bytes

       It is assumed that (possibly signed) size_t bit values suffice to
       represent chunk sizes. `Possibly signed' is due to the fact
4000ba91:	47                   	inc    %edi
       that `size_t' may be defined on a system as either a signed or
4000ba92:	83 f9 08             	cmp    $0x8,%ecx
4000ba95:	7f 19                	jg     4000bab0 <__hexnan+0x160>
4000ba97:	8b 13                	mov    (%ebx),%edx
       an unsigned type. To be conservative, values that would appear
       as negative numbers are avoided.  
       Requests for sizes with a negative sign bit will return a
       minimum-sized chunk.

  Maximum overhead wastage per allocated chunk: normally 15 bytes
4000ba99:	c1 e2 04             	shl    $0x4,%edx
4000ba9c:	83 e0 0f             	and    $0xf,%eax
4000ba9f:	09 c2                	or     %eax,%edx
4000baa1:	89 13                	mov    %edx,(%ebx)
4000baa3:	e9 08 ff ff ff       	jmp    4000b9b0 <__hexnan+0x60>
4000baa8:	90                   	nop    
4000baa9:	8d b4 26 00 00 00 00 	lea    0x0(%esi),%esi
                          8-byte size_t: 2^63 - 16 bytes

       It is assumed that (possibly signed) size_t bit values suffice to
       represent chunk sizes. `Possibly signed' is due to the fact
       that `size_t' may be defined on a system as either a signed or
       an unsigned type. To be conservative, values that would appear
4000bab0:	3b 5d 10             	cmp    0x10(%ebp),%ebx
4000bab3:	0f 86 f7 fe ff ff    	jbe    4000b9b0 <__hexnan+0x60>
       as negative numbers are avoided.  
       Requests for sizes with a negative sign bit will return a
       minimum-sized chunk.
4000bab9:	83 eb 04             	sub    $0x4,%ebx
4000babc:	b9 01 00 00 00       	mov    $0x1,%ecx
4000bac1:	31 d2                	xor    %edx,%edx
4000bac3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
4000bac9:	eb ce                	jmp    4000ba99 <__hexnan+0x149>
            from a system page (the minimal mmap unit); typically 4096 bytes.

* Limitations

    Here are some features that are NOT currently supported

4000bacb:	8b 7d e4             	mov    -0x1c(%ebp),%edi
4000bace:	85 ff                	test   %edi,%edi
4000bad0:	74 6c                	je     4000bb3e <__hexnan+0x1ee>
    * No user-definable hooks for callbacks and the like.
4000bad2:	b9 20 00 00 00       	mov    $0x20,%ecx
4000bad7:	8b 75 e4             	mov    -0x1c(%ebp),%esi
4000bada:	29 f1                	sub    %esi,%ecx
4000badc:	83 c8 ff             	or     $0xffffffff,%eax
4000badf:	d3 e8                	shr    %cl,%eax
4000bae1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
4000bae4:	8b 19                	mov    (%ecx),%ebx
4000bae6:	21 d8                	and    %ebx,%eax
4000bae8:	89 01                	mov    %eax,(%ecx)
4000baea:	e9 64 ff ff ff       	jmp    4000ba53 <__hexnan+0x103>

  Maximum overhead wastage per allocated chunk: normally 15 bytes

       Alignnment demands, plus the minimum allocatable size restriction
       make the normal worst-case wastage 15 bytes (i.e., up to 15
       more bytes will be allocated than were requested in malloc), with 
4000baef:	83 f9 07             	cmp    $0x7,%ecx
4000baf2:	0f 8f 2b ff ff ff    	jg     4000ba23 <__hexnan+0xd3>
       two exceptions:
4000baf8:	8b 55 e8             	mov    -0x18(%ebp),%edx
4000bafb:	89 d8                	mov    %ebx,%eax
4000bafd:	e8 ee fd ff ff       	call   4000b8f0 <L_shift>
         1. Because requests for zero bytes allocate non-zero space,
4000bb02:	39 5d 10             	cmp    %ebx,0x10(%ebp)
4000bb05:	73 c4                	jae    4000bacb <__hexnan+0x17b>
4000bb07:	e9 20 ff ff ff       	jmp    4000ba2c <__hexnan+0xdc>
       needed; 4 (8) for a trailing size field
       and 8 (16) bytes for free list pointers. Thus, the minimum
       allocatable size is 16/24/32 bytes.

       Even a request for zero bytes (i.e., malloc(0)) returns a
       pointer to something of the minimum allocatable size.
4000bb0c:	83 fa 29             	cmp    $0x29,%edx
4000bb0f:	74 37                	je     4000bb48 <__hexnan+0x1f8>

    People have reported using previous versions of this malloc on all
    versions of Unix, sometimes by tweaking some of the defines
    below. It has been tested most extensively on Solaris and
    Linux. It is also reported to work on WIN32 platforms.
    People have also reported adapting this malloc for use in
4000bb11:	83 c4 1c             	add    $0x1c,%esp
    Here are some features that are NOT currently supported

    * No user-definable hooks for callbacks and the like.
    * No automated mechanism for fully checking that all accesses
      to malloced memory stay within their bounds.
    * No support for compaction.
4000bb14:	b8 04 00 00 00       	mov    $0x4,%eax

    People have reported using previous versions of this malloc on all
    versions of Unix, sometimes by tweaking some of the defines
    below. It has been tested most extensively on Solaris and
    Linux. It is also reported to work on WIN32 platforms.
    People have also reported adapting this malloc for use in
4000bb19:	5b                   	pop    %ebx
4000bb1a:	5e                   	pop    %esi
4000bb1b:	5f                   	pop    %edi
4000bb1c:	5d                   	pop    %ebp
4000bb1d:	c3                   	ret    
     Changes one of the tunable parameters described below. Returns
     1 if successful in changing the parameter, else 0.

* Vital statistics:

  Alignment:                            8-byte
4000bb1e:	e8 1d f5 ff ff       	call   4000b040 <__hexdig_init>
4000bb23:	e9 3e fe ff ff       	jmp    4000b966 <__hexnan+0x16>
    * No automated mechanism for fully checking that all accesses
      to malloced memory stay within their bounds.
    * No support for compaction.

* Synopsis of compile-time options:

4000bb28:	8b 45 10             	mov    0x10(%ebp),%eax
4000bb2b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    People have reported using previous versions of this malloc on all
    versions of Unix, sometimes by tweaking some of the defines
    below. It has been tested most extensively on Solaris and
    Linux. It is also reported to work on WIN32 platforms.
    People have also reported adapting this malloc for use in
4000bb31:	83 c4 1c             	add    $0x1c,%esp
    * No automated mechanism for fully checking that all accesses
      to malloced memory stay within their bounds.
    * No support for compaction.

* Synopsis of compile-time options:

4000bb34:	b8 05 00 00 00       	mov    $0x5,%eax
    People have reported using previous versions of this malloc on all
    versions of Unix, sometimes by tweaking some of the defines
    below. It has been tested most extensively on Solaris and
    Linux. It is also reported to work on WIN32 platforms.
    People have also reported adapting this malloc for use in
4000bb39:	5b                   	pop    %ebx
4000bb3a:	5e                   	pop    %esi
4000bb3b:	5f                   	pop    %edi
4000bb3c:	5d                   	pop    %ebp
4000bb3d:	c3                   	ret    
            from a system page (the minimal mmap unit); typically 4096 bytes.

* Limitations

    Here are some features that are NOT currently supported

4000bb3e:	8b 55 f0             	mov    -0x10(%ebp),%edx
4000bb41:	8b 02                	mov    (%edx),%eax
4000bb43:	e9 0b ff ff ff       	jmp    4000ba53 <__hexnan+0x103>
       needed; 4 (8) for a trailing size field
       and 8 (16) bytes for free list pointers. Thus, the minimum
       allocatable size is 16/24/32 bytes.

       Even a request for zero bytes (i.e., malloc(0)) returns a
       pointer to something of the minimum allocatable size.
4000bb48:	85 ff                	test   %edi,%edi
4000bb4a:	74 c5                	je     4000bb11 <__hexnan+0x1c1>

4000bb4c:	8b 55 08             	mov    0x8(%ebp),%edx
4000bb4f:	8d 46 01             	lea    0x1(%esi),%eax
4000bb52:	89 02                	mov    %eax,(%edx)
4000bb54:	e9 b9 fe ff ff       	jmp    4000ba12 <__hexnan+0xc2>
4000bb59:	90                   	nop    
4000bb5a:	90                   	nop    
4000bb5b:	90                   	nop    
4000bb5c:	90                   	nop    
4000bb5d:	90                   	nop    
4000bb5e:	90                   	nop    
4000bb5f:	90                   	nop    

4000bb60 <free>:
4000bb60:	55                   	push   %ebp
4000bb61:	89 e5                	mov    %esp,%ebp
4000bb63:	83 ec 10             	sub    $0x10,%esp
4000bb66:	a1 60 d0 00 40       	mov    0x4000d060,%eax
4000bb6b:	8b 55 08             	mov    0x8(%ebp),%edx
4000bb6e:	52                   	push   %edx
4000bb6f:	50                   	push   %eax
4000bb70:	e8 eb b3 ff ff       	call   40006f60 <_free_r>
4000bb75:	83 c4 10             	add    $0x10,%esp
4000bb78:	c9                   	leave  
4000bb79:	c3                   	ret    
4000bb7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

4000bb80 <malloc>:
4000bb80:	55                   	push   %ebp
4000bb81:	89 e5                	mov    %esp,%ebp
4000bb83:	83 ec 10             	sub    $0x10,%esp
4000bb86:	8b 0d 60 d0 00 40    	mov    0x4000d060,%ecx
4000bb8c:	8b 45 08             	mov    0x8(%ebp),%eax
4000bb8f:	50                   	push   %eax
4000bb90:	51                   	push   %ecx
4000bb91:	e8 4a 4c ff ff       	call   400007e0 <_malloc_r>
4000bb96:	c9                   	leave  
4000bb97:	c3                   	ret    
4000bb98:	90                   	nop    
4000bb99:	90                   	nop    
4000bb9a:	90                   	nop    
4000bb9b:	90                   	nop    
4000bb9c:	90                   	nop    
4000bb9d:	90                   	nop    
4000bb9e:	90                   	nop    
4000bb9f:	90                   	nop    

4000bba0 <__do_global_ctors_aux>:
4000bba0:	55                   	push   %ebp
4000bba1:	89 e5                	mov    %esp,%ebp
4000bba3:	56                   	push   %esi
4000bba4:	53                   	push   %ebx
4000bba5:	e8 00 00 00 00       	call   4000bbaa <__do_global_ctors_aux+0xa>
4000bbaa:	5b                   	pop    %ebx
4000bbab:	81 c3 7a 14 00 00    	add    $0x147a,%ebx
4000bbb1:	8d 83 e4 ff ff ff    	lea    -0x1c(%ebx),%eax
4000bbb7:	8d 50 fc             	lea    -0x4(%eax),%edx
4000bbba:	8b 40 fc             	mov    -0x4(%eax),%eax
4000bbbd:	83 f8 ff             	cmp    $0xffffffff,%eax
4000bbc0:	74 1b                	je     4000bbdd <__do_global_ctors_aux+0x3d>
4000bbc2:	89 d6                	mov    %edx,%esi
4000bbc4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
4000bbca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
4000bbd0:	ff d0                	call   *%eax
4000bbd2:	8b 46 fc             	mov    -0x4(%esi),%eax
4000bbd5:	83 ee 04             	sub    $0x4,%esi
4000bbd8:	83 f8 ff             	cmp    $0xffffffff,%eax
4000bbdb:	75 f3                	jne    4000bbd0 <__do_global_ctors_aux+0x30>
4000bbdd:	5b                   	pop    %ebx
4000bbde:	5e                   	pop    %esi
4000bbdf:	5d                   	pop    %ebp
4000bbe0:	c3                   	ret    
Disassembly of section .fini:

4000bbe1 <.fini>:
4000bbe1:	e8 ba 44 ff ff       	call   400000a0 <__do_global_dtors_aux>
